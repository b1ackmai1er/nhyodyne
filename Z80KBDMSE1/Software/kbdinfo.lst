0001   0000             ;
0002   0000             ;=======================================================================
0003   0000             ; Keyboard Information Utility (KBDINFO)
0004   0000             ;=======================================================================
0005   0000             ;
0006   0000             ; Simple utility that attempts to determine the type of keyboard you
0007   0000             ; have attached to an 8242 keyboard controller.
0008   0000             ;
0009   0000             ;=======================================================================
0010   0000             ;
0011   0000             ; Keyboard controller port addresses (adjust as needed)
0012   0000             ;
0013   0000             iocmd	.equ	$E3	; keyboard controller command port address
0014   0000             iodat	.equ	$E2	; keyboard controller data port address
0015   0000             ;
0016   0000             cpumhz	.equ	8	; for time delay calculations (not critical)
0017   0000             ;
0018   0000             ; General operational equates (should not requre adjustment)
0019   0000             ;
0020   0000             stksiz	.equ	$40			; Working stack size
0021   0000             ;
0022   0000             ltimout	.equ	0			; 256*10ms = 2.56s
0023   0000             stimout	.equ	10			; 10*10ms = 100ms
0024   0000             ;
0025   0000             restart	.equ	$0000			; CP/M restart vector
0026   0000             bdos	.equ	$0005			; BDOS invocation vector
0027   0000             ;
0028   0000             ;=======================================================================
0029   0000             ;
0030   0100             	.org	$100	; standard CP/M executable
0031   0100             ;
0032   0100             ;
0033   0100             	; setup stack (save old value)
0034   0100 ED 73 01 0A 	ld	(stksav),sp		; save stack
0035   0104 31 43 0A    	ld	sp,stack		; set new stack
0036   0107             ;
0037   0107 CD DE 04    	call	crlf
0038   010A 11 FF 04    	ld	de,str_banner		; banner
0039   010D CD 34 04    	call	prtstr
0040   0110             ;
0041   0110 CD 31 01    	call	main			; do the real work
0042   0113 28 09       	jr	z,exit			; completed all tests
0043   0115 11 18 09    	ld	de,str_run_failed
0044   0118 CD DB 04    	call	crlf2
0045   011B CD 34 04    	call	prtstr
0046   011E             ;
0047   011E             exit:
0048   011E CD DB 04    	call	crlf2
0049   0121 11 26 05    	ld	de,str_exit
0050   0124 CD 34 04    	call	prtstr
0051   0127             
0052   0127             	; clean up and return to command processor
0053   0127 CD DE 04    	call	crlf			; formatting
0054   012A ED 7B 01 0A 	ld	sp,(stksav)		; restore stack
0055   012E C3 00 00    	jp	restart			; return to CP/M via restart
0056   0131             ;
0057   0131             ;
0058   0131             ;=======================================================================
0059   0131             ; Main Program
0060   0131             ;=======================================================================
0061   0131             ;
0062   0131             main:
0063   0131             ;
0064   0131             ; Display active keyboard controller port addresses
0065   0131             ;
0066   0131 CD DB 04    	call	crlf2
0067   0134 11 56 05    	ld	de,str_cmdport
0068   0137 CD 34 04    	call	prtstr
0069   013A 3E E3       	ld	a,iocmd
0070   013C CD 50 04    	call	prthex
0071   013F CD DE 04    	call	crlf
0072   0142 11 79 05    	ld	de,str_dataport
0073   0145 CD 34 04    	call	prtstr
0074   0148 3E E2       	ld	a,iodat
0075   014A CD 50 04    	call	prthex
0076   014D             ;
0077   014D             ; First, we attempt to contact the controller and keyboard, then
0078   014D             ; print the keyboard identity and scan codes scupported
0079   014D             ;
0080   014D             	; Run test series with translation off
0081   014D CD DB 04    	call	crlf2
0082   0150 11 5B 06    	ld	de,str_basic
0083   0153 CD 34 04    	call	prtstr
0084   0156             ;
0085   0156 CD 7E 01    	call	do_basic
0086   0159 C0          	ret	nz
0087   015A             ;
0088   015A             ; We make two passes through the test series with different controller
0089   015A             ; setup values.  The first time is with scan code translation off and
0090   015A             ; the second time with it on.
0091   015A             ;
0092   015A             	; Run test series with translation off
0093   015A CD DB 04    	call	crlf2
0094   015D 11 95 06    	ld	de,str_trans_off
0095   0160 CD 34 04    	call	prtstr
0096   0163             ;
0097   0163 3E 20       	ld	a,$20			; xlat disabled, mouse disabled, no ints
0098   0165 32 4C 0A    	ld	(ctlr_cfgval),a
0099   0168 CD B8 01    	call	do_tests
0100   016B             ;
0101   016B             	; Run test series with translation on
0102   016B CD DB 04    	call	crlf2
0103   016E 11 CD 06    	ld	de,str_trans_on
0104   0171 CD 34 04    	call	prtstr
0105   0174             ;
0106   0174 3E 60       	ld	a,$60			; xlat enabled, mouse disabled, no ints
0107   0176 32 4C 0A    	ld	(ctlr_cfgval),a
0108   0179 CD B8 01    	call	do_tests
0109   017C             	
0110   017C AF          	xor	a			; signal success
0111   017D C9          	ret
0112   017E             ;
0113   017E             ; Perform basic keyboard tests, display keyboard identity, and
0114   017E             ; inventory the supported scan code sets.
0115   017E             ;
0116   017E             do_basic:
0117   017E CD D7 01    	call	ctlr_test
0118   0181 C0          	ret	nz
0119   0182             ;
0120   0182 3E 20       	ld	a,$20			; Xlat off for this checking
0121   0184 CD FE 01    	call	ctlr_setup
0122   0187 C0          	ret	nz
0123   0188             ;
0124   0188 CD 1A 02    	call	kbd_reset
0125   018B C0          	ret	nz
0126   018C             ;
0127   018C CD 4C 02    	call	kbd_ident
0128   018F             	;ret	nz
0129   018F             ;
0130   018F 06 03       	ld	b,3			; Loop control, 3 scan code sets
0131   0191 0E 01       	ld	c,1			; Current scan code number
0132   0193             do_basic1:
0133   0193 79          	ld	a,c			; Scan code set to A
0134   0194 C5          	push	bc
0135   0195 CD 00 03    	call	kbd_setsc		; Attempt to set it
0136   0198 C1          	pop	bc
0137   0199 F5          	push	af			; save result
0138   019A CD DB 04    	call	crlf2
0139   019D 11 46 08    	ld	de,str_sc_tag
0140   01A0 CD 34 04    	call	prtstr
0141   01A3 79          	ld	a,c
0142   01A4 CD 99 04    	call	prtdecb
0143   01A7 F1          	pop	af			; restore result
0144   01A8 11 56 08    	ld	de,str_sc_ok
0145   01AB 28 03       	jr	z,do_basic2
0146   01AD 11 64 08    	ld	de,str_sc_fail
0147   01B0             do_basic2:
0148   01B0 CD 34 04    	call	prtstr
0149   01B3 0C          	inc	c
0150   01B4 10 DD       	djnz	do_basic1
0151   01B6             ;
0152   01B6 AF          	xor	a			; signal success
0153   01B7 C9          	ret
0154   01B8             ;
0155   01B8             ; This routine runs a series of controller and keyboard tests.  The
0156   01B8             ; desired controller setup value should be placed in ctlr_cfgval
0157   01B8             ; prior to invoking this routine.
0158   01B8             ;
0159   01B8             do_tests:
0160   01B8 CD D7 01    	call	ctlr_test
0161   01BB C0          	ret	nz
0162   01BC             ;
0163   01BC 3A 4C 0A    	ld	a,(ctlr_cfgval)
0164   01BF CD FE 01    	call	ctlr_setup
0165   01C2 C0          	ret	nz
0166   01C3             ;
0167   01C3 CD 1A 02    	call	kbd_reset
0168   01C6 C0          	ret	nz
0169   01C7             ;
0170   01C7 CD 4C 02    	call	kbd_ident
0171   01CA             	;ret	nz
0172   01CA             ;
0173   01CA 3E 02       	ld	a,2
0174   01CC CD 00 03    	call	kbd_setsc
0175   01CF             	;ret	nz
0176   01CF             ;
0177   01CF CD BB 02    	call	kbd_dispsc
0178   01D2             	;ret	nz
0179   01D2             ;
0180   01D2 CD 39 03    	call	kbd_showkeys
0181   01D5             	;ret	nz
0182   01D5             ;
0183   01D5 AF          	xor	a			; signal success
0184   01D6 C9          	ret
0185   01D7             ;
0186   01D7             ;=======================================================================
0187   01D7             ; Keyboard/Controller Test Routines
0188   01D7             ;=======================================================================
0189   01D7             ;
0190   01D7             ; Attempt self-test command on keyboard controller
0191   01D7             ;
0192   01D7             ;   Keyboard controller should respond with an 0x55 on data port
0193   01D7             ;   after being sent a 0xAA on the command port.
0194   01D7             ;
0195   01D7             ctlr_test:
0196   01D7 CD DB 04    	call	crlf2
0197   01DA 11 07 06    	ld	de,str_ctlr_test
0198   01DD CD 34 04    	call	prtstr
0199   01E0 3E AA       	ld	a,$aa			; self-test command
0200   01E2 CD A7 03    	call	put_cmd_dbg
0201   01E5 DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0202   01E8 CD E5 03    	call	get_data_dbg
0203   01EB DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0204   01EE FE 55       	cp	$55			; expected value?
0205   01F0 C2 FD 03    	jp	nz,err_ctlr_test	; handle self-test error
0206   01F3 CD DE 04    	call	crlf
0207   01F6 11 27 06    	ld	de,str_ctlr_test_ok
0208   01F9 CD 34 04    	call	prtstr
0209   01FC AF          	xor	a
0210   01FD C9          	ret
0211   01FE             ;
0212   01FE             ; Keyboard controller setup
0213   01FE             ;
0214   01FE             ;   Set keyboard controller command register to value in A
0215   01FE             ;
0216   01FE             ctlr_setup:
0217   01FE F5          	push	af			; save incoming value
0218   01FF CD DB 04    	call	crlf2
0219   0202 11 3F 06    	ld	de,str_ctlr_setup
0220   0205 CD 34 04    	call	prtstr
0221   0208 3E 60       	ld	a,$60			; write to command register 0
0222   020A CD A7 03    	call	put_cmd_dbg
0223   020D C1          	pop	bc			; recover incoming to B
0224   020E DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0225   0211 78          	ld	a,b
0226   0212 CD C7 03    	call	put_data_dbg
0227   0215 DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0228   0218 AF          	xor	a
0229   0219 C9          	ret
0230   021A             ;
0231   021A             ; Perform a keyboard reset
0232   021A             ;
0233   021A             kbd_reset:
0234   021A CD DB 04    	call	crlf2
0235   021D 11 04 07    	ld	de,str_kbd_reset
0236   0220 CD 34 04    	call	prtstr
0237   0223 3E FF       	ld	a,$ff			; Keyboard reset
0238   0225 CD C7 03    	call	put_data_dbg
0239   0228 DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0240   022B CD E5 03    	call	get_data_dbg
0241   022E DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0242   0231 FE FA       	cp	$FA			; Is it an ack as expected?
0243   0233 C2 02 04    	jp	nz,err_kbd_reset
0244   0236 CD E5 03    	call	get_data_dbg
0245   0239 DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0246   023C FE AA       	cp	$AA			; Success?
0247   023E C2 02 04    	jp	nz,err_kbd_reset
0248   0241 CD DE 04    	call	crlf
0249   0244 11 1E 07    	ld	de,str_kbd_reset_ok
0250   0247 CD 34 04    	call	prtstr
0251   024A AF          	xor	a
0252   024B C9          	ret
0253   024C             ;
0254   024C             ; Identify keyboard
0255   024C             ;
0256   024C             kbd_ident:
0257   024C CD DB 04    	call	crlf2
0258   024F 11 1A 08    	ld	de,str_kbd_ident
0259   0252 CD 34 04    	call	prtstr
0260   0255 3E F2       	ld	a,$f2			; Identify keyboard command
0261   0257 CD C7 03    	call	put_data_dbg
0262   025A DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0263   025D CD E5 03    	call	get_data_dbg
0264   0260 DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0265   0263 FE FA       	cp	$FA			; Is it an ack as expected?
0266   0265 C2 11 04    	jp	nz,err_kbd_ident
0267   0268             	; Now we need to receive 0-2 bytes.  There is no way to know
0268   0268             	; how many are coming, so we receive bytes until there is a
0269   0268             	; timeout error.  Timeout is shortened here so that we don't
0270   0268             	; have to wait seconds for the routine to complete normally.
0271   0268             	; A short timeout is more than sufficient here.
0272   0268 DD 21 43 0A 	ld	ix,workbuf
0273   026C 3A 4E 0A    	ld	a,(timeout)		; save current timeout
0274   026F F5          	push	af
0275   0270 3E 0A       	ld	a,stimout		; set a short timeout
0276   0272 32 4E 0A    	ld	(timeout),a
0277   0275 06 08       	ld	b,8			; buf max
0278   0277 0E 00       	ld	c,0			; buf len
0279   0279             kbd_ident1:
0280   0279 C5          	push	bc
0281   027A CD E5 03    	call	get_data_dbg
0282   027D C1          	pop	bc
0283   027E 38 08       	jr	c,kbd_ident2
0284   0280 DD 77 00    	ld	(ix),a
0285   0283 DD 23       	inc	ix
0286   0285 0C          	inc	c
0287   0286 10 F1       	djnz	kbd_ident1
0288   0288             kbd_ident2:
0289   0288 F1          	pop	af			; restore original timeout
0290   0289 32 4E 0A    	ld	(timeout),a
0291   028C CD DE 04    	call	crlf
0292   028F 11 32 08    	ld	de,str_kbd_ident_disp
0293   0292 CD 34 04    	call	prtstr
0294   0295 3E 5B       	ld	a,'['
0295   0297 CD 1F 04    	call	prtchr
0296   029A DD 21 43 0A 	ld	ix,workbuf
0297   029E 79          	ld	a,c			; bytes to print
0298   029F B7          	or	a			; check for zero
0299   02A0 28 12       	jr	z,kbd_ident4		; handle zero
0300   02A2 47          	ld	b,a			; setup loop counter
0301   02A3 18 05       	jr	kbd_ident3a
0302   02A5             kbd_ident3:
0303   02A5 3E 2C       	ld	a,','
0304   02A7 CD 1F 04    	call	prtchr
0305   02AA             kbd_ident3a:
0306   02AA DD 7E 00    	ld	a,(ix)
0307   02AD CD 50 04    	call	prthex
0308   02B0 DD 23       	inc	ix
0309   02B2 10 F1       	djnz	kbd_ident3
0310   02B4             kbd_ident4:
0311   02B4 3E 5D       	ld	a,']'
0312   02B6 CD 1F 04    	call	prtchr
0313   02B9 AF          	xor	a
0314   02BA C9          	ret
0315   02BB             ;
0316   02BB             ; Display active scan code set being used
0317   02BB             ;
0318   02BB             kbd_dispsc:
0319   02BB CD DB 04    	call	crlf2
0320   02BE 11 46 07    	ld	de,str_kbd_getsc
0321   02C1 CD 34 04    	call	prtstr
0322   02C4 3E F0       	ld	a,$f0			; Keyboard get/set scan code
0323   02C6 CD C7 03    	call	put_data_dbg
0324   02C9 DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0325   02CC CD E5 03    	call	get_data_dbg
0326   02CF DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0327   02D2 FE FA       	cp	$FA			; Is it an ack as expected?
0328   02D4 C2 07 04    	jp	nz,err_kbd_getsc
0329   02D7 3E 00       	ld	a,$00			; Get active scan code set
0330   02D9 CD C7 03    	call	put_data_dbg
0331   02DC DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0332   02DF CD E5 03    	call	get_data_dbg
0333   02E2 DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0334   02E5 FE FA       	cp	$FA			; Is it an ack as expected?
0335   02E7 C2 07 04    	jp	nz,err_kbd_getsc
0336   02EA CD E5 03    	call	get_data_dbg
0337   02ED DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0338   02F0 F5          	push	af
0339   02F1 CD DE 04    	call	crlf
0340   02F4 11 74 07    	ld	de,str_kbd_dispsc
0341   02F7 CD 34 04    	call	prtstr
0342   02FA F1          	pop	af
0343   02FB CD 99 04    	call	prtdecb
0344   02FE AF          	xor	a
0345   02FF C9          	ret
0346   0300             ;
0347   0300             ; Set active scan code set to value in A
0348   0300             ;
0349   0300             kbd_setsc:
0350   0300 32 38 03    	ld	(kbd_setsc_val),a	; Save incoming value
0351   0303 CD DB 04    	call	crlf2
0352   0306 11 C3 07    	ld	de,str_kbd_setsc
0353   0309 CD 34 04    	call	prtstr
0354   030C CD 99 04    	call	prtdecb
0355   030F 3E F0       	ld	a,$f0			; Keyboard get/set scan code
0356   0311 CD C7 03    	call	put_data_dbg
0357   0314 DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0358   0317 CD E5 03    	call	get_data_dbg
0359   031A DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0360   031D FE FA       	cp	$FA			; Is it an ack as expected?
0361   031F C2 0C 04    	jp	nz,err_kbd_setsc
0362   0322 3A 38 03    	ld	a,(kbd_setsc_val)	; Recover scan code set value
0363   0325 CD C7 03    	call	put_data_dbg
0364   0328 DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0365   032B CD E5 03    	call	get_data_dbg
0366   032E DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0367   0331 FE FA       	cp	$FA			; Is it an ack as expected?
0368   0333 C2 0C 04    	jp	nz,err_kbd_setsc
0369   0336 AF          	xor	a
0370   0337 C9          	ret
0371   0338             ;
0372   0338 00          kbd_setsc_val	.db	0
0373   0339             ;
0374   0339             ;
0375   0339             ; Read and display raw scan codes
0376   0339             ;
0377   0339             kbd_showkeys:
0378   0339 CD DB 04    	call	crlf2
0379   033C 11 9F 08    	ld	de,str_disp_scan_codes
0380   033F CD 34 04    	call	prtstr
0381   0342             read_loop:
0382   0342 0E 06       	ld	c,$06			; BDOS direct console I/O
0383   0344 1E FF       	ld	e,$FF			; Subfunction = read
0384   0346 CD 05 00    	call	bdos
0385   0349 FE 1B       	cp	$1B			; Escape key?
0386   034B C8          	ret	z
0387   034C CD 93 03    	call	check_read
0388   034F 20 F1       	jr	nz,read_loop
0389   0351 CD DA 03    	call	get_data
0390   0354 DA F8 03    	jp	c,err_ctlr_to		; handle controller error
0391   0357 F5          	push	af
0392   0358 3E 20       	ld	a,' '
0393   035A CD 1F 04    	call	prtchr
0394   035D 3E 5B       	ld	a,'['
0395   035F CD 1F 04    	call	prtchr
0396   0362 F1          	pop	af
0397   0363 CD 50 04    	call	prthex
0398   0366 3E 5D       	ld	a,']'
0399   0368 CD 1F 04    	call	prtchr
0400   036B 18 D5       	jr	read_loop
0401   036D             ;
0402   036D             ;=======================================================================
0403   036D             ; Keyboard Controller I/O Routines
0404   036D             ;=======================================================================
0405   036D             ;
0406   036D             wait_write:
0407   036D             ;
0408   036D             ; Wait for keyboard controller to be ready for a write
0409   036D             ;   A=0 indicates success (ZF set)
0410   036D             ;
0411   036D 3A 4E 0A    	ld	a,(timeout)		; setup timeout constant
0412   0370 47          	ld	b,a
0413   0371             wait_write1:
0414   0371 DB E3       	in	a,(iocmd)		; get status
0415   0373 4F          	ld	c,a			; save status
0416   0374 E6 02       	and	$02			; isolate input buf status bit
0417   0376 C8          	ret	z			; 0 means ready, all done
0418   0377 CD EB 04    	call	delay			; wait a bit
0419   037A 10 F5       	djnz	wait_write1		; loop until counter exhausted
0420   037C             ;	ld	de,str_timeout_write	; write timeout message
0421   037C             ;	call	crlf
0422   037C             ;	call	prtstr
0423   037C             ;	ld	a,c			; recover last status value
0424   037C             ;	call	prthex
0425   037C F6 FF       	or	$ff			; signal error
0426   037E C9          	ret
0427   037F             ;
0428   037F             wait_read:
0429   037F             ;
0430   037F             ; Wait for keyboard controller to be ready to read a byte
0431   037F             ;   A=0 indicates success (ZF set)
0432   037F             ;
0433   037F 3A 4E 0A    	ld	a,(timeout)		; setup timeout constant
0434   0382 47          	ld	b,a
0435   0383             wait_read1:
0436   0383 DB E3       	in	a,(iocmd)		; get status
0437   0385 4F          	ld	c,a			; save status
0438   0386 E6 01       	and	$01			; isolate input buf status bit
0439   0388 EE 01       	xor	$01			; invert so 0 means ready
0440   038A C8          	ret	z			; if 0, all done
0441   038B CD EB 04    	call	delay			; wait a bit
0442   038E 10 F3       	djnz	wait_read1		; loop until counter exhausted
0443   0390             ;	ld	de,str_timeout_read	; write timeout message
0444   0390             ;	call	crlf
0445   0390             ;	call	prtstr
0446   0390             ;	ld	a,c			; recover last status value
0447   0390             ;	call	prthex
0448   0390 F6 FF       	or	$ff			; signal error
0449   0392 C9          	ret
0450   0393             ;
0451   0393             check_read:
0452   0393             ;
0453   0393             ; Check for data ready to read
0454   0393             ;   A=0 indicates data available (ZF set)
0455   0393             ;
0456   0393 DB E3       	in	a,(iocmd)		; get status
0457   0395 E6 01       	and	$01			; isolate input buf status bit
0458   0397 EE 01       	xor	$01			; invert so 0 means ready
0459   0399 C9          	ret
0460   039A             ;
0461   039A             put_cmd:
0462   039A             ;
0463   039A             ; Put a cmd byte from A to the keyboard interface with timeout
0464   039A             ; CF set indicates timeout error
0465   039A             ;
0466   039A 5F          	ld	e,a			; save incoming value
0467   039B CD 6D 03    	call	wait_write		; wait for controller ready
0468   039E 28 02       	jr	z,put_cmd1		; if ready, move on
0469   03A0 37          	scf				; else, signal timeout error
0470   03A1 C9          	ret				; and bail out
0471   03A2             put_cmd1:
0472   03A2 7B          	ld	a,e			; recover value to write
0473   03A3 D3 E3       	out	(iocmd),a		; write it
0474   03A5 B7          	or	a			; clear CF for success
0475   03A6 C9          	ret
0476   03A7             ;
0477   03A7             put_cmd_dbg:
0478   03A7 CD 9A 03    	call	put_cmd
0479   03AA D8          	ret	c
0480   03AB F5          	push	af
0481   03AC             
0482   03AC CD DE 04    	call	crlf
0483   03AF 11 DE 05    	ld	de,str_put_cmd
0484   03B2 CD 34 04    	call	prtstr
0485   03B5 CD 50 04    	call	prthex
0486   03B8             
0487   03B8             ;	ld	de,str_prefix		; "  "
0488   03B8             ;	call	prtstr
0489   03B8             ;	call	prthex
0490   03B8             ;	ld	de,str_cmdout		; "->(CMD)"
0491   03B8             ;	call	prtstr
0492   03B8             
0493   03B8 F1          	pop	af
0494   03B9 C9          	ret
0495   03BA             ;	
0496   03BA             put_data:
0497   03BA             ;
0498   03BA             ; Put a data byte from A to the keyboard interface with timeout
0499   03BA             ; CF set indicates timeout error
0500   03BA             ;
0501   03BA 5F          	ld	e,a			; save incoming value
0502   03BB CD 6D 03    	call	wait_write		; wait for controller ready
0503   03BE 28 02       	jr	z,put_data1		; if ready, move on
0504   03C0 37          	scf				; else, signal timeout error
0505   03C1 C9          	ret				; and bail out
0506   03C2             put_data1:
0507   03C2 7B          	ld	a,e			; recover value to write
0508   03C3 D3 E2       	out	(iodat),a		; write it
0509   03C5 B7          	or	a			; clear CF for success
0510   03C6 C9          	ret
0511   03C7             ;
0512   03C7             put_data_dbg:
0513   03C7 CD BA 03    	call	put_data
0514   03CA D8          	ret	c
0515   03CB F5          	push	af
0516   03CC             
0517   03CC CD DE 04    	call	crlf
0518   03CF 11 EE 05    	ld	de,str_put_data
0519   03D2 CD 34 04    	call	prtstr
0520   03D5 CD 50 04    	call	prthex
0521   03D8             
0522   03D8             ;	ld	de,str_prefix		; "  "
0523   03D8             ;	call	prtstr
0524   03D8             ;	call	prthex
0525   03D8             ;	ld	de,str_dataout		; "->(DATA)"
0526   03D8             ;	call	prtstr
0527   03D8             
0528   03D8 F1          	pop	af
0529   03D9 C9          	ret
0530   03DA             
0531   03DA             ;
0532   03DA             ; Get a data byte from the keyboard interface to A with timeout
0533   03DA             ; CF set indicates timeout error
0534   03DA             ;
0535   03DA             get_data:
0536   03DA CD 7F 03    	call	wait_read		; wait for byte to be ready
0537   03DD 28 02       	jr	z,get_data1		; if readym, move on
0538   03DF 37          	scf				; else signal timeout error
0539   03E0 C9          	ret				; and bail out
0540   03E1             get_data1:
0541   03E1 DB E2       	in	a,(iodat)		; get data byte
0542   03E3 B7          	or	a			; clear CF for success
0543   03E4 C9          	ret
0544   03E5             ;
0545   03E5             get_data_dbg:
0546   03E5 CD DA 03    	call	get_data
0547   03E8 D8          	ret	c
0548   03E9 F5          	push	af
0549   03EA             
0550   03EA CD DE 04    	call	crlf
0551   03ED 11 FB 05    	ld	de,str_get_data
0552   03F0 CD 34 04    	call	prtstr
0553   03F3 CD 50 04    	call	prthex
0554   03F6             
0555   03F6             ;	ld	de,str_datain		; "  (DATA)->"
0556   03F6             ;	call	prtstr
0557   03F6             ;	call	prthex
0558   03F6             
0559   03F6 F1          	pop	af
0560   03F7 C9          	ret
0561   03F8             ;
0562   03F8             ; Error Handlers
0563   03F8             ;
0564   03F8             err_ctlr_to:
0565   03F8 11 99 05    	ld	de,str_err_ctlr_to
0566   03FB 18 19       	jr	err_ret
0567   03FD             ;
0568   03FD             err_ctlr_test:
0569   03FD 11 B9 05    	ld	de,str_err_ctlr_test
0570   0400 18 14       	jr	err_ret
0571   0402             ;
0572   0402             err_kbd_reset:
0573   0402 11 30 07    	ld	de,str_err_kbd_reset
0574   0405 18 0F       	jr	err_ret
0575   0407             ;
0576   0407             err_kbd_getsc:
0577   0407 11 97 07    	ld	de,str_err_kbd_getsc
0578   040A 18 0A       	jr	err_ret
0579   040C             ;
0580   040C             err_kbd_setsc:
0581   040C 11 EE 07    	ld	de,str_err_kbd_setsc
0582   040F 18 05       	jr	err_ret
0583   0411             ;
0584   0411             err_kbd_ident:
0585   0411 11 76 08    	ld	de,str_err_kbd_ident
0586   0414 18 00       	jr	err_ret
0587   0416             ;
0588   0416             err_ret:
0589   0416 CD DB 04    	call	crlf2
0590   0419 CD 34 04    	call	prtstr
0591   041C F6 FF       	or	$ff			; signal error
0592   041E C9          	ret
0593   041F             ;
0594   041F             ;=======================================================================
0595   041F             ; Utility Routines
0596   041F             ;=======================================================================
0597   041F             ;
0598   041F             ;
0599   041F             ; Print character in A without destroying any registers
0600   041F             ;
0601   041F             prtchr:
0602   041F C5          	push	bc		; save registers
0603   0420 D5          	push	de
0604   0421 E5          	push	hl
0605   0422 5F          	ld	e,a		; character to print in E
0606   0423 0E 02       	ld	c,$02		; BDOS function to output a character
0607   0425 CD 05 00    	call	bdos		; do it
0608   0428 E1          	pop	hl		; restore registers
0609   0429 D1          	pop	de
0610   042A C1          	pop	bc
0611   042B C9          	ret
0612   042C             ;
0613   042C             prtdot:
0614   042C             ;
0615   042C             	; shortcut to print a dot preserving all regs
0616   042C F5          	push	af		; save af
0617   042D 3E 2E       	ld	a,'.'		; load dot char
0618   042F CD 1F 04    	call	prtchr		; print it
0619   0432 F1          	pop	af		; restore af
0620   0433 C9          	ret			; done
0621   0434             ;
0622   0434             ; Print a zero terminated string at (de) without destroying any registers
0623   0434             ;
0624   0434             prtstr:
0625   0434 F5          	push	af
0626   0435 D5          	push	de
0627   0436             ;
0628   0436             prtstr1:
0629   0436 1A          	ld	a,(de)		; get next char
0630   0437 B7          	or	a
0631   0438 28 06       	jr	z,prtstr2
0632   043A CD 1F 04    	call	prtchr
0633   043D 13          	inc	de
0634   043E 18 F6       	jr	prtstr1
0635   0440             ;
0636   0440             prtstr2:
0637   0440 D1          	pop	de		; restore registers
0638   0441 F1          	pop	af
0639   0442 C9          	ret
0640   0443             ;
0641   0443             ; Print a hex value prefix "0x"
0642   0443             ;
0643   0443             prthexpre:
0644   0443 F5          	push	af
0645   0444 3E 30       	ld	a,'0'
0646   0446 CD 1F 04    	call	prtchr
0647   0449 3E 78       	ld	a,'x'
0648   044B CD 1F 04    	call	prtchr
0649   044E F1          	pop	af
0650   044F C9          	ret
0651   0450             
0652   0450             ;
0653   0450             ; Print the value in A in hex without destroying any registers
0654   0450             ;
0655   0450             prthex:
0656   0450 CD 43 04    	call	prthexpre
0657   0453             prthex1:
0658   0453 F5          	push	af		; save AF
0659   0454 D5          	push	de		; save DE
0660   0455 CD 81 04    	call	hexascii	; convert value in A to hex chars in DE
0661   0458 7A          	ld	a,d		; get the high order hex char
0662   0459 CD 1F 04    	call	prtchr		; print it
0663   045C 7B          	ld	a,e		; get the low order hex char
0664   045D CD 1F 04    	call	prtchr		; print it
0665   0460 D1          	pop	de		; restore DE
0666   0461 F1          	pop	af		; restore AF
0667   0462 C9          	ret			; done
0668   0463             ;
0669   0463             ; print the hex word value in hl
0670   0463             ;
0671   0463             prthexword:
0672   0463 CD 43 04    	call	prthexpre
0673   0466             prthexword1:
0674   0466 F5          	push	af
0675   0467 7C          	ld	a,h
0676   0468 CD 53 04    	call	prthex1
0677   046B 7D          	ld	a,l
0678   046C CD 53 04    	call	prthex1 
0679   046F F1          	pop	af
0680   0470 C9          	ret
0681   0471             ;
0682   0471             ; print the hex dword value in de:hl
0683   0471             ;
0684   0471             prthex32:
0685   0471 CD 43 04    	call	prthexpre
0686   0474 C5          	push	bc
0687   0475 D5          	push	de
0688   0476 C1          	pop	bc
0689   0477 CD 66 04    	call	prthexword1
0690   047A E5          	push	hl
0691   047B C1          	pop	bc
0692   047C CD 66 04    	call	prthexword1
0693   047F C1          	pop	bc
0694   0480 C9          	ret
0695   0481             ;
0696   0481             ; Convert binary value in A to ascii hex characters in DE
0697   0481             ;
0698   0481             hexascii:
0699   0481 57          	ld	d,a		; save A in D
0700   0482 CD 90 04    	call	hexconv		; convert low nibble of A to hex
0701   0485 5F          	ld	e,a		; save it in E
0702   0486 7A          	ld	a,d		; get original value back
0703   0487 07          	rlca			; rotate high order nibble to low bits
0704   0488 07          	rlca
0705   0489 07          	rlca
0706   048A 07          	rlca
0707   048B CD 90 04    	call	hexconv		; convert nibble
0708   048E 57          	ld	d,a		; save it in D
0709   048F C9          	ret			; done
0710   0490             ;
0711   0490             ; Convert low nibble of A to ascii hex
0712   0490             ;
0713   0490             hexconv:
0714   0490 E6 0F       	and	$0F	     	; low nibble only
0715   0492 C6 90       	add	a,$90
0716   0494 27          	daa	
0717   0495 CE 40       	adc	a,$40
0718   0497 27          	daa	
0719   0498 C9          	ret
0720   0499             ;
0721   0499             ; Print value of A or HL in decimal with leading zero suppression
0722   0499             ; Use prtdecb for A or prtdecw for HL
0723   0499             ;
0724   0499             prtdecb:
0725   0499 E5          	push	hl
0726   049A 26 00       	ld	h,0
0727   049C 6F          	ld	l,a
0728   049D CD A2 04    	call	prtdecw		; print it
0729   04A0 E1          	pop	hl
0730   04A1 C9          	ret
0731   04A2             ;
0732   04A2             prtdecw:
0733   04A2 F5          	push	af
0734   04A3 C5          	push	bc
0735   04A4 D5          	push	de
0736   04A5 E5          	push	hl
0737   04A6 CD AE 04    	call	prtdec0
0738   04A9 E1          	pop	hl
0739   04AA D1          	pop	de
0740   04AB C1          	pop	bc
0741   04AC F1          	pop	af
0742   04AD C9          	ret
0743   04AE             ;
0744   04AE             prtdec0:
0745   04AE 1E 30       	ld	e,'0'
0746   04B0 01 F0 D8    	ld	bc,-10000
0747   04B3 CD CB 04    	call	prtdec1
0748   04B6 01 18 FC    	ld	bc,-1000
0749   04B9 CD CB 04    	call	prtdec1
0750   04BC 01 9C FF    	ld	bc,-100
0751   04BF CD CB 04    	call	prtdec1
0752   04C2 0E F6       	ld	c,-10
0753   04C4 CD CB 04    	call	prtdec1
0754   04C7 1E 00       	ld	e,0
0755   04C9 0E FF       	ld	c,-1
0756   04CB             prtdec1:
0757   04CB 3E 2F       	ld	a,'0' - 1
0758   04CD             prtdec2:
0759   04CD 3C          	inc	a
0760   04CE 09          	add	hl,bc
0761   04CF 38 FC       	jr	c,prtdec2
0762   04D1 ED 42       	sbc	hl,bc
0763   04D3 BB          	cp	e
0764   04D4 C8          	ret	z
0765   04D5 1E 00       	ld	e,0
0766   04D7 CD 1F 04    	call	prtchr
0767   04DA C9          	ret
0768   04DB             ;
0769   04DB             ; Start a new line
0770   04DB             ;
0771   04DB             crlf2:
0772   04DB CD DE 04    	call	crlf		; two of them
0773   04DE             crlf:
0774   04DE F5          	push	af		; preserve AF
0775   04DF 3E 0D       	ld	a,13		; <CR>
0776   04E1 CD 1F 04    	call	prtchr		; print it
0777   04E4 3E 0A       	ld	a,10		; <LF>
0778   04E6 CD 1F 04    	call	prtchr		; print it
0779   04E9 F1          	pop	af		; restore AF
0780   04EA C9          	ret
0781   04EB             ;
0782   04EB             ; Delay ~10ms
0783   04EB             ;
0784   04EB             delay:
0785   04EB F5          	push	af
0786   04EC D5          	push	de
0787   04ED 11 71 02    	ld	de,625			; 10000us/16us
0788   04F0             delay0:
0789   04F0 3A 4D 0A    	ld	a,(cpuscl)
0790   04F3             delay1:
0791   04F3 3D          	dec	a
0792   04F4 20 FD       	jr	nz,delay1
0793   04F6 1B          	dec	de
0794   04F7 7A          	ld	a,d
0795   04F8 B3          	or	e
0796   04F9 C2 F0 04    	jp	nz,delay0
0797   04FC D1          	pop	de
0798   04FD F1          	pop	af
0799   04FE C9          	ret
0800   04FF             ;
0801   04FF             ;
0802   04FF             ;
0803   04FF             ;=======================================================================
0804   04FF             ; Constants
0805   04FF             ;=======================================================================
0806   04FF             ;
0807   04FF 4B 65 79 62 str_banner		.db	"Keyboard Information v0.2, 23-Dec-2021",0
0807   0503 6F 61 72 64 
0807   0507 20 49 6E 66 
0807   050B 6F 72 6D 61 
0807   050F 74 69 6F 6E 
0807   0513 20 76 30 2E 
0807   0517 32 2C 20 32 
0807   051B 33 2D 44 65 
0807   051F 63 2D 32 30 
0807   0523 32 31 00 
0808   0526 44 6F 6E 65 str_exit		.db	"Done, Thank you for using Keyboard Information!",0
0808   052A 2C 20 54 68 
0808   052E 61 6E 6B 20 
0808   0532 79 6F 75 20 
0808   0536 66 6F 72 20 
0808   053A 75 73 69 6E 
0808   053E 67 20 4B 65 
0808   0542 79 62 6F 61 
0808   0546 72 64 20 49 
0808   054A 6E 66 6F 72 
0808   054E 6D 61 74 69 
0808   0552 6F 6E 21 00 
0809   0556 4B 65 79 62 str_cmdport		.db	"Keyboard Controller Command Port: ",0
0809   055A 6F 61 72 64 
0809   055E 20 43 6F 6E 
0809   0562 74 72 6F 6C 
0809   0566 6C 65 72 20 
0809   056A 43 6F 6D 6D 
0809   056E 61 6E 64 20 
0809   0572 50 6F 72 74 
0809   0576 3A 20 00 
0810   0579 4B 65 79 62 str_dataport		.db	"Keyboard Controller Data Port: ",0
0810   057D 6F 61 72 64 
0810   0581 20 43 6F 6E 
0810   0585 74 72 6F 6C 
0810   0589 6C 65 72 20 
0810   058D 44 61 74 61 
0810   0591 20 50 6F 72 
0810   0595 74 3A 20 00 
0811   0599             ;str_prefix		.db	"  ",0
0812   0599             ;str_cmdout		.db	"->(CMD)",0
0813   0599             ;str_dataout		.db	"->(DATA)",0
0814   0599             ;str_datain		.db	"  (DATA)->",0
0815   0599             ;str_timeout_write	.db	"Keyboard Controller Write Timeout, Status: ",0
0816   0599             ;str_timeout_read	.db	"Keyboard Controller Read Timeout, Status: ",0
0817   0599 4B 65 79 62 str_err_ctlr_to		.db	"Keyboard Controller I/O Timeout",0
0817   059D 6F 61 72 64 
0817   05A1 20 43 6F 6E 
0817   05A5 74 72 6F 6C 
0817   05A9 6C 65 72 20 
0817   05AD 49 2F 4F 20 
0817   05B1 54 69 6D 65 
0817   05B5 6F 75 74 00 
0818   05B9 4B 65 79 62 str_err_ctlr_test	.db	"Keyboard Controller Self-Test Failed",0
0818   05BD 6F 61 72 64 
0818   05C1 20 43 6F 6E 
0818   05C5 74 72 6F 6C 
0818   05C9 6C 65 72 20 
0818   05CD 53 65 6C 66 
0818   05D1 2D 54 65 73 
0818   05D5 74 20 46 61 
0818   05D9 69 6C 65 64 
0818   05DD 00 
0819   05DE 20 20 53 65 str_put_cmd		.db	"  Sent Command ",0
0819   05E2 6E 74 20 43 
0819   05E6 6F 6D 6D 61 
0819   05EA 6E 64 20 00 
0820   05EE 20 20 53 65 str_put_data		.db	"  Sent Data ",0
0820   05F2 6E 74 20 44 
0820   05F6 61 74 61 20 
0820   05FA 00 
0821   05FB 20 20 47 6F str_get_data		.db	"  Got Data ",0
0821   05FF 74 20 44 61 
0821   0603 74 61 20 00 
0822   0607 41 74 74 65 str_ctlr_test		.db	"Attempting Controller Self-Test",0
0822   060B 6D 70 74 69 
0822   060F 6E 67 20 43 
0822   0613 6F 6E 74 72 
0822   0617 6F 6C 6C 65 
0822   061B 72 20 53 65 
0822   061F 6C 66 2D 54 
0822   0623 65 73 74 00 
0823   0627 43 6F 6E 74 str_ctlr_test_ok	.db	"Controller Self-Test OK",0
0823   062B 72 6F 6C 6C 
0823   062F 65 72 20 53 
0823   0633 65 6C 66 2D 
0823   0637 54 65 73 74 
0823   063B 20 4F 4B 00 
0824   063F 50 65 72 66 str_ctlr_setup		.db	"Performing Controller Setup",0
0824   0643 6F 72 6D 69 
0824   0647 6E 67 20 43 
0824   064B 6F 6E 74 72 
0824   064F 6F 6C 6C 65 
0824   0653 72 20 53 65 
0824   0657 74 75 70 00 
0825   065B 2A 2A 2A 2A str_basic		.db	"***** Basic Keyboard Checks and Scan Code Inventory *****",0
0825   065F 2A 20 42 61 
0825   0663 73 69 63 20 
0825   0667 4B 65 79 62 
0825   066B 6F 61 72 64 
0825   066F 20 43 68 65 
0825   0673 63 6B 73 20 
0825   0677 61 6E 64 20 
0825   067B 53 63 61 6E 
0825   067F 20 43 6F 64 
0825   0683 65 20 49 6E 
0825   0687 76 65 6E 74 
0825   068B 6F 72 79 20 
0825   068F 2A 2A 2A 2A 
0825   0693 2A 00 
0826   0695 2A 2A 2A 2A str_trans_off		.db	"***** Testing with Scan Code Translation DISABLED *****",0
0826   0699 2A 20 54 65 
0826   069D 73 74 69 6E 
0826   06A1 67 20 77 69 
0826   06A5 74 68 20 53 
0826   06A9 63 61 6E 20 
0826   06AD 43 6F 64 65 
0826   06B1 20 54 72 61 
0826   06B5 6E 73 6C 61 
0826   06B9 74 69 6F 6E 
0826   06BD 20 44 49 53 
0826   06C1 41 42 4C 45 
0826   06C5 44 20 2A 2A 
0826   06C9 2A 2A 2A 00 
0827   06CD 2A 2A 2A 2A str_trans_on		.db	"***** Testing with Scan Code Translation ENABLED *****",0
0827   06D1 2A 20 54 65 
0827   06D5 73 74 69 6E 
0827   06D9 67 20 77 69 
0827   06DD 74 68 20 53 
0827   06E1 63 61 6E 20 
0827   06E5 43 6F 64 65 
0827   06E9 20 54 72 61 
0827   06ED 6E 73 6C 61 
0827   06F1 74 69 6F 6E 
0827   06F5 20 45 4E 41 
0827   06F9 42 4C 45 44 
0827   06FD 20 2A 2A 2A 
0827   0701 2A 2A 00 
0828   0704 41 74 74 65 str_kbd_reset		.db	"Attempting Keyboard Reset",0
0828   0708 6D 70 74 69 
0828   070C 6E 67 20 4B 
0828   0710 65 79 62 6F 
0828   0714 61 72 64 20 
0828   0718 52 65 73 65 
0828   071C 74 00 
0829   071E 4B 65 79 62 str_kbd_reset_ok	.db	"Keyboard Reset OK",0
0829   0722 6F 61 72 64 
0829   0726 20 52 65 73 
0829   072A 65 74 20 4F 
0829   072E 4B 00 
0830   0730 4B 65 79 62 str_err_kbd_reset	.db	"Keyboard Reset Failed",0
0830   0734 6F 61 72 64 
0830   0738 20 52 65 73 
0830   073C 65 74 20 46 
0830   0740 61 69 6C 65 
0830   0744 64 00 
0831   0746 52 65 71 75 str_kbd_getsc		.db	"Requesting Active Scan Code Set from Keyboard",0
0831   074A 65 73 74 69 
0831   074E 6E 67 20 41 
0831   0752 63 74 69 76 
0831   0756 65 20 53 63 
0831   075A 61 6E 20 43 
0831   075E 6F 64 65 20 
0831   0762 53 65 74 20 
0831   0766 66 72 6F 6D 
0831   076A 20 4B 65 79 
0831   076E 62 6F 61 72 
0831   0772 64 00 
0832   0774 41 63 74 69 str_kbd_dispsc		.db	"Active Keyboard Scan Code Set is #",0
0832   0778 76 65 20 4B 
0832   077C 65 79 62 6F 
0832   0780 61 72 64 20 
0832   0784 53 63 61 6E 
0832   0788 20 43 6F 64 
0832   078C 65 20 53 65 
0832   0790 74 20 69 73 
0832   0794 20 23 00 
0833   0797 45 72 72 6F str_err_kbd_getsc	.db	"Error getting Active Keyboard Scan Code Set",0
0833   079B 72 20 67 65 
0833   079F 74 74 69 6E 
0833   07A3 67 20 41 63 
0833   07A7 74 69 76 65 
0833   07AB 20 4B 65 79 
0833   07AF 62 6F 61 72 
0833   07B3 64 20 53 63 
0833   07B7 61 6E 20 43 
0833   07BB 6F 64 65 20 
0833   07BF 53 65 74 00 
0834   07C3 53 65 74 74 str_kbd_setsc		.db	"Setting Active Keyboard Scan Code Set to #",0
0834   07C7 69 6E 67 20 
0834   07CB 41 63 74 69 
0834   07CF 76 65 20 4B 
0834   07D3 65 79 62 6F 
0834   07D7 61 72 64 20 
0834   07DB 53 63 61 6E 
0834   07DF 20 43 6F 64 
0834   07E3 65 20 53 65 
0834   07E7 74 20 74 6F 
0834   07EB 20 23 00 
0835   07EE 45 72 72 6F str_err_kbd_setsc	.db	"Error setting Active Keyboard Scan Code Set",0
0835   07F2 72 20 73 65 
0835   07F6 74 74 69 6E 
0835   07FA 67 20 41 63 
0835   07FE 74 69 76 65 
0835   0802 20 4B 65 79 
0835   0806 62 6F 61 72 
0835   080A 64 20 53 63 
0835   080E 61 6E 20 43 
0835   0812 6F 64 65 20 
0835   0816 53 65 74 00 
0836   081A 4B 65 79 62 str_kbd_ident		.db	"Keyboard Identification",0
0836   081E 6F 61 72 64 
0836   0822 20 49 64 65 
0836   0826 6E 74 69 66 
0836   082A 69 63 61 74 
0836   082E 69 6F 6E 00 
0837   0832 4B 65 79 62 str_kbd_ident_disp	.db	"Keyboard Identity: ",0
0837   0836 6F 61 72 64 
0837   083A 20 49 64 65 
0837   083E 6E 74 69 74 
0837   0842 79 3A 20 00 
0838   0846 53 63 61 6E str_sc_tag		.db	"Scan Code Set #",0
0838   084A 20 43 6F 64 
0838   084E 65 20 53 65 
0838   0852 74 20 23 00 
0839   0856 20 49 53 20 str_sc_ok		.db	" IS supported",0
0839   085A 73 75 70 70 
0839   085E 6F 72 74 65 
0839   0862 64 00 
0840   0864 20 49 53 20 str_sc_fail		.db	" IS NOT supported",0
0840   0868 4E 4F 54 20 
0840   086C 73 75 70 70 
0840   0870 6F 72 74 65 
0840   0874 64 00 
0841   0876 45 72 72 6F str_err_kbd_ident	.db	"Error performing Keyboard Identification",0
0841   087A 72 20 70 65 
0841   087E 72 66 6F 72 
0841   0882 6D 69 6E 67 
0841   0886 20 4B 65 79 
0841   088A 62 6F 61 72 
0841   088E 64 20 49 64 
0841   0892 65 6E 74 69 
0841   0896 66 69 63 61 
0841   089A 74 69 6F 6E 
0841   089E 00 
0842   089F 44 69 73 70 str_disp_scan_codes	.db	"Displaying Raw Scan Codes",13,10
0842   08A3 6C 61 79 69 
0842   08A7 6E 67 20 52 
0842   08AB 61 77 20 53 
0842   08AF 63 61 6E 20 
0842   08B3 43 6F 64 65 
0842   08B7 73 0D 0A 
0843   08BA 20 20 50 72 			.db	"  Press keys on test keyboard to display scan codes",13,10
0843   08BE 65 73 73 20 
0843   08C2 6B 65 79 73 
0843   08C6 20 6F 6E 20 
0843   08CA 74 65 73 74 
0843   08CE 20 6B 65 79 
0843   08D2 62 6F 61 72 
0843   08D6 64 20 74 6F 
0843   08DA 20 64 69 73 
0843   08DE 70 6C 61 79 
0843   08E2 20 73 63 61 
0843   08E6 6E 20 63 6F 
0843   08EA 64 65 73 0D 
0843   08EE 0A 
0844   08EF 20 20 50 72 			.db	"  Press <esc> on CP/M console to end",13,10,13,10,0
0844   08F3 65 73 73 20 
0844   08F7 3C 65 73 63 
0844   08FB 3E 20 6F 6E 
0844   08FF 20 43 50 2F 
0844   0903 4D 20 63 6F 
0844   0907 6E 73 6F 6C 
0844   090B 65 20 74 6F 
0844   090F 20 65 6E 64 
0844   0913 0D 0A 0D 0A 
0844   0917 00 
0845   0918 2A 2A 2A 2A str_run_failed		.db	"***** HARDWARE ERROR *****",13,10,13,10
0845   091C 2A 20 48 41 
0845   0920 52 44 57 41 
0845   0924 52 45 20 45 
0845   0928 52 52 4F 52 
0845   092C 20 2A 2A 2A 
0845   0930 2A 2A 0D 0A 
0845   0934 0D 0A 
0846   0936 41 20 62 61 			.db	"A basic hardware or configuration issue prevented",13,10
0846   093A 73 69 63 20 
0846   093E 68 61 72 64 
0846   0942 77 61 72 65 
0846   0946 20 6F 72 20 
0846   094A 63 6F 6E 66 
0846   094E 69 67 75 72 
0846   0952 61 74 69 6F 
0846   0956 6E 20 69 73 
0846   095A 73 75 65 20 
0846   095E 70 72 65 76 
0846   0962 65 6E 74 65 
0846   0966 64 0D 0A 
0847   0969 4B 65 79 62 			.db	"Keyboard Information from completing the full set",13,10
0847   096D 6F 61 72 64 
0847   0971 20 49 6E 66 
0847   0975 6F 72 6D 61 
0847   0979 74 69 6F 6E 
0847   097D 20 66 72 6F 
0847   0981 6D 20 63 6F 
0847   0985 6D 70 6C 65 
0847   0989 74 69 6E 67 
0847   098D 20 74 68 65 
0847   0991 20 66 75 6C 
0847   0995 6C 20 73 65 
0847   0999 74 0D 0A 
0848   099C 6F 66 20 74 			.db	"of tests.  Check your hardware and verify the port",13,10
0848   09A0 65 73 74 73 
0848   09A4 2E 20 20 43 
0848   09A8 68 65 63 6B 
0848   09AC 20 79 6F 75 
0848   09B0 72 20 68 61 
0848   09B4 72 64 77 61 
0848   09B8 72 65 20 61 
0848   09BC 6E 64 20 76 
0848   09C0 65 72 69 66 
0848   09C4 79 20 74 68 
0848   09C8 65 20 70 6F 
0848   09CC 72 74 0D 0A 
0849   09D0 61 64 64 72 			.db	"addresses being used for the keyboard controller",0
0849   09D4 65 73 73 65 
0849   09D8 73 20 62 65 
0849   09DC 69 6E 67 20 
0849   09E0 75 73 65 64 
0849   09E4 20 66 6F 72 
0849   09E8 20 74 68 65 
0849   09EC 20 6B 65 79 
0849   09F0 62 6F 61 72 
0849   09F4 64 20 63 6F 
0849   09F8 6E 74 72 6F 
0849   09FC 6C 6C 65 72 
0849   0A00 00 
0850   0A01             ;
0851   0A01             ;=======================================================================
0852   0A01             ; Working data
0853   0A01             ;=======================================================================
0854   0A01             ;
0855   0A01 00 00       stksav		.dw	0		; stack pointer saved at start
0856   0A03 00 00 00 00 		.fill	stksiz,0	; stack
0856   0A07 00 00 00 00 
0856   0A0B 00 00 00 00 
0856   0A0F 00 00 00 00 
0856   0A13 00 00 00 00 
0856   0A17 00 00 00 00 
0856   0A1B 00 00 00 00 
0856   0A1F 00 00 00 00 
0856   0A23 00 00 00 00 
0856   0A27 00 00 00 00 
0856   0A2B 00 00 00 00 
0856   0A2F 00 00 00 00 
0856   0A33 00 00 00 00 
0856   0A37 00 00 00 00 
0856   0A3B 00 00 00 00 
0856   0A3F 00 00 00 00 
0857   0A43             stack		.equ	$		; stack top
0858   0A43             ;
0859   0A43 FF FF FF FF workbuf		.fill	8
0859   0A47 FF FF FF FF 
0860   0A4B 00          workbuf_len	.db	0
0861   0A4C             ;
0862   0A4C 00          ctlr_cfgval	.db	0		; Value for controller cmd reg 0
0863   0A4D             ;
0864   0A4D 06          cpuscl		.db	cpumhz - 2
0865   0A4E 00          timeout		.db	ltimout
0866   0A4F             ;
0867   0A4F             ;=======================================================================
0868   0A4F             ;
0869   0A4F             	.endtasm: Number of errors = 0
