ca65 V2.18 - Ubuntu 2.19-1
Main file   : format.asm
Current file: format.asm

000000r 1               ;__FLOPPY FORMAT_________________________________________________________________________________________________________________
000000r 1               ;
000000r 1               ; 	DOS/65 floppy FORMATTER for Nhyodyne FDC card
000000r 1               ;
000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               ;
000000r 1               DFLFCB          = $107          ;DEFAULT FCB
000000r 1               PEM             = $103          ;PEM ENTRY
000000r 1               BOOT            = $100          ;WARM BOOT
000000r 1               TEA             = $800          ;EXECUTION ORG
000000r 1               CCMLNG          = 2048          ;CCM LENGTH
000000r 1               CRSYM           = 32            ;CR SYMBOL
000000r 1               LASTROW         = 20
000000r 1               MAXCOL          = 80
000000r 1               
000000r 1               USEDSKYNG       = 0
000000r 1               USEDSKY         = 0
000000r 1               
000000r 1               OUTMSG_W        = $F0
000000r 1               STACKA          = $3A
000000r 1               DENS            = 2             ; DENSITY
000000r 1               EOTSEC          = 09            ; LAST SECTOR OF TRACK
000000r 1               
000000r 1               DRIVERS         = 0
000000r 1               
000000r 1               ;MAIN PROGRAM
000000r 1                       .SEGMENT "TEA"
000000r 1                       .ORG    $0800
000800  1               
000800  1               
000800  1               
000800  1  A9 34                LDA     #STR_BANNER &$FF
000802  1  A0 13                LDY     #STR_BANNER>>8 & $FF
000804  1  20 F7 0E             JSR     WRITESTR
000807  1               
000807  1               INLOOP:
000807  1  20 0B 0F             JSR     CIN
00080A  1  C9 31                CMP     #'1'
00080C  1  F0 07                BEQ     TRACK40
00080E  1  C9 32                CMP     #'2'
000810  1  F0 10                BEQ     TRACK80
000812  1  4C 07 08             JMP     INLOOP
000815  1               
000815  1               TRACK40:
000815  1  A9 28                LDA     #40
000817  1  8D 33 13             STA     MAXTRACK
00081A  1  A9 50                LDA     #$50
00081C  1  8D 2A 0F             STA     FMTGAP          ; GAP FOR FORMAT 5.25=$50, 3.5=$54
00081F  1  4C 2F 08             JMP     FMTCONT
000822  1               
000822  1               TRACK80:
000822  1  A9 50                LDA     #80
000824  1  8D 33 13             STA     MAXTRACK
000827  1  A9 54                LDA     #$54
000829  1  8D 2A 0F             STA     FMTGAP          ; GAP FOR FORMAT 5.25=$50, 3.5=$54
00082C  1  4C 2F 08             JMP     FMTCONT
00082F  1               
00082F  1               
00082F  1               FMTCONT:
00082F  1  A9 B8                LDA     #STR_DRIVE &$FF
000831  1  A0 13                LDY     #STR_DRIVE>>8 & $FF
000833  1  20 F7 0E             JSR     WRITESTR
000836  1               
000836  1               INLOOP1:
000836  1  20 0B 0F             JSR     CIN
000839  1  C9 31                CMP     #'1'
00083B  1  F0 07                BEQ     FMTCONT1
00083D  1  C9 32                CMP     #'2'
00083F  1  F0 10                BEQ     FMTCONT2
000841  1  4C 36 08             JMP     INLOOP1
000844  1               
000844  1               FMTCONT1:
000844  1  A9 00                LDA     #$00
000846  1  8D 30 0F             STA     sekdsk
000849  1  A9 11                LDA     #%00010001
00084B  1  8D 31 0F             STA     DSKUNIT
00084E  1  4C 5E 08             JMP     FMTCONT3
000851  1               
000851  1               FMTCONT2:
000851  1  A9 01                LDA     #$01
000853  1  8D 30 0F             STA     sekdsk
000856  1  A9 21                LDA     #%00100001
000858  1  8D 31 0F             STA     DSKUNIT
00085B  1  4C 5E 08             JMP     FMTCONT3
00085E  1               
00085E  1               
00085E  1               FMTCONT3:
00085E  1  A9 E9                LDA     #STR_INTRO &$FF
000860  1  A0 13                LDY     #STR_INTRO>>8 & $FF
000862  1  20 F7 0E             JSR     WRITESTR
000865  1               
000865  1  A9 26                LDA     #STR_CONFIRM &$FF
000867  1  A0 14                LDY     #STR_CONFIRM>>8 & $FF
000869  1  20 F7 0E             JSR     WRITESTR
00086C  1               
00086C  1  20 15 0F             JSR     CONF
00086F  1               
00086F  1  20 CF 0E             JSR     PC_CR
000872  1  20 D7 0E             JSR     PC_LF
000875  1  A9 00                LDA     #$00
000877  1  8D B4 0E             STA     debcyl
00087A  1               
00087A  1               FMTLOOP:
00087A  1  A9 00                LDA     #$00
00087C  1  8D B3 0E             STA     debhead
00087F  1  20 A0 08             JSR     FMTCYL
000882  1               
000882  1  A9 01                LDA     #$01
000884  1  8D B3 0E             STA     debhead
000887  1  20 A0 08             JSR     FMTCYL
00088A  1               
00088A  1  EE B4 0E             INC     debcyl
00088D  1  AD B4 0E             LDA     debcyl
000890  1  CD 33 13             CMP     MAXTRACK
000893  1  D0 E5                BNE     FMTLOOP
000895  1               
000895  1               DONE:
000895  1  20 CF 0E             JSR     PC_CR
000898  1  20 D7 0E             JSR     PC_LF
00089B  1  A2 00                LDX     #$00
00089D  1  4C 03 01             JMP     PEM
0008A0  1               
0008A0  1               
0008A0  1               ;__FMTCYL________________________________________________________________________________________________________________________
0008A0  1               ;
0008A0  1               ; 	FORMAT A FLOPPY TRACK
0008A0  1               ;________________________________________________________________________________________________________________________________
0008A0  1               ;
0008A0  1               FMTCYL:
0008A0  1  20 57 0D             JSR     SETTRACK        ; PERFORM SEEK TO TRACK
0008A3  1  78                   SEI
0008A4  1  20 F5 0D             JSR     CHECKINT        ; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
0008A7  1  C9 FF                CMP     #$FF            ; DID IT RETURN WITH ERROR CODE?
0008A9  1  D0 0A                BNE     FMTGO           ; IF YES, EXIT WITH ERROR CODE
0008AB  1  A9 52                LDA     #STR_ERR1 &$FF
0008AD  1  A0 14                LDY     #STR_ERR1>>8 & $FF
0008AF  1  20 F7 0E             JSR     WRITESTR
0008B2  1  4C 92 0C             JMP     DSKEXIT
0008B5  1               FMTGO:  ; 					;
0008B5  1               FMT:    ; FORMAT TRACK COMMAND
0008B5  1               ;
0008B5  1  18                   CLC
0008B6  1  AD 30 0F             LDA     sekdsk          ; GET DISK UNIT NUMBER
0008B9  1  29 01                AND     #$01            ; MASK FOR TWO DRIVES.
0008BB  1  8D BA 0E             STA     UNIT            ; PARK IT IN TEMP
0008BE  1  AD B3 0E             LDA     debhead         ; GET HEAD SELECTION
0008C1  1  29 01                AND     #$01            ; INSURE SINGLE BIT
0008C3  1  0A                   ASL     A               ;
0008C4  1  0A                   ASL     A               ; MOVE HEAD TO BIT 2 POSITION
0008C5  1  0D BA 0E             ORA     UNIT            ; OR HEAD TO UNIT BYTE IN COMMAND BLOCK
0008C8  1  8D BA 0E             STA     UNIT            ; STORE IN UNIT
0008CB  1               ;
0008CB  1  A9 4D                LDA     #$4D            ; BIT 6 SETS MFM, 0DH IS FORMAT COMMAND
0008CD  1  20 B1 0D             JSR     PFDATA          ; PUSH FORMAT COMMAND TO I8272
0008D0  1  AD BA 0E             LDA     UNIT            ;
0008D3  1  20 B1 0D             JSR     PFDATA          ; WHICH DRIVE UNIT TO FORMAT
0008D6  1  A9 02                LDA     #DENS           ;
0008D8  1  20 B1 0D             JSR     PFDATA          ; WHAT DENSITY
0008DB  1  A9 09                LDA     #EOTSEC         ;
0008DD  1  20 B1 0D             JSR     PFDATA          ; SECTOR COUNT
0008E0  1  AD 2A 0F             LDA     FMTGAP          ;
0008E3  1  20 B1 0D             JSR     PFDATA          ; WHAT GAP IS NEEDED
0008E6  1  A9 E5                LDA     #$E5            ;
0008E8  1  20 DC 0D             JSR     PFDATAS         ; FILLER BYTE FOR SECTORS
0008EB  1  A0 01                LDY     #$01            ; SET SECTOR#
0008ED  1               
0008ED  1               FMT1:
0008ED  1  AD 30 03             LDA     FDC_MSR         ; GET STATUS
0008F0  1  10 FB                BPL     FMT1
0008F2  1  8D 32 13             STA     temp            ;
0008F5  1  29 20                AND     #%00100000      ; EXECUTION MODE?
0008F7  1  F0 49                BEQ     DSKFMEND1       ; NO, ERROR
0008F9  1               
0008F9  1  AD B4 0E             LDA     debcyl          ; UPDATE I8272 DURING FORMAT
0008FC  1  8D 31 03             STA     FDC_DATA        ; SEND CYLINDER NUMBER
0008FF  1               ;
0008FF  1               ;
0008FF  1               FMT1A:
0008FF  1  AD 30 03             LDA     FDC_MSR         ; GET STATUS
000902  1  10 FB                BPL     FMT1A
000904  1  8D 32 13             STA     temp            ;
000907  1  29 20                AND     #%00100000      ; EXECUTION MODE?
000909  1  F0 44                BEQ     DSKFMEND1A      ; NO, ERROR
00090B  1  AD B3 0E             LDA     debhead         ; UPDATE I8272 DURING FORMAT
00090E  1  8D 31 03             STA     FDC_DATA        ; SEND HEAD NUMBER
000911  1               
000911  1               FMT1B:
000911  1  AD 30 03             LDA     FDC_MSR         ; GET STATUS
000914  1  10 FB                BPL     FMT1B
000916  1  8D 32 13             STA     temp            ;
000919  1  29 20                AND     #%00100000      ; EXECUTION MODE?
00091B  1  F0 3F                BEQ     DSKFMEND1B      ; NO, ERROR
00091D  1               ;
00091D  1  98                   TYA
00091E  1  8D 31 03             STA     FDC_DATA        ; WHAT SECTOR NUMBER
000921  1               
000921  1               
000921  1               FMT1C:
000921  1  AD 30 03             LDA     FDC_MSR         ; GET STATUS
000924  1  10 FB                BPL     FMT1C
000926  1  8D 32 13             STA     temp            ;
000929  1  29 20                AND     #%00100000      ; EXECUTION MODE?
00092B  1  F0 3C                BEQ     DSKFMEND1C      ; NO, ERROR
00092D  1               ;
00092D  1  A9 02                LDA     #DENS           ;
00092F  1  8D 31 03             STA     FDC_DATA        ; NUMBER OF BYTES PER SECTOR (N2)
000932  1               
000932  1               FMT1D:
000932  1  AD 30 03             LDA     FDC_MSR         ; GET STATUS
000935  1  10 FB                BPL     FMT1D           ;
000937  1               ;
000937  1  C8                   INY                     ; INCREASE SECTOR COUNT
000938  1               ;
000938  1  C0 0A                CPY     #$0A            ; IS THIS PAST THE LAST SECTOR OF TRACK?
00093A  1  D0 B1                BNE     FMT1            ; IF NO, SEND ANOTHER SECTOR
00093C  1  20 C7 0E             JSR     PC_PERIOD
00093F  1  4C 76 09             JMP     FMTEND
000942  1               
000942  1               
000942  1               
000942  1               DSKFMEND1:
000942  1  A9 63                LDA     #STR_ERR2 &$FF
000944  1  A0 14                LDY     #STR_ERR2>>8 & $FF
000946  1  20 F7 0E             JSR     WRITESTR
000949  1  20 7F 09             JSR     GETERR
00094C  1  4C 95 08             JMP     DONE
00094F  1               DSKFMEND1A:
00094F  1  A9 74                LDA     #STR_ERR3 &$FF
000951  1  A0 14                LDY     #STR_ERR3>>8 & $FF
000953  1  20 F7 0E             JSR     WRITESTR
000956  1  20 7F 09             JSR     GETERR
000959  1  4C 95 08             JMP     DONE
00095C  1               DSKFMEND1B:
00095C  1  A9 85                LDA     #STR_ERR4 &$FF
00095E  1  A0 14                LDY     #STR_ERR4>>8 & $FF
000960  1  20 F7 0E             JSR     WRITESTR
000963  1  20 7F 09             JSR     GETERR
000966  1  4C 95 08             JMP     DONE
000969  1               DSKFMEND1C:
000969  1  A9 96                LDA     #STR_ERR5 &$FF
00096B  1  A0 14                LDY     #STR_ERR5>>8 & $FF
00096D  1  20 F7 0E             JSR     WRITESTR
000970  1  20 7F 09             JSR     GETERR
000973  1  4C 95 08             JMP     DONE
000976  1               
000976  1               FMTEND:
000976  1               ;* CLEAR OUT ANY REMAINING DATA
000976  1  A0 10                LDY     #$10
000978  1               FMTEND_1:
000978  1  20 3E 0E             JSR     GFDATA          ;GET ERROR TYPE
00097B  1  88                   DEY
00097C  1  D0 FA                BNE     FMTEND_1
00097E  1  60                   RTS
00097F  1               
00097F  1               GETERR:
00097F  1  AD 32 13             LDA     temp            ;GET ERROR TYPE
000982  1  20 EA 0E             JSR     PRINT_BYTE
000985  1  20 BF 0E             JSR     PC_SPACE
000988  1  20 3E 0E             JSR     GFDATA          ;GET ERROR TYPE
00098B  1  20 EA 0E             JSR     PRINT_BYTE
00098E  1  20 BF 0E             JSR     PC_SPACE
000991  1  20 3E 0E             JSR     GFDATA          ;GET ERROR TYPE
000994  1  20 EA 0E             JSR     PRINT_BYTE
000997  1  20 BF 0E             JSR     PC_SPACE
00099A  1  20 3E 0E             JSR     GFDATA          ;GET ERROR TYPE
00099D  1  20 EA 0E             JSR     PRINT_BYTE
0009A0  1  20 BF 0E             JSR     PC_SPACE
0009A3  1  20 3E 0E             JSR     GFDATA          ;GET ERROR TYPE
0009A6  1  20 EA 0E             JSR     PRINT_BYTE
0009A9  1  20 BF 0E             JSR     PC_SPACE
0009AC  1  20 3E 0E             JSR     GFDATA          ;GET ERROR TYPE
0009AF  1  20 EA 0E             JSR     PRINT_BYTE
0009B2  1  20 BF 0E             JSR     PC_SPACE
0009B5  1  20 3E 0E             JSR     GFDATA          ;GET ERROR TYPE
0009B8  1  20 EA 0E             JSR     PRINT_BYTE
0009BB  1  20 BF 0E             JSR     PC_SPACE
0009BE  1  20 3E 0E             JSR     GFDATA          ;GET ERROR TYPE
0009C1  1  20 EA 0E             JSR     PRINT_BYTE
0009C4  1  60                   RTS
0009C5  1               
0009C5  1               
0009C5  1                       .INCLUDE "../os/macro.asm"
0009C5  2               ;__MACRO___________________________________________________________________________________________________________________
0009C5  2               ;
0009C5  2               ; 	Macros for the betterment of Mankind
0009C5  2               ;________________________________________________________________________________________________________________________________
0009C5  2               ;
0009C5  2               
0009C5  2               .macro          PRTDBG      message
0009C5  2               .LOCAL p1
0009C5  2               .LOCAL p2
0009C5  2               .LOCAL p3
0009C5  2               .LOCAL p4
0009C5  2               .LOCAL p5
0009C5  2                 .if     .paramcount <> 1
0009C5  2                       .error  "Too few parameters for macro PRTDBG"
0009C5  2                       .endif
0009C5  2                       .if DEBUG=1
0009C5  2                       PHA
0009C5  2                       txa
0009C5  2                       PHa
0009C5  2                       tya
0009C5  2                       PHa
0009C5  2                       LDX #$00
0009C5  2               p1:
0009C5  2                       LDA p4,x
0009C5  2                       INX
0009C5  2                       CMP #'$'
0009C5  2                       BEQ p2
0009C5  2                       JSR conwrt
0009C5  2                       JMP p1
0009C5  2               p2:
0009C5  2                       LDA #13
0009C5  2                       jsr conwrt
0009C5  2                       LDA #10
0009C5  2                       jsr conwrt
0009C5  2                       PLA
0009C5  2                       tay
0009C5  2                       PLA
0009C5  2                       tax
0009C5  2                       pla
0009C5  2                       JMP p5
0009C5  2               p4:
0009C5  2                       .BYTE message
0009C5  2               p5:
0009C5  2                       .endif
0009C5  2               .endmacro
0009C5  2               
0009C5  2               .macro          PRTS      message
0009C5  2               .LOCAL p1
0009C5  2               .LOCAL p2
0009C5  2               .LOCAL p3
0009C5  2               .LOCAL p4
0009C5  2               .LOCAL p5
0009C5  2                 .if     .paramcount <> 1
0009C5  2                       .error  "Too few parameters for macro PRTS"
0009C5  2                       .endif
0009C5  2                       PHA
0009C5  2                       txa
0009C5  2                       PHa
0009C5  2                       tya
0009C5  2                       PHa
0009C5  2                       LDX #$00
0009C5  2               p1:
0009C5  2                       LDA p4,x
0009C5  2                       INX
0009C5  2                       CMP #'$'
0009C5  2                       BEQ p2
0009C5  2                       JSR conwrt
0009C5  2                       JMP p1
0009C5  2               p2:
0009C5  2                       PLa
0009C5  2                       tay
0009C5  2                       pla
0009C5  2                       tax
0009C5  2                       pla
0009C5  2                       JMP p5
0009C5  2               p4:
0009C5  2                       .BYTE message
0009C5  2               p5:
0009C5  2               .endmacro
0009C5  2               
0009C5  2               
0009C5  2               
0009C5  2               
0009C5  2               ;__PRTHEXBYTE__________________________________________________
0009C5  2               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
0009C5  2               ;______________________________________________________________
0009C5  2               PRTHEXBYTE:
0009C5  2  48                   PHA
0009C6  2  85 3A                sta     STACKA
0009C8  2  8A                   TXA
0009C9  2  48                   PHa
0009CA  2  98                   tya
0009CB  2  48                   PHA
0009CC  2  A5 3A                LDA     STACKA
0009CE  2  AA                   TAX				; SAVE A REGISTER
0009CF  2  4A                   LSR 				; SHIFT HIGH NIBBLE TO LOW NIBBLE
0009D0  2  4A                   LSR 				;
0009D1  2  4A                   LSR 				;
0009D2  2  4A                   LSR 				;
0009D3  2  18                   CLC               		; CLEAR CARRY
0009D4  2  20 E1 09             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
0009D7  2  8A                   TXA				; RESTORE ACCUMULATOR
0009D8  2  20 E1 09             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
0009DB  2  68                   PLa
0009DC  2  A8                   TAY
0009DD  2  68                   plA
0009DE  2  AA                   TAX
0009DF  2  68                   PLA
0009E0  2  60                   RTS
0009E1  2               
0009E1  2               ;__PRINT_DIGIT_________________________________________________
0009E1  2               ;
0009E1  2               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
0009E1  2               ;
0009E1  2               ;______________________________________________________________
0009E1  2               PRINT_DIGIT:
0009E1  2  29 0F                       AND #$0F				; STRIP OFF HIGH NIBBLE
0009E3  2  09 30                       ORA #$30				; ADD $30 TO PRODUCE ASCII
0009E5  2  C9 3A                       CMP #$3A               		; IS GREATER THAN 9
0009E7  2  30 03                       BMI PRINT_DIGIT_OUT		; NO, SKIP ADD
0009E9  2  18                          CLC				; CLEAR CARRY
0009EA  2  69 07                       ADC #$07				; ADD ON FOR LETTER VALUES
0009EC  2               PRINT_DIGIT_OUT:					;
0009EC  2  4C DF 0E                    JMP conwrt              		; PRINT OUT CHAR
0009EF  2               
0009EF  2               NEWLINE:
0009EF  2  48                           pha
0009F0  2  8A                           TXA
0009F1  2  48                           PHA
0009F2  2  98                           TYA
0009F3  2  48                           phA
0009F4  2  A9 0D                        LDA #$0D
0009F6  2  20 DF 0E                     JSR conwrt
0009F9  2  A9 0A                        LDA #$0A
0009FB  2  20 DF 0E                     Jsr conwrt
0009FE  2  68                           pla
0009FF  2  A8                           TAY
000A00  2  68                           pla
000A01  2  AA                           TAX
000A02  2  68                           pla
000A03  2  60                           rts
000A04  2               
000A04  2               PRTDEC:
000A04  2  85 3A                        STA             STACKA
000A06  2  98                           TYA
000A07  2  48                           phA
000A08  2  8A                           TXA
000A09  2  48                           PHa
000A0A  2  A5 3A                        LDA             STACKA
000A0C  2  48                           PHA
000A0D  2  A0 00                        ldy #00
000A0F  2  A2 FF                        LDX #$FF
000A11  2  38                           SEC
000A12  2               PrDec100:
000A12  2  E8                           INX
000A13  2  E9 64                        SBC #100
000A15  2  B0 FB                        BCS PrDec100            ;Count how many 100s
000A17  2  69 64                        ADC #100
000A19  2  20 39 0A                     JSR PrDecDigit          ;Print the 100s
000A1C  2  A2 FF                        LDX #$FF
000A1E  2  38                           SEC                     ;Prepare for subtraction
000A1F  2               PrDec10:
000A1F  2  E8                           INX
000A20  2  E9 0A                        SBC #10
000A22  2  B0 FB                        BCS PrDec10             ;Count how many 10s
000A24  2  69 0A                        ADC #10
000A26  2  20 39 0A                     JSR PrDecDigit          ;Print the 10s
000A29  2  AA                           TAX                     ;Pass 1s into X
000A2A  2  A0 01                        ldy #1
000A2C  2  20 39 0A                     JSR PrDecDigit          ;Print the 1s
000A2F  2  68                           PLA
000A30  2  85 3A                        STA STACKA
000A32  2  68                           PLa
000A33  2  AA                           TAX
000A34  2  68                           pla
000A35  2  A8                           TAY
000A36  2  A5 3A                        LDA     STACKA
000A38  2  60                           RTS
000A39  2               PrDecDigit:
000A39  2  48                           PHA
000A3A  2  C0 00                        cpy #$00
000A3C  2  D0 09                        bne PrDecDigit1
000A3E  2  8A                           txa
000A3F  2  A8                           tay
000A40  2  C0 00                        cpy #$00
000A42  2  D0 03                        bne PrDecDigit1
000A44  2  4C 4D 0A                     jmp PrDecDigit2
000A47  2               PrDecDigit1:
000A47  2  8A                           TXA                     ;Save A, pass digit to A
000A48  2  09 30                        ORA #'0'
000A4A  2  20 DF 0E                     JSR  conwrt             ;Convert to character and print it
000A4D  2               PrDecDigit2:
000A4D  2  68                           PLA
000A4E  2  60                           RTS                     ;Restore A and return
000A4F  2               
000A4F  1                       .INCLUDE "../os/dosflp.asm"
000A4F  2               ;__FLOPPY DRIVERS________________________________________________________________________________________________________________
000A4F  2               ;
000A4F  2               ; 	DOS/65 floppy drivers for MBC FDC card
000A4F  2               ;
000A4F  2               ;	Entry points:
000A4F  2               ;		FL_SETUP        - called during OS init
000A4F  2               ;		FL_READ_SECTOR	- read a sector from drive
000A4F  2               ;		FL_WRITE_SECTOR	- write a sector to drive
000A4F  2               ;
000A4F  2               ;________________________________________________________________________________________________________________________________
000A4F  2               ;
000A4F  2               ;*
000A4F  2               ;* HARDWARE I/O ADDRESSES
000A4F  2               ;*
000A4F  2               FDC_MSR         = $0330         ; ADDRESS OF MAIN STATUS REGISTER
000A4F  2               FDC_DATA        = $0331         ; FLOPPY DATA REGISTER
000A4F  2               FDC_RESET       = $0333         ; FLOPPY RESET
000A4F  2               FDC_DCR         = $0335         ; LOAD CONTROL REGISTER
000A4F  2               FDC_DOR         = $0336         ; CONFIGURATION CONTROL REGISTER
000A4F  2               FDC_TC          = $0337         ; TERMINAL COUNT
000A4F  2               
000A4F  2               ;
000A4F  2               ; FDC COMMANDS
000A4F  2               ;
000A4F  2               CFD_READ        = %00000110     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
000A4F  2               CFD_READDEL     = %00001100     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
000A4F  2               CFD_WRITE       = %00000101     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
000A4F  2               CFD_WRITEDEL    = %00001001     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
000A4F  2               CFD_READTRK     = %00000010     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
000A4F  2               CFD_READID      = %00001010     ; CMD,HDS/DS --> ST0,ST1,ST2,C,H,R,N
000A4F  2               CFD_FMTTRK      = %00001101     ; CMD,HDS/DS,N,SC,GPL,D --> ST0,ST1,ST2,C,H,R,N
000A4F  2               CFD_SCANEQ      = %00010001     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
000A4F  2               CFD_SCANLOEQ    = %00011001     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
000A4F  2               CFD_SCANHIEQ    = %00011101     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
000A4F  2               CFD_RECAL       = %00000111     ; CMD,DS --> <EMPTY>
000A4F  2               CFD_SENSEINT    = %00001000     ; CMD --> ST0,PCN
000A4F  2               CFD_SPECIFY     = %00000011     ; CMD,SRT/HUT,HLT/ND --> <EMPTY>
000A4F  2               CFD_DRVSTAT     = %00000100     ; CMD,HDS/DS --> ST3
000A4F  2               CFD_SEEK        = %00001111     ; CMD,HDS/DS --> <EMPTY>
000A4F  2               CFD_VERSION     = %00010000     ; CMD --> ST0
000A4F  2               
000A4F  2               CFD_MFM         = %01000000     ;
000A4F  2               
000A4F  2               ;
000A4F  2               ;
000A4F  2               ; Specify Command:
000A4F  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
000A4F  2               ; |Byte |  7  |	 6  |  5  |  4	|  3  |	 2  |  1  |  0	|
000A4F  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
000A4F  2               ; |  0	|  0  |	 0  |  0  |  0	|  0  |	 0  |  1  |  1	|
000A4F  2               ; |  1	| ----- STEP RATE ----- | -- HEAD UNLOAD TIME - |
000A4F  2               ; |  2	| ------------ HEAD LOAD TIME ----------- | NDM |
000A4F  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
000A4F  2               ;
000A4F  2               ;
000A4F  2               ; Step Rate (milliseconds):		 Head Unload Time (milliseconds):	Head Load Time (milliseconds):
000A4F  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
000A4F  2               ; |	 |	   BITRATE	     |	 |	|	  BITRATE	    |	|      |	 BITRATE	   |
000A4F  2               ; |  VAL | 1.0M | 500K | 300K | 250K |	 |  VAL | 1.0M | 500K | 300K | 250K |	|  VAL | 1.0M | 500K | 300K | 250K |
000A4F  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
000A4F  2               ; |    0 |  8.0 | 16.0 | 26.7 | 32.0 |	 |    0 |  128 |  256 |	 426 |	512 |	|    0 |  128 |	 256 |	426 |  512 |
000A4F  2               ; |    1 |  7.5 | 15.0 | 25.0 | 30.0 |	 |    1 |    8 |   16 | 26.7 |	 32 |	|    1 |    1 |	   2 |	3.3 |	 4 |
000A4F  2               ; |    2 |  7.0 | 14.0 | 23.3 | 28.0 |	 |    2 |   16 |   32 | 53.3 |	 64 |	|    2 |    2 |	   4 |	6.7 |	 8 |
000A4F  2               ; |  ... |  ... |  ... |  ... |	 ... |	 |  ... |  ... |  ... |	 ... |	... |	|  ... |  ... |	 ... |	... |  ... |
000A4F  2               ; |   14 |  1.0 |  2.0 |  3.3 |	 4.0 |	 |   14 |  112 |  224 |	 373 |	448 |	|  126 |  126 |	 252 |	420 |  504 |
000A4F  2               ; |   15 |  0.5 |  1.0 |  1.7 |	 2.0 |	 |   15 |  120 |  240 |	 400 |	480 |	|  127 |  127 |	 254 |	423 |  508 |
000A4F  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
000A4F  2               ;
000A4F  2               ; IBM PS/2 CALLS FOR:
000A4F  2               ;   STEP RATE: 3ms (6ms FOR ALL 41mm OR 720K DRIVES)
000A4F  2               ;   HEAD LOAD TIME: 15ms
000A4F  2               
000A4F  2               DOR_INIT        = %00001100     ; SOFT RESET INACTIVE, DMA ENABLED
000A4F  2               DOR_BR250       = DOR_INIT
000A4F  2               DOR_BR500       = DOR_INIT
000A4F  2               
000A4F  2               
000A4F  2               
000A4F  2               FLOPPY_RETRIES  = 6             ; HOW ABOUT SIX RETIRES?
000A4F  2               FLOPPY_RETRIES1 = 2             ; TWO ITERATIONS OF RECAL?
000A4F  2               
000A4F  2               ;__FL_SETUP______________________________________________________________________________________________________________________
000A4F  2               ;
000A4F  2               ;	SETUP FLOPPY DRIVE SETTINGS
000A4F  2               ;________________________________________________________________________________________________________________________________
000A4F  2               ;
000A4F  2               FL_SETUP:
000A4F  2  A9 00                LDA     #$00            ; RESET TRACK/CYL/SEC STORAGE
000A51  2  8D B3 0E             STA     debhead         ;
000A54  2  8D B4 0E             STA     debcyl          ;
000A57  2  8D B5 0E             STA     debsec          ;
000A5A  2  A9 FF                LDA     #$FF            ; SET CACHE TO INVALID
000A5C  2  8D B6 0E             STA     Cdebhead        ;
000A5F  2  8D B7 0E             STA     Cdebcyl         ;
000A62  2  8D B8 0E             STA     Cdebsec         ;
000A65  2               
000A65  2  48 8A 48 98          PRTS    "FD: MODE=MBC$"
000A69  2  48 A2 00 BD  
000A6D  2  82 0A E8 C9  
000A8F  2               ;
000A8F  2  48 8A 48 98          PRTS    " IO=0x$"
000A93  2  48 A2 00 BD  
000A97  2  AC 0A E8 C9  
000AB3  2  A9 03                LDA     #>FDC_MSR
000AB5  2  20 C5 09             JSR     PRTHEXBYTE
000AB8  2  A9 30                LDA     #<FDC_MSR
000ABA  2  20 C5 09             JSR     PRTHEXBYTE
000ABD  2  20 57 0E             JSR     FD_DETECT       ; CHECK FOR FDC
000AC0  2  C9 00                CMP     #$00
000AC2  2  F0 30                BEQ     :+              ; CONTINUE IF FOUND
000AC4  2  48 8A 48 98          PRTS    " NOT PRESENT$" ; NOT ZERO, H/W NOT PRESENT
000AC8  2  48 A2 00 BD  
000ACC  2  E1 0A E8 C9  
000AEE  2  20 EF 09             JSR     NEWLINE
000AF1  2  A9 FF                LDA     #$FF
000AF3  2  60                   RTS                     ; BAIL OUT
000AF4  2               :
000AF4  2  48 8A 48 98          PRTS    " PRESENT$"     ; NOT ZERO, H/W NOT PRESENT
000AF8  2  48 A2 00 BD  
000AFC  2  11 0B E8 C9  
000B1A  2  20 EF 09             JSR     NEWLINE
000B1D  2  A9 0C                LDA     #DOR_INIT       ; RESET SETTINGS
000B1F  2  8D 36 03             STA     FDC_DOR
000B22  2               
000B22  2  20 F5 0D             JSR     CHECKINT        ;
000B25  2  A9 03                LDA     #CFD_SPECIFY    ; SPECIFY COMMAND
000B27  2  20 B1 0D             JSR     PFDATA          ; OUTPUT TO FDC
000B2A  2  A9 7F                LDA     #$7F            ; 6 MS STEP, 480 MS HEAD UNLOAD
000B2C  2  20 B1 0D             JSR     PFDATA          ; OUTPUT TO FDC
000B2F  2  A9 05                LDA     #$05            ; 508 MS HEAD LOAD, NON-DMA MODE
000B31  2  20 B1 0D             JSR     PFDATA          ; OUTPUT TO FDC
000B34  2               
000B34  2  20 F5 0D             JSR     CHECKINT        ; SEND SEVERAL INTERRUPTS TO ENSURE PROPER STATE
000B37  2  20 F5 0D             JSR     CHECKINT        ;
000B3A  2  20 F5 0D             JSR     CHECKINT        ;
000B3D  2  20 F5 0D             JSR     CHECKINT        ;
000B40  2  20 F5 0D             JSR     CHECKINT        ;
000B43  2  20 F5 0D             JSR     CHECKINT        ;
000B46  2               
000B46  2  A9 00                LDA     #$00
000B48  2  8D 30 0F             STA     sekdsk
000B4B  2  A9 10                LDA     #%00010000
000B4D  2  8D 31 0F             STA     DSKUNIT
000B50  2  20 86 0D             JSR     RECAL           ;
000B53  2  A9 27                LDA     #39             ;
000B55  2  8D B4 0E             STA     debcyl          ;
000B58  2  20 69 0D             JSR     SETTRK1
000B5B  2  20 86 0D             JSR     RECAL           ;
000B5E  2               
000B5E  2  A9 01                LDA     #$01
000B60  2  8D 30 0F             STA     sekdsk
000B63  2  A9 21                LDA     #%00100001
000B65  2  8D 31 0F             STA     DSKUNIT
000B68  2  20 86 0D             JSR     RECAL           ;
000B6B  2  A9 27                LDA     #39             ;
000B6D  2  8D B4 0E             STA     debcyl          ;
000B70  2  20 69 0D             JSR     SETTRK1
000B73  2  20 86 0D             JSR     RECAL           ;
000B76  2  A9 0C                LDA     #DOR_INIT       ; RESET SETTINGS
000B78  2  8D 36 03             STA     FDC_DOR
000B7B  2  60                   RTS
000B7C  2               
000B7C  2               
000B7C  2               ;__FL_READ_SECTOR________________________________________________________________________________________________________________
000B7C  2               ;
000B7C  2               ; 	READ A FLOPPY SECTOR
000B7C  2               ;________________________________________________________________________________________________________________________________
000B7C  2               ;
000B7C  2               ;
000B7C  2               FL_READ_SECTOR:
000B7C  2  AD B2 0E             LDA     HARDWARE_DETCT
000B7F  2  C9 00                CMP     #$00
000B81  2  F0 01                BEQ     :+
000B83  2  60                   RTS
000B84  2               :
000B84  2  20 8D 0B             JSR     FL_READ_SECTOR_RAW
000B87  2  48                   PHA
000B88  2  20 E9 0E             JSR     DEBSECR512
000B8B  2  68                   PLA
000B8C  2  60                   RTS
000B8D  2               
000B8D  2               FL_READ_SECTOR_RAW:
000B8D  2  A9 00                LDA     #$00
000B8F  2  8D BD 0E             STA     FLRETRY         ; BLANK RETRIES
000B92  2  8D BE 0E             STA     FLRETRY1
000B95  2  A9 0C                LDA     #DOR_INIT
000B97  2  0D 31 0F             ORA     DSKUNIT         ;
000B9A  2  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
000B9D  2  20 62 0C             JSR     SETUP_FD_CHS
000BA0  2  AD B3 0E             LDA     debhead         ;
000BA3  2  CD B6 0E             CMP     Cdebhead        ;
000BA6  2  D0 13                BNE     READFL_DIRTY
000BA8  2  AD B4 0E             LDA     debcyl          ;
000BAB  2  CD B7 0E             CMP     Cdebcyl         ;
000BAE  2  D0 0B                BNE     READFL_DIRTY
000BB0  2  AD B5 0E             LDA     debsec          ;
000BB3  2  CD B8 0E             CMP     Cdebsec         ;
000BB6  2  D0 03                BNE     READFL_DIRTY
000BB8  2               ; SECTOR ALREADY IN CACHE, DEBLOCK
000BB8  2  A9 00                LDA     #$00
000BBA  2  60                   RTS
000BBB  2               READFL_DIRTY:
000BBB  2  AD B3 0E             LDA     debhead         ; STORE CURRENT PARMS
000BBE  2  8D B6 0E             STA     Cdebhead        ;
000BC1  2  AD B4 0E             LDA     debcyl          ;
000BC4  2  8D B7 0E             STA     Cdebcyl         ;
000BC7  2  AD B5 0E             LDA     debsec          ;
000BCA  2  8D B8 0E             STA     Cdebsec         ;
000BCD  2               
000BCD  2               READFL1:
000BCD  2  A9 46                LDA     #CFD_READ|CFD_MFM; BIT 6 SETS MFM, 06H IS READ COMMAND
000BCF  2  8D BB 0E             STA     FCMD            ; SET COMMAND
000BD2  2  20 7A 0C             JSR     DSKOP           ; DO DISK OPERATION
000BD5  2               
000BD5  2  C9 00                CMP     #$00
000BD7  2  F0 2B                BEQ     READFLDONE      ; OPERATION SUCCESSFUL
000BD9  2  EE BD 0E             INC     FLRETRY         ; LET'S RETRY
000BDC  2  AD BD 0E             LDA     FLRETRY
000BDF  2  C9 06                CMP     #FLOPPY_RETRIES
000BE1  2  D0 EA                BNE     READFL1
000BE3  2  20 86 0D             JSR     RECAL           ; AFTER X RETRIES, LET'S RECAL THE HEAD
000BE6  2  20 57 0D             JSR     SETTRACK        ;
000BE9  2  A9 00                LDA     #$00            ;
000BEB  2  8D BD 0E             STA     FLRETRY         ; MORE RETRIES!
000BEE  2  EE BE 0E             INC     FLRETRY1
000BF1  2  AD BE 0E             LDA     FLRETRY1
000BF4  2  C9 02                CMP     #FLOPPY_RETRIES1
000BF6  2  D0 D5                BNE     READFL1
000BF8  2               
000BF8  2  A9 FF                LDA     #$FF            ; RETRIES FAILED, INVALIDATE CACHE AND REPORT ERROR
000BFA  2  8D B6 0E             STA     Cdebhead        ;
000BFD  2  8D B7 0E             STA     Cdebcyl         ;
000C00  2  8D B8 0E             STA     Cdebsec         ;
000C03  2  60                   RTS                     ; A = $FF ON RETURN = OPERATION ERROR
000C04  2               READFLDONE:
000C04  2  A9 00                LDA     #$00            ; A = 0 ON RETURN = OPERATION OK
000C06  2  60                   RTS
000C07  2               
000C07  2               ;__FL_WRITE_SECTOR_______________________________________________________________________________________________________________
000C07  2               ;
000C07  2               ; 	WRITE A FLOPPY SECTOR
000C07  2               ;________________________________________________________________________________________________________________________________
000C07  2               ;
000C07  2               FL_WRITE_SECTOR:
000C07  2  AD B2 0E             LDA     HARDWARE_DETCT
000C0A  2  C9 00                CMP     #$00
000C0C  2  F0 01                BEQ     :+
000C0E  2  60                   RTS
000C0F  2               :
000C0F  2  20 8D 0B             JSR     FL_READ_SECTOR_RAW
000C12  2  20 E9 0E             JSR     BLKSECR512
000C15  2               
000C15  2               FL_WRITE_SECTOR_RAW:
000C15  2  A9 00                LDA     #$00
000C17  2  8D BD 0E             STA     FLRETRY         ; BLANK RETRIES
000C1A  2  8D BE 0E             STA     FLRETRY1
000C1D  2  A9 FF                LDA     #$FF
000C1F  2  8D B6 0E             STA     Cdebhead        ; INVALIDATE CACHE
000C22  2  8D B7 0E             STA     Cdebcyl         ;
000C25  2  8D B8 0E             STA     Cdebsec         ;
000C28  2               
000C28  2               WRITEFL1:
000C28  2  A9 45                LDA     #CFD_WRITE|CFD_MFM; BIT 6 SETS MFM, 05H IS WRITE COMMAND
000C2A  2  8D BB 0E             STA     FCMD
000C2D  2  20 7A 0C             JSR     DSKOP
000C30  2               
000C30  2  C9 00                CMP     #$00
000C32  2  F0 2B                BEQ     WRITEFLDONE
000C34  2  EE BD 0E             INC     FLRETRY
000C37  2  AD BD 0E             LDA     FLRETRY
000C3A  2  C9 06                CMP     #FLOPPY_RETRIES
000C3C  2  D0 EA                BNE     WRITEFL1
000C3E  2  20 86 0D             JSR     RECAL
000C41  2  20 57 0D             JSR     SETTRACK
000C44  2  A9 00                LDA     #$00
000C46  2  8D BD 0E             STA     FLRETRY
000C49  2  EE BE 0E             INC     FLRETRY1
000C4C  2  AD BE 0E             LDA     FLRETRY1
000C4F  2  C9 02                CMP     #FLOPPY_RETRIES1
000C51  2  D0 D5                BNE     WRITEFL1
000C53  2  A9 FF                LDA     #$FF            ; INVALIDATE CACHE
000C55  2  8D B6 0E             STA     Cdebhead        ;
000C58  2  8D B7 0E             STA     Cdebcyl         ;
000C5B  2  8D B8 0E             STA     Cdebsec         ;
000C5E  2  60                   RTS                     ; A = $FF ON RETURN = OPERATION ERROR
000C5F  2               WRITEFLDONE:
000C5F  2  A9 00                LDA     #$00            ; A = 0 ON RETURN = OPERATION OK
000C61  2  60                   RTS
000C62  2               
000C62  2               
000C62  2               ;__SETUP_FD_CHS__________________________________________________________________________________________________________________
000C62  2               ;
000C62  2               ; 	TRANSFORM DOS65 CHS TO FLOPPY
000C62  2               ;________________________________________________________________________________________________________________________________
000C62  2               ;
000C62  2               SETUP_FD_CHS:
000C62  2  AD 2C 0F             LDA     sektrk          ; LOAD TRACK # (LOW BYTE)
000C65  2  29 01                AND     #$01            ; FILTER OUT HEAD
000C67  2  8D B3 0E             STA     debhead         ; STORE HEAD
000C6A  2  AD 2C 0F             LDA     sektrk          ; SAVE TRACK IN A
000C6D  2  4A                   LSR     A               ; REMOVE HEAD BIT
000C6E  2  8D B4 0E             STA     debcyl          ; STORE IN TRACK
000C71  2  AD 2E 0F             LDA     seksec          ; LOAD SECTOR # (LOW BYTE)
000C74  2  4A                   LSR     A               ;
000C75  2  4A                   LSR     A               ; DIVIDE BY 4 (FOR BLOCKING)
000C76  2  8D B5 0E             STA     debsec          ; STORE IN SECTOR
000C79  2               
000C79  2                       .IF     USEDSKY=1 || USEDSKYNG=1
000C79  2                           PRTDBG  "DSKY OUTPUT 1$"
000C79  2                           LDA     sekdsk
000C79  2                           STA     DSKY_HEXBUF
000C79  2                           LDA     debcyl
000C79  2                           STA     DSKY_HEXBUF+1
000C79  2                           LDA     debhead
000C79  2                           STA     DSKY_HEXBUF+2
000C79  2                           LDA     debsec
000C79  2                           STA     DSKY_HEXBUF+3
000C79  2                           JSR     DSKY_BIN2SEG
000C79  2                           JSR     DSKY_SHOW
000C79  2                       .ENDIF
000C79  2               
000C79  2  60                   RTS
000C7A  2               
000C7A  2               ;__DSKOP__________________________________________________________________________________________________________________________
000C7A  2               ;
000C7A  2               ; 	PERFORM A DISK OPERATION
000C7A  2               ;________________________________________________________________________________________________________________________________
000C7A  2               ;
000C7A  2               DSKOP:
000C7A  2  78                   SEI
000C7B  2  20 F5 0D             JSR     CHECKINT        ; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
000C7E  2  C9 FF                CMP     #$FF            ; DID IT RETURN WITH ERROR CODE?
000C80  2  F0 10                BEQ     DSKEXIT         ; IF YES, EXIT WITH ERROR CODE
000C82  2               ;
000C82  2  20 57 0D             JSR     SETTRACK        ; PERFORM SEEK TO TRACK
000C85  2               ;
000C85  2  AD BB 0E             LDA     FCMD            ; WHAT COMMAND IS PENDING?
000C88  2  C9 46                CMP     #CFD_READ|CFD_MFM; IS IT A READ COMMAND?
000C8A  2  D0 03                BNE     GWRR_POLL       ;
000C8C  2  4C E7 0C             JMP     RDD_POLL        ;
000C8F  2               GWRR_POLL:
000C8F  2  4C 2D 0D             JMP     WRR_POLL        ;
000C92  2               DSKEXIT:
000C92  2  A9 00                LDA     #0              ; SET MOTOR OFF
000C94  2  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
000C97  2  A9 FF                LDA     #$FF            ; SET IF ERROR
000C99  2  58                   CLI
000C9A  2  60                   RTS
000C9B  2               
000C9B  2               SNDFDWR:
000C9B  2  18                   CLC
000C9C  2  AD 31 0F             LDA     DSKUNIT         ; GET DISK UNIT NUMBER
000C9F  2  29 01                AND     #$01            ; MASK FOR TWO DRIVES.
000CA1  2  8D BA 0E             STA     UNIT            ; PARK IT IN TEMP
000CA4  2  AD B3 0E             LDA     debhead         ; GET HEAD SELECTION
000CA7  2  29 01                AND     #$01            ; INSURE SINGLE BIT
000CA9  2  0A                   ASL     A               ;
000CAA  2  0A                   ASL     A               ; MOVE HEAD TO BIT 2 POSITION
000CAB  2  0D BA 0E             ORA     UNIT            ; OR HEAD TO UNIT BYTE IN COMMAND BLOCK
000CAE  2  8D BA 0E             STA     UNIT            ; STORE IN UNIT
000CB1  2  AD BB 0E             LDA     FCMD            ;
000CB4  2  20 B1 0D             JSR     PFDATA          ; PUSH COMMAND TO I8272
000CB7  2  AD BA 0E             LDA     UNIT            ;
000CBA  2  20 B1 0D             JSR     PFDATA          ;
000CBD  2  AD B4 0E             LDA     debcyl          ;
000CC0  2  20 B1 0D             JSR     PFDATA          ;
000CC3  2  AD B3 0E             LDA     debhead         ;
000CC6  2  20 B1 0D             JSR     PFDATA          ;
000CC9  2  18                   CLC                     ;
000CCA  2  AD B5 0E             LDA     debsec          ;
000CCD  2  69 01                ADC     #$01            ;
000CCF  2  20 B1 0D             JSR     PFDATA          ;
000CD2  2  A9 02                LDA     #$02            ;
000CD4  2  20 B1 0D             JSR     PFDATA          ; WHAT DENSITY
000CD7  2  A9 09                LDA     #$09            ;
000CD9  2  20 B1 0D             JSR     PFDATA          ; ASSUME SC (SECTOR COUNT)  EOT
000CDC  2  A9 1B                LDA     #$1B            ;
000CDE  2  20 B1 0D             JSR     PFDATA          ; WHAT GAP IS NEEDED
000CE1  2  A9 FF                LDA     #$FF            ; DTL, IS THE LAST COMMAND BYTE TO I8272
000CE3  2  20 DC 0D             JSR     PFDATAS
000CE6  2  60                   RTS
000CE7  2               
000CE7  2               
000CE7  2               ; PERFORM READ
000CE7  2               ; FROM READ TO READ MUST NOT EXCEED 25US WORST CASE MIN. (AT 2MHZ IS 2,000,000 CYCLES PER SECOND == 50 CYCLE BUDGET.)
000CE7  2               ;
000CE7  2               RDD_POLL:
000CE7  2  A2 00                LDX     #$00
000CE9  2  A0 00                LDY     #$00
000CEB  2  20 9B 0C             JSR     SNDFDWR         ;
000CEE  2               RDS1:
000CEE  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS  (4 CYCLES)
000CF1  2  10 FB                BPL     RDS1            ; FDC IS NOT READY, WAIT FOR IT (UP TO 4 CYCLES)
000CF3  2  29 20                AND     #%00100000      ; EXECUTION MODE? (2 CYCLES)
000CF5  2  F0 1D                BEQ     DSKOPEND        ; NO, ERROR
000CF7  2               RDS1A:
000CF7  2  AD 31 03             LDA     FDC_DATA        ; GET DATA (4 CYCLES)
000CFA  2  99 32 0F             STA     hstbuf,Y        ; WRITE IT (5 CYCLES)
000CFD  2  C8                   INY                     ; (2 CYCLES)
000CFE  2  D0 EE                BNE     RDS1            ; KEEP GOING (UP TO 4 CYCLES)   TOTAL =
000D00  2  A2 00                LDX     #$00
000D02  2               RDS2:
000D02  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS
000D05  2  10 FB                BPL     RDS2            ; FDC IS NOT READY, WAIT FOR IT (UP TO 4 CYCLES)
000D07  2  29 20                AND     #%00100000      ; EXECUTION MODE?
000D09  2  F0 09                BEQ     DSKOPEND        ; NO, ERROR
000D0B  2               RDS2A:
000D0B  2  AD 31 03             LDA     FDC_DATA        ; GET DATA
000D0E  2  99 32 10             STA     hstbuf+256,Y    ; WRITE IT
000D11  2  C8                   INY
000D12  2  D0 EE                BNE     RDS2            ; KEEP GOING
000D14  2               DSKOPEND:
000D14  2  AD 37 03             LDA     FDC_TC
000D17  2  20 A3 0E             JSR     FDDELAY
000D1A  2               ;
000D1A  2  20 3E 0E             JSR     GFDATA          ;GET ERROR TYPE
000D1D  2  8D B9 0E             STA     FLERR
000D20  2               ;* CLEAR OUT ANY REMAINING DATA
000D20  2               RESUL3:
000D20  2  20 3E 0E             JSR     GFDATA          ;READ BYTE FROM FDC
000D23  2  C9 00                CMP     #$00
000D25  2  D0 F9                BNE     RESUL3          ;CLEAR THEM ALL
000D27  2  AD B9 0E             LDA     FLERR           ;
000D2A  2  29 C0                AND     #%11000000      ;
000D2C  2  60                   RTS
000D2D  2               
000D2D  2               
000D2D  2               WRR_POLL:
000D2D  2  20 9B 0C             JSR     SNDFDWR         ;
000D30  2               WRS1:   ;
000D30  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS
000D33  2  10 FB                BPL     WRS1            ; NOT READY
000D35  2  29 20                AND     #%00100000      ; EXECUTION MODE?
000D37  2  F0 1B                BEQ     WRS3            ; NO, ERROR
000D39  2  B9 32 0F             LDA     hstbuf,Y        ; WRITE IT
000D3C  2  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
000D3F  2  C8                   INY
000D40  2  D0 EE                BNE     WRS1            ; DO NEXT
000D42  2               WRS2:   ;
000D42  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS
000D45  2  10 FB                BPL     WRS2            ; NOT READY
000D47  2  29 20                AND     #%00100000      ; EXECUTION MODE?
000D49  2  F0 09                BEQ     WRS3            ; NO, ERROR
000D4B  2  B9 32 10             LDA     hstbuf+256,Y    ; WRITE IT
000D4E  2  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
000D51  2  C8                   INY
000D52  2  D0 EE                BNE     WRS2            ; DO NEXT
000D54  2               WRS3:
000D54  2  4C 14 0D             JMP     DSKOPEND        ;
000D57  2               
000D57  2               
000D57  2               ;__SETTRACK__________________________________________________________________________________________________________________________
000D57  2               ;
000D57  2               ; 	SEEK TO A TRACK ON GIVEN UNIT
000D57  2               ; 	A: TRACK #
000D57  2               ;________________________________________________________________________________________________________________________________
000D57  2               ;
000D57  2               SETTRACK:
000D57  2  A9 0C                LDA     #DOR_INIT
000D59  2  0D 31 0F             ORA     DSKUNIT         ; SET MOTOR ON
000D5C  2  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
000D5F  2               
000D5F  2               ; ANY INTERUPT PENDING
000D5F  2               ; IF YES FIND OUT WHY/CLEAR
000D5F  2  20 F5 0D             JSR     CHECKINT        ; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
000D62  2  C9 FF                CMP     #$FF            ; DID IT RTSURN WITH ERROR CODE?
000D64  2  D0 03                BNE     SETTRK1
000D66  2  4C B0 0D             JMP     SETTRKEXIT      ;
000D69  2               
000D69  2               ;
000D69  2               SETTRK1:
000D69  2  AD B4 0E             LDA     debcyl          ; GET TRACK
000D6C  2  C9 00                CMP     #$00            ;
000D6E  2  F0 16                BEQ     RECAL           ; IF 0 PERFORM RECAL INSTEAD OF SEEK
000D70  2  A9 0F                LDA     #CFD_SEEK       ; SEEK COMMAND
000D72  2  20 B1 0D             JSR     PFDATA          ; PUSH COMMAND
000D75  2  AD 31 0F             LDA     DSKUNIT         ; SAY WHICH UNIT
000D78  2  29 01                AND     #$01
000D7A  2  20 B1 0D             JSR     PFDATA          ; SEND THAT
000D7D  2  AD B4 0E             LDA     debcyl          ; TO WHAT TRACK
000D80  2  20 B1 0D             JSR     PFDATA          ; SEND THAT TOO
000D83  2  4C 9B 0D             JMP     WAINT           ; WAIT FOR INTERRUPT SAYING DONE
000D86  2               RECAL:
000D86  2  A9 0C                LDA     #DOR_INIT
000D88  2  0D 31 0F             ORA     DSKUNIT         ; SET MOTOR ON
000D8B  2  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
000D8E  2  A9 07                LDA     #CFD_RECAL      ; RECAL TO TRACK 0
000D90  2  20 B1 0D             JSR     PFDATA          ; SEND IT
000D93  2  AD 31 0F             LDA     DSKUNIT         ; SAY WHICH UNIT
000D96  2  29 01                AND     #$01
000D98  2  20 B1 0D             JSR     PFDATA          ; SEND THAT TOO
000D9B  2               ;
000D9B  2               WAINT:
000D9B  2  48                   PHA
000D9C  2  8A                   TXA
000D9D  2  48                   PHA
000D9E  2  A2 64                LDX     #100
000DA0  2  20 A8 0E             JSR     FDVDELAY
000DA3  2  68                   PLA
000DA4  2  AA                   TAX
000DA5  2  68                   PLA
000DA6  2               :
000DA6  2  20 F5 0D             JSR     CHECKINT
000DA9  2  AD 30 03             LDA     FDC_MSR         ; READ SEEK STATUS
000DAC  2  29 0F                AND     #%00001111      ; ANY DRIVES SEEKING?
000DAE  2  D0 F6                BNE     :-              ; YES, WAIT FOR THEM
000DB0  2               ;
000DB0  2               SETTRKEXIT:
000DB0  2  60                   RTS
000DB1  2               
000DB1  2               ;__PFDATA__________________________________________________________________________________________________________________________
000DB1  2               ;
000DB1  2               ; WRITE A COMMAND OR PARAMETER SEQUENCE
000DB1  2               ;
000DB1  2               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
000DB1  2               ;	RQM  DIO
000DB1  2               ;	0	0	BUSY
000DB1  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
000DB1  2               ;	1	1	BYTE FOR READ BY HOST PENDING
000DB1  2               ;	0	1	BUSY
000DB1  2               ;
000DB1  2               ;________________________________________________________________________________________________________________________________
000DB1  2               ;
000DB1  2               PFDATA:
000DB1  2  48                   PHA                     ; SAVE DATA BYTE
000DB2  2  A0 00                LDY     #$00
000DB4  2               WRF1:
000DB4  2  AD 30 03             LDA     FDC_MSR         ; READ FDC STATUS
000DB7  2  AA                   TAX
000DB8  2  29 80                AND     #$80            ;
000DBA  2  D0 07                BNE     :+
000DBC  2  C8                   INY
000DBD  2  D0 F5                BNE     WRF1            ; FDC IS NOT READY, WAIT FOR IT
000DBF  2  68                   PLA
000DC0  2  A9 FF                LDA     #$FF
000DC2  2  60                   RTS
000DC3  2               :
000DC3  2  8A                   TXA
000DC4  2  29 40                AND     #$40            ; TEST DIO BIT
000DC6  2  D0 0E                BNE     WRF2            ; FDC IS OUT OF SYNC
000DC8  2  68                   PLA                     ; RESTORE DATA
000DC9  2  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
000DCC  2  20 A3 0E             JSR     FDDELAY
000DCF  2  20 A3 0E             JSR     FDDELAY
000DD2  2  20 A3 0E             JSR     FDDELAY
000DD5  2  60                   RTS
000DD6  2               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
000DD6  2               WRF2:
000DD6  2  AD 31 03             LDA     FDC_DATA        ; READ DATA REGISTER
000DD9  2  4C B4 0D             JMP     WRF1            ; AND CONTINUE
000DDC  2               
000DDC  2               ;__PFDATAS_________________________________________________________________________________________________________________________
000DDC  2               ;
000DDC  2               ; WRITE A COMMAND OR PARAMETER SEQUENCE (NO PAUSE)
000DDC  2               ;
000DDC  2               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
000DDC  2               ;	RQM  DIO
000DDC  2               ;	0	0	BUSY
000DDC  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
000DDC  2               ;	1	1	BYTE FOR READ BY HOST PENDING
000DDC  2               ;	0	1	BUSY
000DDC  2               ;
000DDC  2               ;________________________________________________________________________________________________________________________________
000DDC  2               ;
000DDC  2               PFDATAS:
000DDC  2  48                   PHA                     ; SAVE DATA BYTE
000DDD  2               WRF1S:
000DDD  2  AD 30 03             LDA     FDC_MSR         ; READ FDC STATUS
000DE0  2  AA                   TAX
000DE1  2  29 80                AND     #$80            ;
000DE3  2  F0 F8                BEQ     WRF1S           ; FDC IS NOT READY, WAIT FOR IT
000DE5  2  8A                   TXA
000DE6  2  29 40                AND     #$40            ; TEST DIO BIT
000DE8  2  D0 05                BNE     WRF2S           ; FDC IS OUT OF SYNC
000DEA  2  68                   PLA                     ; RESTORE DATA
000DEB  2  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
000DEE  2  60                   RTS
000DEF  2               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
000DEF  2               WRF2S:
000DEF  2  AD 31 03             LDA     FDC_DATA        ; READ DATA REGISTER
000DF2  2  4C DD 0D             JMP     WRF1S           ; AND CONTINUE
000DF5  2               
000DF5  2               
000DF5  2               
000DF5  2               ;__CHECKINT__________________________________________________________________________________________________________________________
000DF5  2               ;
000DF5  2               ; CHECK FOR ACTIVE FDC INTERRUPTS BEFORE GIVING I8272 COMMANDS
000DF5  2               ; POLL RQM FOR WHEN NOT BUSY AND THEN SEND FDC
000DF5  2               ; SENSE INTERRUPT COMMAND.  IF IT RTSURNS WITH NON ZERO
000DF5  2               ; ERROR CODE, PASS BACK TO JSRING ROUTINE FOR HANDLING
000DF5  2               ;________________________________________________________________________________________________________________________________
000DF5  2               ;
000DF5  2               CHECKINT:
000DF5  2  A0 00                LDY     #$00
000DF7  2               :
000DF7  2  AD 30 03             LDA     FDC_MSR         ; READING OR WRITING IS KEYS TO D7 RQM
000DFA  2  29 80                AND     #$80
000DFC  2  D0 09                BNE     :+              ; WAIT FOR RQM TO BE TRUE. WAIT UNTIL DONE
000DFE  2  20 A3 0E             JSR     FDDELAY
000E01  2  C8                   INY
000E02  2  D0 F3                BNE     :-
000E04  2  4C 0F 0E             JMP     ERRCLR
000E07  2               
000E07  2               :
000E07  2  AD 30 03             LDA     FDC_MSR         ; READING OR WRITING IS KEYS TO D7 RQM
000E0A  2  29 40                AND     #$40            ; WAITING FOR INPUT?
000E0C  2  F0 16                BEQ     SENDINT
000E0E  2  60                   RTS
000E0F  2               
000E0F  2               ERRCLR:
000E0F  2  A0 00                LDY     #$00
000E11  2               :
000E11  2  AD 31 03             LDA     FDC_DATA        ; CLEAR THE JUNK OUT OF DATA REGISTER
000E14  2  AD 30 03             LDA     FDC_MSR         ; CHECK WITH RQM
000E17  2  29 80                AND     #$80            ; IF STILL NOT READY, READ OUT MORE JUNK
000E19  2  D0 06                BNE     :+              ;
000E1B  2  20 A3 0E             JSR     FDDELAY
000E1E  2  C8                   INY
000E1F  2  D0 F0                BNE     :-
000E21  2               :
000E21  2  A9 FF                LDA     #$FF            ; RETURN ERROR CODE -1
000E23  2               ;
000E23  2  60                   RTS
000E24  2               
000E24  2               ;__SENDINT__________________________________________________________________________________________________________________________
000E24  2               ;
000E24  2               ; SENSE INTERRUPT COMMAND
000E24  2               ;________________________________________________________________________________________________________________________________
000E24  2               ;
000E24  2               SENDINT:
000E24  2  A9 08                LDA     #CFD_SENSEINT   ; SENSE INTERRUPT COMMAND
000E26  2  20 B1 0D             JSR     PFDATA          ; SEND IT
000E29  2  20 3E 0E             JSR     GFDATA          ; GET RESULTS
000E2C  2  8D BC 0E             STA     ST0             ; STORE THAT
000E2F  2  29 C0                AND     #$C0            ; MASK OFF INTERRUPT STATUS BITS
000E31  2  C9 80                CMP     #$80            ; CHECK IF INVALID COMMAND
000E33  2  F0 08                BEQ     ENDSENDINT      ; YES, EXIT
000E35  2  20 3E 0E             JSR     GFDATA          ; GET ANOTHER (STATUS CODE 1)
000E38  2  AD BC 0E             LDA     ST0             ; GET FIRST ONE
000E3B  2  29 C0                AND     #$C0            ; MASK OFF ALL BUT INTERRUPT CODE 00 IS NORMAL
000E3D  2               ENDSENDINT:
000E3D  2  60                   RTS                     ; ANYTHING ELSE IS AN ERROR
000E3E  2               
000E3E  2               
000E3E  2               ;__GFDATA__________________________________________________________________________________________________________________________
000E3E  2               ;
000E3E  2               ; GET DATA FROM FLOPPY CONTROLLER
000E3E  2               ;
000E3E  2               ; TRANSFERS ARE SYNCHONIZED BYT MSR D7 <RQM> AND D6 <DIO>
000E3E  2               ;	RQM  DIO
000E3E  2               ;	0	0	BUSY
000E3E  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
000E3E  2               ;	1	1	BYTE FOR READ BY HOST PENDING
000E3E  2               ;	0	1	BUSY
000E3E  2               ;
000E3E  2               ;________________________________________________________________________________________________________________________________
000E3E  2               ;
000E3E  2               GFDATA:
000E3E  2  A0 00                LDY     #$00
000E40  2               :
000E40  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS
000E43  2  AA                   TAX                     ;
000E44  2  29 80                AND     #%10000000      ; NOT READY, WAIT
000E46  2  D0 06                BNE     :+              ;
000E48  2  C8                   INY
000E49  2  D0 F5                BNE     :-
000E4B  2  A9 00                LDA     #$00
000E4D  2  60                   RTS
000E4E  2               :
000E4E  2  8A                   TXA
000E4F  2  29 40                AND     #%01000000      ; ANY DATA FOR US?
000E51  2  F0 03                BEQ     GFDATA1         ; NO, SKIP IT
000E53  2  AD 31 03             LDA     FDC_DATA        ; GET FDC DATA
000E56  2               GFDATA1:
000E56  2  60                   RTS
000E57  2               
000E57  2               ;__FD_DETECT______________________________________________________________________________________________________________________
000E57  2               ;
000E57  2               ; 	DETECT FLOPPY HARDWARE
000E57  2               ;________________________________________________________________________________________________________________________________
000E57  2               FD_DETECT:
000E57  2               ; BLINDLY RESET FDC (WHICH MAY OR MAY NOT EXIST)
000E57  2  20 85 0E             JSR     FC_RESETFDC     ; RESET FDC
000E5A  2               
000E5A  2  AD 30 03             LDA     FDC_MSR         ; READ MSR
000E5D  2  C9 80                CMP     #$80
000E5F  2  F0 0A                BEQ     FD_DETECT1      ; $80 IS OK
000E61  2  C9 D0                CMP     #$D0
000E63  2  F0 06                BEQ     FD_DETECT1      ; $D0 IS OK
000E65  2  A9 FF                LDA     #$FF            ; NOT OK
000E67  2  8D B2 0E             STA     HARDWARE_DETCT
000E6A  2  60                   RTS
000E6B  2               ;
000E6B  2               FD_DETECT1:
000E6B  2  A2 64                LDX     #100
000E6D  2  20 A8 0E             JSR     FDVDELAY        ; WAIT A BIT FOR FDC
000E70  2  AD 30 03             LDA     FDC_MSR         ; READ MSR AGAIN
000E73  2  C9 80                CMP     #$80
000E75  2  F0 08                BEQ     :+              ; $80 IS OK
000E77  2  C9 D0                CMP     #$D0
000E79  2  A9 FF                LDA     #$FF            ; NOT OK
000E7B  2  8D B2 0E             STA     HARDWARE_DETCT
000E7E  2  60                   RTS
000E7F  2               :
000E7F  2  A9 00                LDA     #$00            ; OK
000E81  2  8D B2 0E             STA     HARDWARE_DETCT
000E84  2  60                   RTS
000E85  2               
000E85  2               FC_RESETFDC:
000E85  2  AD 33 03             LDA     FDC_RESET
000E88  2  AD 33 03             LDA     FDC_RESET
000E8B  2  A2 96                LDX     #150
000E8D  2  20 A8 0E             JSR     FDVDELAY        ; WAIT A BIT FOR FDC
000E90  2               
000E90  2  A9 00                LDA     #$00
000E92  2  8D 36 03             STA     FDC_DOR
000E95  2  20 A3 0E             JSR     FDDELAY
000E98  2  A9 0C                LDA     #DOR_INIT
000E9A  2  8D 36 03             STA     FDC_DOR
000E9D  2  A2 96                LDX     #150            ;
000E9F  2  20 A8 0E             JSR     FDVDELAY
000EA2  2  60                   RTS
000EA3  2               
000EA3  2               
000EA3  2               FDDELAY:
000EA3  2  48                   PHA
000EA4  2  68                   PLA
000EA5  2  48                   PHA
000EA6  2  68                   PLA
000EA7  2  60                   RTS
000EA8  2               FDVDELAY:
000EA8  2  48                   PHA
000EA9  2  68                   PLA
000EAA  2  48                   PHA
000EAB  2  68                   PLA
000EAC  2  CA                   DEX
000EAD  2  E0 00                CPX     #$00
000EAF  2  D0 F7                BNE     FDVDELAY
000EB1  2  60                   RTS
000EB2  2               
000EB2  2                       .IF     DRIVERS=1
000EB2  2               ;*__FL_STORE_BOOT_IMAGE_______________________________________________________________________________
000EB2  2               ;*
000EB2  2               ;*  WRITE Boot image to block 0 of device
000EB2  2               ;*
000EB2  2               ;*  YA points to:
000EB2  2               ;* 			DB 	Device Unit
000EB2  2               ;*			DB 	RAM Page
000EB2  2               ;*			DW 	Source Address
000EB2  2               ;* 			DB	Image Length (Pages)
000EB2  2               ;*____________________________________________________________________________________________________
000EB2  2               FL_STORE_BOOT_IMAGE:
000EB2  2               
000EB2  2                           STA     pointr          ; SET POINTR TO INFO BLOCK
000EB2  2                           STY     pointr+1
000EB2  2                           LDA     #<BOOTUNIT
000EB2  2                           STA     room
000EB2  2                           LDA     #>BOOTUNIT
000EB2  2                           STA     room+1
000EB2  2                           LDY     #$00            ; COPY PARAMETERS TO USEFUL AREA
000EB2  2               :
000EB2  2                           LDA     (pointr),Y
000EB2  2                           STA     (room),Y
000EB2  2                           INY
000EB2  2                           CPY     #05
000EB2  2                           BNE     :-
000EB2  2               
000EB2  2                           LDA     #$00
000EB2  2                           STA     sektrk
000EB2  2                           STA     sektrk+1
000EB2  2                           STA     seksec          ;
000EB2  2                           STA     seksec+1        ;
000EB2  2                           LDA     DSKUNIT
000EB2  2                           STA     BOOTUNIT
000EB2  2               
000EB2  2                           JSR     INIT_PAGE_COPY  ; COPY PAGE COPY CODE TO LORAM
000EB2  2                           LDA     BOOTSOURCE      ; SETUP SOURCE POINTER
000EB2  2                           STA     pointr
000EB2  2                           LDA     BOOTSOURCE+1
000EB2  2                           STA     pointr+1
000EB2  2               
000EB2  2               :
000EB2  2                           LDA     BOOTRAMPAGE
000EB2  2                           JSR     COPY_PAGE_TO_HSTBUF; COPY 512 BYTES AT POINTR TO HSTBUF (AND INC POINTER)
000EB2  2               
000EB2  2                           JSR     FL_WRITE_SECTOR_RAW
000EB2  2                           CMP     #$FF
000EB2  2                           BEQ     FL_STORE_BOOT_IMAGE_ERROR
000EB2  2                           INC     seksec
000EB2  2                           LDA     seksec
000EB2  2                           CMP     #36
000EB2  2                           BNE     :+
000EB2  2                           LDA     #00
000EB2  2                           STA     seksec
000EB2  2                           INC     sektrk
000EB2  2               :
000EB2  2                           DEC     BOOTLENGTH
000EB2  2                           LDA     BOOTLENGTH
000EB2  2                           CMP     #$00
000EB2  2                           BNE     :--
000EB2  2                           LDA     #$00            ; ZERO ON RETURN = OPERATION OK
000EB2  2                           RTS
000EB2  2               FL_STORE_BOOT_IMAGE_ERROR:
000EB2  2                           LDA     #$FF            ; 1 ON RETURN = OPERATION FAIL
000EB2  2                           RTS
000EB2  2               
000EB2  2               ;*__IDE_RESTORE_BOOT_IMAGE____________________________________________________________________________
000EB2  2               ;*
000EB2  2               ;*  READ Boot image from block 0 of device
000EB2  2               ;*
000EB2  2               ;*  YA points to:
000EB2  2               ;* 			DB 	Device Unit
000EB2  2               ;*			DB 	RAM Page
000EB2  2               ;*			DW 	Source Address
000EB2  2               ;* 			DB	Image Length (Pages)
000EB2  2               ;*____________________________________________________________________________________________________
000EB2  2               FL_RESTORE_BOOT_IMAGE:
000EB2  2               
000EB2  2                           STA     pointr          ; SET POINTR TO INFO BLOCK
000EB2  2                           STY     pointr+1
000EB2  2                           LDA     #<BOOTUNIT
000EB2  2                           STA     room
000EB2  2                           LDA     #>BOOTUNIT
000EB2  2                           STA     room+1
000EB2  2                           LDY     #$00            ; COPY PARAMETERS TO USEFUL AREA
000EB2  2               :
000EB2  2                           LDA     (pointr),Y
000EB2  2                           STA     (room),Y
000EB2  2                           INY
000EB2  2                           CPY     #05
000EB2  2                           BNE     :-
000EB2  2               
000EB2  2                           LDA     #$00
000EB2  2                           LDA     #$00
000EB2  2                           STA     sektrk
000EB2  2                           STA     sektrk+1
000EB2  2                           STA     seksec          ;
000EB2  2                           STA     seksec+1        ;
000EB2  2                           LDA     DSKUNIT
000EB2  2                           STA     BOOTUNIT
000EB2  2               
000EB2  2               
000EB2  2                           JSR     INIT_PAGE_COPY  ; COPY PAGE COPY CODE TO LORAM
000EB2  2                           LDA     BOOTSOURCE      ; SETUP SOURCE POINTER
000EB2  2                           STA     pointr
000EB2  2                           LDA     BOOTSOURCE+1
000EB2  2                           STA     pointr+1
000EB2  2               
000EB2  2               :
000EB2  2                           JSR     FL_READ_SECTOR_RAW
000EB2  2                           CMP     #$FF
000EB2  2                           BEQ     FL_RESTORE_BOOT_IMAGE_ERROR
000EB2  2                           LDA     BOOTRAMPAGE
000EB2  2                           JSR     COPY_HSTBUF_TOPAGE; COPY 512 BYTES FROM HSTBUF TO POINTR HSTBUF (AND INC POINTER)
000EB2  2                           INC     seksec
000EB2  2                           LDA     seksec
000EB2  2                           CMP     #36
000EB2  2                           BNE     :+
000EB2  2                           LDA     #00
000EB2  2                           STA     seksec
000EB2  2                           INC     sektrk
000EB2  2               :
000EB2  2                           DEC     BOOTLENGTH
000EB2  2                           LDA     BOOTLENGTH
000EB2  2                           CMP     #$00
000EB2  2                           BNE     :--
000EB2  2                           LDA     #$00            ; ZERO ON RETURN = OPERATION OK
000EB2  2                           RTS
000EB2  2               FL_RESTORE_BOOT_IMAGE_ERROR:
000EB2  2                           LDA     #$FF            ; 1 ON RETURN = OPERATION FAIL
000EB2  2                           RTS
000EB2  2                       .ENDIF
000EB2  2               
000EB2  2               
000EB2  2               HARDWARE_DETCT:
000EB2  2  00                   .BYTE   0               ; HARDWARE DETECTED
000EB3  2               debhead:
000EB3  2  00                   .BYTE   0               ; DEBLOCKED HEAD
000EB4  2               debcyl:
000EB4  2  00                   .BYTE   0               ; DEBLOCKED CYLINDER
000EB5  2               debsec:
000EB5  2  00                   .BYTE   0               ; DEBLOCKED SECTOR
000EB6  2               Cdebhead:
000EB6  2  00                   .BYTE   0               ; DEBLOCKED HEAD (cache)
000EB7  2               Cdebcyl:
000EB7  2  00                   .BYTE   0               ; DEBLOCKED CYLINDER (cache)
000EB8  2               Cdebsec:
000EB8  2  00                   .BYTE   0               ; DEBLOCKED SECTOR (cache)
000EB9  2               FLERR:
000EB9  2  00                   .BYTE   $00             ;
000EBA  2               UNIT:
000EBA  2  00                   .BYTE   $00             ;
000EBB  2               FCMD:
000EBB  2  00                   .BYTE   0               ; COMMAND READ OR WRITE,
000EBC  2               ST0:
000EBC  2  00                   .BYTE   0               ; COMMAND READ OR WRITE,
000EBD  2               FLRETRY:
000EBD  2  00                   .BYTE   00
000EBE  2               FLRETRY1:
000EBE  2  00                   .BYTE   00
000EBF  2               
000EBF  1               
000EBF  1               
000EBF  1               
000EBF  1               
000EBF  1               ;
000EBF  1               ;==================================================================================================
000EBF  1               ; UTILITY FUNCTIONS
000EBF  1               ;==================================================================================================
000EBF  1               ;
000EBF  1               ;
000EBF  1               CHR_CR          = $0D
000EBF  1               CHR_LF          = $0A
000EBF  1               CHR_BS          = $08
000EBF  1               CHR_ESC         = $1B
000EBF  1               ;
000EBF  1               ;__________________________________________________________________________________________________
000EBF  1               ;
000EBF  1               ; UTILITY PROCS TO PRINT SINGLE CHARACTERS WITHOUT TRASHING ANY REGISTERS
000EBF  1               ;
000EBF  1               
000EBF  1               PC_SPACE:
000EBF  1  48                   PHA
000EC0  1  A9 20                LDA     #' '
000EC2  1  20 DF 0E             JSR     OUT             ; PRINT CHAR IN ACC
000EC5  1  68                   PLA
000EC6  1  60                   RTS
000EC7  1               
000EC7  1               PC_PERIOD:
000EC7  1  48                   PHA
000EC8  1  A9 2E                LDA     #'.'
000ECA  1  20 DF 0E             JSR     OUT             ; PRINT CHAR IN ACC
000ECD  1  68                   PLA
000ECE  1  60                   RTS
000ECF  1               
000ECF  1               
000ECF  1               PC_CR:
000ECF  1  48                   PHA
000ED0  1  A9 0D                LDA     #CHR_CR
000ED2  1  20 DF 0E             JSR     OUT             ; PRINT CHAR IN ACC
000ED5  1  68                   PLA
000ED6  1  60                   RTS
000ED7  1               
000ED7  1               PC_LF:
000ED7  1  48                   PHA
000ED8  1  A9 0A                LDA     #CHR_LF
000EDA  1  20 DF 0E             JSR     OUT             ; PRINT CHAR IN ACC
000EDD  1  68                   PLA
000EDE  1  60                   RTS
000EDF  1               
000EDF  1               OUT:
000EDF  1               conwrt:
000EDF  1  DA                   PHX
000EE0  1  5A                   PHY
000EE1  1  A2 02                LDX     #2              ;
000EE3  1  20 03 01             JSR     PEM             ;
000EE6  1  7A                   PLY
000EE7  1  FA                   PLX
000EE8  1  60                   RTS
000EE9  1               
000EE9  1               BLKSECR512:
000EE9  1               DEBSECR512:
000EE9  1  60                   RTS
000EEA  1               
000EEA  1               ;__PRINT_BYTE__________________________________________________
000EEA  1               ;
000EEA  1               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
000EEA  1               ;
000EEA  1               ;______________________________________________________________
000EEA  1               PRINT_BYTE:
000EEA  1  AA                   TAX                     ; SAVE A REGISTER
000EEB  1  4A                   LSR     A               ; SHIFT HIGH NIBBLE TO LOW NIBBLE
000EEC  1  4A                   LSR     A               ;
000EED  1  4A                   LSR     A               ;
000EEE  1  4A                   LSR     A               ;
000EEF  1  18                   CLC                     ; CLEAR CARRY
000EF0  1  20 E1 09             JSR     PRINT_DIGIT     ; PRINT LOW NIBBLE
000EF3  1  8A                   TXA                     ; RESTORE ACCUMULATOR
000EF4  1  4C E1 09             JMP     PRINT_DIGIT     ; PRINT LOW NIBBLE
000EF7  1               
000EF7  1               
000EF7  1               ;
000EF7  1               ; OUTPUT A '$' TERMINATED STRING
000EF7  1               ;
000EF7  1               WRITESTR:
000EF7  1  85 F0                STA     OUTMSG_W
000EF9  1  84 F1                STY     OUTMSG_W+1
000EFB  1  A0 00                LDY     #$00
000EFD  1               WRITESTR1:
000EFD  1  B1 F0                LDA     (OUTMSG_W),Y    ; LOAD NEXT CHAR FROM STRING INTO ACC
000EFF  1  C9 24                CMP     #'$'            ; IS END?
000F01  1  F0 07                BEQ     ENDOUTSTR       ; YES, END PRINT OUT
000F03  1  20 DF 0E             JSR     OUT             ; PRINT CHAR IN ACC
000F06  1  C8                   INY                     ; Y=Y+1 (BUMP INDEX)
000F07  1  4C FD 0E             JMP     WRITESTR1       ; DO NEXT CHAR
000F0A  1               ENDOUTSTR:
000F0A  1  60                   RTS                     ; RETURN
000F0B  1               
000F0B  1               
000F0B  1               
000F0B  1               
000F0B  1               
000F0B  1               CIN:
000F0B  1  DA                   PHX
000F0C  1  5A                   PHY
000F0D  1  A2 01                LDX     #1              ;
000F0F  1  20 03 01             JSR     PEM             ;
000F12  1  7A                   PLY
000F13  1  FA                   PLX
000F14  1  60                   RTS
000F15  1               
000F15  1               
000F15  1               CONF:
000F15  1  20 0B 0F             JSR     CIN
000F18  1  C9 1B                CMP     #$1B
000F1A  1  F0 05                BEQ     EXIT
000F1C  1  C9 0D                CMP     #$0D
000F1E  1  D0 F5                BNE     CONF
000F20  1               
000F20  1  60                   RTS
000F21  1               
000F21  1               EXIT:
000F21  1               ; CLEAN UP AND RETURN TO OS
000F21  1  20 EF 09             JSR     NEWLINE
000F24  1  20 EF 09             JSR     NEWLINE
000F27  1  4C 00 01             JMP     $0100
000F2A  1               
000F2A  1               
000F2A  1               FMTGAP:
000F2A  1  00                   .BYTE   0               ; GAP FOR FORMAT 5.25=$50, 3.5=$54
000F2B  1               CURSEC:
000F2B  1  00                   .BYTE   0
000F2C  1               
000F2C  1               sektrk:
000F2C  1  00 00                .BYTE   0,0             ;seek track number
000F2E  1               seksec:
000F2E  1  00 00                .BYTE   0,0             ;seek sector number
000F30  1               sekdsk:
000F30  1  00                   .BYTE   0
000F31  1               DSKUNIT:
000F31  1  00                   .BYTE   0
000F32  1               hstbuf:
000F32  1  xx xx xx xx          .RES    1024
000F36  1  xx xx xx xx  
000F3A  1  xx xx xx xx  
001332  1               temp:
001332  1  00                   .BYTE   0
001333  1               MAXTRACK:
001333  1  28                   .BYTE   40
001334  1               
001334  1               STR_BANNER:
001334  1  0D 0A 4E 68          .BYTE   $0D,$0A,"Nhyodyne Floppy Disk Format v1.0"
001338  1  79 6F 64 79  
00133C  1  6E 65 20 46  
001356  1  0D 0A 43 68          .BYTE   $0D,$0A,"Choose Floppy type:",$0D,$0A
00135A  1  6F 6F 73 65  
00135E  1  20 46 6C 6F  
00136D  1  31 3E 20 35          .BYTE   "1> 5.25 inch floppy  360K 40 tracks",$0D,$0A
001371  1  2E 32 35 20  
001375  1  69 6E 63 68  
001392  1  32 3E 20 33          .BYTE   "2> 3.5 inch floppy   720K 80 tracks",$0D,$0A,"$"
001396  1  2E 35 20 69  
00139A  1  6E 63 68 20  
0013B8  1               STR_DRIVE:
0013B8  1  0D 0A 43 68          .BYTE   $0D,$0A,"Choose Floppy drive:",$0D,$0A
0013BC  1  6F 6F 73 65  
0013C0  1  20 46 6C 6F  
0013D0  1  31 3E 20 44          .BYTE   "1> DRIVE 0",$0D,$0A
0013D4  1  52 49 56 45  
0013D8  1  20 30 0D 0A  
0013DC  1  32 3E 20 44          .BYTE   "2> DRIVE 1",$0D,$0A,"$"
0013E0  1  52 49 56 45  
0013E4  1  20 31 0D 0A  
0013E9  1               STR_INTRO:
0013E9  1  0D 0A 0D 0A          .BYTE   $0D,$0A,$0D,$0A,"Insert FLOPPY, NOTE EXISTING DATA WILL BE DESTROYED!!!",$0D,$0A,"$"
0013ED  1  49 6E 73 65  
0013F1  1  72 74 20 46  
001426  1               STR_CONFIRM:
001426  1  50 72 65 73          .BYTE   "Press <Enter> to continue, <Esc> to abort",$0D,$0A,"$"
00142A  1  73 20 3C 45  
00142E  1  6E 74 65 72  
001452  1               
001452  1               
001452  1               
001452  1               
001452  1               
001452  1               STR_ERR1:
001452  1  0D 0A 44 49          .BYTE   $0D,$0A,"DISK ERROR 1",$0D,$0A,"$"
001456  1  53 4B 20 45  
00145A  1  52 52 4F 52  
001463  1               STR_ERR2:
001463  1  0D 0A 44 49          .BYTE   $0D,$0A,"DISK ERROR 2",$0D,$0A,"$"
001467  1  53 4B 20 45  
00146B  1  52 52 4F 52  
001474  1               STR_ERR3:
001474  1  0D 0A 44 49          .BYTE   $0D,$0A,"DISK ERROR 3",$0D,$0A,"$"
001478  1  53 4B 20 45  
00147C  1  52 52 4F 52  
001485  1               STR_ERR4:
001485  1  0D 0A 44 49          .BYTE   $0D,$0A,"DISK ERROR 4",$0D,$0A,"$"
001489  1  53 4B 20 45  
00148D  1  52 52 4F 52  
001496  1               STR_ERR5:
001496  1  0D 0A 44 49          .BYTE   $0D,$0A,"DISK ERROR 5",$0D,$0A,"$"
00149A  1  53 4B 20 45  
00149E  1  52 52 4F 52  
0014A7  1               
0014A7  1                       .END
