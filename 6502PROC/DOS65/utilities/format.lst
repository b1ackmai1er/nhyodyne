ca65 V2.18 - Ubuntu 2.19-1
Main file   : format.asm
Current file: format.asm

000000r 1               ;__FLOPPY FORMAT_________________________________________________________________________________________________________________
000000r 1               ;
000000r 1               ; 	DOS/65 floppy FORMATTER for Nhyodyne FDC card
000000r 1               ;
000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               ;
000000r 1               DFLFCB	=	$107		;DEFAULT FCB
000000r 1               PEM		=	$103		;PEM ENTRY
000000r 1               BOOT	=	$100		;WARM BOOT
000000r 1               TEA		=	$800		;EXECUTION ORG
000000r 1               CCMLNG	=	2048		;CCM LENGTH
000000r 1               CRSYM	=	32			;CR SYMBOL
000000r 1               LASTROW =	20
000000r 1               MAXCOL  =	80
000000r 1               
000000r 1               USEDSKYNG=	0
000000r 1               USEDSKY	=	0
000000r 1               
000000r 1               OUTMSG_W=	$F0
000000r 1               
000000r 1               DENS	= 	2	; DENSITY
000000r 1               EOTSEC	=	09	; LAST SECTOR OF TRACK
000000r 1               
000000r 1               
000000r 1               ;MAIN PROGRAM
000000r 1                	.segment "TEA"
000000r 1               	.ORG $0800
000800  1               
000800  1               
000800  1               
000800  1  A9 04        	LDA	#STR_BANNER &$FF
000802  1  A0 13        	LDY	#STR_BANNER>>8 & $FF
000804  1  20 C7 0E     	JSR	WRITESTR
000807  1               
000807  1               INLOOP:
000807  1  20 DB 0E     	JSR	CIN
00080A  1  C9 31        	CMP	#'1'
00080C  1  F0 07        	BEQ	TRACK40
00080E  1  C9 32        	CMP	#'2'
000810  1  F0 10        	BEQ	TRACK80
000812  1  4C 07 08     	JMP	INLOOP
000815  1               
000815  1               TRACK40:
000815  1  A9 28        	LDA	#40
000817  1  8D 03 13     	STA	MAXTRACK
00081A  1  A9 50        	LDA #$50
00081C  1  8D FA 0E     	STA FMTGAP		; GAP FOR FORMAT 5.25=$50, 3.5=$54
00081F  1  4C 2F 08     	JMP	FMTCONT
000822  1               
000822  1               TRACK80:
000822  1  A9 50        	LDA	#80
000824  1  8D 03 13     	STA	MAXTRACK
000827  1  A9 54        	LDA #$54
000829  1  8D FA 0E     	STA FMTGAP		; GAP FOR FORMAT 5.25=$50, 3.5=$54
00082C  1  4C 2F 08     	JMP	FMTCONT
00082F  1               
00082F  1               
00082F  1               FMTCONT:
00082F  1  A9 88        	LDA	#STR_DRIVE &$FF
000831  1  A0 13        	LDY	#STR_DRIVE>>8 & $FF
000833  1  20 C7 0E     	JSR	WRITESTR
000836  1               
000836  1               INLOOP1:
000836  1  20 DB 0E     	JSR	CIN
000839  1  C9 31        	CMP	#'1'
00083B  1  F0 07        	BEQ	FMTCONT1
00083D  1  C9 32        	CMP	#'2'
00083F  1  F0 10        	BEQ	FMTCONT2
000841  1  4C 36 08     	JMP	INLOOP1
000844  1               
000844  1               FMTCONT1:
000844  1  A9 00        	LDA #$00
000846  1  8D 00 0F     	STA sekdsk
000849  1  A9 11        	LDA #%00010001
00084B  1  8D 01 0F     	STA	DSKUNIT
00084E  1  4C 5E 08     	JMP FMTCONT3
000851  1               
000851  1               FMTCONT2:
000851  1  A9 01        	LDA #$01
000853  1  8D 00 0F     	STA sekdsk
000856  1  A9 21        	LDA #%00100001
000858  1  8D 01 0F     	STA	DSKUNIT
00085B  1  4C 5E 08     	JMP FMTCONT3
00085E  1               
00085E  1               
00085E  1               FMTCONT3:
00085E  1  A9 B9        	LDA	#STR_INTRO &$FF
000860  1  A0 13        	LDY	#STR_INTRO>>8 & $FF
000862  1  20 C7 0E     	JSR	WRITESTR
000865  1               
000865  1  A9 F6        	LDA	#STR_CONFIRM &$FF
000867  1  A0 13        	LDY	#STR_CONFIRM>>8 & $FF
000869  1  20 C7 0E     	JSR	WRITESTR
00086C  1               
00086C  1  20 E5 0E     	JSR	CONF
00086F  1               
00086F  1  20 9F 0E     	jsr	PC_CR
000872  1  20 A7 0E     	JSR	PC_LF
000875  1  A9 00        	LDA	#$00
000877  1  8D 84 0E     	sta	debcyl
00087A  1               
00087A  1               FMTLOOP:
00087A  1  A9 00        	lda	#$00
00087C  1  8D 83 0E     	STA	debhead
00087F  1  20 A0 08     	jsr	FMTCYL
000882  1               
000882  1  A9 01        	lda	#$01
000884  1  8D 83 0E     	STA	debhead
000887  1  20 A0 08     	jsr	FMTCYL
00088A  1               
00088A  1  EE 84 0E     	INC	debcyl
00088D  1  AD 84 0E     	LDA	debcyl
000890  1  CD 03 13     	CMP	MAXTRACK
000893  1  D0 E5        	BNE	FMTLOOP
000895  1               
000895  1               DONE:
000895  1  20 9F 0E     	JSR	PC_CR
000898  1  20 A7 0E     	JSR	PC_LF
00089B  1  A2 00        	LDX	#$00
00089D  1  4C 03 01     	JMP	PEM
0008A0  1               
0008A0  1               
0008A0  1               ;__FMTCYL________________________________________________________________________________________________________________________
0008A0  1               ;
0008A0  1               ; 	FORMAT A FLOPPY TRACK
0008A0  1               ;________________________________________________________________________________________________________________________________
0008A0  1               ;
0008A0  1               FMTCYL:
0008A0  1  20 2B 0D     	JSR	SETTRACK		; PERFORM SEEK TO TRACK
0008A3  1  78           	SEI
0008A4  1  20 C5 0D     	JSR	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
0008A7  1  C9 FF        	CMP	#$FF			; DID IT RETURN WITH ERROR CODE?
0008A9  1  D0 0A        	BNE	FMTGO			; IF YES, EXIT WITH ERROR CODE
0008AB  1  A9 22        	LDA	#STR_ERR1 &$FF
0008AD  1  A0 14        	LDY #STR_ERR1>>8 & $FF
0008AF  1  20 C7 0E     	JSR	WRITESTR
0008B2  1  4C 66 0C     	JMP	DSKEXIT
0008B5  1               FMTGO:					; 					;
0008B5  1               FMT:					; FORMAT TRACK COMMAND
0008B5  1               						;
0008B5  1  18           	CLC
0008B6  1  AD 00 0F     	LDA	sekdsk			; GET DISK UNIT NUMBER
0008B9  1  29 01        	AND	#$01			; MASK FOR TWO DRIVES.
0008BB  1  8D 8A 0E     	STA	UNIT			; PARK IT IN TEMP
0008BE  1  AD 83 0E     	LDA	debhead			; GET HEAD SELECTION
0008C1  1  29 01        	AND	#$01			; INSURE SINGLE BIT
0008C3  1  0A           	ASL	A				;
0008C4  1  0A           	ASL	A				; MOVE HEAD TO BIT 2 POSITION
0008C5  1  0D 8A 0E     	ORA	UNIT			; OR HEAD TO UNIT BYTE IN COMMAND BLOCK
0008C8  1  8D 8A 0E     	STA	UNIT			; STORE IN UNIT
0008CB  1               						;
0008CB  1  A9 4D        	LDA	#$4D			; BIT 6 SETS MFM, 0DH IS FORMAT COMMAND
0008CD  1  20 81 0D     	JSR	PFDATA			; PUSH FORMAT COMMAND TO I8272
0008D0  1  AD 8A 0E     	LDA UNIT			;
0008D3  1  20 81 0D     	JSR	PFDATA			; WHICH DRIVE UNIT TO FORMAT
0008D6  1  A9 02        	LDA	#DENS			;
0008D8  1  20 81 0D     	JSR	PFDATA			; WHAT DENSITY
0008DB  1  A9 09        	LDA	#EOTSEC			;
0008DD  1  20 81 0D     	JSR	PFDATA			; SECTOR COUNT
0008E0  1  AD FA 0E     	LDA	FMTGAP			;
0008E3  1  20 81 0D     	JSR	PFDATA			; WHAT GAP IS NEEDED
0008E6  1  A9 E5        	LDA #$E5			;
0008E8  1  20 AC 0D     	JSR	PFDATAS			; FILLER BYTE FOR SECTORS
0008EB  1  A0 01        	LDY	#$01			; SET SECTOR#
0008ED  1               
0008ED  1               FMT1:
0008ED  1  AD 30 03     	LDA	FDC_MSR			; GET STATUS
0008F0  1  10 FB        	BPL	FMT1
0008F2  1  8D 02 13     	sta	temp			;
0008F5  1  29 20        	AND	#%00100000		; EXECUTION MODE?
0008F7  1  F0 49        	BEQ	DSKFMEND1		; NO, ERROR
0008F9  1               
0008F9  1  AD 84 0E     	LDA	debcyl			; UPDATE I8272 DURING FORMAT
0008FC  1  8D 31 03     	STA	FDC_DATA		; SEND CYLINDER NUMBER
0008FF  1                 						;
0008FF  1               						;
0008FF  1               FMT1A:
0008FF  1  AD 30 03     	LDA	FDC_MSR			; GET STATUS
000902  1  10 FB        	BPL	FMT1A
000904  1  8D 02 13     	sta	temp			;
000907  1  29 20        	AND	#%00100000		; EXECUTION MODE?
000909  1  F0 44        	BEQ	DSKFMEND1A		; NO, ERROR
00090B  1  AD 83 0E     	LDA	debhead			; UPDATE I8272 DURING FORMAT
00090E  1  8D 31 03     	STA	FDC_DATA		; SEND HEAD NUMBER
000911  1               
000911  1               FMT1B:
000911  1  AD 30 03     	LDA	FDC_MSR			; GET STATUS
000914  1  10 FB        	BPL	FMT1B
000916  1  8D 02 13     	sta	temp			;
000919  1  29 20        	AND	#%00100000		; EXECUTION MODE?
00091B  1  F0 3F        	BEQ	DSKFMEND1B		; NO, ERROR
00091D  1               						;
00091D  1  98           	TYA
00091E  1  8D 31 03     	STA	FDC_DATA		; WHAT SECTOR NUMBER
000921  1               
000921  1               
000921  1               FMT1C:
000921  1  AD 30 03     	LDA	FDC_MSR			; GET STATUS
000924  1  10 FB        	BPL	FMT1C
000926  1  8D 02 13     	sta	temp			;
000929  1  29 20        	AND	#%00100000		; EXECUTION MODE?
00092B  1  F0 3C        	BEQ	DSKFMEND1C		; NO, ERROR
00092D  1               						;
00092D  1  A9 02        	LDA	#DENS			;
00092F  1  8D 31 03     	STA	FDC_DATA		; NUMBER OF BYTES PER SECTOR (N2)
000932  1               
000932  1               FMT1D:
000932  1  AD 30 03     	LDA	FDC_MSR			; GET STATUS
000935  1  10 FB        	BPL	FMT1D			;
000937  1               						;
000937  1  C8           	INY 				; INCREASE SECTOR COUNT
000938  1               						;
000938  1  C0 0A        	CPY	#$0A			; IS THIS PAST THE LAST SECTOR OF TRACK?
00093A  1  D0 B1        	BNE	FMT1			; IF NO, SEND ANOTHER SECTOR
00093C  1  20 97 0E     	JSR	PC_PERIOD
00093F  1  4C 76 09     	JMP	FMTEND
000942  1               
000942  1               
000942  1               
000942  1               DSKFMEND1:
000942  1  A9 33        	LDA	#STR_ERR2 &$FF
000944  1  A0 14        	LDY #STR_ERR2>>8 & $FF
000946  1  20 C7 0E     	JSR	WRITESTR
000949  1  20 7F 09     	JSR	GETERR
00094C  1  4C 95 08     	JMP DONE
00094F  1               DSKFMEND1A:
00094F  1  A9 44        	LDA	#STR_ERR3 &$FF
000951  1  A0 14        	LDY	#STR_ERR3>>8 & $FF
000953  1  20 C7 0E     	JSR	WRITESTR
000956  1  20 7F 09     	JSR	GETERR
000959  1  4C 95 08     	JMP DONE
00095C  1               DSKFMEND1B:
00095C  1  A9 55        	LDA	#STR_ERR4 &$FF
00095E  1  A0 14        	LDY	#STR_ERR4>>8 & $FF
000960  1  20 C7 0E     	JSR	WRITESTR
000963  1  20 7F 09     	JSR	GETERR
000966  1  4C 95 08     	JMP DONE
000969  1               DSKFMEND1C:
000969  1  A9 66        	LDA	#STR_ERR5 &$FF
00096B  1  A0 14        	LDY	#STR_ERR5>>8 & $FF
00096D  1  20 C7 0E     	JSR	WRITESTR
000970  1  20 7F 09     	JSR	GETERR
000973  1  4C 95 08     	JMP DONE
000976  1               
000976  1               FMTEND:
000976  1               ;* CLEAR OUT ANY REMAINING DATA
000976  1  A0 10        	LDY #$10
000978  1               FMTEND_1:
000978  1  20 0E 0E     	JSR	GFDATA			;GET ERROR TYPE
00097B  1  88           	DEY
00097C  1  D0 FA        	BNE FMTEND_1
00097E  1  60           	RTS
00097F  1               
00097F  1               GETERR:
00097F  1  AD 02 13     	LDA	temp			;GET ERROR TYPE
000982  1  20 BA 0E     	JSR	PRINT_BYTE
000985  1  20 8F 0E     	JSR	PC_SPACE
000988  1  20 0E 0E     	JSR	GFDATA			;GET ERROR TYPE
00098B  1  20 BA 0E     	JSR	PRINT_BYTE
00098E  1  20 8F 0E     	JSR	PC_SPACE
000991  1  20 0E 0E     	JSR	GFDATA			;GET ERROR TYPE
000994  1  20 BA 0E     	JSR	PRINT_BYTE
000997  1  20 8F 0E     	JSR	PC_SPACE
00099A  1  20 0E 0E     	JSR	GFDATA			;GET ERROR TYPE
00099D  1  20 BA 0E     	JSR	PRINT_BYTE
0009A0  1  20 8F 0E     	JSR	PC_SPACE
0009A3  1  20 0E 0E     	JSR	GFDATA			;GET ERROR TYPE
0009A6  1  20 BA 0E     	JSR	PRINT_BYTE
0009A9  1  20 8F 0E     	JSR	PC_SPACE
0009AC  1  20 0E 0E     	JSR	GFDATA			;GET ERROR TYPE
0009AF  1  20 BA 0E     	JSR	PRINT_BYTE
0009B2  1  20 8F 0E     	JSR	PC_SPACE
0009B5  1  20 0E 0E     	JSR	GFDATA			;GET ERROR TYPE
0009B8  1  20 BA 0E     	JSR	PRINT_BYTE
0009BB  1  20 8F 0E     	JSR	PC_SPACE
0009BE  1  20 0E 0E     	JSR	GFDATA			;GET ERROR TYPE
0009C1  1  20 BA 0E     	JSR	PRINT_BYTE
0009C4  1  60           	RTS
0009C5  1               
0009C5  1               
0009C5  1               	.INCLUDE "../os/macro.asm"
0009C5  2               ;__MACRO___________________________________________________________________________________________________________________
0009C5  2               ;
0009C5  2               ; 	Macros for the betterment of Mankind
0009C5  2               ;________________________________________________________________________________________________________________________________
0009C5  2               ;
0009C5  2               
0009C5  2               .macro          PRTDBG      message
0009C5  2               .LOCAL p1
0009C5  2               .LOCAL p2
0009C5  2               .LOCAL p3
0009C5  2               .LOCAL p4
0009C5  2               .LOCAL p5
0009C5  2                 .if     .paramcount <> 1
0009C5  2                       .error  "Too few parameters for macro PRTDBG"
0009C5  2                       .endif
0009C5  2                       .if DEBUG=1
0009C5  2                       PHA
0009C5  2                       PHX
0009C5  2                       PHY
0009C5  2                       LDX #$00
0009C5  2               p1:
0009C5  2                       LDA p4,x
0009C5  2                       INX
0009C5  2                       CMP #'$'
0009C5  2                       BEQ p2
0009C5  2                       JSR conwrt
0009C5  2                       JMP p1
0009C5  2               p2:
0009C5  2                       LDA #13
0009C5  2                       jsr conwrt
0009C5  2                       LDA #10
0009C5  2                       jsr conwrt
0009C5  2                       PLY
0009C5  2                       plx
0009C5  2                       pla
0009C5  2                       JMP p5
0009C5  2               p4:
0009C5  2                       .BYTE message
0009C5  2               p5:
0009C5  2                       .endif
0009C5  2               .endmacro
0009C5  2               
0009C5  2               .macro          PRTS      message
0009C5  2               .LOCAL p1
0009C5  2               .LOCAL p2
0009C5  2               .LOCAL p3
0009C5  2               .LOCAL p4
0009C5  2               .LOCAL p5
0009C5  2                 .if     .paramcount <> 1
0009C5  2                       .error  "Too few parameters for macro PRTS"
0009C5  2                       .endif
0009C5  2                       PHA
0009C5  2                       PHX
0009C5  2                       PHY
0009C5  2                       LDX #$00
0009C5  2               p1:
0009C5  2                       LDA p4,x
0009C5  2                       INX
0009C5  2                       CMP #'$'
0009C5  2                       BEQ p2
0009C5  2                       JSR conwrt
0009C5  2                       JMP p1
0009C5  2               p2:
0009C5  2                       PLY
0009C5  2                       plx
0009C5  2                       pla
0009C5  2                       JMP p5
0009C5  2               p4:
0009C5  2                       .BYTE message
0009C5  2               p5:
0009C5  2               .endmacro
0009C5  2               
0009C5  2               
0009C5  2               
0009C5  2               
0009C5  2               ;__PRTHEXBYTE__________________________________________________
0009C5  2               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
0009C5  2               ;______________________________________________________________
0009C5  2               PRTHEXBYTE:
0009C5  2  48                   PHA
0009C6  2  DA                   PHX
0009C7  2  5A                   PHY
0009C8  2  AA                   TAX				; SAVE A REGISTER
0009C9  2  4A                   LSR 				; SHIFT HIGH NIBBLE TO LOW NIBBLE
0009CA  2  4A                   LSR 				;
0009CB  2  4A                   LSR 				;
0009CC  2  4A                   LSR 				;
0009CD  2  18                   CLC               		; CLEAR CARRY
0009CE  2  20 D9 09             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
0009D1  2  8A                   TXA				; RESTORE ACCUMULATOR
0009D2  2  20 D9 09             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
0009D5  2  7A                   PLY
0009D6  2  FA                   plx
0009D7  2  68                   PLA
0009D8  2  60                   RTS
0009D9  2               
0009D9  2               ;__PRINT_DIGIT_________________________________________________
0009D9  2               ;
0009D9  2               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
0009D9  2               ;
0009D9  2               ;______________________________________________________________
0009D9  2               PRINT_DIGIT:
0009D9  2  29 0F                       AND #$0F				; STRIP OFF HIGH NIBBLE
0009DB  2  09 30                       ORA #$30				; ADD $30 TO PRODUCE ASCII
0009DD  2  C9 3A                       CMP #$3A               		; IS GREATER THAN 9
0009DF  2  30 03                       BMI PRINT_DIGIT_OUT		; NO, SKIP ADD
0009E1  2  18                          CLC				; CLEAR CARRY
0009E2  2  69 07                       ADC #$07				; ADD ON FOR LETTER VALUES
0009E4  2               PRINT_DIGIT_OUT:					;
0009E4  2  4C AF 0E                    JMP conwrt              		; PRINT OUT CHAR
0009E7  2               
0009E7  2               NEWLINE:
0009E7  2  48                           pha
0009E8  2  DA                           PHX
0009E9  2  5A                           phy
0009EA  2  A9 0D                        LDA #$0D
0009EC  2  20 AF 0E                     JSR conwrt
0009EF  2  A9 0A                        LDA #$0A
0009F1  2  20 AF 0E                     Jsr conwrt
0009F4  2  7A                           ply
0009F5  2  FA                           plx
0009F6  2  68                           pla
0009F7  2  60                           rts
0009F8  2               
0009F8  2               PRTDEC:
0009F8  2  5A                           phy
0009F9  2  DA                           PHX
0009FA  2  48                           PHA
0009FB  2  A0 00                        ldy #00
0009FD  2  A2 FF                        LDX #$FF
0009FF  2  38                           SEC
000A00  2               PrDec100:
000A00  2  E8                           INX
000A01  2  E9 64                        SBC #100
000A03  2  B0 FB                        BCS PrDec100            ;Count how many 100s
000A05  2  69 64                        ADC #100
000A07  2  20 21 0A                     JSR PrDecDigit          ;Print the 100s
000A0A  2  A2 FF                        LDX #$FF
000A0C  2  38                           SEC                     ;Prepare for subtraction
000A0D  2               PrDec10:
000A0D  2  E8                           INX
000A0E  2  E9 0A                        SBC #10
000A10  2  B0 FB                        BCS PrDec10             ;Count how many 10s
000A12  2  69 0A                        ADC #10
000A14  2  20 21 0A                     JSR PrDecDigit          ;Print the 10s
000A17  2  AA                           TAX                     ;Pass 1s into X
000A18  2  A0 01                        ldy #1
000A1A  2  20 21 0A                     JSR PrDecDigit          ;Print the 1s
000A1D  2  68                           PLA
000A1E  2  FA                           PLX
000A1F  2  7A                           ply
000A20  2  60                           RTS
000A21  2               PrDecDigit:
000A21  2  48                           PHA
000A22  2  C0 00                        cpy #$00
000A24  2  D0 09                        bne PrDecDigit1
000A26  2  8A                           txa
000A27  2  A8                           tay
000A28  2  C0 00                        cpy #$00
000A2A  2  D0 03                        bne PrDecDigit1
000A2C  2  4C 35 0A                     jmp PrDecDigit2
000A2F  2               PrDecDigit1:
000A2F  2  8A                           TXA                     ;Save A, pass digit to A
000A30  2  09 30                        ORA #'0'
000A32  2  20 AF 0E                     JSR  conwrt             ;Convert to character and print it
000A35  2               PrDecDigit2:
000A35  2  68                           PLA
000A36  2  60                           RTS                     ;Restore A and return
000A37  2               
000A37  1               	.INCLUDE "../os/dosflp.asm"
000A37  2               ;__FLOPPY DRIVERS________________________________________________________________________________________________________________
000A37  2               ;
000A37  2               ; 	DOS/65 floppy drivers for MBC FDC card
000A37  2               ;
000A37  2               ;	Entry points:
000A37  2               ;		FL_SETUP        - called during OS init
000A37  2               ;		FL_READ_SECTOR	- read a sector from drive
000A37  2               ;		FL_WRITE_SECTOR	- write a sector to drive
000A37  2               ;
000A37  2               ;________________________________________________________________________________________________________________________________
000A37  2               ;
000A37  2               ;*
000A37  2               ;* HARDWARE I/O ADDRESSES
000A37  2               ;*
000A37  2               FDC_MSR		=	$0330		; ADDRESS OF MAIN STATUS REGISTER
000A37  2               FDC_DATA	=	$0331		; FLOPPY DATA REGISTER
000A37  2               FDC_RESET	=	$0333		; FLOPPY RESET
000A37  2               FDC_DCR		=	$0335		; LOAD CONTROL REGISTER
000A37  2               FDC_DOR		=   $0336		; CONFIGURATION CONTROL REGISTER
000A37  2               FDC_TC		=	$0337		; TERMINAL COUNT
000A37  2               
000A37  2               ;
000A37  2               ; FDC COMMANDS
000A37  2               ;
000A37  2               CFD_READ	=	%00000110	; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
000A37  2               CFD_READDEL	=	%00001100	; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
000A37  2               CFD_WRITE	=	%00000101	; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
000A37  2               CFD_WRITEDEL=	%00001001	; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
000A37  2               CFD_READTRK	=	%00000010	; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
000A37  2               CFD_READID	=	%00001010	; CMD,HDS/DS --> ST0,ST1,ST2,C,H,R,N
000A37  2               CFD_FMTTRK	=	%00001101	; CMD,HDS/DS,N,SC,GPL,D --> ST0,ST1,ST2,C,H,R,N
000A37  2               CFD_SCANEQ	=	%00010001	; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
000A37  2               CFD_SCANLOEQ=	%00011001	; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
000A37  2               CFD_SCANHIEQ=	%00011101	; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
000A37  2               CFD_RECAL	=	%00000111	; CMD,DS --> <EMPTY>
000A37  2               CFD_SENSEINT=	%00001000	; CMD --> ST0,PCN
000A37  2               CFD_SPECIFY	=	%00000011	; CMD,SRT/HUT,HLT/ND --> <EMPTY>
000A37  2               CFD_DRVSTAT	=	%00000100	; CMD,HDS/DS --> ST3
000A37  2               CFD_SEEK	=	%00001111	; CMD,HDS/DS --> <EMPTY>
000A37  2               CFD_VERSION	=	%00010000	; CMD --> ST0
000A37  2               
000A37  2               CFD_MFM	    =	%01000000	;
000A37  2               
000A37  2               ;
000A37  2               ;
000A37  2               ; Specify Command:
000A37  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
000A37  2               ; |Byte |  7  |	 6  |  5  |  4	|  3  |	 2  |  1  |  0	|
000A37  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
000A37  2               ; |  0	|  0  |	 0  |  0  |  0	|  0  |	 0  |  1  |  1	|
000A37  2               ; |  1	| ----- STEP RATE ----- | -- HEAD UNLOAD TIME - |
000A37  2               ; |  2	| ------------ HEAD LOAD TIME ----------- | NDM |
000A37  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
000A37  2               ;
000A37  2               ;
000A37  2               ; Step Rate (milliseconds):		 Head Unload Time (milliseconds):	Head Load Time (milliseconds):
000A37  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
000A37  2               ; |	 |	   BITRATE	     |	 |	|	  BITRATE	    |	|      |	 BITRATE	   |
000A37  2               ; |  VAL | 1.0M | 500K | 300K | 250K |	 |  VAL | 1.0M | 500K | 300K | 250K |	|  VAL | 1.0M | 500K | 300K | 250K |
000A37  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
000A37  2               ; |    0 |  8.0 | 16.0 | 26.7 | 32.0 |	 |    0 |  128 |  256 |	 426 |	512 |	|    0 |  128 |	 256 |	426 |  512 |
000A37  2               ; |    1 |  7.5 | 15.0 | 25.0 | 30.0 |	 |    1 |    8 |   16 | 26.7 |	 32 |	|    1 |    1 |	   2 |	3.3 |	 4 |
000A37  2               ; |    2 |  7.0 | 14.0 | 23.3 | 28.0 |	 |    2 |   16 |   32 | 53.3 |	 64 |	|    2 |    2 |	   4 |	6.7 |	 8 |
000A37  2               ; |  ... |  ... |  ... |  ... |	 ... |	 |  ... |  ... |  ... |	 ... |	... |	|  ... |  ... |	 ... |	... |  ... |
000A37  2               ; |   14 |  1.0 |  2.0 |  3.3 |	 4.0 |	 |   14 |  112 |  224 |	 373 |	448 |	|  126 |  126 |	 252 |	420 |  504 |
000A37  2               ; |   15 |  0.5 |  1.0 |  1.7 |	 2.0 |	 |   15 |  120 |  240 |	 400 |	480 |	|  127 |  127 |	 254 |	423 |  508 |
000A37  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
000A37  2               ;
000A37  2               ; IBM PS/2 CALLS FOR:
000A37  2               ;   STEP RATE: 3ms (6ms FOR ALL 41mm OR 720K DRIVES)
000A37  2               ;   HEAD LOAD TIME: 15ms
000A37  2               
000A37  2               DOR_INIT	=	%00001100	; SOFT RESET INACTIVE, DMA ENABLED
000A37  2               DOR_BR250	=	DOR_INIT
000A37  2               DOR_BR500	=	DOR_INIT
000A37  2               
000A37  2               
000A37  2               
000A37  2               FLOPPY_RETRIES  =       6               ; HOW ABOUT SIX RETIRES?
000A37  2               FLOPPY_RETRIES1 =       2               ; TWO ITERATIONS OF RECAL?
000A37  2               
000A37  2               ;__FL_SETUP______________________________________________________________________________________________________________________
000A37  2               ;
000A37  2               ;	SETUP FLOPPY DRIVE SETTINGS
000A37  2               ;________________________________________________________________________________________________________________________________
000A37  2               ;
000A37  2               FL_SETUP:
000A37  2  A9 00        	LDA	#$00                    ; RESET TRACK/CYL/SEC STORAGE
000A39  2  8D 83 0E     	STA	debhead                 ;
000A3C  2  8D 84 0E     	STA	debcyl                  ;
000A3F  2  8D 85 0E     	STA	debsec                  ;
000A42  2  A9 FF        	LDA	#$FF			; SET CACHE TO INVALID
000A44  2  8D 86 0E     	STA	Cdebhead		;
000A47  2  8D 87 0E     	STA	Cdebcyl			;
000A4A  2  8D 88 0E     	STA	Cdebsec			;
000A4D  2               
000A4D  2  48 DA 5A A2  	PRTS "FD: MODE=MBC$"
000A51  2  00 BD 66 0A  
000A55  2  E8 C9 24 F0  
000A73  2               ;
000A73  2  48 DA 5A A2  	PRTS " IO=0x$"
000A77  2  00 BD 8C 0A  
000A7B  2  E8 C9 24 F0  
000A93  2  A9 03        	LDA	#>FDC_MSR
000A95  2  20 C5 09     	JSR	PRTHEXBYTE
000A98  2  A9 30        	LDA	#<FDC_MSR
000A9A  2  20 C5 09     	JSR	PRTHEXBYTE
000A9D  2  20 27 0E     	JSR	FD_DETECT		; CHECK FOR FDC
000AA0  2  C9 00            CMP     #$00
000AA2  2  F0 2C            BEQ     :+                      ; CONTINUE IF FOUND
000AA4  2  48 DA 5A A2  	PRTS " NOT PRESENT$" 		; NOT ZERO, H/W NOT PRESENT
000AA8  2  00 BD BD 0A  
000AAC  2  E8 C9 24 F0  
000ACA  2  20 E7 09        	JSR	NEWLINE
000ACD  2  A9 FF            LDA     #$FF
000ACF  2  60           	RTS				; BAIL OUT
000AD0  2               :
000AD0  2  48 DA 5A A2      PRTS " PRESENT$" 		; NOT ZERO, H/W NOT PRESENT
000AD4  2  00 BD E9 0A  
000AD8  2  E8 C9 24 F0  
000AF2  2  20 E7 09         JSR	NEWLINE
000AF5  2  A9 0C        	LDA	#DOR_INIT	 		; RESET SETTINGS
000AF7  2  8D 36 03     	STA	FDC_DOR
000AFA  2               
000AFA  2  20 C5 0D     	JSR	CHECKINT		;
000AFD  2  A9 03        	LDA	#CFD_SPECIFY		; SPECIFY COMMAND
000AFF  2  20 81 0D     	JSR	PFDATA			; OUTPUT TO FDC
000B02  2  A9 7F        	LDA	#$7F			; 6 MS STEP, 480 MS HEAD UNLOAD
000B04  2  20 81 0D     	JSR	PFDATA			; OUTPUT TO FDC
000B07  2  A9 05        	LDA	#$05			; 508 MS HEAD LOAD, NON-DMA MODE
000B09  2  20 81 0D     	JSR	PFDATA			; OUTPUT TO FDC
000B0C  2               
000B0C  2  20 C5 0D     	JSR	CHECKINT		; SEND SEVERAL INTERRUPTS TO ENSURE PROPER STATE
000B0F  2  20 C5 0D     	JSR	CHECKINT		;
000B12  2  20 C5 0D     	JSR	CHECKINT		;
000B15  2  20 C5 0D     	JSR	CHECKINT		;
000B18  2  20 C5 0D     	JSR	CHECKINT		;
000B1B  2  20 C5 0D     	JSR	CHECKINT		;
000B1E  2               
000B1E  2  A9 00        	LDA #$00
000B20  2  8D 00 0F     	STA sekdsk
000B23  2  A9 10        	LDA #%00010000
000B25  2  8D 01 0F     	STA DSKUNIT
000B28  2  20 5A 0D     	JSR	RECAL			;
000B2B  2  A9 27        	LDA	#39			;
000B2D  2  8D 84 0E     	STA	debcyl			;
000B30  2  20 3D 0D     	JSR	SETTRK1
000B33  2  20 5A 0D     	JSR	RECAL			;
000B36  2               
000B36  2  A9 01        	LDA #$01
000B38  2  8D 00 0F     	STA sekdsk
000B3B  2  A9 21        	LDA #%00100001
000B3D  2  8D 01 0F     	STA DSKUNIT
000B40  2  20 5A 0D     	JSR	RECAL			;
000B43  2  A9 27        	LDA	#39			;
000B45  2  8D 84 0E     	STA	debcyl			;
000B48  2  20 3D 0D     	JSR	SETTRK1
000B4B  2  20 5A 0D     	JSR	RECAL			;
000B4E  2  A9 0C        	LDA	#DOR_INIT	 		; RESET SETTINGS
000B50  2  8D 36 03     	STA	FDC_DOR
000B53  2  60           	RTS
000B54  2               
000B54  2               
000B54  2               ;__FL_READ_SECTOR________________________________________________________________________________________________________________
000B54  2               ;
000B54  2               ; 	READ A FLOPPY SECTOR
000B54  2               ;________________________________________________________________________________________________________________________________
000B54  2               ;
000B54  2               ;
000B54  2               FL_READ_SECTOR:
000B54  2  AD 82 0E             LDA     HARDWARE_DETCT
000B57  2  C9 00                CMP     #$00
000B59  2  F0 01                BEQ     :+
000B5B  2  60                   RTS
000B5C  2               :
000B5C  2  8D 8D 0E             STA     FLRETRY                 ; BLANK RETRIES
000B5F  2  8D 8E 0E             STA     FLRETRY1
000B62  2  20 6B 0B             JSR     FL_READ_SECTOR_RAW
000B65  2  48                   PHA
000B66  2  20 B9 0E             JSR	DEBSECR512
000B69  2  68                   PLA
000B6A  2  60                   RTS
000B6B  2               
000B6B  2               FL_READ_SECTOR_RAW:
000B6B  2  A9 0C        	LDA #DOR_INIT
000B6D  2  0D 01 0F     	ORA  DSKUNIT			;
000B70  2  8D 36 03     	STA	FDC_DOR				; OUTPUT TO CONTROLLER
000B73  2  20 36 0C         JSR     SETUP_FD_CHS
000B76  2  AD 83 0E     	LDA	debhead			;
000B79  2  CD 86 0E     	CMP	Cdebhead		;
000B7C  2  D0 13        	BNE	READFL_DIRTY
000B7E  2  AD 84 0E     	LDA	debcyl			;
000B81  2  CD 87 0E     	CMP	Cdebcyl			;
000B84  2  D0 0B        	BNE	READFL_DIRTY
000B86  2  AD 85 0E     	LDA	debsec			;
000B89  2  CD 88 0E     	CMP	Cdebsec			;
000B8C  2  D0 03        	BNE	READFL_DIRTY
000B8E  2                                                       ; SECTOR ALREADY IN CACHE, DEBLOCK
000B8E  2  A9 00        	LDA	#$00
000B90  2  60           	RTS
000B91  2               READFL_DIRTY:
000B91  2  AD 83 0E     	LDA	debhead			; STORE CURRENT PARMS
000B94  2  8D 86 0E     	STA	Cdebhead		;
000B97  2  AD 84 0E     	LDA	debcyl			;
000B9A  2  8D 87 0E     	STA	Cdebcyl			;
000B9D  2  AD 85 0E     	LDA	debsec			;
000BA0  2  8D 88 0E     	STA	Cdebsec			;
000BA3  2               
000BA3  2               READFL1:
000BA3  2  A9 46        	LDA	#CFD_READ|CFD_MFM	; BIT 6 SETS MFM, 06H IS READ COMMAND
000BA5  2  8D 8B 0E     	STA	FCMD                    ; SET COMMAND
000BA8  2  20 4E 0C     	JSR	DSKOP                   ; DO DISK OPERATION
000BAB  2               
000BAB  2  C9 00        	CMP	#$00
000BAD  2  F0 2B        	BEQ	READFLDONE              ; OPERATION SUCCESSFUL
000BAF  2  EE 8D 0E     	INC	FLRETRY                 ; LET'S RETRY
000BB2  2  AD 8D 0E     	LDA	FLRETRY
000BB5  2  C9 06        	CMP	#FLOPPY_RETRIES
000BB7  2  D0 EA        	BNE	READFL1
000BB9  2  20 5A 0D     	JSR 	RECAL                   ; AFTER X RETRIES, LET'S RECAL THE HEAD
000BBC  2  20 2B 0D     	JSR	SETTRACK                ;
000BBF  2  A9 00        	LDA	#$00                    ;
000BC1  2  8D 8D 0E     	STA	FLRETRY                 ; MORE RETRIES!
000BC4  2  EE 8E 0E     	INC	FLRETRY1
000BC7  2  AD 8E 0E     	LDA	FLRETRY1
000BCA  2  C9 02        	CMP	#FLOPPY_RETRIES1
000BCC  2  D0 D5        	BNE	READFL1
000BCE  2               
000BCE  2  A9 FF        	LDA	#$FF                    ; RETRIES FAILED, INVALIDATE CACHE AND REPORT ERROR
000BD0  2  8D 86 0E     	STA	Cdebhead		;
000BD3  2  8D 87 0E     	STA	Cdebcyl			;
000BD6  2  8D 88 0E     	STA	Cdebsec			;
000BD9  2  60           	RTS				; A = $FF ON RETURN = OPERATION ERROR
000BDA  2               READFLDONE:
000BDA  2  A9 00        	LDA	#$00			; A = 0 ON RETURN = OPERATION OK
000BDC  2  60           	RTS
000BDD  2               
000BDD  2               ;__FL_WRITE_SECTOR_______________________________________________________________________________________________________________
000BDD  2               ;
000BDD  2               ; 	WRITE A FLOPPY SECTOR
000BDD  2               ;________________________________________________________________________________________________________________________________
000BDD  2               ;
000BDD  2               FL_WRITE_SECTOR:
000BDD  2  AD 82 0E         LDA     HARDWARE_DETCT
000BE0  2  C9 00            CMP     #$00
000BE2  2  F0 01            BEQ     :+
000BE4  2  60               RTS
000BE5  2               :
000BE5  2  20 6B 0B         JSR     FL_READ_SECTOR_RAW
000BE8  2  8D 8D 0E         STA     FLRETRY                 ; BLANK RETRIES
000BEB  2  8D 8E 0E         STA     FLRETRY1
000BEE  2  20 B9 0E         JSR	BLKSECR512
000BF1  2               
000BF1  2  A9 FF        	LDA	#$FF
000BF3  2  8D 86 0E     	STA	Cdebhead		; INVALIDATE CACHE
000BF6  2  8D 87 0E     	STA	Cdebcyl			;
000BF9  2  8D 88 0E     	STA	Cdebsec			;
000BFC  2               
000BFC  2               WRITEFL1:
000BFC  2  A9 45        	LDA	#CFD_WRITE|CFD_MFM	; BIT 6 SETS MFM, 05H IS WRITE COMMAND
000BFE  2  8D 8B 0E     	STA	FCMD
000C01  2  20 4E 0C     	JSR	DSKOP
000C04  2               
000C04  2  C9 00        	CMP	#$00
000C06  2  F0 2B        	BEQ	WRITEFLDONE
000C08  2  EE 8D 0E     	INC	FLRETRY
000C0B  2  AD 8D 0E     	LDA	FLRETRY
000C0E  2  C9 06        	CMP	#FLOPPY_RETRIES
000C10  2  D0 EA        	BNE	WRITEFL1
000C12  2  20 5A 0D     	JSR RECAL
000C15  2  20 2B 0D     	JSR	SETTRACK
000C18  2  A9 00        	LDA	#$00
000C1A  2  8D 8D 0E     	STA	FLRETRY
000C1D  2  EE 8E 0E     	INC	FLRETRY1
000C20  2  AD 8E 0E     	LDA	FLRETRY1
000C23  2  C9 02        	CMP	#FLOPPY_RETRIES1
000C25  2  D0 D5        	BNE	WRITEFL1
000C27  2  A9 FF        	LDA	#$FF			; INVALIDATE CACHE
000C29  2  8D 86 0E     	STA	Cdebhead		;
000C2C  2  8D 87 0E     	STA	Cdebcyl			;
000C2F  2  8D 88 0E     	STA	Cdebsec			;
000C32  2  60           	RTS				; A = $FF ON RETURN = OPERATION ERROR
000C33  2               WRITEFLDONE:
000C33  2  A9 00        	LDA	#$00			; A = 0 ON RETURN = OPERATION OK
000C35  2  60           	RTS
000C36  2               
000C36  2               
000C36  2               ;__SETUP_FD_CHS__________________________________________________________________________________________________________________
000C36  2               ;
000C36  2               ; 	TRANSFORM DOS65 CHS TO FLOPPY
000C36  2               ;________________________________________________________________________________________________________________________________
000C36  2               ;
000C36  2               SETUP_FD_CHS:
000C36  2  AD FC 0E     	LDA	sektrk			; LOAD TRACK # (LOW BYTE)
000C39  2  29 01        	AND	#$01			; FILTER OUT HEAD
000C3B  2  8D 83 0E     	STA	debhead			; STORE HEAD
000C3E  2  AD FC 0E     	LDA	sektrk			; SAVE TRACK IN A
000C41  2  4A           	LSR	A			; REMOVE HEAD BIT
000C42  2  8D 84 0E     	STA	debcyl			; STORE IN TRACK
000C45  2  AD FE 0E     	LDA	seksec			; LOAD SECTOR # (LOW BYTE)
000C48  2  4A           	LSR	A			;
000C49  2  4A           	LSR	A			; DIVIDE BY 4 (FOR BLOCKING)
000C4A  2  8D 85 0E     	STA	debsec			; STORE IN SECTOR
000C4D  2               
000C4D  2                 .IF USEDSKY=1 || USEDSKYNG=1
000C4D  2                 	PRTDBG "DSKY OUTPUT 1$"
000C4D  2                 	lda	sekdsk
000C4D  2                 	sta	DSKY_HEXBUF
000C4D  2                	lda	debcyl
000C4D  2                 	sta	DSKY_HEXBUF+1
000C4D  2                	lda	debhead
000C4D  2                 	sta	DSKY_HEXBUF+2
000C4D  2                  	lda	debsec
000C4D  2                 	sta	DSKY_HEXBUF+3
000C4D  2                 	JSR	DSKY_BIN2SEG
000C4D  2               	JSR	DSKY_SHOW
000C4D  2                 .ENDIF
000C4D  2               
000C4D  2  60                   RTS
000C4E  2               
000C4E  2               ;__DSKOP__________________________________________________________________________________________________________________________
000C4E  2               ;
000C4E  2               ; 	PERFORM A DISK OPERATION
000C4E  2               ;________________________________________________________________________________________________________________________________
000C4E  2               ;
000C4E  2               DSKOP:
000C4E  2  78           	SEI
000C4F  2  20 C5 0D     	JSR	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
000C52  2  C9 FF        	CMP	#$FF			; DID IT RETURN WITH ERROR CODE?
000C54  2  F0 10        	BEQ	DSKEXIT			; IF YES, EXIT WITH ERROR CODE
000C56  2               						;
000C56  2  20 2B 0D     	JSR	SETTRACK		; PERFORM SEEK TO TRACK
000C59  2               						;
000C59  2  AD 8B 0E     	LDA	FCMD			; WHAT COMMAND IS PENDING?
000C5C  2  C9 46        	CMP	#CFD_READ|CFD_MFM	; IS IT A READ COMMAND?
000C5E  2  D0 03        	BNE	GWRR_POLL		;
000C60  2  4C BB 0C     	JMP	RDD_POLL		;
000C63  2               GWRR_POLL:
000C63  2  4C 01 0D     	JMP	WRR_POLL		;
000C66  2               DSKEXIT:
000C66  2  A9 00        	LDA	#0				; SET MOTOR OFF
000C68  2  8D 36 03     	STA	FDC_DOR			; OUTPUT TO CONTROLLER
000C6B  2  A9 FF        	LDA	#$FF			; SET IF ERROR
000C6D  2  58           	CLI
000C6E  2  60           	RTS
000C6F  2               
000C6F  2               SNDFDWR:
000C6F  2  18           	CLC
000C70  2  AD 01 0F     	LDA	DSKUNIT			; GET DISK UNIT NUMBER
000C73  2  29 01        	AND	#$01			; MASK FOR TWO DRIVES.
000C75  2  8D 8A 0E     	STA	UNIT			; PARK IT IN TEMP
000C78  2  AD 83 0E     	LDA	debhead			; GET HEAD SELECTION
000C7B  2  29 01        	AND	#$01			; INSURE SINGLE BIT
000C7D  2  0A           	ASL	A				;
000C7E  2  0A           	ASL	A				; MOVE HEAD TO BIT 2 POSITION
000C7F  2  0D 8A 0E     	ORA	UNIT			; OR HEAD TO UNIT BYTE IN COMMAND BLOCK
000C82  2  8D 8A 0E     	STA	UNIT			; STORE IN UNIT
000C85  2  AD 8B 0E     	LDA	FCMD			;
000C88  2  20 81 0D     	JSR	PFDATA			; PUSH COMMAND TO I8272
000C8B  2  AD 8A 0E     	LDA	UNIT			;
000C8E  2  20 81 0D     	JSR	PFDATA			;
000C91  2  AD 84 0E     	LDA	debcyl			;
000C94  2  20 81 0D     	JSR	PFDATA			;
000C97  2  AD 83 0E     	LDA	debhead			;
000C9A  2  20 81 0D     	JSR	PFDATA			;
000C9D  2  18           	CLC					;
000C9E  2  AD 85 0E     	LDA	debsec			;
000CA1  2  69 01        	ADC	#$01			;
000CA3  2  20 81 0D     	JSR	PFDATA			;
000CA6  2  A9 02        	LDA	#$02			;
000CA8  2  20 81 0D     	JSR	PFDATA			; WHAT DENSITY
000CAB  2  A9 09        	LDA	#$09			;
000CAD  2  20 81 0D     	JSR	PFDATA			; ASSUME SC (SECTOR COUNT)  EOT
000CB0  2  A9 1B        	LDA	#$1B			;
000CB2  2  20 81 0D     	JSR	PFDATA			; WHAT GAP IS NEEDED
000CB5  2  A9 FF        	LDA	#$FF			; DTL, IS THE LAST COMMAND BYTE TO I8272
000CB7  2  20 AC 0D     	JSR	PFDATAS
000CBA  2  60           	RTS
000CBB  2               
000CBB  2               
000CBB  2               ; PERFORM READ
000CBB  2               ; FROM READ TO READ MUST NOT EXCEED 25US WORST CASE MIN. (AT 2MHZ IS 2,000,000 CYCLES PER SECOND == 50 CYCLE BUDGET.)
000CBB  2               ;
000CBB  2               RDD_POLL:
000CBB  2  A2 00            LDX #$00
000CBD  2  A0 00        	LDY #$00
000CBF  2  20 6F 0C     	JSR	SNDFDWR			;
000CC2  2               RDS1:
000CC2  2  AD 30 03     	LDA	FDC_MSR			; GET STATUS  (4 CYCLES)
000CC5  2  10 FB        	BPL	RDS1            ; FDC IS NOT READY, WAIT FOR IT (UP TO 4 CYCLES)
000CC7  2  29 20        	AND	#%00100000		; EXECUTION MODE? (2 CYCLES)
000CC9  2  F0 1D        	BEQ	DSKOPEND		; NO, ERROR
000CCB  2               RDS1A:
000CCB  2  AD 31 03     	LDA	FDC_DATA		; GET DATA (4 CYCLES)
000CCE  2  99 02 0F     	STA	hstbuf,Y		; WRITE IT (5 CYCLES)
000CD1  2  C8           	INY                 ; (2 CYCLES)
000CD2  2  D0 EE        	BNE	RDS1			; KEEP GOING (UP TO 4 CYCLES)   TOTAL =
000CD4  2  A2 00            LDX #$00
000CD6  2               RDS2:
000CD6  2  AD 30 03     	LDA	FDC_MSR			; GET STATUS
000CD9  2  10 FB        	BPL	RDS2            ; FDC IS NOT READY, WAIT FOR IT (UP TO 4 CYCLES)
000CDB  2  29 20        	AND	#%00100000		; EXECUTION MODE?
000CDD  2  F0 09        	BEQ	DSKOPEND		; NO, ERROR
000CDF  2               RDS2A:
000CDF  2  AD 31 03     	LDA	FDC_DATA		; GET DATA
000CE2  2  99 02 10     	STA	hstbuf+256,Y	; WRITE IT
000CE5  2  C8           	INY
000CE6  2  D0 EE        	BNE	RDS2			; KEEP GOING
000CE8  2               DSKOPEND:
000CE8  2  AD 37 03     	LDA	FDC_TC
000CEB  2  20 73 0E        	JSR FDDELAY
000CEE  2               						;
000CEE  2  20 0E 0E     	JSR	GFDATA			;GET ERROR TYPE
000CF1  2  8D 89 0E     	STA	FLERR
000CF4  2               ;* CLEAR OUT ANY REMAINING DATA
000CF4  2               RESUL3:
000CF4  2  20 0E 0E         JSR GFDATA			;READ BYTE FROM FDC
000CF7  2  C9 00            CMP #$00
000CF9  2  D0 F9            BNE RESUL3			;CLEAR THEM ALL
000CFB  2  AD 89 0E         LDA FLERR			;
000CFE  2  29 C0            AND	#%11000000		;
000D00  2  60               RTS
000D01  2               
000D01  2               
000D01  2               WRR_POLL:
000D01  2  20 6F 0C     	JSR	SNDFDWR			;
000D04  2               WRS1:					;
000D04  2  AD 30 03     	LDA	FDC_MSR			; GET STATUS
000D07  2  10 FB        	BPL	WRS1			; NOT READY
000D09  2  29 20        	AND	#%00100000		; EXECUTION MODE?
000D0B  2  F0 1B        	BEQ	WRS3			; NO, ERROR
000D0D  2  B9 02 0F     	LDA	hstbuf,Y		; WRITE IT
000D10  2  8D 31 03     	STA	FDC_DATA		; WRITE TO FDC
000D13  2  C8           	INY
000D14  2  D0 EE        	BNE	WRS1			; DO NEXT
000D16  2               WRS2:					;
000D16  2  AD 30 03     	LDA	FDC_MSR			; GET STATUS
000D19  2  10 FB        	BPL	WRS2			; NOT READY
000D1B  2  29 20        	AND	#%00100000		; EXECUTION MODE?
000D1D  2  F0 09        	BEQ	WRS3			; NO, ERROR
000D1F  2  B9 02 10     	LDA	hstbuf+256,Y		; WRITE IT
000D22  2  8D 31 03     	STA	FDC_DATA		; WRITE TO FDC
000D25  2  C8           	INY
000D26  2  D0 EE        	BNE	WRS2			; DO NEXT
000D28  2               WRS3:
000D28  2  4C E8 0C     	JMP	DSKOPEND		;
000D2B  2               
000D2B  2               
000D2B  2               ;__SETTRACK__________________________________________________________________________________________________________________________
000D2B  2               ;
000D2B  2               ; 	SEEK TO A TRACK ON GIVEN UNIT
000D2B  2               ; 	A: TRACK #
000D2B  2               ;________________________________________________________________________________________________________________________________
000D2B  2               ;
000D2B  2               SETTRACK:
000D2B  2  A9 0C        	LDA #DOR_INIT
000D2D  2  0D 01 0F     	ORA	DSKUNIT			; SET MOTOR ON
000D30  2  8D 36 03     	STA	FDC_DOR			; OUTPUT TO CONTROLLER
000D33  2               
000D33  2               					; ANY INTERUPT PENDING
000D33  2               					; IF YES FIND OUT WHY/CLEAR
000D33  2  20 C5 0D     	JSR	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
000D36  2  C9 FF        	CMP	#$FF			; DID IT RTSURN WITH ERROR CODE?
000D38  2  D0 03        	BNE	SETTRK1
000D3A  2  4C 80 0D     	JMP	SETTRKEXIT		;
000D3D  2               
000D3D  2               					;
000D3D  2               SETTRK1:
000D3D  2  AD 84 0E     	LDA	debcyl			; GET TRACK
000D40  2  C9 00        	CMP	#$00			;
000D42  2  F0 16        	BEQ	RECAL			; IF 0 PERFORM RECAL INSTEAD OF SEEK
000D44  2  A9 0F        	LDA	#CFD_SEEK		; SEEK COMMAND
000D46  2  20 81 0D     	JSR	PFDATA			; PUSH COMMAND
000D49  2  AD 01 0F     	LDA	DSKUNIT			; SAY WHICH UNIT
000D4C  2  29 01        	AND #$01
000D4E  2  20 81 0D     	JSR	PFDATA			; SEND THAT
000D51  2  AD 84 0E     	LDA	debcyl			; TO WHAT TRACK
000D54  2  20 81 0D     	JSR	PFDATA			; SEND THAT TOO
000D57  2  4C 6F 0D     	JMP	WAINT			; WAIT FOR INTERRUPT SAYING DONE
000D5A  2               RECAL:
000D5A  2  A9 0C        	LDA #DOR_INIT
000D5C  2  0D 01 0F     	ORA	DSKUNIT			; SET MOTOR ON
000D5F  2  8D 36 03         STA	FDC_DOR			; OUTPUT TO CONTROLLER
000D62  2  A9 07        	LDA	#CFD_RECAL		; RECAL TO TRACK 0
000D64  2  20 81 0D     	JSR	PFDATA			; SEND IT
000D67  2  AD 01 0F     	LDA	DSKUNIT			; SAY WHICH UNIT
000D6A  2  29 01        	AND #$01
000D6C  2  20 81 0D     	JSR	PFDATA			; SEND THAT TOO
000D6F  2               ;
000D6F  2               WAINT:
000D6F  2  DA               PHX
000D70  2  A2 64        	LDX	#100
000D72  2  20 78 0E         JSR     FDVDELAY
000D75  2  FA               PLX
000D76  2               :
000D76  2  20 C5 0D     	JSR	CHECKINT
000D79  2  AD 30 03     	LDA	FDC_MSR			; READ SEEK STATUS
000D7C  2  29 0F        	AND	#%00001111		; ANY DRIVES SEEKING?
000D7E  2  D0 F6        	BNE	:-			; YES, WAIT FOR THEM
000D80  2               ;
000D80  2               SETTRKEXIT:
000D80  2  60           	RTS
000D81  2               
000D81  2               ;__PFDATA__________________________________________________________________________________________________________________________
000D81  2               ;
000D81  2               ; WRITE A COMMAND OR PARAMETER SEQUENCE
000D81  2               ;
000D81  2               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
000D81  2               ;	RQM  DIO
000D81  2               ;	0	0	BUSY
000D81  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
000D81  2               ;	1	1	BYTE FOR READ BY HOST PENDING
000D81  2               ;	0	1	BUSY
000D81  2               ;
000D81  2               ;________________________________________________________________________________________________________________________________
000D81  2               ;
000D81  2               PFDATA:
000D81  2  48           	PHA				; SAVE DATA BYTE
000D82  2  A0 00                LDY     #$00
000D84  2               WRF1:
000D84  2  AD 30 03     	LDA	FDC_MSR			; READ FDC STATUS
000D87  2  AA           	TAX
000D88  2  29 80        	AND	#$80			;
000D8A  2  D0 07        	BNE     :+
000D8C  2  C8                   INY
000D8D  2  D0 F5                BNE     WRF1			; FDC IS NOT READY, WAIT FOR IT
000D8F  2  68                   PLA
000D90  2  A9 FF                LDA     #$FF
000D92  2  60                   RTS
000D93  2               :
000D93  2  8A           	TXA
000D94  2  29 40        	AND	#$40			; TEST DIO BIT
000D96  2  D0 0E        	BNE	WRF2			; FDC IS OUT OF SYNC
000D98  2  68           	PLA				; RESTORE DATA
000D99  2  8D 31 03     	STA	FDC_DATA		; WRITE TO FDC
000D9C  2  20 73 0E             JSR     FDDELAY
000D9F  2  20 73 0E             JSR     FDDELAY
000DA2  2  20 73 0E             JSR     FDDELAY
000DA5  2  60           	RTS
000DA6  2               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
000DA6  2               WRF2:
000DA6  2  AD 31 03     	LDA	FDC_DATA		; READ DATA REGISTER
000DA9  2  4C 84 0D     	JMP	WRF1			; AND CONTINUE
000DAC  2               
000DAC  2               ;__PFDATAS_________________________________________________________________________________________________________________________
000DAC  2               ;
000DAC  2               ; WRITE A COMMAND OR PARAMETER SEQUENCE (NO PAUSE)
000DAC  2               ;
000DAC  2               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
000DAC  2               ;	RQM  DIO
000DAC  2               ;	0	0	BUSY
000DAC  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
000DAC  2               ;	1	1	BYTE FOR READ BY HOST PENDING
000DAC  2               ;	0	1	BUSY
000DAC  2               ;
000DAC  2               ;________________________________________________________________________________________________________________________________
000DAC  2               ;
000DAC  2               PFDATAS:
000DAC  2  48           	PHA				; SAVE DATA BYTE
000DAD  2               WRF1S:
000DAD  2  AD 30 03     	LDA	FDC_MSR			; READ FDC STATUS
000DB0  2  AA           	TAX
000DB1  2  29 80        	AND	#$80			;
000DB3  2  F0 F8        	BEQ	WRF1S			; FDC IS NOT READY, WAIT FOR IT
000DB5  2  8A           	TXA
000DB6  2  29 40        	AND	#$40			; TEST DIO BIT
000DB8  2  D0 05        	BNE	WRF2S			; FDC IS OUT OF SYNC
000DBA  2  68           	PLA				; RESTORE DATA
000DBB  2  8D 31 03     	STA	FDC_DATA		; WRITE TO FDC
000DBE  2  60           	RTS
000DBF  2               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
000DBF  2               WRF2S:
000DBF  2  AD 31 03     	LDA	FDC_DATA		; READ DATA REGISTER
000DC2  2  4C AD 0D     	JMP	WRF1S			; AND CONTINUE
000DC5  2               
000DC5  2               
000DC5  2               
000DC5  2               ;__CHECKINT__________________________________________________________________________________________________________________________
000DC5  2               ;
000DC5  2               ; CHECK FOR ACTIVE FDC INTERRUPTS BEFORE GIVING I8272 COMMANDS
000DC5  2               ; POLL RQM FOR WHEN NOT BUSY AND THEN SEND FDC
000DC5  2               ; SENSE INTERRUPT COMMAND.  IF IT RTSURNS WITH NON ZERO
000DC5  2               ; ERROR CODE, PASS BACK TO JSRING ROUTINE FOR HANDLING
000DC5  2               ;________________________________________________________________________________________________________________________________
000DC5  2               ;
000DC5  2               CHECKINT:
000DC5  2  A0 00                LDY     #$00
000DC7  2               :
000DC7  2  AD 30 03     	LDA	FDC_MSR			; READING OR WRITING IS KEYS TO D7 RQM
000DCA  2  29 80        	AND	#$80
000DCC  2  D0 09        	BNE	:+      		; WAIT FOR RQM TO BE TRUE. WAIT UNTIL DONE
000DCE  2  20 73 0E             JSR     FDDELAY
000DD1  2  C8                   INY
000DD2  2  D0 F3                BNE     :-
000DD4  2  4C DF 0D             JMP     ERRCLR
000DD7  2               
000DD7  2               :
000DD7  2  AD 30 03     	LDA	FDC_MSR			; READING OR WRITING IS KEYS TO D7 RQM
000DDA  2  29 40        	AND	#$40			; WAITING FOR INPUT?
000DDC  2  F0 16        	BEQ	SENDINT
000DDE  2  60           	RTS
000DDF  2               
000DDF  2               ERRCLR:
000DDF  2  A0 00                LDY     #$00
000DE1  2               :
000DE1  2  AD 31 03     	LDA	FDC_DATA		; CLEAR THE JUNK OUT OF DATA REGISTER
000DE4  2  AD 30 03     	LDA	FDC_MSR			; CHECK WITH RQM
000DE7  2  29 80        	AND	#$80			; IF STILL NOT READY, READ OUT MORE JUNK
000DE9  2  D0 06        	BNE	:+			;
000DEB  2  20 73 0E             JSR     FDDELAY
000DEE  2  C8                   INY
000DEF  2  D0 F0                BNE     :-
000DF1  2               :
000DF1  2  A9 FF        	LDA	#$FF			; RETURN ERROR CODE -1
000DF3  2               					;
000DF3  2  60           	RTS
000DF4  2               
000DF4  2               ;__SENDINT__________________________________________________________________________________________________________________________
000DF4  2               ;
000DF4  2               ; SENSE INTERRUPT COMMAND
000DF4  2               ;________________________________________________________________________________________________________________________________
000DF4  2               ;
000DF4  2               SENDINT:
000DF4  2  A9 08        	LDA	#CFD_SENSEINT		; SENSE INTERRUPT COMMAND
000DF6  2  20 81 0D     	JSR	PFDATA			; SEND IT
000DF9  2  20 0E 0E     	JSR	GFDATA			; GET RESULTS
000DFC  2  8D 8C 0E     	STA	ST0			; STORE THAT
000DFF  2  29 C0        	AND	#$C0			; MASK OFF INTERRUPT STATUS BITS
000E01  2  C9 80        	CMP	#$80			; CHECK IF INVALID COMMAND
000E03  2  F0 08        	BEQ	ENDSENDINT		; YES, EXIT
000E05  2  20 0E 0E     	JSR	GFDATA			; GET ANOTHER (STATUS CODE 1)
000E08  2  AD 8C 0E     	LDA	ST0			; GET FIRST ONE
000E0B  2  29 C0        	AND	#$C0			; MASK OFF ALL BUT INTERRUPT CODE 00 IS NORMAL
000E0D  2               ENDSENDINT:
000E0D  2  60           	RTS				; ANYTHING ELSE IS AN ERROR
000E0E  2               
000E0E  2               
000E0E  2               ;__GFDATA__________________________________________________________________________________________________________________________
000E0E  2               ;
000E0E  2               ; GET DATA FROM FLOPPY CONTROLLER
000E0E  2               ;
000E0E  2               ; TRANSFERS ARE SYNCHONIZED BYT MSR D7 <RQM> AND D6 <DIO>
000E0E  2               ;	RQM  DIO
000E0E  2               ;	0	0	BUSY
000E0E  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
000E0E  2               ;	1	1	BYTE FOR READ BY HOST PENDING
000E0E  2               ;	0	1	BUSY
000E0E  2               ;
000E0E  2               ;________________________________________________________________________________________________________________________________
000E0E  2               ;
000E0E  2               GFDATA:
000E0E  2  A0 00                LDY     #$00
000E10  2               :
000E10  2  AD 30 03     	LDA	FDC_MSR			; GET STATUS
000E13  2  AA           	TAX				;
000E14  2  29 80        	AND	#%10000000		; NOT READY, WAIT
000E16  2  D0 06        	BNE	:+			;
000E18  2  C8                   INY
000E19  2  D0 F5                BNE     :-
000E1B  2  A9 00                LDA     #$00
000E1D  2  60                   RTS
000E1E  2               :
000E1E  2  8A           	TXA
000E1F  2  29 40        	AND	#%01000000		; ANY DATA FOR US?
000E21  2  F0 03        	BEQ	GFDATA1			; NO, SKIP IT
000E23  2  AD 31 03     	LDA	FDC_DATA		; GET FDC DATA
000E26  2               GFDATA1:
000E26  2  60           	RTS
000E27  2               
000E27  2               ;__FD_DETECT______________________________________________________________________________________________________________________
000E27  2               ;
000E27  2               ; 	DETECT FLOPPY HARDWARE
000E27  2               ;________________________________________________________________________________________________________________________________
000E27  2               FD_DETECT:
000E27  2               	; BLINDLY RESET FDC (WHICH MAY OR MAY NOT EXIST)
000E27  2  20 55 0E     	JSR	FC_RESETFDC	; RESET FDC
000E2A  2               
000E2A  2  AD 30 03     	LDA 	FDC_MSR	        ; READ MSR
000E2D  2  C9 80        	CMP	#$80
000E2F  2  F0 0A        	BEQ 	FD_DETECT1	; $80 IS OK
000E31  2  C9 D0        	CMP	#$D0
000E33  2  F0 06        	BEQ	FD_DETECT1	; $D0 IS OK
000E35  2  A9 FF                LDA     #$FF            ; NOT OK
000E37  2  8D 82 0E             STA     HARDWARE_DETCT
000E3A  2  60                   RTS
000E3B  2               ;
000E3B  2               FD_DETECT1:
000E3B  2  A2 64        	LDX     #100
000E3D  2  20 78 0E             JSR     FDVDELAY	; WAIT A BIT FOR FDC
000E40  2  AD 30 03     	LDA	FDC_MSR 	; READ MSR AGAIN
000E43  2  C9 80        	CMP	#$80
000E45  2  F0 08        	BEQ 	:+      	; $80 IS OK
000E47  2  C9 D0        	CMP	#$D0
000E49  2  A9 FF                LDA     #$FF            ; NOT OK
000E4B  2  8D 82 0E             STA     HARDWARE_DETCT
000E4E  2  60                   RTS
000E4F  2               :
000E4F  2  A9 00                LDA     #$00            ; OK
000E51  2  8D 82 0E             STA     HARDWARE_DETCT
000E54  2  60                   RTS
000E55  2               
000E55  2               FC_RESETFDC:
000E55  2  AD 33 03             LDA     FDC_RESET
000E58  2  AD 33 03             LDA     FDC_RESET
000E5B  2  A2 96        	LDX     #150
000E5D  2  20 78 0E             JSR     FDVDELAY	; WAIT A BIT FOR FDC
000E60  2               
000E60  2  A9 00        	LDA     #$00
000E62  2  8D 36 03         STA     FDC_DOR
000E65  2  20 73 0E     	JSR		FDDELAY
000E68  2  A9 0C        	LDA     #DOR_INIT
000E6A  2  8D 36 03         STA     FDC_DOR
000E6D  2  A2 96        	LDX	#150			;
000E6F  2  20 78 0E     	JSR	FDVDELAY
000E72  2  60           	RTS
000E73  2               
000E73  2               
000E73  2               FDDELAY:
000E73  2  48                   PHA
000E74  2  68                   PLA
000E75  2  48                   PHA
000E76  2  68                   PLA
000E77  2  60                   RTS
000E78  2               FDVDELAY:
000E78  2  48                   PHA
000E79  2  68                   PLA
000E7A  2  48                   PHA
000E7B  2  68                   PLA
000E7C  2  CA                   DEX
000E7D  2  E0 00                CPX     #$00
000E7F  2  D0 F7                BNE     FDVDELAY
000E81  2  60                   RTS
000E82  2               
000E82  2               
000E82  2               
000E82  2  00           HARDWARE_DETCT: .byte 0		; HARDWARE DETECTED
000E83  2  00           debhead:        .byte 0		; DEBLOCKED HEAD
000E84  2  00           debcyl:	        .byte 0		; DEBLOCKED CYLINDER
000E85  2  00           debsec:	        .byte 0		; DEBLOCKED SECTOR
000E86  2  00           Cdebhead:		.byte 0		; DEBLOCKED HEAD (cache)
000E87  2  00           Cdebcyl:		.byte 0		; DEBLOCKED CYLINDER (cache)
000E88  2  00           Cdebsec:		.byte 0		; DEBLOCKED SECTOR (cache)
000E89  2  00           FLERR:	        .BYTE	$00	;
000E8A  2  00           UNIT:	        .BYTE	$00	;
000E8B  2  00           FCMD:	        .BYTE	0	; COMMAND READ OR WRITE,
000E8C  2  00           ST0:	        .BYTE	0	; COMMAND READ OR WRITE,
000E8D  2  00           FLRETRY:        .BYTE	00
000E8E  2  00           FLRETRY1:       .BYTE	00
000E8F  2               
000E8F  1               
000E8F  1               
000E8F  1               
000E8F  1               ;
000E8F  1               ;==================================================================================================
000E8F  1               ; UTILITY FUNCTIONS
000E8F  1               ;==================================================================================================
000E8F  1               ;
000E8F  1               ;
000E8F  1               CHR_CR	=		$0D
000E8F  1               CHR_LF	=		$0A
000E8F  1               CHR_BS	=		$08
000E8F  1               CHR_ESC	=		$1B
000E8F  1               ;
000E8F  1               ;__________________________________________________________________________________________________
000E8F  1               ;
000E8F  1               ; UTILITY PROCS TO PRINT SINGLE CHARACTERS WITHOUT TRASHING ANY REGISTERS
000E8F  1               ;
000E8F  1               
000E8F  1               PC_SPACE:
000E8F  1  48           		PHA
000E90  1  A9 20        		LDA #' '
000E92  1  20 AF 0E     		JSR OUT	  		; PRINT CHAR IN ACC
000E95  1  68           		PLA
000E96  1  60           		RTS
000E97  1               
000E97  1               PC_PERIOD:
000E97  1  48           		PHA
000E98  1  A9 2E        		LDA #'.'
000E9A  1  20 AF 0E     		JSR OUT	  		; PRINT CHAR IN ACC
000E9D  1  68           		PLA
000E9E  1  60           		RTS
000E9F  1               
000E9F  1               
000E9F  1               PC_CR:
000E9F  1  48           		PHA
000EA0  1  A9 0D        		LDA #CHR_CR
000EA2  1  20 AF 0E     		JSR OUT	  		; PRINT CHAR IN ACC
000EA5  1  68           		PLA
000EA6  1  60           		RTS
000EA7  1               
000EA7  1               PC_LF:
000EA7  1  48           		PHA
000EA8  1  A9 0A        		LDA	#CHR_LF
000EAA  1  20 AF 0E     		JSR OUT	  		; PRINT CHAR IN ACC
000EAD  1  68           		PLA
000EAE  1  60           		RTS
000EAF  1               
000EAF  1               OUT:
000EAF  1               conwrt:
000EAF  1  DA           	PHX
000EB0  1  5A           	PHY
000EB1  1  A2 02        	LDX	#2			;
000EB3  1  20 03 01     	JSR	PEM			;
000EB6  1  7A           	PLY
000EB7  1  FA           	PLX
000EB8  1  60           	rts
000EB9  1               
000EB9  1               BLKSECR512:
000EB9  1               DEBSECR512:
000EB9  1  60           		rts
000EBA  1               
000EBA  1               ;__PRINT_BYTE__________________________________________________
000EBA  1               ;
000EBA  1               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
000EBA  1               ;
000EBA  1               ;______________________________________________________________
000EBA  1               PRINT_BYTE:
000EBA  1  AA                          TAX					; SAVE A REGISTER
000EBB  1  4A                          LSR A				; SHIFT HIGH NIBBLE TO LOW NIBBLE
000EBC  1  4A                          LSR A				;
000EBD  1  4A                          LSR A				;
000EBE  1  4A                          LSR A				;
000EBF  1  18                          CLC               	; CLEAR CARRY
000EC0  1  20 D9 09                    JSR PRINT_DIGIT		; PRINT LOW NIBBLE
000EC3  1  8A                          TXA					; RESTORE ACCUMULATOR
000EC4  1  4C D9 09                    JMP PRINT_DIGIT		; PRINT LOW NIBBLE
000EC7  1               
000EC7  1               
000EC7  1               ;
000EC7  1               ; OUTPUT A '$' TERMINATED STRING
000EC7  1               ;
000EC7  1               WRITESTR:
000EC7  1  85 F0        		STA OUTMSG_W
000EC9  1  84 F1        		STY OUTMSG_W+1
000ECB  1  A0 00        		LDY #$00
000ECD  1               WRITESTR1:
000ECD  1  B1 F0               	LDA (OUTMSG_W),Y 	; LOAD NEXT CHAR FROM STRING INTO ACC
000ECF  1  C9 24               	CMP #'$'			; IS END?
000ED1  1  F0 07               	BEQ ENDOUTSTR		; YES, END PRINT OUT
000ED3  1  20 AF 0E            	JSR OUT	  		; PRINT CHAR IN ACC
000ED6  1  C8                  	INY 	     		; Y=Y+1 (BUMP INDEX)
000ED7  1  4C CD 0E            	JMP WRITESTR1		; DO NEXT CHAR
000EDA  1               ENDOUTSTR:
000EDA  1  60                  	RTS					; RETURN
000EDB  1               
000EDB  1               
000EDB  1               
000EDB  1               
000EDB  1               
000EDB  1               CIN:
000EDB  1  DA           	PHX
000EDC  1  5A           	PHY
000EDD  1  A2 01        	LDX	#1			;
000EDF  1  20 03 01     	JSR	PEM			;
000EE2  1  7A           	PLY
000EE3  1  FA           	PLX
000EE4  1  60           	rts
000EE5  1               
000EE5  1               
000EE5  1               CONF:
000EE5  1  20 DB 0E     	JSR	CIN
000EE8  1  C9 1B        	CMP	#$1B
000EEA  1  F0 05        	BEQ 	EXIT
000EEC  1  C9 0D        	CMP	#$0D
000EEE  1  D0 F5        	BNE 	CONF
000EF0  1               
000EF0  1  60           	RTS
000EF1  1               
000EF1  1               EXIT:
000EF1  1               ; CLEAN UP AND RETURN TO OS
000EF1  1  20 E7 09     	JSR	NEWLINE
000EF4  1  20 E7 09     	JSR	NEWLINE
000EF7  1  4C 00 01     	JMP $0100
000EFA  1               
000EFA  1               
000EFA  1  00           FMTGAP:		.BYTE 0			; GAP FOR FORMAT 5.25=$50, 3.5=$54
000EFB  1  00           CURSEC:		.BYTE 0
000EFC  1               
000EFC  1  00 00        sektrk:		.byte 0,0		;seek track number
000EFE  1  00 00        seksec:		.byte 0,0		;seek sector number
000F00  1  00           sekdsk:		.byte 0
000F01  1  00           DSKUNIT:	.byte 0
000F02  1  xx xx xx xx  hstbuf:		.res 1024
000F06  1  xx xx xx xx  
000F0A  1  xx xx xx xx  
001302  1  00           temp:		.byte 0
001303  1  28           MAXTRACK:	.byte 40
001304  1               
001304  1               STR_BANNER:
001304  1  0D 0A 4E 68  		.byte	$0D,$0A,"Nhyodyne Floppy Disk Format v1.0"
001308  1  79 6F 64 79  
00130C  1  6E 65 20 46  
001326  1  0D 0A 43 68  		.byte	$0D,$0A,"Choose Floppy type:",$0D,$0A
00132A  1  6F 6F 73 65  
00132E  1  20 46 6C 6F  
00133D  1  31 3E 20 35  		.byte	"1> 5.25 inch floppy  360K 40 tracks",$0D,$0A
001341  1  2E 32 35 20  
001345  1  69 6E 63 68  
001362  1  32 3E 20 33  		.byte	"2> 3.5 inch floppy   720K 80 tracks",$0D,$0A,"$"
001366  1  2E 35 20 69  
00136A  1  6E 63 68 20  
001388  1               STR_DRIVE:
001388  1  0D 0A 43 68  		.byte	$0D,$0A,"Choose Floppy drive:",$0D,$0A
00138C  1  6F 6F 73 65  
001390  1  20 46 6C 6F  
0013A0  1  31 3E 20 44  		.byte	"1> DRIVE 0",$0D,$0A
0013A4  1  52 49 56 45  
0013A8  1  20 30 0D 0A  
0013AC  1  32 3E 20 44  		.byte	"2> DRIVE 1",$0D,$0A,"$"
0013B0  1  52 49 56 45  
0013B4  1  20 31 0D 0A  
0013B9  1               STR_INTRO:
0013B9  1  0D 0A 0D 0A  		.byte	$0D,$0A,$0D,$0A,"Insert FLOPPY, NOTE EXISTING DATA WILL BE DESTROYED!!!",$0D,$0A,"$"
0013BD  1  49 6E 73 65  
0013C1  1  72 74 20 46  
0013F6  1               STR_CONFIRM:
0013F6  1  50 72 65 73  		.byte	"Press <Enter> to continue, <Esc> to abort",$0D,$0A,"$"
0013FA  1  73 20 3C 45  
0013FE  1  6E 74 65 72  
001422  1               
001422  1               
001422  1               
001422  1               
001422  1               
001422  1  0D 0A 44 49  STR_ERR1:	.byte	$0D,$0A,"DISK ERROR 1",$0D,$0A,"$"
001426  1  53 4B 20 45  
00142A  1  52 52 4F 52  
001433  1  0D 0A 44 49  STR_ERR2:	.byte	$0D,$0A,"DISK ERROR 2",$0D,$0A,"$"
001437  1  53 4B 20 45  
00143B  1  52 52 4F 52  
001444  1  0D 0A 44 49  STR_ERR3:	.byte	$0D,$0A,"DISK ERROR 3",$0D,$0A,"$"
001448  1  53 4B 20 45  
00144C  1  52 52 4F 52  
001455  1  0D 0A 44 49  STR_ERR4:	.byte	$0D,$0A,"DISK ERROR 4",$0D,$0A,"$"
001459  1  53 4B 20 45  
00145D  1  52 52 4F 52  
001466  1  0D 0A 44 49  STR_ERR5:	.byte	$0D,$0A,"DISK ERROR 5",$0D,$0A,"$"
00146A  1  53 4B 20 45  
00146E  1  52 52 4F 52  
001477  1               
001477  1                .END
