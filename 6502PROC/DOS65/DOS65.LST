ca65 V2.18 - Ubuntu 2.19-1
Main file   : DOS65.ASM
Current file: DOS65.ASM

000000r 1               ;sysgen
000000r 1               ;version 2.15-a
000000r 1               ;released:	30 november 1985 (2.10)
000000r 1               ;last revised:	2 may 1996 (2.11)
000000r 1               ;			eliminated word mode for 1024 blocks
000000r 1               ;			made extent a single byte
000000r 1               ;		3 may 1996 (2.12)
000000r 1               ;			added initial exm related code
000000r 1               ;		11 may 1996 (2.13)
000000r 1               ;			added use of exm in getblk
000000r 1               ;			added code to set exm & cexm1f
000000r 1               ;			corrected errors
000000r 1               ;		19 may 1996 (2.14)
000000r 1               ;			changed ccm ren to "to from" syntax
000000r 1               ;			allowed _ in file names
000000r 1               ;		13 march 2008 (2.15)
000000r 1               ;			reformatted for TASM & ASM210+
000000r 1               ;			eliminated dependence on "IBM" format
000000r 1               ;			  by reading first sector # using SIM+51
000000r 1               ;			  TRANSLATE code. If translate
000000r 1               ;			  does not have first physical sector in first
000000r 1               ;			  position this approach may not work.
000000r 1               ;			  SIM can also perform no translation at all.
000000r 1               ;			  Also assumes BOOT & SIM both know correct
000000r 1               ;			  starting sector for cold & warm boot. It
000000r 1               ;			  should work regardless of physical sector
000000r 1               ;			  size as long as existing SIM is configured
000000r 1               ;			  correctly for destination drive. BOOT
000000r 1               ;			  must correctly handle sectors > 128 bytes
000000r 1               ;			  as must WARM BOOT in SIM.
000000r 1               ;			  In any case BOOT and WARM BOOT must
000000r 1               ;			  read sectors in sequential order, i.e.,
000000r 1               ;			  no interleave.
000000r 1               ;this program contains the complete dos/65 operating
000000r 1               ;system except for the boot and sim.
000000r 1               ;when used by the system operator this program
000000r 1               ;provides the capability to construct a new
000000r 1               ;operating system including the users boot and sim.
000000r 1               ;the system is relocated to fit the memory size
000000r 1               ;specified by the user and is written onto
000000r 1               ;the system tracks of the specified drive.
000000r 1               ;improvements over version 2.0 include:
000000r 1               ;	use of "from to" syntax for ren
000000r 1               ;	addition of go command
000000r 1               ;	addition of load command
000000r 1               ;	ability to enter numbers as decimal or hex
000000r 1               ;	address parameter added to save
000000r 1               ;	error checking in sysgen (write)
000000r 1               ;	write type for deblocking added
000000r 1               ;	page zero 0 & 1 not used
000000r 1               ;	allow _ in file names
000000r 1               ;base addresses and definitions
000000r 1               btejmp	=	$100		;warm boot jump
000000r 1               pemjmp	=	$103		;jump to pem
000000r 1               iostat	=	$106		;i/o status
000000r 1               dflfcb	=	$107		;default fcb
000000r 1               dflbuf	=	$128		;default buffer
000000r 1               tea	=	$800		;tea start
000000r 1               ccmlng	=	2048		;ccm length
000000r 1               pemlng	=	3072		;pem length
000000r 1               ;zero page for setup
000000r 1               trknum	=	$02			;current track
000000r 1               dcbadd	=	$04			;dcb address
000000r 1               nmsstr	=	$06			;number system tracks
000000r 1               nsectr	=	$08			;number sectors per track
000000r 1               ttlsec	=	$0A			;total sectors to write
000000r 1               trkcnt	=	ttlsec
000000r 1               size	=	$0B			;ascii size
000000r 1               lokim	=	$0D			;low kim limit
000000r 1               hikim	=	$0F			;high kim limit
000000r 1               offset	=	$11			;relocation offset
000000r 1               kimcnt	=	$13			;kim counter
000000r 1               pointr	=	$14			;pointer
000000r 1               lengt	=	$16			;inst length
000000r 1               point	=	$17			;relocate pointer
000000r 1               adjust	=	$19			;relocate distance
000000r 1               kimpnt	=	$1B			;kim file index
000000r 1               savex	=	$1C			;save for x
000000r 1               savey	=	$1D			;save for y
000000r 1               number	=	$1E			;input pack buffer
000000r 1               dstdrv	=	$20			;destination drive
000000r 1               defalt	=	$21			;default drive
000000r 1               seccnt	=	$22			;sector count
000000r 1               secnum	=	$24			;sector number
000000r 1               curccm	=	$26			;start of current ccm
000000r 1               simlng	=	$28			;length of sim
000000r 1               room	=	$2A			;memory needed for sysgen
000000r 1               stksav	=	$2C			;save stack register
000000r 1               frstsc	=	$2D			;first sector number of disk
000000r 1               dskcfpc	=	$2E			;pointer to disk configuration table
000000r 1               lastzp	=	$30
000000r 1               ;fixed parameters
000000r 1               lf	=	$a		;linefeeed
000000r 1               cr	=	$d		;return
000000r 1               eof	=	$1a		;end of file
000000r 1               null	=	0		;null
000000r 1               ctlc	=	3		;abort
000000r 1               ctle	=	5		;physical cr lf
000000r 1               ctli	=	9		;tab character
000000r 1               ctlp	=	$10		;toggle printer
000000r 1               ctlr	=	$12		;repeat line
000000r 1               ctls	=	$13		;freeze
000000r 1               ctlx	=	$18		;cancel
000000r 1               semico	=	$3b		;semicolon
000000r 1               delete	=	$08		;delete character
000000r 1               numcmd	=	36		;number commands
000000r 1               
000000r 1               DEBUG	=	0		; assemble with debug information on
000000r 1               
000000r 1               
000000r 1                		.segment "LOADER"
000000r 1               		.ORG $b7E0
00B7E0  1  F3           		.BYTE 		$F3 			;DI - DISABLE INTERRUPTS
00B7E1  1  01 00 48     		.BYTE 		$01,$00,$48    		;LD	BC,$3E00 -BYTES TO MOVE
00B7E4  1  11 00 38     		.BYTE 		$11,$00,$38    		;LD	DE,$3800 -DESTINATION ADDRESS (6502 IS !A15)
00B7E7  1  21 20 01     		.BYTE 		$21,$20,$01	    	;LD	HL,$0120 -SOURCE ADDRESS
00B7EA  1  ED B0        		.BYTE 		$ED,$B0       		;LDIR  	-COPY RAM
00B7EC  1  21 FC 7F     		.BYTE 		$21,$FC,$7F	    	;LD	HL,$7FFC -VECTOR
00B7EF  1  3E 6D        		.BYTE		$3E,<boot		;LD 	A,<BOOT
00B7F1  1  77           		.BYTE 		$77			;LD 	(HL),A
00B7F2  1  21 FD 7F     		.BYTE 		$21,$FD,$7F	    	;LD	HL,$7FFD -VECTOR
00B7F5  1  3E CD        		.BYTE		$3E,>boot		;LD 	A,<BOOT
00B7F7  1  77           		.BYTE 		$77			;LD 	(HL),A
00B7F8  1  DB FF        		.BYTE		$DB,$FF       		;IN 	A,$FF    -ENABLE 6502
00B7FA  1               ;
00B7FA  1               ;
00B7FA  1               		.PC02
00B7FA  1                               .segment "OS"
00B7FA  1               		.ORG $B800
00B800  1               		.include "CCM215.ASM"
00B800  2               
00B800  2               ;-------------------------------
00B800  2               ;dos/65 console command module
00B800  2               ;-------------------------------
00B800  2               ;ccm unique definitions
00B800  2               nbuilt	=	7		;number built in commands
00B800  2               ;main program
00B800  2  D8           ccm:	cld			;set binary mode
00B801  2  48           	pha			;save drive number
00B802  2  20 F7 BB     	jsr	rstdsk		;initialize system
00B805  2  68           	pla			;restore drive num
00B806  2  20 FB BB     	jsr	slctds		;select drive
00B809  2  AD 81 CC     	lda	sysdef+6	;get line length
00B80C  2  4A           	lsr	a		;divide
00B80D  2  4A           	lsr	a		;by
00B80E  2  4A           	lsr	a		;16
00B80F  2  4A           	lsr	a		;for dir
00B810  2  8D F2 BF     	sta	sixten		;and save
00B813  2  AD 3E BF     	lda	cnslng		;get buffer length
00B816  2  D0 3C        	bne	mrecmd		;if more handle it
00B818  2  A2 FF        ccmlpe:	ldx	#$ff		;set
00B81A  2  9A           	txs			;stack
00B81B  2  D8           	cld			;set binary mode
00B81C  2  A9 11        	lda	#17		; SEND A XON
00B81E  2  20 EB BB     	jsr	chrout		; ----------
00B821  2  20 64 BC     	jsr	hdrout		;send header
00B824  2  A9 3E        	lda	#'>'		;then print
00B826  2  20 EB BB     	jsr	chrout		;prompt
00B829  2  AD 86 BE     	lda	cnsbvc		;point to start
00B82C  2  AC 87 BE     	ldy	cnsbvc+1	;of buffer
00B82F  2  20 EF BB     	jsr	rdebuf		;do buffer read
00B832  2  A0 00        	ldy	#0		;clear index
00B834  2  AE 3E BF     	ldx	cnslng		;get length
00B837  2  F0 DF        	beq	ccmlpe		;loop if empty
00B839  2  B9 3F BF     lwrupr:	lda	cnstxt,y	;else get char
00B83C  2  C9 61        	cmp	#'a'		;if less than a
00B83E  2  90 09        	bcc	nxtchg		;skip convert
00B840  2  C9 7B        	cmp	#'z'+1		;if over z
00B842  2  B0 05        	bcs	nxtchg		;skip convert
00B844  2  29 5F        	and	#%01011111	;else convert
00B846  2  99 3F BF     	sta	cnstxt,y	;put back in buffer
00B849  2  C8           nxtchg:	iny			;bump index
00B84A  2  CA           	dex			;count down
00B84B  2  D0 EC        	bne	lwrupr		;loop if more
00B84D  2  8A           	txa			;set a to zero
00B84E  2  99 3F BF     	sta	cnstxt,y	;insert stopper
00B851  2  8D E2 BF     	sta	cnbfpt		;initialize pointer
00B854  2  20 9F BD     mrecmd:	jsr	stdflb		;set default buffer
00B857  2  20 26 BC     	jsr	intdsk		;get drive number
00B85A  2  8D E3 BF     	sta	dfldsk		;store as default
00B85D  2  20 A0 BC     	jsr	prslin		;parse command
00B860  2  D0 64        	bne	cmderr		;error if afn
00B862  2  AD E4 BF     	lda	tmpdsk		;get temporary
00B865  2  F0 04        	beq	nodrch		;if zero ok
00B867  2  A9 15        	lda	#nbuilt*3	;else set and
00B869  2  D0 2E        	bne	dotrns		;do transient
00B86B  2  A9 00        nodrch:	lda	#0		;clear
00B86D  2  AA           	tax			;table index
00B86E  2  8D E8 BF     	sta	ccmcount		;and count
00B871  2  A0 01        tsnxfn:	ldy	#1		;set fcb index
00B873  2  BD 18 BF     tsnxch:	lda	fnctbl,x	;get table entry
00B876  2  F0 1A        	beq	gotcmd		;if zero got it
00B878  2  D9 BE BF     	cmp	fcbone,y	;else test
00B87B  2  D0 04        	bne	nocmpr		;no good if not =
00B87D  2  E8           	inx			;bump
00B87E  2  C8           	iny			;pointers
00B87F  2  D0 F2        	bne	tsnxch		;and loop
00B881  2  E8           nocmpr:	inx			;go to end
00B882  2  BD 18 BF     	lda	fnctbl,x	;of table
00B885  2  D0 FA        	bne	nocmpr		;entry
00B887  2  E8           	inx			;point to next
00B888  2  EE E8 BF     	inc	ccmcount		;bump count
00B88B  2  AD E8 BF     	lda	ccmcount		;and if not
00B88E  2  C9 07        	cmp	#nbuilt		;limit then
00B890  2  D0 DF        	bne	tsnxfn		;try next
00B892  2  AD E8 BF     gotcmd:	lda	ccmcount		;get count
00B895  2  0A           	asl	a		;multiply by two
00B896  2  6D E8 BF     	adc	ccmcount		;then add for x3
00B899  2  AA           dotrns:	tax			;use as index
00B89A  2  E8           	inx			;bump to pass jmp
00B89B  2  BD 91 BE     	lda	xqfntb,x	;to get
00B89E  2  BC 92 BE     	ldy	xqfntb+1,x	;entry address
00B8A1  2  8D E6 BF     	sta	vector		;then set
00B8A4  2  8C E7 BF     	sty	vector+1	;vector
00B8A7  2  AD 8A BE     	lda	extcvc+1	;save
00B8AA  2  48           	pha			;return
00B8AB  2  AD 89 BE     	lda	extcvc		;address
00B8AE  2  48           	pha			;on stack
00B8AF  2  6C E6 BF     	jmp	(vector)	;execute
00B8B2  2  20 2F BC     extcmd:	jsr	rstddr		;restore default
00B8B5  2  20 A0 BC     extwod:	jsr	prslin		;parse more
00B8B8  2  AD BF BF     	lda	fcbone+1	;if first
00B8BB  2  38           	sec			;character
00B8BC  2  E9 20        	sbc	#' '		;not a space
00B8BE  2  0D E4 BF     	ora	tmpdsk		;or if temporary
00B8C1  2  D0 03        	bne	cmderr		;then an error
00B8C3  2  4C 18 B8     	jmp	ccmlpe		;else loop
00B8C6  2               ;command error syntax handler
00B8C6  2  20 DC BB     cmderr:	jsr	ccrlf		;do a cr lf
00B8C9  2  AC E9 BF     	ldy	curpnt		;get command pointer
00B8CC  2  B9 3F BF     cmerlp:	lda	cnstxt,y	;get char
00B8CF  2  F0 0A        	beq	cmerex		;if null then done
00B8D1  2  C9 20        	cmp	#' '		;if space
00B8D3  2  F0 06        	beq	cmerex		;then done
00B8D5  2  20 6D BC     	jsr	cotsxy		;output with save
00B8D8  2  C8           	iny			;point to next
00B8D9  2  D0 F1        	bne	cmerlp		;and loop
00B8DB  2  A9 3F        cmerex:	lda	#'?'		;send a
00B8DD  2  20 EB BB     	jsr	chrout		;question mark
00B8E0  2  4C 18 B8     	jmp	ccmlpe		;and start over
00B8E3  2               ;execute dir command
00B8E3  2               ; dir <afn>
00B8E3  2  20 A0 BC     dir:	jsr	prslin		;find object file
00B8E6  2  20 A6 BD     	jsr	clrslt		;clear auto and select
00B8E9  2  A9 20        	lda	#' '		;if name
00B8EB  2  CD BF BF     	cmp	fcbone+1	;and
00B8EE  2  D0 0F        	bne	findfr		;type are
00B8F0  2  CD C7 BF     	cmp	fcbone+9	;not empty
00B8F3  2  D0 0A        	bne	findfr		;then use it
00B8F5  2  A9 3F        	lda	#'?'		;else
00B8F7  2  A0 0B        	ldy	#11		;fill
00B8F9  2  99 BE BF     fillqu:	sta	fcbone,y	;fcb
00B8FC  2  88           	dey			;with
00B8FD  2  D0 FA        	bne	fillqu		;question marks
00B8FF  2  20 5A BC     findfr:	jsr	srchf1		;search for first match
00B902  2  30 56        	bmi	notfnd		;error if none
00B904  2  AD F2 BF     fnddir:	lda	sixten		;set across
00B907  2  8D F1 BF     	sta	across		;to four
00B90A  2  20 DC BB     	jsr	ccrlf		;do a crlf
00B90D  2  20 67 BC     dirl:	jsr	hdr		;do header
00B910  2  A9 3A        	lda	#':'		;then a
00B912  2  20 EB BB     	jsr	chrout		;colon
00B915  2  AD EA BF     	lda	diradd		;get number
00B918  2  0A           	asl	a		;and
00B919  2  0A           	asl	a		;multiply
00B91A  2  0A           	asl	a		;by
00B91B  2  0A           	asl	a		;thirty two
00B91C  2  0A           	asl	a		;then
00B91D  2  29 60        	and	#%01100000	;mask out insignificant
00B91F  2  A8           	tay			;make a pointer
00B920  2  C8           	iny			;and bump
00B921  2  A2 01        	ldx	#1		;set counter
00B923  2  B9 28 01     nmelpe:	lda	dflbuf,y	;get name
00B926  2  20 6D BC     	jsr	cotsxy		;else send to console
00B929  2  C8           noname:	iny			;bump index
00B92A  2  E8           	inx			;and count
00B92B  2  E0 0C        	cpx	#12		;if count is 12
00B92D  2  F0 0C        	beq	endnme		;then done
00B92F  2  E0 09        	cpx	#9		;or if not 9
00B931  2  D0 F0        	bne	nmelpe		;then loop
00B933  2  A9 2E        	lda	#'.'		;else send
00B935  2  20 6D BC     	jsr	cotsxy		;a period
00B938  2  4C 23 B9     	jmp	nmelpe		;and loop
00B93B  2  20 F3 BB     endnme:	jsr	chkcst		;check console status
00B93E  2  D0 19        	bne	extdir		;if key down quit
00B940  2  20 92 BC     	jsr	setone		;else point to fcb
00B943  2  20 0B BC     	jsr	srchnx		;else search for next
00B946  2  8D EA BF     	sta	diradd		;save number
00B949  2  30 0E        	bmi	extdir		;quit if not found
00B94B  2  CE F1 BF     	dec	across		;drop count
00B94E  2  F0 B4        	beq	fnddir		;new line if 0
00B950  2  20 E9 BB     	jsr	spcout		;send
00B953  2  20 E9 BB     	jsr	spcout		;two spaces
00B956  2  4C 0D B9     	jmp	dirl		;and stay
00B959  2  60           extdir:	rts			;else done
00B95A  2               ;not found error handler
00B95A  2  A0 34        notfnd:	ldy	#ntfnms		;point to message
00B95C  2  4C BB BD     	jmp	sndmsg		;send and exit
00B95F  2               ;execute ren command
00B95F  2               ; ren <ufn> <ufn>
00B95F  2               ;where first ufn is from name and second is to name
00B95F  2  20 A0 BC     ren:	jsr	prslin		;get old name
00B962  2  D0 57        	bne	renerr		;error if afn
00B964  2  20 99 BC     	jsr	tmpold		;save drive
00B967  2  20 A6 BD     	jsr	clrslt		;clear auto and select
00B96A  2  20 5A BC     	jsr	srchf1		;if file does not exist
00B96D  2  30 4F        	bmi	fntfnd		;then an error
00B96F  2  20 DB BD     	jsr	frssec		;move name to second half
00B972  2  AC E2 BF     	ldy	cnbfpt		;get pointer
00B975  2  B9 3F BF     	lda	cnstxt,y	;and then char
00B978  2  C9 20        	cmp	#' '		;if not a space
00B97A  2  D0 3C        	bne	rensyn		;then error
00B97C  2  20 A0 BC     	jsr	prslin		;get new name
00B97F  2  D0 37        	bne	rensyn		;error if afn
00B981  2  AD E4 BF     	lda	tmpdsk		;get new drive
00B984  2  F0 12        	beq	nonwdr		;if zero ok
00B986  2  CD EE BF     	cmp	oldtmp		;compare to old
00B989  2  F0 0D        	beq	nonwdr		;ok if same
00B98B  2  38           	sec			;drop for default check
00B98C  2  E9 01        	sbc	#1
00B98E  2  CD E3 BF     	cmp	dfldsk		;if not default
00B991  2  D0 25        	bne	rensyn		;is error
00B993  2  AD EE BF     	lda	oldtmp		;and then if from not
00B996  2  D0 20        	bne	rensyn		;default is error
00B998  2  AD EE BF     nonwdr:	lda	oldtmp		;else get old
00B99B  2  8D E4 BF     	sta	tmpdsk		;and save
00B99E  2  A9 00        	lda	#0		;clear
00B9A0  2  8D CE BF     	sta	fcbone+16
00B9A3  2  20 A6 BD     	jsr	clrslt		;reselect
00B9A6  2  20 5A BC     	jsr	srchf1		;search for old
00B9A9  2  10 09        	bpl	filexs		;error if found
00B9AB  2  20 DB BD     	jsr	frssec		;swap names
00B9AE  2  20 92 BC     	jsr	setone		;point to fcb
00B9B1  2  4C 22 BC     	jmp	renmfl		;and do it
00B9B4  2               ;ren file exists error handler
00B9B4  2  A0 3E        filexs:	ldy	#flexms		;point to
00B9B6  2  D0 08        	bne	remsg		;and send
00B9B8  2               ;ren syntax error handler
00B9B8  2  20 2F BC     rensyn:	jsr	rstddr		;restore default
00B9BB  2  4C C6 B8     renerr:	jmp	cmderr		;do error
00B9BE  2               ;ren source file not found error handler
00B9BE  2  A0 34        fntfnd:	ldy	#ntfnms		;point to
00B9C0  2  4C BB BD     remsg:	jmp	sndmsg		;and send
00B9C3  2               ;execute save command
00B9C3  2               ; save <length> <drive:>ufn (<address>)
00B9C3  2  A9 00        save:	lda	#<tea		;set start address to tea start
00B9C5  2  A0 08        	ldy	#>tea
00B9C7  2  8D F8 BF     	sta	sadr
00B9CA  2  8C F9 BF     	sty	sadr+1
00B9CD  2  20 00 BE     	jsr	bldnum		;calculate length
00B9D0  2  D0 7A        	bne	saverr		;error if > 255 pages
00B9D2  2  8D ED BF     	sta	length		;else save low
00B9D5  2  0D ED BF     	ora	length		;test for zero length
00B9D8  2  F0 72        	beq	saverr		;error if is
00B9DA  2  20 A0 BC     	jsr	prslin		;get file name
00B9DD  2  D0 6D        	bne	saverr		;error if afn
00B9DF  2  20 DB BD     	jsr	frssec		;move name to second half
00B9E2  2  20 99 BC     	jsr	tmpold		;save drive
00B9E5  2  20 00 BE     	jsr	bldnum		;it is so find value
00B9E8  2  AE BF BF     	ldx	fcbone+1	;see if there
00B9EB  2  E0 20        	cpx	#' '
00B9ED  2  F0 0A        	beq	nosadr		;it is not
00B9EF  2  8D F8 BF     	sta	sadr		;and set address
00B9F2  2  8C F9 BF     	sty	sadr+1
00B9F5  2  C0 02        	cpy	#2		;make sure is high enough
00B9F7  2  90 53        	bcc	saverr		;error if not
00B9F9  2  20 EE BD     nosadr:	jsr	secfrs		;move name back
00B9FC  2  20 A6 BD     	jsr	clrslt		;clear auto and select
00B9FF  2  20 0F BC     	jsr	dlt1		;delete
00BA02  2  20 92 BC     	jsr	setone		;then create
00BA05  2  20 1E BC     	jsr	cratfl		;new file
00BA08  2  30 45        	bmi	noroom		;say no room if error
00BA0A  2  20 45 BC     	jsr	open1		;open file
00BA0D  2  30 44        	bmi	noopen		;if error
00BA0F  2  18           	clc			;now find end page
00BA10  2  AD F9 BF     	lda	sadr+1
00BA13  2  6D ED BF     	adc	length
00BA16  2  8D ED BF     	sta	length
00BA19  2  AD F8 BF     	lda	sadr		;get start address
00BA1C  2  AC F9 BF     	ldy	sadr+1
00BA1F  2  8D EF BF     wrtmre:	sta	dskbuf		;set
00BA22  2  8C F0 BF     	sty	dskbuf+1	;buffer
00BA25  2  20 C0 CA     	jsr	mv128		;move data to buffer
00BA28  2  20 92 BC     	jsr	setone		;point to fcb
00BA2B  2  20 1A BC     	jsr	wrrcrd		;write record
00BA2E  2  D0 27        	bne	wrterr		;exit if error
00BA30  2  18           	clc			;else
00BA31  2  AD EF BF     	lda	dskbuf		;get old
00BA34  2  AC F0 BF     	ldy	dskbuf+1	;buffer
00BA37  2  69 80        	adc	#128		;add 128
00BA39  2  90 03        	bcc	donotc		;if carry
00BA3B  2  C8           	iny			;bump upper
00BA3C  2  F0 05        	beq	clssav		;done if page zero
00BA3E  2  CC ED BF     donotc:	cpy	length		;loop if upper
00BA41  2  D0 DC        	bne	wrtmre		;not at limit
00BA43  2  20 92 BC     clssav:	jsr	setone		;else point to
00BA46  2  20 03 BC     	jsr	clsefl		;and close file
00BA49  2  30 10        	bmi	cantcl		;say so if error
00BA4B  2  60           extera:	rts
00BA4C  2               ;save error handler
00BA4C  2  4C C6 B8     saverr:	jmp	cmderr		;do error
00BA4F  2               ;save no room error handler
00BA4F  2  A0 01        noroom:	ldy	#nospms		;point to
00BA51  2  D0 0A        	bne	semsg		;and send
00BA53  2               ;save can not open error handler
00BA53  2  A0 55        noopen:	ldy	#cnnoms		;point to
00BA55  2  D0 06        	bne	semsg		;and send
00BA57  2               ;save write error handler
00BA57  2  A0 62        wrterr:	ldy	#wrerms		;point
00BA59  2  D0 02        	bne	semsg		;to and send
00BA5B  2               ;save can not close error
00BA5B  2  A0 0A        cantcl:	ldy	#ntclms		;point to
00BA5D  2  4C BB BD     semsg:	jmp	sndmsg		;and send
00BA60  2               ;execute era command
00BA60  2               ; era <afn>
00BA60  2  20 A0 BC     era:	jsr	prslin		;get file name
00BA63  2  C9 0B        	cmp	#11		;if not all ?
00BA65  2  D0 13        	bne	nteral		;then skip verify
00BA67  2  A0 18        	ldy	#alflms		;else point to
00BA69  2  20 BB BD     	jsr	sndmsg		;and send all files
00BA6C  2  20 E5 BB     	jsr	cnsrde		;get an input
00BA6F  2  48           	pha			;and save
00BA70  2  20 DC BB     	jsr	ccrlf		;do a cr lf
00BA73  2  68           	pla			;restore char
00BA74  2  29 5F        	and	#$5f		;convert to upper case
00BA76  2  C9 59        	cmp	#'Y'		;if not y
00BA78  2  D0 D1        	bne	extera		;then quit
00BA7A  2  20 A6 BD     nteral:	jsr	clrslt		;clear auto and select
00BA7D  2  4C 0F BC     	jmp	dlt1		;delete first
00BA80  2               ;execute type command
00BA80  2               ; type d:ufn
00BA80  2  20 A0 BC     type:	jsr	prslin		;get file
00BA83  2  D0 30        	bne	typafn		;error if afn
00BA85  2  20 42 BC     	jsr	casdo1		;clear - select - open file 1
00BA88  2  30 32        	bmi	notype		;error if not found
00BA8A  2  20 DC BB     	jsr	ccrlf		;else do cr lf
00BA8D  2  20 54 BC     typmre:	jsr	read1		;read record
00BA90  2  F0 04        	beq	okread		;if ok continue
00BA92  2  10 20        	bpl	exttyp		;exit if just end
00BA94  2  30 22        	bmi	typerr		;else error
00BA96  2  A2 00        okread:	ldx	#0		;clear index
00BA98  2  BD 28 01     typlpe:	lda	dflbuf,x	;get char
00BA9B  2  C9 1A        	cmp	#eof		;if eof
00BA9D  2  F0 15        	beq	exttyp		;then exit
00BA9F  2  20 6D BC     	jsr	cotsxy		;else send
00BAA2  2  20 F3 BB     	jsr	chkcst		;if key down
00BAA5  2  D0 08        	bne	exttok		;then exit
00BAA7  2  AE EB BF     	ldx	savx		;else get index
00BAAA  2  E8           	inx			;bump it
00BAAB  2  10 EB        	bpl	typlpe		;and loop if < 128
00BAAD  2  30 DE        	bmi	typmre		;else read more
00BAAF  2  A2 06        exttok:	ldx	#6		;clear console
00BAB1  2  20 03 01     	jsr	pemjmp		;with no echo
00BAB4  2  60           exttyp:	rts
00BAB5  2               ;type syntax error handler
00BAB5  2  4C C6 B8     typafn:	jmp	cmderr		;error return
00BAB8  2               ;type read error handler
00BAB8  2  A0 29        typerr:	ldy	#rderms		;point to
00BABA  2  D0 02        	bne	temsg		;and send
00BABC  2               ;type not found error handler
00BABC  2  A0 34        notype:	ldy	#ntfnms		;point to
00BABE  2  4C BB BD     temsg:	jmp	sndmsg		;and send
00BAC1  2               ;execute load command
00BAC1  2               ; load <ufn> (<address>)
00BAC1  2  20 D0 BD     load:	jsr	setddb		;set load start to tea start
00BAC4  2  20 A0 BC     	jsr	prslin		;build fcb
00BAC7  2  D0 EC        	bne	typafn		;error if afn
00BAC9  2  20 DB BD     	jsr	frssec		;save in second half
00BACC  2  20 99 BC     	jsr	tmpold		;save file
00BACF  2  20 00 BE     	jsr	bldnum		;find start address
00BAD2  2  AE BF BF     	ldx	fcbone+1	;see if number
00BAD5  2  E0 20        	cpx	#' '
00BAD7  2  F0 03        	beq	usedfl		;if none use default
00BAD9  2  20 D4 BD     	jsr	setdb		;and set
00BADC  2  20 EE BD     usedfl:	jsr	secfrs		;move name back
00BADF  2  20 42 BC     	jsr	casdo1		;clear - select - open file 1
00BAE2  2  30 D8        	bmi	notype		;exit if not found
00BAE4  2  AD EF BF     	lda	dskbuf		;get load start
00BAE7  2  AC F0 BF     	ldy	dskbuf+1
00BAEA  2  20 2A BC     lcmdlp:	jsr	setbuf		;set as disk buffer
00BAED  2  20 54 BC     	jsr	read1		;read record
00BAF0  2  D0 06        	bne	loadnd		;done if not zero
00BAF2  2  20 AD CA     	jsr	adjdb		;bump address
00BAF5  2  4C EA BA     	jmp	lcmdlp		;and loop
00BAF8  2  30 BE        loadnd:	bmi	typerr		;if error say so
00BAFA  2  4C 9F BD     	jmp	stdflb		;back to default buffer
00BAFD  2               ;execute go command
00BAFD  2               ; go (<address>)
00BAFD  2  20 00 BE     go:	jsr	bldnum		;get address
00BB00  2  AE BF BF     	ldx	fcbone+1	;get first char
00BB03  2  E0 20        	cpx	#' '		;see if nothing
00BB05  2  F0 03        	beq	nolnum		;nothing so use tea
00BB07  2  4C 71 BB     	jmp	godoit		;then execute
00BB0A  2  4C 6D BB     nolnum:	jmp	gotea
00BB0D  2               ;execute trns (transient) command
00BB0D  2               ; <ufn> (<fn>) (<fn>)
00BB0D  2  AD BF BF     trns:	lda	fcbone+1	;get first char
00BB10  2  C9 20        	cmp	#' '		;if not space
00BB12  2  D0 11        	bne	chktyp		;check type
00BB14  2  AD E4 BF     	lda	tmpdsk		;else test temp
00BB17  2  F0 09        	beq	skpdrv		;if none skip
00BB19  2  38           	sec			;else convert
00BB1A  2  E9 01        	sbc	#1		;to number
00BB1C  2  8D E3 BF     	sta	dfldsk		;set default
00BB1F  2  20 FB BB     	jsr	slctds		;and select
00BB22  2  4C B5 B8     skpdrv:	jmp	extwod		;return
00BB25  2  AD C7 BF     chktyp:	lda	fcbone+9	;get type
00BB28  2  C9 20        	cmp	#' '		;if space
00BB2A  2  F0 03        	beq	typemp		;then ok
00BB2C  2  4C D4 BB     	jmp	trnerr		;else error
00BB2F  2  A2 02        typemp:	ldx	#2		;make
00BB31  2  BD DF BF     setcom:	lda	typcom,x	;type
00BB34  2  9D C7 BF     	sta	fcbone+9,x	;com
00BB37  2  CA           	dex			;then
00BB38  2  10 F7        	bpl	setcom		;continue
00BB3A  2  20 42 BC     	jsr	casdo1		;clear - select - open file one
00BB3D  2  10 03        	bpl	gottrn		;jump if ok
00BB3F  2  4C D1 BB     	jmp	topner		;else do error
00BB42  2  20 D0 BD     gottrn:	jsr	setddb		;set start to tea
00BB45  2  20 2A BC     nxtrcr:	jsr	setbuf		;set address
00BB48  2  20 54 BC     	jsr	read1		;read fcb 1
00BB4B  2  D0 1E        	bne	endlde		;branch if error or eof
00BB4D  2  20 AD CA     	jsr	adjdb		;adjust address up by 128
00BB50  2  CD 8C BE     	cmp	ccmvc		;if new low
00BB53  2  90 07        	bcc	tryhig		;ok try high
00BB55  2  CC 8D BE     	cpy	ccmvc+1		;else if high
00BB58  2  90 EB        	bcc	nxtrcr		;ok do more
00BB5A  2  B0 07        	bcs	chklnd		;else check for end
00BB5C  2  CC 8D BE     tryhig:	cpy	ccmvc+1		;if high less
00BB5F  2  90 E4        	bcc	nxtrcr		;then ok
00BB61  2  F0 E2        	beq	nxtrcr		;or ok if same
00BB63  2  20 9F BD     chklnd:	jsr	stdflb		;set buffer to default
00BB66  2  20 54 BC     	jsr	read1		;read (should be eof)
00BB69  2  F0 6C        	beq	tlderr		;error if more
00BB6B  2  30 6A        endlde:	bmi	tlderr		;do error
00BB6D  2  A9 00        gotea:	lda	#<tea		;set go address to tea start
00BB6F  2  A0 08        	ldy	#>tea
00BB71  2  8D C6 BB     godoit:	sta	do+1		;set to ay
00BB74  2  8C C7 BB     	sty	do+2
00BB77  2  20 2F BC     	jsr	rstddr		;else restore default
00BB7A  2  20 A0 BC     	jsr	prslin		;parse file
00BB7D  2  AD E4 BF     	lda	tmpdsk		;set auto
00BB80  2  8D BE BF     	sta	fcbone		;select position
00BB83  2  A2 10        	ldx	#16		;do a second
00BB85  2  20 A2 BC     	jsr	prsmre		;fcb if there
00BB88  2  AD E4 BF     	lda	tmpdsk		;set auto select
00BB8B  2  8D CE BF     	sta	fcbone+16	;again
00BB8E  2  A0 00        	ldy	#0		;clear record
00BB90  2  8C DE BF     	sty	fcbone+32	;counter
00BB93  2  A2 20        	ldx	#32		;move
00BB95  2  BD BE BF     movfcb:	lda	fcbone,x	;all
00BB98  2  9D 07 01     	sta	dflfcb,x	;to
00BB9B  2  CA           	dex			;default
00BB9C  2  10 F7        	bpl	movfcb		;fcb
00BB9E  2  E8           	inx			;set x to zero
00BB9F  2  B9 3F BF     tstbuf:	lda	cnstxt,y	;get char
00BBA2  2  F0 07        	beq	isnull		;if null jump
00BBA4  2  C9 20        	cmp	#' '		;or if space
00BBA6  2  F0 03        	beq	isnull		;jump
00BBA8  2  C8           	iny			;else bump pointer
00BBA9  2  D0 F4        	bne	tstbuf		;and loop
00BBAB  2  A9 00        isnull:	lda	#0		;clear
00BBAD  2  8D 28 01     	sta	dflbuf		;count
00BBB0  2  B9 3F BF     movbuf:	lda	cnstxt,y	;get char
00BBB3  2  9D 29 01     	sta	dflbuf+1,x	;and move
00BBB6  2  F0 07        	beq	fillov		;exit if null
00BBB8  2  E8           	inx			;increment
00BBB9  2  C8           	iny			;counters
00BBBA  2  EE 28 01     	inc	dflbuf		;and length
00BBBD  2  D0 F1        	bne	movbuf		;and loop
00BBBF  2  20 DC BB     fillov:	jsr	ccrlf		;do a cr lf
00BBC2  2  20 9F BD     	jsr	stdflb		;set default
00BBC5  2  20 00 08     do:	jsr	tea		;execute
00BBC8  2  AD E3 BF     	lda	dfldsk		;get default
00BBCB  2  20 FB BB     	jsr	slctds		;and set
00BBCE  2  4C 18 B8     	jmp	ccmlpe		;then loop
00BBD1  2               ;trns syntax error handler
00BBD1  2  20 2F BC     topner:	jsr	rstddr		;restore default
00BBD4  2  4C C6 B8     trnerr:	jmp	cmderr		;do error
00BBD7  2               ;trns load error
00BBD7  2  A0 4A        tlderr:	ldy	#lderms		;point to
00BBD9  2  4C BB BD     	jmp	sndmsg		;and send
00BBDC  2               ;carriage return and linefeed
00BBDC  2  A9 0D        ccrlf:	lda	#cr		;get a cr
00BBDE  2  20 EB BB     	jsr	chrout		;send
00BBE1  2  A9 0A        	lda	#lf		;get a lf
00BBE3  2  D0 06        	bne	chrout		;and send
00BBE5  2               ;pem entry routines
00BBE5  2  A2 01        cnsrde:	ldx	#1		;console read
00BBE7  2  D0 43        	bne	pemgo
00BBE9  2  A9 20        spcout:	lda	#' '		;output space
00BBEB  2  A2 02        chrout:	ldx	#2		;console output
00BBED  2  D0 3D        	bne	pemgo
00BBEF  2  A2 0A        rdebuf:	ldx	#10		;buffered input
00BBF1  2  D0 39        	bne	pemgo
00BBF3  2  A2 0B        chkcst:	ldx	#11		;check console
00BBF5  2  D0 35        	bne	pemgo
00BBF7  2  A2 0D        rstdsk:	ldx	#13		;initialize system
00BBF9  2  D0 31        	bne	pemgo
00BBFB  2  A2 0E        slctds:	ldx	#14		;select drive
00BBFD  2  D0 2D        	bne	pemgo
00BBFF  2  A2 0F        openfl:	ldx	#15		;open file
00BC01  2  D0 29        	bne	pemgo
00BC03  2  A2 10        clsefl:	ldx	#16		;close file
00BC05  2  D0 25        	bne	pemgo
00BC07  2  A2 11        srchfr:	ldx	#17		;first match
00BC09  2  D0 21        	bne	pemgo
00BC0B  2  A2 12        srchnx:	ldx	#18		;next match
00BC0D  2  D0 1D        	bne	pemgo
00BC0F  2               ;delete file one
00BC0F  2  20 92 BC     dlt1:	jsr	setone		;point to fcb
00BC12  2  A2 13        dltfil:	ldx	#19		;delete file
00BC14  2  D0 16        	bne	pemgo
00BC16  2  A2 14        rdrcrd:	ldx	#20		;read record
00BC18  2  D0 12        	bne	pemgo
00BC1A  2  A2 15        wrrcrd:	ldx	#21		;write record
00BC1C  2  D0 0E        	bne	pemgo
00BC1E  2  A2 16        cratfl:	ldx	#22		;create file
00BC20  2  D0 0A        	bne	pemgo
00BC22  2  A2 17        renmfl:	ldx	#23		;rename file
00BC24  2  D0 06        	bne	pemgo
00BC26  2  A2 19        intdsk:	ldx	#25		;read drive num
00BC28  2  D0 02        	bne	pemgo
00BC2A  2  A2 1A        setbuf:	ldx	#26		;set buffer add
00BC2C  2  4C 03 01     pemgo:	jmp	pemjmp		;go to pem
00BC2F  2               ;restore default drive
00BC2F  2  AD E4 BF     rstddr:	lda	tmpdsk		;if temp drive
00BC32  2  F0 1F        	beq	extddr		;zero then exit
00BC34  2  38           	sec			;else
00BC35  2  E9 01        	sbc	#1		;subtract one
00BC37  2  CD E3 BF     	cmp	dfldsk		;compare to default
00BC3A  2  F0 17        	beq	extddr		;exit if same
00BC3C  2  AD E3 BF     seldfl:	lda	dfldsk		;else get default
00BC3F  2  4C FB BB     	jmp	slctds		;select
00BC42  2               ;clear auto - select disk - open file at fcbone
00BC42  2  20 A6 BD     casdo1:	jsr	clrslt		;clear auto and select
00BC45  2               ;open file one
00BC45  2               ; returns:n=1 if not found
00BC45  2  A9 00        open1:	lda	#0		;clear
00BC47  2  8D DE BF     	sta	fcbone+32	;record number
00BC4A  2  20 92 BC     	jsr	setone		;point to fcb
00BC4D  2  20 FF BB     	jsr	openfl		;open it
00BC50  2  8D EA BF     	sta	diradd		;save number
00BC53  2  60           extddr:	rts
00BC54  2               ;read file one
00BC54  2  20 92 BC     read1:	jsr	setone		;point to fcb
00BC57  2  4C 16 BC     	jmp	rdrcrd		;do read
00BC5A  2               ;search for first file one
00BC5A  2               ; returns:n=1 if not found
00BC5A  2  20 92 BC     srchf1:	jsr	setone		;point to fcb
00BC5D  2  20 07 BC     	jsr	srchfr		;search for first
00BC60  2  8D EA BF     	sta	diradd		;save number
00BC63  2  60           	rts
00BC64  2               ;header output
00BC64  2  20 DC BB     hdrout:	jsr	ccrlf		;do cr lf
00BC67  2  20 26 BC     hdr:	jsr	intdsk		;get drive number
00BC6A  2  18           	clc			;make
00BC6B  2  69 41        	adc	#'A'		;a letter
00BC6D  2               ;output with save of x and y
00BC6D  2               ;this routine calls the pem resident routine
00BC6D  2               ;tstchr to see if a char is a printing char.
00BC6D  2               ;if it is then c=1 upon return from tstchr.
00BC6D  2  8E EB BF     cotsxy:	stx	savx		;save x
00BC70  2  8C EC BF     	sty	savy		;and y
00BC73  2  20 B7 C8     	jsr	tstchr		;see if printing
00BC76  2  B0 10        	bcs	isprnt		;jump if is
00BC78  2  48           	pha			;else save
00BC79  2  AD 7F CC     	lda	sysdef+4	;get invert
00BC7C  2  20 EB BB     	jsr	chrout		;send it
00BC7F  2  68           	pla			;get char
00BC80  2  09 40        	ora	#'@'		;make printing
00BC82  2  20 EB BB     	jsr	chrout		;send it
00BC85  2  AD 7E CC     	lda	sysdef+3	;get normal
00BC88  2  20 EB BB     isprnt:	jsr	chrout		;do output
00BC8B  2  AC EC BF     	ldy	savy		;get y
00BC8E  2  AE EB BF     	ldx	savx		;and x
00BC91  2  60           	rts
00BC92  2               ;set up fcb one pointer
00BC92  2  AD 8F BE     setone:	lda	fcb1vc		;low
00BC95  2  AC 90 BE     	ldy	fcb1vc+1	;and high
00BC98  2  60           	rts
00BC99  2               ;save tmpdsk in oldtmp
00BC99  2  AD E4 BF     tmpold:	lda	tmpdsk
00BC9C  2  8D EE BF     	sta	oldtmp
00BC9F  2  60           	rts
00BCA0  2               ;parse command line
00BCA0  2  A2 00        prslin:	ldx	#0		;clear index
00BCA2  2  8A           prsmre:	txa			;save
00BCA3  2  48           	pha			;index
00BCA4  2  A9 00        	lda	#0		;clear temp
00BCA6  2  8D E4 BF     	sta	tmpdsk		;drive flag
00BCA9  2  AC E2 BF     	ldy	cnbfpt		;get buffer pointer
00BCAC  2  20 6D BD     	jsr	skpspc		;find first non-space
00BCAF  2  8C E9 BF     	sty	curpnt		;save index
00BCB2  2  F0 0D        	beq	nulchr		;jump if null
00BCB4  2  29 0F        	and	#%00001111	;else look at 4 lsbs
00BCB6  2  48           	pha			;and save
00BCB7  2  C8           	iny			;point to next char
00BCB8  2  B9 3F BF     	lda	cnstxt,y	;and get it
00BCBB  2  C9 3A        	cmp	#':'		;if a colon
00BCBD  2  F0 0A        	beq	drvinp		;jump and set drive
00BCBF  2  68           	pla			;else clear stack
00BCC0  2  88           	dey			;backup index
00BCC1  2  AD E3 BF     nulchr:	lda	dfldsk		;set automatic
00BCC4  2  9D BE BF     	sta	fcbone,x	;to default
00BCC7  2  10 08        	bpl	trynme		;then parse name
00BCC9  2  68           drvinp:	pla			;get number
00BCCA  2  8D E4 BF     	sta	tmpdsk		;set temp flag
00BCCD  2  9D BE BF     	sta	fcbone,x	;and fcb
00BCD0  2  C8           	iny			;point past colon
00BCD1  2  A9 08        trynme:	lda	#8		;set name count
00BCD3  2  8D E8 BF     	sta	ccmcount		;to eight
00BCD6  2  20 7A BD     tstnme:	jsr	tstlgl		;test for illegal
00BCD9  2  F0 1D        	beq	flnmsp		;if illegal jump
00BCDB  2  E8           	inx			;bump pointer
00BCDC  2  C9 2A        	cmp	#'*'		;if not *
00BCDE  2  D0 07        	bne	notafn		;skip ? fill
00BCE0  2  A9 3F        	lda	#'?'		;get a ?
00BCE2  2  9D BE BF     	sta	fcbone,x	;store
00BCE5  2  D0 04        	bne	nxtout		;and jump
00BCE7  2  9D BE BF     notafn:	sta	fcbone,x	;store char
00BCEA  2  C8           	iny			;bump source
00BCEB  2  CE E8 BF     nxtout:	dec	ccmcount		;drop counter down
00BCEE  2  D0 E6        	bne	tstnme		;and loop
00BCF0  2  20 7A BD     skpmre:	jsr	tstlgl		;if illegal
00BCF3  2  F0 11        	beq	trytyp		;try type
00BCF5  2  C8           	iny			;else bump index
00BCF6  2  D0 F8        	bne	skpmre		;and loop
00BCF8  2  E8           flnmsp:	inx			;next position
00BCF9  2  A9 20        	lda	#' '		;get a space
00BCFB  2  9D BE BF     	sta	fcbone,x	;store
00BCFE  2  CE E8 BF     	dec	ccmcount		;count down
00BD01  2  D0 F5        	bne	flnmsp		;and loop
00BD03  2  B9 3F BF     	lda	cnstxt,y	;get char again
00BD06  2  48           trytyp:	pha			;save char
00BD07  2  A9 03        	lda	#3		;set count
00BD09  2  8D E8 BF     	sta	ccmcount		;to three
00BD0C  2  68           	pla			;get char
00BD0D  2  C9 2E        	cmp	#'.'		;if not .
00BD0F  2  D0 23        	bne	fltysp		;then fill spaces
00BD11  2  C8           	iny			;else bump source
00BD12  2  20 7A BD     tsttyp:	jsr	tstlgl		;if not legal
00BD15  2  F0 1D        	beq	fltysp		;then fill spaces
00BD17  2  E8           	inx			;else bump index
00BD18  2  C9 2A        	cmp	#'*'		;if not *
00BD1A  2  D0 07        	bne	notaft		;then skip fill
00BD1C  2  A9 3F        	lda	#'?'		;else get ?
00BD1E  2  9D BE BF     	sta	fcbone,x	;move to fcb
00BD21  2  D0 04        	bne	mrtyfl		;and loop
00BD23  2  9D BE BF     notaft:	sta	fcbone,x	;move char to fcb
00BD26  2  C8           	iny			;bump source
00BD27  2  CE E8 BF     mrtyfl:	dec	ccmcount		;count down
00BD2A  2  D0 E6        	bne	tsttyp		;and loop
00BD2C  2  20 7A BD     nttype:	jsr	tstlgl		;if illegal
00BD2F  2  F0 0E        	beq	filnul		;fill out nulls
00BD31  2  C8           	iny			;else bump source
00BD32  2  D0 F8        	bne	nttype		;and loop
00BD34  2  E8           fltysp:	inx			;bump fcb pointer
00BD35  2  A9 20        	lda	#' '		;get space
00BD37  2  9D BE BF     	sta	fcbone,x	;put in fcb
00BD3A  2  CE E8 BF     	dec	ccmcount		;count down
00BD3D  2  D0 F5        	bne	fltysp		;and continue
00BD3F  2  A9 03        filnul:	lda	#3		;clear
00BD41  2  8D E8 BF     	sta	ccmcount		;three
00BD44  2  E8           mrnlty:	inx			;bump fcb pointer
00BD45  2  A9 00        	lda	#0		;get a zero
00BD47  2  9D BE BF     	sta	fcbone,x	;move to fcb
00BD4A  2  CE E8 BF     	dec	ccmcount		;count down
00BD4D  2  D0 F5        	bne	mrnlty		;loop until done
00BD4F  2  8C E2 BF     	sty	cnbfpt		;update start pointer
00BD52  2  A9 00        	lda	#0		;clear
00BD54  2  8D E8 BF     	sta	ccmcount		;count
00BD57  2  68           	pla			;restore stack
00BD58  2  A8           	tay			;move to index
00BD59  2  A2 0B        	ldx	#11		;counter to 11
00BD5B  2  C8           tstqus:	iny			;point to
00BD5C  2  B9 BE BF     	lda	fcbone,y	;and get char
00BD5F  2  C9 3F        	cmp	#'?'		;if not a ?
00BD61  2  D0 03        	bne	nxtqus		;then jump
00BD63  2  EE E8 BF     	inc	ccmcount		;else bump count
00BD66  2  CA           nxtqus:	dex			;loop until
00BD67  2  D0 F2        	bne	tstqus		;11 tested
00BD69  2  AD E8 BF     	lda	ccmcount		;get count
00BD6C  2  60           	rts			;and return
00BD6D  2               ;skip space
00BD6D  2  B9 3F BF     skpspc:	lda	cnstxt,y	;get char
00BD70  2  F0 07        	beq	extskp		;jump if null
00BD72  2  C9 20        	cmp	#' '		;if not space
00BD74  2  D0 03        	bne	extskp		;then exit
00BD76  2  C8           	iny			;else go to next
00BD77  2  D0 F4        	bne	skpspc		;and test
00BD79  2  60           extskp:	rts
00BD7A  2               ;test legal
00BD7A  2  B9 3F BF     tstlgl:	lda	cnstxt,y	;get char
00BD7D  2  F0 1C        	beq	extlgl
00BD7F  2  C9 20        	cmp	#' '		;if space
00BD81  2  90 19        	bcc	badinp		;ok - less is error
00BD83  2  F0 16        	beq	extlgl
00BD85  2  C9 3D        	cmp	#'='
00BD87  2  F0 12        	beq	extlgl
00BD89  2  C9 2E        	cmp	#'.'
00BD8B  2  F0 0E        	beq	extlgl
00BD8D  2  C9 3A        	cmp	#':'
00BD8F  2  F0 0A        	beq	extlgl
00BD91  2  C9 3B        	cmp	#semico
00BD93  2  F0 06        	beq	extlgl
00BD95  2  C9 3C        	cmp	#'<'
00BD97  2  F0 02        	beq	extlgl
00BD99  2  C9 3E        	cmp	#'>'
00BD9B  2  60           extlgl:	rts
00BD9C  2  4C C6 B8     badinp:	jmp	cmderr
00BD9F  2               ;set default buffer address
00BD9F  2  A9 28        stdflb:	lda	#<dflbuf 	;point to
00BDA1  2  A0 01        	ldy	#>dflbuf	;location
00BDA3  2  4C 2A BC     	jmp	setbuf		;and set
00BDA6  2               ;clear automatic and select
00BDA6  2  A9 00        clrslt:	lda	#0		;clear auto
00BDA8  2  8D BE BF     	sta	fcbone		;select
00BDAB  2  AD E4 BF     slttmp:	lda	tmpdsk		;get temp
00BDAE  2  F0 1F        	beq	extsnd		;if zero exit
00BDB0  2  38           	sec			;else subtract
00BDB1  2  E9 01        	sbc	#1		;one
00BDB3  2  CD E3 BF     	cmp	dfldsk		;if same as default
00BDB6  2  F0 17        	beq	extsnd		;then quit
00BDB8  2  4C FB BB     	jmp	slctds		;else set
00BDBB  2               ;send message
00BDBB  2  8C EC BF     sndmsg:	sty	savy		;save index
00BDBE  2  20 DC BB     	jsr	ccrlf		;do cr and lf
00BDC1  2  AC EC BF     	ldy	savy		;get index
00BDC4  2  B9 AA BE     lpesnd:	lda	msgtbl,y	;get char
00BDC7  2  F0 06        	beq	extsnd		;if null quit
00BDC9  2  20 6D BC     	jsr	cotsxy		;else send
00BDCC  2  C8           	iny			;point to next
00BDCD  2  D0 F5        	bne	lpesnd		;and loop
00BDCF  2  60           extsnd:	rts
00BDD0  2               ;set load start address
00BDD0  2  A9 00        setddb:	lda	#<tea		;to tea start
00BDD2  2  A0 08        	ldy	#>tea
00BDD4  2  8D EF BF     setdb:	sta	dskbuf		;to ay
00BDD7  2  8C F0 BF     	sty	dskbuf+1
00BDDA  2  60           	rts
00BDDB  2               ;move first part of fcb to second half
00BDDB  2               ;and move second part to first part.
00BDDB  2               ;only ren depends upon this routine to actually
00BDDB  2               ;swap fcb halves.
00BDDB  2               ;alters:a,x,p
00BDDB  2               ;returns:x=$ff
00BDDB  2  A2 0F        frssec:	ldx	#15		;set index to last
00BDDD  2  BD BE BF     frsclp:	lda	fcbone,x	;get byte
00BDE0  2  BC CE BF     	ldy	fcbone+16,x
00BDE3  2  9D CE BF     	sta	fcbone+16,x	;move it
00BDE6  2  98           	tya
00BDE7  2  9D BE BF     	sta	fcbone,x
00BDEA  2  CA           	dex
00BDEB  2  10 F0        	bpl	frsclp		;until 16 moved
00BDED  2  60           	rts
00BDEE  2               ;move second part of fcb to first half
00BDEE  2               ;restore tmpdsk from save location
00BDEE  2               ;alters:a,x,p
00BDEE  2               ;returns:x=$ff
00BDEE  2  A2 0F        secfrs:	ldx	#15		;set index to last
00BDF0  2  BD CE BF     scfrlp:	lda	fcbone+16,x	;get byte
00BDF3  2  9D BE BF     	sta	fcbone,x	;move it
00BDF6  2  CA           	dex
00BDF7  2  10 F7        	bpl	scfrlp		;loop until done
00BDF9  2  AD EE BF     	lda	oldtmp		;get old flag
00BDFC  2  8D E4 BF     	sta	tmpdsk		;and set
00BDFF  2  60           	rts
00BE00  2               ;build a number from command line and leave in num
00BE00  2               ;will handle either decimal (e.g., 578) or hexadecimal (e.g., $3f2)
00BE00  2               ;move parse index past number
00BE00  2               ;modifies:all
00BE00  2               ;returns:a,y set to low and high of number
00BE00  2               ;	 flags set according to y which is high part of number
00BE00  2  A9 09        bldnum:	lda	#9		;preset to decimal
00BE02  2  8D F3 BF     	sta	moduls
00BE05  2  20 A0 BC     	jsr	prslin		;put in fcb
00BE08  2  AD E4 BF     	lda	tmpdsk		;if temp
00BE0B  2  D0 67        	bne	numerr		;is error
00BE0D  2  8D F4 BF     	sta	num		;else clear num
00BE10  2  8D F5 BF     	sta	num+1
00BE13  2  A8           	tay			;and index
00BE14  2  B9 BF BF     	lda	fcbone+1,y	;get first char
00BE17  2  C9 24        	cmp	#'$'		;see if hex signal
00BE19  2  D0 06        	bne	bnumlp		;skip if not
00BE1B  2  A9 0F        	lda	#15		;set for modulus
00BE1D  2  8D F3 BF     	sta	moduls
00BE20  2  C8           	iny			;bump past $
00BE21  2  C8           bnumlp:	iny			;next char
00BE22  2  B9 BE BF     	lda	fcbone,y	;get digit
00BE25  2  C9 20        	cmp	#' '		;see if space
00BE27  2  F0 4E        	beq	endnlp		;done if is
00BE29  2  20 97 CA     	jsr	tstdec		;see if decimal
00BE2C  2  90 0E        	bcc	usedig		;use if is
00BE2E  2  20 A1 CA     	jsr	tsthex		;see if hex
00BE31  2  B0 41        	bcs	numerr		;error if not
00BE33  2  E9 06        	sbc	#6		;remove offset
00BE35  2  A2 0F        	ldx	#15		;test for hex modulus
00BE37  2  EC F3 BF     	cpx	moduls
00BE3A  2  D0 38        	bne	numerr		;error if not
00BE3C  2  29 0F        usedig:	and	#%00001111	;eliminate ascii bias
00BE3E  2  48           	pha			;save result
00BE3F  2  AD F4 BF     	lda	num		;move number to temp
00BE42  2  8D F6 BF     	sta	tnum
00BE45  2  AD F5 BF     	lda	num+1
00BE48  2  8D F7 BF     	sta	tnum+1
00BE4B  2  AE F3 BF     	ldx	moduls		;get modulus
00BE4E  2  18           	clc
00BE4F  2  AD F4 BF     addlpe:	lda	num		;add number to itself
00BE52  2  6D F6 BF     	adc	tnum
00BE55  2  8D F4 BF     	sta	num
00BE58  2  AD F5 BF     	lda	num+1		;modulus times
00BE5B  2  6D F7 BF     	adc	tnum+1
00BE5E  2  8D F5 BF     	sta	num+1
00BE61  2  B0 11        	bcs	numerr		;error if carry out
00BE63  2  CA           	dex
00BE64  2  D0 E9        	bne	addlpe		;loop if more
00BE66  2  68           	pla			;get input back
00BE67  2  6D F4 BF     	adc	num		;add in
00BE6A  2  8D F4 BF     	sta	num
00BE6D  2  90 B2        	bcc	bnumlp		;loop if no carry
00BE6F  2  EE F5 BF     	inc	num+1		;else bump high
00BE72  2  D0 AD        	bne	bnumlp		;and loop for more
00BE74  2               ;error in bldnum - handle and quit
00BE74  2  4C C6 B8     numerr:	jmp	cmderr		;do general error
00BE77  2               ;end of use of name part - check type
00BE77  2  AD C7 BF     endnlp:	lda	fcbone+9	;get first
00BE7A  2  C9 20        	cmp	#' '		;see if space
00BE7C  2  D0 F6        	bne	numerr		;error if not
00BE7E  2  AD F4 BF     	lda	num		;return with result
00BE81  2  AC F5 BF     	ldy	num+1
00BE84  2  60           	rts
00BE85  2               ;relocatable vectors
00BE85  2  4C           	.byte	$4c
00BE86  2  3D BF        cnsbvc:	.word	cnsbuf
00BE88  2  4C           	.byte	$4c
00BE89  2  B1 B8        extcvc:	.word	extcmd-1
00BE8B  2  4C           	.byte	$4c
00BE8C  2  00 B8        ccmvc:	.word	ccm
00BE8E  2  4C           	.byte	$4c
00BE8F  2  BE BF        fcb1vc:	.word	fcbone
00BE91  2               ;function entry vector
00BE91  2  4C E3 B8     xqfntb:	jmp	dir
00BE94  2  4C C3 B9     	jmp	save
00BE97  2  4C 60 BA     	jmp	era
00BE9A  2  4C 80 BA     	jmp	type
00BE9D  2  4C 5F B9     	jmp	ren
00BEA0  2  4C FD BA     	jmp	go
00BEA3  2  4C C1 BA     	jmp	load
00BEA6  2  4C 0D BB     	jmp	trns
00BEA9  2               ;terminator for relocation
00BEA9  2  FF           	.byte	$ff
00BEAA  2               ;messages
00BEAA  2               msgtbl:
00BEAA  2  00           	.byte 0
00BEAB  2               nospms	=	*-msgtbl
00BEAB  2  4E 4F 20 53  	.byte	"NO SPACE",0
00BEAF  2  50 41 43 45  
00BEB3  2  00           
00BEB4  2               ntclms	=	*-msgtbl
00BEB4  2  43 41 4E 20  	.byte "CAN NOT CLOSE",0
00BEB8  2  4E 4F 54 20  
00BEBC  2  43 4C 4F 53  
00BEC2  2               alflms	=	*-msgtbl
00BEC2  2  41 4C 4C 20  	.byte "ALL FILES (Y/N)?",0
00BEC6  2  46 49 4C 45  
00BECA  2  53 20 28 59  
00BED3  2               rderms	=	*-msgtbl
00BED3  2  52 45 41 44  	.byte	"READ ERROR",0
00BED7  2  20 45 52 52  
00BEDB  2  4F 52 00     
00BEDE  2               ntfnms	=	*-msgtbl
00BEDE  2  4E 4F 54 20  	.byte	"NOT FOUND",0
00BEE2  2  46 4F 55 4E  
00BEE6  2  44 00        
00BEE8  2               flexms	=	*-msgtbl
00BEE8  2  46 49 4C 45  	.byte "FILE EXISTS",0
00BEEC  2  20 45 58 49  
00BEF0  2  53 54 53 00  
00BEF4  2               lderms	=	*-msgtbl
00BEF4  2  4C 4F 41 44  	.byte "LOAD ERROR",0
00BEF8  2  20 45 52 52  
00BEFC  2  4F 52 00     
00BEFF  2               cnnoms	=	*-msgtbl
00BEFF  2  43 41 4E 20  	.byte "CAN NOT OPEN",0
00BF03  2  4E 4F 54 20  
00BF07  2  4F 50 45 4E  
00BF0C  2               wrerms	=	*-msgtbl
00BF0C  2  57 52 49 54  	.byte "WRITE ERROR",0
00BF10  2  45 20 45 52  
00BF14  2  52 4F 52 00  
00BF18  2               ;function name table
00BF18  2  44 49 52 20  fnctbl:	.byte	"DIR ",0
00BF1C  2  00           
00BF1D  2  53 41 56 45  	.byte	"SAVE ",0
00BF21  2  20 00        
00BF23  2  45 52 41 20  	.byte	"ERA ",0
00BF27  2  00           
00BF28  2  54 59 50 45  	.byte	"TYPE ",0
00BF2C  2  20 00        
00BF2E  2  52 45 4E 20  	.byte	"REN ",0
00BF32  2  00           
00BF33  2  47 4F 20 00  	.byte	"GO ",0
00BF37  2  4C 4F 41 44  	.byte	"LOAD ",0
00BF3B  2  20 00        
00BF3D  2               ;input buffer
00BF3D  2               cnsbuf:
00BF3D  2  7F           cnsmax: .byte 127
00BF3E  2  00           cnslng: .byte 0
00BF3F  2               cnstxt:
00BF3F  2  xx xx xx xx  	.res 127
00BF43  2  xx xx xx xx  
00BF47  2  xx xx xx xx  
00BFBE  2               ;fcb one
00BFBE  2               fcbone:
00BFBE  2  xx xx xx xx  	.res 33
00BFC2  2  xx xx xx xx  
00BFC6  2  xx xx xx xx  
00BFDF  2               ;com type field
00BFDF  2  43 4F 4D     typcom:	.byte	"COM"
00BFE2  2               ;variable storage
00BFE2  2  00           cnbfpt:	.byte	0		;buffer index
00BFE3  2  00           dfldsk:	.byte	0		;default drive
00BFE4  2  00           tmpdsk:	.byte	0		;temporary dvive
00BFE5  2               ;align vector on word boundary
00BFE5  2  xx           	.align 2
00BFE6  2  00 00        vector:	.word	0		;execution vector
00BFE8  2  00           ccmcount:	.byte	0		;counter
00BFE9  2  00           curpnt:	.byte	0		;input parse start
00BFEA  2  00           diradd:	.byte	0		;directory number
00BFEB  2  00           savx:	.byte	0		;save x location
00BFEC  2  00           savy:	.byte	0		;save y location
00BFED  2  00           length:	.byte	0		;number tages to save
00BFEE  2  00           oldtmp:	.byte	0		;temp drive in ren
00BFEF  2  00 08        dskbuf:	.word	tea		;disk buffer start
00BFF1  2  00           across:	.byte	0		;dir count on line
00BFF2  2  00           sixten:	.byte	0		;line length div 16
00BFF3  2  09           moduls:	.byte	9		;modulus-1 for number input
00BFF4  2  00 00        num:	.word	0		;input number
00BFF6  2  00 00        tnum:	.word	0		;temp in bldnum
00BFF8  2  00 08        sadr:	.word	tea		;save start address
00BFFA  2               
00BFFA  1               		.include "PEM215.ASM"
00BFFA  2               ;-------------------------------
00BFFA  2               ;dos/65 primitive execution module (pem)
00BFFA  2               ;-------------------------------
00BFFA  2               ;zero page data storage
00BFFA  2               addinp	=	$02		;initialized to a,y
00BFFA  2               bufadd	=	$04		;buffer address
00BFFA  2               alcpnt	=	$06		;allocation map pointer
00BFFA  2               chkpnt	=	$08		;checksum map pointer
00BFFA  2               numvar	=	8		;eight bytes
00BFFA  2               ;main program
00BFFA  2               ; input:x=command,a=value,a&y=address
00BFFA  2               ; returns:a=value,a&y=address
00BFFA  2               ; alters:all
00BFFA  2               pem:
00BFFA  2  D8           	cld			;set binary mode
00BFFB  2  8D 8E CB     	sta	bytinp		;save input
00BFFE  2  8D D2 CB     	sta	lowin		;value and
00C001  2  8C 8F CB     	sty	bytinp+1	;save high
00C004  2  8C D3 CB     	sty	lowin+1		;address
00C007  2  8E 90 CB     	stx	cmdinp		;and command
00C00A  2  E0 24        	cpx	#numcmd		;if invalid
00C00C  2  B0 50        	bcs	extpem		;then exit
00C00E  2  BD 4A CB     	lda	swctbl,x	;if flag zero
00C011  2  F0 08        	beq	noswin		;skip switch
00C013  2  A9 FF        	lda	#255		;else set
00C015  2  8D 8D CB     	sta	swcflg		;memory switch flag
00C018  2  20 E5 C2     	jsr	switch		;move data to page zero
00C01B  2  A9 00        noswin:	lda	#0		;clear drive
00C01D  2  8D 95 CB     	sta	tmpdrv		;switch flag
00C020  2  AD 90 CB     	lda	cmdinp		;get command
00C023  2  0A           	asl	a		;multiply by two
00C024  2  6D 90 CB     	adc	cmdinp		;then add to get x3
00C027  2  AA           	tax			;and make a pointer
00C028  2  E8           	inx			;bump to pass jmp
00C029  2  BD 72 C0     	lda	cmdtbl,x	;get command
00C02C  2  BC 73 C0     	ldy	cmdtbl+1,x	;address
00C02F  2  8D 96 CB     	sta	xqtvec		;and put
00C032  2  8C 97 CB     	sty	xqtvec+1	;in vector
00C035  2  AD DA CA     	lda	extevc+1	;get return
00C038  2  48           	pha			;address
00C039  2  AD D9 CA     	lda	extevc		;and push
00C03C  2  48           	pha			;as return
00C03D  2  AD 8E CB     	lda	bytinp		;get input value
00C040  2  AC 8F CB     	ldy	bytinp+1
00C043  2  6C 96 CB     	jmp	(xqtvec)	;then execute
00C046  2  8D 91 CB     extexq:	sta	bytout		;save value
00C049  2  8C 92 CB     	sty	addout+1	;and address
00C04C  2  AD 95 CB     	lda	tmpdrv		;get temp drive
00C04F  2  F0 0D        	beq	extpem		;if zero skip switch
00C051  2  A0 00        	ldy	#0		;else
00C053  2  91 02        	sta	(addinp),y	;put back in fcb
00C055  2  AD 9F CB     	lda	olddrv		;get old drive number
00C058  2  8D 8E CB     	sta	bytinp		;set input value
00C05B  2  20 00 C3     	jsr	chgdrv		;then switch back
00C05E  2  2C 8D CB     extpem:	bit	swcflg		;test memory switch
00C061  2  10 08        	bpl	noswot		;if not set skip
00C063  2  20 E5 C2     	jsr	switch		;else do memory switch
00C066  2  A9 00        	lda	#0		;clear
00C068  2  8D 8D CB     	sta	swcflg		;flag
00C06B  2  AC 92 CB     noswot:	ldy	addout+1	;get address
00C06E  2  AD 91 CB     	lda	bytout		;and value (address low)
00C071  2  60           	rts
00C072  2               ;command vector table
00C072  2  4C E6 C0     cmdtbl:	jmp	xwboot		;warm boot
00C075  2  4C D7 C2     	jmp	xcnsin		;console input with echo
00C078  2  4C 0F C9     	jmp	sndchr		;console output
00C07B  2  4C 5A CC     	jmp	sim+21		;tape reader
00C07E  2  4C 57 CC     	jmp	sim+18		;tape punch
00C081  2  4C 54 CC     	jmp	sim+15		;printer output
00C084  2  4C 81 C8     	jmp	getcon		;console input w/o echo
00C087  2  4C 1B C1     	jmp	xgtios		;read i/o status
00C08A  2  4C 26 C1     	jmp	xstios		;set i/o status
00C08D  2  4C C6 C8     	jmp	sndstr		;print buffer
00C090  2  4C 7B C9     	jmp	bufinp		;read buffer
00C093  2  4C 91 C8     	jmp	kbdsts		;test console ready
00C096  2  4C 72 CC     	jmp	sim+45		;read list status
00C099  2  4C 2E C3     	jmp	xintds		;initialize system
00C09C  2  4C 00 C3     	jmp	chgdrv		;log in drive
00C09F  2  4C AB C5     	jmp	xopen		;open file
00C0A2  2  4C E6 C5     	jmp	xclose		;close file
00C0A5  2  4C 0A C6     	jmp	xfndfr		;find first match
00C0A8  2  4C 36 C1     	jmp	xfndnx		;find next match
00C0AB  2  4C 9E C1     	jmp	xdltfl		;delete file
00C0AE  2  4C 3E C1     	jmp	xread		;read record
00C0B1  2  4C C3 C1     	jmp	xwrite		;write record
00C0B4  2  4C AD C6     	jmp	xmake		;create file
00C0B7  2  4C 7C C1     	jmp	xrenme		;rename file
00C0BA  2  4C 2E C1     	jmp	xintlg		;interrogate log in status
00C0BD  2  4C 2A C1     	jmp	xintdr		;interrogate current drive
00C0C0  2  4C F5 C2     	jmp	chgdma		;set buffer address
00C0C3  2  4C 1F C1     	jmp	xrdalv		;read allocation map start
00C0C6  2  4C 69 C5     	jmp	setron		;set r/w status
00C0C9  2  4C 32 C1     	jmp	xrdros		;read r/w status
00C0CC  2  4C DE C0     	jmp	setlst		;set list echo status
00C0CF  2  4C E2 C0     	jmp	lststs		;read list echo status
00C0D2  2  4C F6 C0     	jmp	xrtclo		;read low clock
00C0D5  2  4C 0A C1     	jmp	xrtchi		;read high clock
00C0D8  2  4C 14 C1     	jmp	xrddcb		;read dcb address
00C0DB  2  4C 78 CC     	jmp	sim+51		;translate sector
00C0DE  2               ;set list echo status
00C0DE  2  8D 8B CB     setlst:	sta	lstflg		;set flag
00C0E1  2  60           	rts
00C0E2  2               ;read list echo status
00C0E2  2  AD 8B CB     lststs:	lda	lstflg		;read flag
00C0E5  2  60           	rts
00C0E6  2               ;execute warm boot
00C0E6  2               ; ***this command does not return to pem***
00C0E6  2               ; ***instead it jumps to sim, resets	***
00C0E6  2               ; ***system and stack and jumps to ccm. ***
00C0E6  2  2C 8D CB     xwboot:	bit	swcflg		;test memory switch flag
00C0E9  2  10 08        	bpl	dowmbt		;if clear do not
00C0EB  2  20 E5 C2     	jsr	switch		;switch memory
00C0EE  2  A9 00        	lda	#0		;clear
00C0F0  2  8D 8D CB     	sta	swcflg		;flag
00C0F3  2  4C 48 CC     dowmbt:	jmp	sim+3		;go to sim
00C0F6  2               
00C0F6  2               ;execute read real time clock
00C0F6  2  20 75 CC     xrtclo:	jsr	sim+48		;read clock
00C0F9  2               
00C0F9  2  8D BB CB     	sta	rtclk		;save low
00C0FC  2  8C BC CB     	sty	rtclk+1		;middle
00C0FF  2  8E BD CB     	stx	rtclk+2		;high
00C102  2  8A           	txa
00C103  2  29 80        	and	#%10000000	;test for valid
00C105  2  A8           	tay
00C106  2  AD BB CB     	lda	rtclk		;get low
00C109  2  60           	rts
00C10A  2               ;execute read real time clock high
00C10A  2  AD BD CB     xrtchi:	lda	rtclk+2		;get high
00C10D  2  29 7F        	and	#%01111111	;clear status
00C10F  2  A8           	tay
00C110  2  AD BC CB     	lda	rtclk+1		;get middle
00C113  2  60           	rts
00C114  2               ;execute read dcb address
00C114  2  AD 68 C3     xrddcb:	lda	cptdcb+1	;get address
00C117  2  AC 69 C3     	ldy	cptdcb+2
00C11A  2  60           	rts
00C11B  2               ;execute read i/o status
00C11B  2  AD 06 01     xgtios:	lda	iostat		;get status byte
00C11E  2  60           	rts
00C11F  2               ;execute read allocation map starting address
00C11F  2  AD CA CB     xrdalv:	lda	alcmap		;get
00C122  2  AC CB CB     	ldy	alcmap+1	;starting address
00C125  2  60           	rts			;then return
00C126  2               ;execute set i/o status
00C126  2  8D 06 01     xstios:	sta	iostat		;set status
00C129  2  60           	rts
00C12A  2               ;execute interrogate current drive
00C12A  2  AD A0 CB     xintdr:	lda	curdrv		;get number
00C12D  2  60           	rts
00C12E  2               ;execute read log in status
00C12E  2  AD A1 CB     xintlg:	lda	lginvc		;get status
00C131  2  60           	rts
00C132  2               ;execute read read/write status
00C132  2  AD A2 CB     xrdros:	lda	ronlst		;get status
00C135  2  60           	rts
00C136  2               ;execute find next match
00C136  2  20 0E C3     xfndnx:	jsr	autodr		;auto drive select
00C139  2  A9 0D        	lda	#13		;match including
00C13B  2  4C 17 C6     	jmp	search		;extent
00C13E  2               ;execute read next record
00C13E  2  20 0E C3     xread:	jsr	autodr		;auto drive select
00C141  2  20 8B C5     	jsr	inrcct		;initialize record counters
00C144  2  AD AB CB     	lda	nxtrec		;if next record less
00C147  2  CD AC CB     	cmp	numrec		;then number records
00C14A  2  90 13        	bcc	tryrde		;then try to read
00C14C  2  C9 80        	cmp	#128		;but if not and
00C14E  2  F0 03        	beq	tryext		;is max try to extend
00C150  2  A9 01        rdeeof:	lda	#1		;else set eof
00C152  2  60           	rts			;code and return
00C153  2  A2 01        tryext:	ldx	#1		;try for a read
00C155  2  20 E9 C6     	jsr	extend		;file extension
00C158  2  C9 00        	cmp	#0		;if not ok exit eof
00C15A  2  D0 F4        	bne	rdeeof		;with jump back
00C15C  2  8D AB CB     	sta	nxtrec		;clear next record
00C15F  2  20 7A C7     tryrde:	jsr	getblk		;and get block
00C162  2  AD A6 CB     	lda	blknum		;if block not zero
00C165  2  0D A7 CB     	ora	blknum+1
00C168  2  D0 03        	bne	dorde		;do the read
00C16A  2  A9 02        	lda	#2		;else set unwritten
00C16C  2  60           	rts			;code and exit
00C16D  2  20 5C C6     dorde:	jsr	calrcn		;calculate record number
00C170  2  20 A8 C4     	jsr	sttrsc		;set track and sector
00C173  2  20 33 C8     	jsr	rdesec		;do sector read
00C176  2  20 9A C5     	jsr	updtrc		;update counters
00C179  2  A9 00        	lda	#0		;return w/o error
00C17B  2  60           extrde:	rts
00C17C  2               ;execute file rename
00C17C  2  20 0E C3     xrenme:	jsr	autodr		;automatic drive select
00C17F  2  20 10 C8     	jsr	tstron		;test for r/o
00C182  2  A9 0C        	lda	#12		;match name
00C184  2  20 0F C6     	jsr	frstsr		;and type
00C187  2  30 14        	bmi	extren		;exit if not found
00C189  2  A9 00        doren:	lda	#0		;clear drive select
00C18B  2  A0 10        	ldy	#16		;in new name
00C18D  2  91 02        	sta	(addinp),y	;part of fcb
00C18F  2  A9 0C        	lda	#12		;then move
00C191  2  A2 10        	ldx	#16		;new name
00C193  2  20 7C C6     	jsr	dirchg		;to directory
00C196  2  A9 0C        	lda	#12		;see if
00C198  2  20 17 C6     	jsr	search		;another match
00C19B  2  10 EC        	bpl	doren		;loop if found
00C19D  2  60           extren:	rts			;number
00C19E  2               ;execute delete file
00C19E  2  20 0E C3     xdltfl:	jsr	autodr		;automatic drive select
00C1A1  2  20 10 C8     	jsr	tstron		;test for r/o
00C1A4  2  A9 0C        	lda	#12		;match name
00C1A6  2  20 0F C6     	jsr	frstsr		;and type
00C1A9  2  30 17        	bmi	extdlt		;done if not found
00C1AB  2  A2 00        dodlt:	ldx	#0		;else do a
00C1AD  2  20 E0 C7     	jsr	mapdir		;delete
00C1B0  2  AC A5 CB     	ldy	subrec		;then change
00C1B3  2  AD 49 CB     	lda	empty		;byte zero to
00C1B6  2  91 04        	sta	(bufadd),y	;empty code
00C1B8  2  20 39 C8     	jsr	updtck		;then update directory
00C1BB  2  A9 0C        	lda	#12		;search
00C1BD  2  20 17 C6     	jsr	search		;for next
00C1C0  2  10 E9        	bpl	dodlt		;loop if found
00C1C2  2  60           extdlt:	rts			;exit
00C1C3  2               ;execute write next record
00C1C3  2  20 0E C3     xwrite:	jsr	autodr		;automatic drive select
00C1C6  2  20 10 C8     	jsr	tstron		;test for r/o
00C1C9  2  20 8B C5     	jsr	inrcct		;initialize counters
00C1CC  2  AD AB CB     	lda	nxtrec		;get next record
00C1CF  2  C9 80        	cmp	#128		;compare to max
00C1D1  2  90 03        	bcc	ntexte		;continue if less
00C1D3  2  A9 01        	lda	#1		;else flag as extend
00C1D5  2  60           	rts			;error and exit
00C1D6  2  20 7A C7     ntexte:	jsr	getblk		;calculate block num
00C1D9  2  A9 00        	lda	#0		;say normal write
00C1DB  2  8D CF CB     	sta	pemwrtype		;for now
00C1DE  2  AD A6 CB     	lda	blknum		;get it and if
00C1E1  2  0D A7 CB     	ora	blknum+1
00C1E4  2  F0 03        	beq	*+5		;zero then get number
00C1E6  2  4C A6 C2     	jmp	blkopn		;else go write
00C1E9  2  A9 02        	lda	#2		;say unalloc write
00C1EB  2  8D CF CB     	sta	pemwrtype
00C1EE  2  AD 87 CB     	lda	fcbind		;get index from prior
00C1F1  2  48           	pha			;and save
00C1F2  2  C9 10        	cmp	#16		;if first block
00C1F4  2  F0 1A        	beq	isfrst		;then don't change
00C1F6  2  A8           	tay			;else make an index
00C1F7  2  88           	dey			;point to last
00C1F8  2  2C B6 CB     	bit	blmode		;test mode
00C1FB  2  10 01        	bpl	*+3		;done if byte
00C1FD  2  88           	dey			;else drop for word
00C1FE  2  B1 02        	lda	(addinp),y	;and get that number
00C200  2  8D A6 CB     	sta	blknum		;store as starting
00C203  2  C8           	iny			;bump for word
00C204  2  A9 00        	lda	#0		;preset for byte
00C206  2  2C B6 CB     	bit	blmode		;test mode
00C209  2  10 02        	bpl	*+4		;done if byte
00C20B  2  B1 02        	lda	(addinp),y	;else get high
00C20D  2  8D A7 CB     	sta	blknum+1	;then set high
00C210  2  AD A6 CB     isfrst:	lda	blknum		;get block
00C213  2  8D 9B CB     	sta	lkdown		;set lower and
00C216  2  8D 9D CB     	sta	lookup		;upper pointers
00C219  2  AD A7 CB     	lda	blknum+1	;now set high part
00C21C  2  8D 9C CB     	sta	lkdown+1
00C21F  2  8D 9E CB     	sta	lookup+1
00C222  2  AD 9D CB     srblag:	lda	lookup		;if upper pointer
00C225  2  CD C1 CB     	cmp	maxblk		;not at max
00C228  2  D0 08        	bne	upnemx		;then keep going
00C22A  2  AC 9E CB     	ldy	lookup+1	;now check high
00C22D  2  CC C2 CB     	cpy	maxblk+1
00C230  2  F0 12        	beq	tstdwn		;go test down
00C232  2  EE 9D CB     upnemx:	inc	lookup		;else bump upper
00C235  2  D0 03        	bne	*+5
00C237  2  EE 9E CB     	inc	lookup+1
00C23A  2  AD 9B CB     	lda	lkdown		;then if lower
00C23D  2  0D 9C CB     	ora	lkdown+1
00C240  2  F0 18        	beq	dotest		;is zero start test
00C242  2  D0 0B        	bne	dcdown		;else drop lower
00C244  2  AD 9B CB     tstdwn:	lda	lkdown		;if upper & lower at
00C247  2  0D 9C CB     	ora	lkdown+1
00C24A  2  D0 03        	bne	dcdown		;drop if not zero
00C24C  2  A8           	tay			;also set y
00C24D  2  F0 30        	beq	extsbl		;then exit
00C24F  2  AD 9B CB     dcdown:	lda	lkdown		;drop lower
00C252  2  D0 03        	bne	*+5
00C254  2  CE 9C CB     	dec	lkdown+1
00C257  2  CE 9B CB     	dec	lkdown
00C25A  2  AD 9B CB     dotest:	lda	lkdown		;get lower
00C25D  2  AC 9C CB     	ldy	lkdown+1
00C260  2  20 4D C5     	jsr	tstblk		;and test
00C263  2  D0 09        	bne	trylup		;if full try upper
00C265  2  AD 9B CB     	lda	lkdown		;else use lower
00C268  2  AC 9C CB     	ldy	lkdown+1
00C26B  2  4C 7F C2     	jmp	extsbl		;as result
00C26E  2  AD 9D CB     trylup:	lda	lookup		;get upper
00C271  2  AC 9E CB     	ldy	lookup+1
00C274  2  20 4D C5     	jsr	tstblk		;if full
00C277  2  D0 A9        	bne	srblag		;then loop
00C279  2  AD 9D CB     	lda	lookup		;else use upper
00C27C  2  AC 9E CB     	ldy	lookup+1
00C27F  2  8D A6 CB     extsbl:	sta	blknum		;then save number
00C282  2  8C A7 CB     	sty	blknum+1
00C285  2  0D A7 CB     	ora	blknum+1	;see if zero
00C288  2  D0 04        	bne	gtgood		;then proceed
00C28A  2  68           	pla			;clear stack
00C28B  2  A9 02        	lda	#2		;set end
00C28D  2  60           	rts			;of data return
00C28E  2  AD A6 CB     gtgood:	lda	blknum		;get low again
00C291  2  20 61 C5     	jsr	setblk		;set allocation map
00C294  2  68           	pla			;get block
00C295  2  A8           	tay			;pointer back
00C296  2  AD A6 CB     	lda	blknum		;get number
00C299  2  91 02        	sta	(addinp),y	;and put in fcb
00C29B  2  AD A7 CB     	lda	blknum+1	;get high
00C29E  2  C8           	iny
00C29F  2  2C B6 CB     	bit	blmode		;test mode
00C2A2  2  10 02        	bpl	*+4		;done if byte
00C2A4  2  91 02        	sta	(addinp),y	;else set high
00C2A6  2  20 5C C6     blkopn:	jsr	calrcn		;calculate record num
00C2A9  2  20 A8 C4     	jsr	sttrsc		;set track and sector
00C2AC  2  20 3F C8     	jsr	wrtsec		;do write
00C2AF  2  AE AB CB     	ldx	nxtrec		;get next record
00C2B2  2  EC AC CB     	cpx	numrec		;if less than max
00C2B5  2  90 05        	bcc	notful		;then ok
00C2B7  2  E8           	inx			;else bump count
00C2B8  2  8E AC CB     	stx	numrec		;and save
00C2BB  2  CA           	dex			;back down
00C2BC  2  E0 7F        notful:	cpx	#127		;if not at max
00C2BE  2  D0 11        	bne	noawex		;skip extending
00C2C0  2  20 9A C5     	jsr	updtrc		;update record counters
00C2C3  2  A2 00        	ldx	#0		;do write
00C2C5  2  20 E9 C6     	jsr	extend		;file extension
00C2C8  2  C9 00        	cmp	#0		;if not ok
00C2CA  2  D0 0A        	bne	extwrt		;exit
00C2CC  2  A9 FF        	lda	#255		;else start counter
00C2CE  2  8D AB CB     	sta	nxtrec		;at one short
00C2D1  2  20 9A C5     noawex:	jsr	updtrc		;then update counters
00C2D4  2  A9 00        	lda	#0		;good return
00C2D6  2  60           extwrt:	rts			;exit
00C2D7  2               ;execute console input
00C2D7  2  20 81 C8     xcnsin:	jsr	getcon		;get input
00C2DA  2  20 B7 C8     	jsr	tstchr		;test it and
00C2DD  2  90 05        	bcc	extxci		;if control exit
00C2DF  2  48           	pha			;else save
00C2E0  2  20 0F C9     	jsr	sndchr		;echo
00C2E3  2  68           	pla			;restore
00C2E4  2  60           extxci:	rts			;return
00C2E5  2               ;switch memory
00C2E5  2               ;page zero block begins at $02 and is numvar bytes long.
00C2E5  2  A2 07        switch:	ldx	#numvar-1	;get number to switch
00C2E7  2  B5 02        nxtswh:	lda	2,x		;get zero page
00C2E9  2  BC D2 CB     	ldy	varblk,x	;and save area
00C2EC  2  9D D2 CB     	sta	varblk,x	;save zero
00C2EF  2  94 02        	sty	2,x		;and high
00C2F1  2  CA           	dex			;count down
00C2F2  2  10 F3        	bpl	nxtswh		;and loop until done
00C2F4  2  60           drvsme:	rts			;then return
00C2F5  2               ;change dma address
00C2F5  2               ; input:addinp=address
00C2F5  2               ; returns:none
00C2F5  2               ; alters:all
00C2F5  2  A5 02        chgdma:	lda	addinp		;get low
00C2F7  2  A4 03        	ldy	addinp+1	;and high address
00C2F9  2  85 04        	sta	bufadd		;then store
00C2FB  2  84 05        	sty	bufadd+1	;in address
00C2FD  2  4C 69 CC     	jmp	sim+36		;then go to sim
00C300  2               
00C300  2               ;change drive
00C300  2               ; input:bytinp
00C300  2               ; returns:none
00C300  2               ; alters:all
00C300  2  AD 8E CB     chgdrv:	lda	bytinp		;get input
00C303  2  CD A0 CB     	cmp	curdrv		;if same as current
00C306  2  F0 EC        	beq	drvsme		;do nothing
00C308  2  8D A0 CB     	sta	curdrv		;else change current
00C30B  2  4C 41 C3     	jmp	mapdrv		;then log it in
00C30E  2               ;automatic drive select
00C30E  2               ; input:(addinp) 0=no change
00C30E  2               ; 1-8 or 'A'-'H' = change
00C30E  2               ; returns:none
00C30E  2               ; alters:all
00C30E  2  A0 00        autodr:	ldy	#0		;get
00C310  2  B1 02        	lda	(addinp),y	;first byte of fcb
00C312  2  F0 19        	beq	qtatdr		;if zero quit
00C314  2  38           	sec			;set carry for
00C315  2  E9 01        	sbc	#1		;subtract one
00C317  2  29 07        	and	#%00000111	;look at three lsbs
00C319  2  8D 8E CB     	sta	bytinp		;make parameter
00C31C  2  AD A0 CB     	lda	curdrv		;get current
00C31F  2  8D 9F CB     	sta	olddrv		;and save
00C322  2  B1 02        	lda	(addinp),y	;get fcb entry
00C324  2  8D 95 CB     	sta	tmpdrv		;and save as flag
00C327  2  98           	tya			;set a to 0
00C328  2  91 02        	sta	(addinp),y	;clear byte zero in fcb
00C32A  2  20 00 C3     	jsr	chgdrv		;then select new drive
00C32D  2  60           qtatdr:	rts			;and return
00C32E  2               ;execute initialize system
00C32E  2               ; input:none
00C32E  2               ; returns:none
00C32E  2               ; alters:all,curdrv,lginvc,bufadd
00C32E  2  A9 02        xintds:	lda	#DEFDRV		;set current
00C330  2  8D A0 CB     	sta	curdrv		;drive to a
00C333  2  8D A1 CB     	sta	lginvc		;clear log in status
00C336  2  A9 28        	lda	#<dflbuf	;get default buffer
00C338  2  A0 01        	ldy	#>dflbuf	;address
00C33A  2  85 02        	sta	addinp		;and set up
00C33C  2  84 03        	sty	addinp+1	;parameters
00C33E  2  20 F5 C2     	jsr	chgdma		;change address
00C341  2               
00C341  2               ;log in drive and set pointers and maps
00C341  2               ; input:curdrv
00C341  2               ; returns:none
00C341  2               ; alters:all
00C341  2  AD A0 CB     mapdrv:	lda	curdrv		;if current drive
00C344  2  C9 08        	cmp	#8		;is 0 to 7
00C346  2  90 0F        	bcc	vlddrv		;then log it in
00C348  2  20 62 C8     drserr:	jsr	errout		;send error message
00C34B  2  AD DC CA     	lda	sltmvc		;point to
00C34E  2  AC DD CA     	ldy	sltmvc+1	;select message
00C351  2  20 C6 C8     	jsr	sndstr		;and send it
00C354  2               
00C354  2  4C E6 C0     	jmp	xwboot		;and abort
00C357  2               
00C357  2  20 60 CC     vlddrv:	jsr	sim+27		;go to sim to set
00C35A  2  8D 68 C3     	sta	cptdcb+1	;save
00C35D  2  8C 69 C3     	sty	cptdcb+2
00C360  2  0D 69 C3     	ora	cptdcb+2	;see if invalid
00C363  2  F0 E3        	beq	drserr		;error if is
00C365  2               ;capture dcb
00C365  2  A0 0D        	ldy	#14-1		;do 14 bytes
00C367  2  B9 FF FF     cptdcb:	lda	$ffff,y		;get value from sim
00C36A  2  99 C1 CB     	sta	dcb,y		;store it
00C36D  2  88           	dey
00C36E  2  10 F7        	bpl	cptdcb		;loop for more
00C370  2  AD C7 CB     	lda	blkscd		;get block size code
00C373  2  A8           	tay			;save in y
00C374  2  18           	clc
00C375  2  69 03        	adc	#3		;convert to sxb
00C377  2  8D BA CB     	sta	sxb		;and save
00C37A  2  B9 81 CB     	lda	sabtbl,y	;get sab
00C37D  2  8D B9 CB     	sta	sab		;and set
00C380  2  AD C8 CB     	lda	maxdir		;get max dir
00C383  2  8D B7 CB     	sta	maxdrc		;set max dir record
00C386  2  AD C9 CB     	lda	maxdir+1
00C389  2  4A           	lsr	a		;divide by 4
00C38A  2  6E B7 CB     	ror	maxdrc
00C38D  2  4A           	lsr	a
00C38E  2  6E B7 CB     	ror	maxdrc
00C391  2  8D B8 CB     	sta	maxdrc+1	;then save high
00C394  2  A9 00        	lda	#0		;set mode to byte
00C396  2  8D B6 CB     	sta	blmode
00C399  2  AD C2 CB     	lda	maxblk+1	;branch if max block
00C39C  2  F0 05        	beq	ntm255		;not over 255
00C39E  2               ;if y=0 when the following line is executed it means
00C39E  2               ;that the user has put an illegal combination into
00C39E  2               ;the disk definition table. may want to consider
00C39E  2               ;putting some error checking here in the future if
00C39E  2               ;there is space in pem.
00C39E  2  88           	dey			;back up index
00C39F  2  38           	sec			;else set mode to word
00C3A0  2  6E B6 CB     	ror	blmode
00C3A3  2  B9 7E CB     ntm255:	lda	exmtbl,y	;get extent mask
00C3A6  2  8D D0 CB     	sta	exm
00C3A9  2               
00C3A9  2  38           	sec			;now calculate cexm1f
00C3AA  2  A9 1F        	lda	#31
00C3AC  2  F9 7E CB     	sbc	exmtbl,y
00C3AF  2  8D D1 CB     	sta	cexm1f
00C3B2  2  AE A0 CB     	ldx	curdrv		;get drive as pointer
00C3B5  2  BD 76 CB     	lda	bitmap,x	;get bit
00C3B8  2  2D A1 CB     	and	lginvc		;if logged in
00C3BB  2  D0 0C        	bne	extstm		;then exit
00C3BD  2  BD 76 CB     	lda	bitmap,x	;get bit back
00C3C0  2  0D A1 CB     	ora	lginvc		;set in log-in
00C3C3  2  8D A1 CB     	sta	lginvc		;and update
00C3C6  2  4C CA C3     	jmp	flinal		;then fill in maps
00C3C9  2               
00C3C9  2  60           extstm:	rts			;and return
00C3CA  2               ;fill in allocation map
00C3CA  2  20 24 C8     flinal:	jsr	setrw		;set to read/write
00C3CD  2  AD C1 CB     	lda	maxblk		;divide max block by
00C3D0  2  8D BE CB     	sta	gpcnt		;eight to get max
00C3D3  2  AD C2 CB     	lda	maxblk+1
00C3D6  2  A2 03        	ldx	#3
00C3D8  2  4A           clcnab:	lsr	a		;use a for speed
00C3D9  2  6E BE CB     	ror	gpcnt
00C3DC  2  CA           	dex
00C3DD  2  D0 F9        	bne	clcnab		;loop if more
00C3DF  2  8D BF CB     	sta	gpcnt+1		;save high
00C3E2  2  EE BE CB     	inc	gpcnt		;bump by one
00C3E5  2  D0 03        	bne	*+5
00C3E7  2  EE BF CB     	inc	gpcnt+1		;with carry
00C3EA  2  AD CA CB     	lda	alcmap		;get map start
00C3ED  2  AC CB CB     	ldy	alcmap+1
00C3F0  2  85 06        	sta	alcpnt		;set pointer to start
00C3F2  2  84 07        	sty	alcpnt+1
00C3F4  2  A0 00        	ldy	#0		;clear index
00C3F6  2  A9 00        clraml:	lda	#0		;clear byte
00C3F8  2  91 06        	sta	(alcpnt),y	;put in map
00C3FA  2  E6 06        	inc	alcpnt		;bump pointer
00C3FC  2  D0 02        	bne	*+4
00C3FE  2  E6 07        	inc	alcpnt+1	;with carry
00C400  2  AD BE CB     	lda	gpcnt		;get low of count
00C403  2  D0 03        	bne	*+5		;skip if not zero
00C405  2  CE BF CB     	dec	gpcnt+1		;else drop high
00C408  2  CE BE CB     	dec	gpcnt		;always drop low
00C40B  2  AD BE CB     	lda	gpcnt		;test for zero
00C40E  2  0D BF CB     	ora	gpcnt+1
00C411  2  D0 E3        	bne	clraml		;loop if more
00C413  2               ;at this point complete map is cleared
00C413  2  AD B7 CB     	lda	maxdrc		;get low of max dir record
00C416  2  8D BE CB     	sta	gpcnt
00C419  2  AD B8 CB     	lda	maxdrc+1	;high in a
00C41C  2  AE BA CB     	ldx	sxb		;set x according to block size
00C41F  2  4A           clcmdb:	lsr	a		;do division
00C420  2  6E BE CB     	ror	gpcnt
00C423  2  CA           	dex
00C424  2  D0 F9        	bne	clcmdb		;until x is zero
00C426  2  8D BF CB     	sta	gpcnt+1		;set high
00C429  2  EE BE CB     	inc	gpcnt		;then bump by one
00C42C  2  D0 03        	bne	*+5
00C42E  2  EE BF CB     	inc	gpcnt+1
00C431  2  8E A6 CB     	stx	blknum		;clear block number
00C434  2  8E A7 CB     	stx	blknum+1
00C437  2  AD A6 CB     fildal:	lda	blknum		;get block number
00C43A  2  AC A7 CB     	ldy	blknum+1
00C43D  2  20 61 C5     	jsr	setblk		;set bit
00C440  2  EE A6 CB     	inc	blknum		;bump block number
00C443  2  D0 03        	bne	*+5
00C445  2  EE A7 CB     	inc	blknum+1
00C448  2  AD BE CB     	lda	gpcnt		;get low of count
00C44B  2  D0 03        	bne	*+5		;skip if not zero
00C44D  2  CE BF CB     	dec	gpcnt+1		;else drop high
00C450  2  CE BE CB     	dec	gpcnt		;always do low
00C453  2  AD BE CB     	lda	gpcnt		;test for zero
00C456  2  0D BF CB     	ora	gpcnt+1
00C459  2  D0 DC        	bne	fildal		;loop if more
00C45B  2               ;at this point directory space is mapped
00C45B  2  20 7A C4     	jsr	intdrv		;initialize drive
00C45E  2  20 D4 C7     	jsr	cldrnm		;clear directory number
00C461  2  A2 01        fillpe:	ldx	#1		;parameter for fill
00C463  2  20 1C C7     	jsr	nxtdir		;execute for next directory
00C466  2  30 11        	bmi	extfil		;done if invalid
00C468  2  AC A5 CB     	ldy	subrec		;get offset
00C46B  2  B1 04        	lda	(bufadd),y	;get empty/valid flag
00C46D  2  C9 E5        	cmp	#$e5		;if empty
00C46F  2  F0 F0        	beq	fillpe		;try next
00C471  2  A2 01        	ldx	#1		;parameter for fill in
00C473  2  20 E0 C7     	jsr	mapdir		;do directory map
00C476  2  4C 61 C4     	jmp	fillpe		;then loop
00C479  2  60           extfil:	rts			;return
00C47A  2               ;initialize drive
00C47A  2               ; input:nsystr
00C47A  2               ; returns:none
00C47A  2               ; alters:all
00C47A  2  20 5D CC     intdrv:	jsr	sim+24		;home then
00C47D  2               
00C47D  2  AD C5 CB     	lda	nsystr		;get number of system tracks
00C480  2  AC C6 CB     	ldy	nsystr+1
00C483  2  4C 63 CC     	jmp	sim+30		;and set in sim
00C486  2               
00C486  2               ;directory record set up
00C486  2               ; input:dirnum
00C486  2               ; returns:none
00C486  2               ; alters:all,recnum,dirrec
00C486  2  AD A4 CB     drrcsu:	lda	dirnum+1	;move high dir number
00C489  2  8D A7 CB     	sta	recnum+1	;to record number
00C48C  2  AD A3 CB     	lda	dirnum		;divide
00C48F  2  4E A7 CB     	lsr	recnum+1	;directory by four
00C492  2  6A           	ror	a
00C493  2  4E A7 CB     	lsr	recnum+1
00C496  2  6A           	ror	a
00C497  2  8D AD CB     	sta	dirrec		;and save
00C49A  2  8D A6 CB     	sta	recnum		;set low record number
00C49D  2  AD A7 CB     	lda	recnum+1	;get high
00C4A0  2  8D AE CB     	sta	dirrec+1	;and set
00C4A3  2  A9 00        	lda	#0		;clear top byte
00C4A5  2  8D A8 CB     	sta	recnum+2
00C4A8  2               ;set track and sector
00C4A8  2               ; input:recnum
00C4A8  2               ; returns:none
00C4A8  2               ; alters:all,countr,trkctr
00C4A8  2  A2 00        sttrsc:	ldx	#0		;clear track counter
00C4AA  2  8E C0 CB     	stx	trkctr
00C4AD  2  8E 98 CB     	stx	countr		;and record
00C4B0  2  8E 99 CB     	stx	countr+1	;counter
00C4B3  2  8E 9A CB     	stx	countr+2
00C4B6  2  AD A6 CB     trnxtr:	lda	recnum		;from
00C4B9  2  CD 98 CB     	cmp	countr		;record number
00C4BC  2  AD A7 CB     	lda	recnum+1	;and if a
00C4BF  2  ED 99 CB     	sbc	countr+1	;borrow then
00C4C2  2  AD A8 CB     	lda	recnum+2
00C4C5  2  ED 9A CB     	sbc	countr+2
00C4C8  2  90 21        	bcc	higher		;gone too far
00C4CA  2  18           	clc			;else
00C4CB  2  AD 98 CB     	lda	countr		;get counter
00C4CE  2  6D C3 CB     	adc	sectrk		;add sectors per track
00C4D1  2  8D 98 CB     	sta	countr		;sectors per track
00C4D4  2  AD 99 CB     	lda	countr+1
00C4D7  2  6D C4 CB     	adc	sectrk+1
00C4DA  2  8D 99 CB     	sta	countr+1
00C4DD  2  90 03        	bcc	bumptr		;done if no carry
00C4DF  2  EE 9A CB     	inc	countr+2	;else bump high
00C4E2  2  E8           bumptr:	inx			;increase track count
00C4E3  2  D0 D1        	bne	trnxtr		;with carry
00C4E5  2  EE C0 CB     	inc	trkctr
00C4E8  2  4C B6 C4     	jmp	trnxtr		;then loop
00C4EB  2  CA           higher:	dex			;back up track
00C4EC  2  E0 FF        	cpx	#$ff		;see if wrap around
00C4EE  2  D0 03        	bne	*+5		;wasn't
00C4F0  2  CE C0 CB     	dec	trkctr		;else drop high
00C4F3  2  8A           	txa			;move to a
00C4F4  2  18           	clc			;add starting track
00C4F5  2  6D C5 CB     	adc	nsystr
00C4F8  2  AA           	tax			;save in x
00C4F9  2  AD C0 CB     	lda	trkctr
00C4FC  2  6D C6 CB     	adc	nsystr+1
00C4FF  2  A8           	tay			;move to correct registers
00C500  2  8A           	txa
00C501  2  20 63 CC     	jsr	sim+30		;then set in sim
00C504  2               
00C504  2  38           	sec			;back
00C505  2  AD 98 CB     	lda	countr		;counter down
00C508  2  ED C3 CB     	sbc	sectrk		;by sectors per track
00C50B  2  8D 98 CB     	sta	countr		;and save
00C50E  2  AD 99 CB     	lda	countr+1
00C511  2  ED C4 CB     	sbc	sectrk+1
00C514  2  8D 99 CB     	sta	countr+1
00C517  2  38           	sec			;now
00C518  2  AD A6 CB     	lda	recnum		;find difference
00C51B  2  ED 98 CB     	sbc	countr		;as sector
00C51E  2  AA           	tax			;save in x
00C51F  2  AD A7 CB     	lda	recnum+1
00C522  2  ED 99 CB     	sbc	countr+1
00C525  2  A8           	tay			;move to correct registers
00C526  2  8A           	txa
00C527  2  20 78 CC     	jsr	sim+51		;translate
00C52A  2               
00C52A  2  4C 66 CC     	jmp	sim+33		;and set through sim
00C52D  2               
00C52D  2               ;get block bit mask and index
00C52D  2               ; input:a&y=block number
00C52D  2               ; returns:a=bit mask and y=0
00C52D  2               ; alters:all and alcpnt
00C52D  2  48           blkmsk:	pha			;save block number
00C52E  2  84 07        	sty	alcpnt+1	;including high
00C530  2  A0 03        	ldy	#3		;divide by eight
00C532  2  46 07        blkmlp:	lsr	alcpnt+1	;shift high
00C534  2  6A           	ror	a
00C535  2  88           	dey			;loop until done
00C536  2  D0 FA        	bne	blkmlp
00C538  2  18           	clc			;now add map start
00C539  2  6D CA CB     	adc	alcmap
00C53C  2  85 06        	sta	alcpnt
00C53E  2  A5 07        	lda	alcpnt+1
00C540  2  6D CB CB     	adc	alcmap+1
00C543  2  85 07        	sta	alcpnt+1
00C545  2  68           	pla			;get number back
00C546  2  29 07        	and	#%00000111	;look at 3 lsbs
00C548  2  AA           	tax			;get
00C549  2  BD 6E CB     	lda	bitmsk,x	;mask
00C54C  2  60           	rts			;and return
00C54D  2               ;test block
00C54D  2               ; input:a&y=block number
00C54D  2               ; returns:z=1 if unassigned
00C54D  2               ; 	   =0 if assigned and bit in a is set
00C54D  2               ; alters:all
00C54D  2  20 2D C5     tstblk:	jsr	blkmsk		;get mask and index
00C550  2  31 06        	and	(alcpnt),y	;mask with map entry
00C552  2  60           	rts			;then return
00C553  2               ;alter block status
00C553  2               ; input:a&y=block number,x=1 if set
00C553  2               ;		   	  =0 if reset
00C553  2               ; returns:none
00C553  2               ; alters:all and allocation map
00C553  2  E0 01        altalc:	cpx	#1		;if set
00C555  2  F0 0A        	beq	setblk		;go do it
00C557  2  20 2D C5     clrblk:	jsr	blkmsk		;else get mask
00C55A  2  49 FF        	eor	#$ff		;and complement
00C55C  2  31 06        	and	(alcpnt),y	;preserve others
00C55E  2  91 06        	sta	(alcpnt),y	;and save
00C560  2  60           	rts			;then return
00C561  2  20 2D C5     setblk:	jsr	blkmsk		;get mask
00C564  2  11 06        	ora	(alcpnt),y	;set bit
00C566  2  91 06        	sta	(alcpnt),y	;and put back
00C568  2  60           	rts			;then return
00C569  2               ;set current drive to read only
00C569  2               ; input:curdrv,ronlst,bitmap
00C569  2               ; returns:none
00C569  2               ; alters:a,x,p and ronlst
00C569  2  AE A0 CB     setron:	ldx	curdrv		;get number
00C56C  2  BD 76 CB     	lda	bitmap,x	;and get mask
00C56F  2  0D A2 CB     	ora	ronlst		;or with status
00C572  2  8D A2 CB     	sta	ronlst		;and put back
00C575  2  60           	rts			;then return
00C576  2               ;calculate checksum of buffer @ bufadd
00C576  2               ; input: buffer@(bufadd)
00C576  2               ; returns:a=checksum
00C576  2               ; alters:a,y,p
00C576  2  A9 00        clcchk:	lda	#0		;clear accumulator
00C578  2  A0 7F        	ldy	#127		;start at end
00C57A  2  18           chkmre:	clc			;no carry
00C57B  2  71 04        	adc	(bufadd),y	;add byte
00C57D  2  88           	dey			;count down
00C57E  2  10 FA        	bpl	chkmre		;and loop until done
00C580  2  60           	rts			;then return
00C581  2               ;check read/write status
00C581  2               ; input:curdrv,ronlst
00C581  2               ; returns:z=0 if r/o or z=1 if r/w
00C581  2               ; alters:a,x,p
00C581  2  AE A0 CB     chkron:	ldx	curdrv		;get current drive
00C584  2  BD 76 CB     	lda	bitmap,x	;get mask
00C587  2  2D A2 CB     	and	ronlst		;and test status
00C58A  2  60           	rts
00C58B  2               ;initialize record counters from fcb
00C58B  2               ; input:fcb@(addinp)
00C58B  2               ; returns:none
00C58B  2               ; alters:a,y,p,nxtrec,numrec
00C58B  2  A0 20        inrcct:	ldy	#32		;next record offset
00C58D  2  B1 02        	lda	(addinp),y	;get next record
00C58F  2  8D AB CB     	sta	nxtrec		;and save
00C592  2  A0 0F        	ldy	#15		;number records offset
00C594  2  B1 02        	lda	(addinp),y	;get number
00C596  2  8D AC CB     	sta	numrec		;and save
00C599  2  60           	rts			;and return
00C59A  2               ;update record counters in fcb
00C59A  2               ; input:nxtrec,numrec
00C59A  2               ; returns:none
00C59A  2               ; alters:all,fcb@(addinp)
00C59A  2  AE AB CB     updtrc:	ldx	nxtrec		;get next record
00C59D  2  E8           	inx			;bump it
00C59E  2  8A           	txa			;transfer
00C59F  2  A0 20        	ldy	#32		;set offset
00C5A1  2  91 02        	sta	(addinp),y	;and store in fcb
00C5A3  2  AD AC CB     	lda	numrec		;get number
00C5A6  2  A0 0F        	ldy	#15		;and its offset
00C5A8  2  91 02        	sta	(addinp),y	;and store
00C5AA  2  60           	rts			;then return
00C5AB  2               ;execute open file
00C5AB  2  20 0E C3     xopen:	jsr	autodr		;auto drive select
00C5AE  2               ;open file
00C5AE  2               ; input:fcb @ (addinp)
00C5AE  2               ; returns:n=1 if not found,a=dirmod (255 if not found)
00C5AE  2               ; alters:all
00C5AE  2  20 0D C6     opnfle:	jsr	fndf13		;match all including extent
00C5B1  2  30 32        	bmi	extopn		;done if not found
00C5B3  2  A9 0C        	lda	#12		;point to first char
00C5B5  2  0D A5 CB     	ora	subrec		;add offset
00C5B8  2  A8           	tay			;make it a pointer
00C5B9  2  B1 04        nxopmv:	lda	(bufadd),y	;get buffer contents
00C5BB  2  AA           	tax			;and save
00C5BC  2  98           	tya			;save index
00C5BD  2  29 1F        	and	#%00011111	;remove offset
00C5BF  2  A8           	tay			;back to index
00C5C0  2  8A           	txa			;get byte back
00C5C1  2  91 02        	sta	(addinp),y	;and store in fcb
00C5C3  2  98           	tya			;get index
00C5C4  2  0D A5 CB     	ora	subrec		;add offset back
00C5C7  2  A8           	tay			;and make index again
00C5C8  2  C8           	iny			;next position
00C5C9  2  98           	tya			;if index
00C5CA  2  29 1F        	and	#%00011111	;not gone past
00C5CC  2  D0 EB        	bne	nxopmv		;end then loop
00C5CE  2               ;now correct extent and max records
00C5CE  2  A0 0C        	ldy	#12		;point at extent in fcb
00C5D0  2  AD 88 CB     	lda	savext		;get save from search
00C5D3  2  D1 02        	cmp	(addinp),y	;compare
00C5D5  2  F0 0B        	beq	extsme		;jump ahead if same
00C5D7  2  91 02        	sta	(addinp),y	;else change extent
00C5D9  2  A9 80        	lda	#128		;assume fcb ext < dir ext
00C5DB  2  90 01        	bcc	fcbxls		;jump ahead if true
00C5DD  2  0A           	asl	a		;clear a
00C5DE  2  A0 0F        fcbxls:	ldy	#15		;point to max
00C5E0  2  91 02        	sta	(addinp),y	;and set
00C5E2  2  AD AF CB     extsme:	lda	dirmod		;else get number
00C5E5  2  60           extopn:	rts			;and return
00C5E6  2               ;execute close file
00C5E6  2  20 0E C3     xclose:	jsr	autodr		;auto drive select
00C5E9  2               ;close file
00C5E9  2               ;if file is r/o then no actual close
00C5E9  2               ;operation is performed.
00C5E9  2               ; input:fcb @ (addinp)
00C5E9  2               ; returns:n=1 if not valid,a=dirmod (255 if invalid)
00C5E9  2               ; alters:all
00C5E9  2  20 0D C6     clsfle:	jsr	fndf13		;match including extent
00C5EC  2  30 1B        	bmi	extcls		;exit if not found
00C5EE  2  20 81 C5     	jsr	chkron		;see if r/o
00C5F1  2  D0 13        	bne	noclse		;branch if is
00C5F3  2               ;now set flag to ensure directory extent and number of
00C5F3  2               ;records fields are only changed if necessary.
00C5F3  2               ;The decision to change is determined by whether or
00C5F3  2               ;not the system is closing an extent less than the
00C5F3  2               ;maximum extent in the directory entry. If that is
00C5F3  2               ;the case, the directory extent and number of record
00C5F3  2               ;fields are not changed.
00C5F3  2  A0 0C        	ldy	#12		;get extent
00C5F5  2  B1 02        	lda	(addinp),y
00C5F7  2  48           	pha			;save it
00C5F8  2  98           	tya			;now look in directory
00C5F9  2  0D A5 CB     	ora	subrec
00C5FC  2  A8           	tay
00C5FD  2  68           	pla			;get extent back
00C5FE  2  D1 04        	cmp	(bufadd),y
00C600  2  6E 86 CB     	ror	skpdir		;save result
00C603  2               ;now go do it
00C603  2  20 78 C6     	jsr	updtdr		;update directory
00C606  2  AD AF CB     noclse:	lda	dirmod		;get directory number
00C609  2  60           extcls:	rts			;and return
00C60A  2               ;execute find first match
00C60A  2  20 0E C3     xfndfr:	jsr	autodr		;auto drive select
00C60D  2  A9 0D        fndf13:	lda	#13		;match including extent
00C60F  2               ;search for first match
00C60F  2               ; input:a=number char to match
00C60F  2               ; returns:n=1 if invalid,a=dirmod (255 if invalid)
00C60F  2               ; alters:all
00C60F  2  48           frstsr:	pha			;save number to match
00C610  2  20 D4 C7     	jsr	cldrnm		;clear directory number to -1
00C613  2  20 7A C4     	jsr	intdrv		;and drive
00C616  2  68           	pla			;get number to match
00C617  2               ;search for directory match
00C617  2               ; input:a=number char to match
00C617  2               ; returns:n=1 if not found,a=dirmod (255 if invalid)
00C617  2               ; alters:all
00C617  2  8D A9 CB     search:	sta	chrcnt		;save number
00C61A  2  A2 00        newtry:	ldx	#0		;set for search
00C61C  2  8E AA CB     	stx	cmppnt		;clear pointer
00C61F  2  20 1C C7     	jsr	nxtdir		;get next entry
00C622  2  30 37        	bmi	exitsr		;exit if not found
00C624  2  AE A9 CB     	ldx	chrcnt		;get count
00C627  2  AC AA CB     mremch:	ldy	cmppnt		;get pointer
00C62A  2  EE AA CB     	inc	cmppnt		;and bump
00C62D  2  B1 02        	lda	(addinp),y	;get fcb entry
00C62F  2  C0 0C        	cpy	#12		;see if at extent
00C631  2  D0 13        	bne	notaex		;jump if not
00C633  2  8D 88 CB     	sta	savext		;save for later use
00C636  2  48           	pha			;save extent
00C637  2  98           	tya			;change to directory
00C638  2  0D A5 CB     	ora	subrec		;coordinates
00C63B  2  A8           	tay
00C63C  2  68           	pla			;get extent back
00C63D  2  51 04        	eor	(bufadd),y	;exclusive or with dir
00C63F  2  2D D1 CB     	and	cexm1f		;and with exm complement + 1f
00C642  2  F0 11        	beq	trynxt		;ok if zero
00C644  2  D0 D4        	bne	newtry		;else get next directory
00C646  2  C9 3F        notaex:	cmp	#'?'		;if a ? then
00C648  2  F0 0B        	beq	trynxt		;is a match
00C64A  2  48           	pha			;save char
00C64B  2  98           	tya			;then add
00C64C  2  0D A5 CB     	ora	subrec		;offset to
00C64F  2  A8           	tay			;make pointer
00C650  2  68           	pla			;get char back
00C651  2  D1 04        	cmp	(bufadd),y	;if not same
00C653  2  D0 C5        	bne	newtry		;try next directory
00C655  2  CA           trynxt:	dex			;else count number down
00C656  2  D0 CF        	bne	mremch		;and loop if more
00C658  2  AD AF CB     	lda	dirmod		;return with directory
00C65B  2  60           exitsr:	rts			;number mod 4
00C65C  2               ;calculate logical record number
00C65C  2               ; input:blknum
00C65C  2               ; returns:none
00C65C  2               ; alters:a,x,p,recnum
00C65C  2  AE BA CB     calrcn:	ldx	sxb		;set x according to blkscd
00C65F  2  0E A6 CB     mulmre:	asl	blknum		;multiply block
00C662  2  2E A7 CB     	rol	blknum+1	;number
00C665  2  2E A8 CB     	rol	blknum+2
00C668  2  CA           	dex			;by code
00C669  2  D0 F4        	bne	mulmre
00C66B  2  AD B9 CB     	lda	sab		;set mask in a
00C66E  2  2D AB CB     	and	nxtrec		;and with next record
00C671  2  0D A6 CB     	ora	recnum		;or with number
00C674  2  8D A6 CB     	sta	recnum		;and save
00C677  2  60           	rts
00C678  2               ;update directory
00C678  2  A9 20        updtdr:	lda	#32		;change all
00C67A  2  A2 00        	ldx	#0		;from start
00C67C  2               ;change directory entry
00C67C  2               ; input:a=number char to change,x=starting position,fcb@(addinp)
00C67C  2               ; returns:none
00C67C  2               ; alters:all,directory,checksums
00C67C  2  8D A9 CB     dirchg:	sta	chrcnt		;save count
00C67F  2  CE A9 CB     	dec	chrcnt		;back up
00C682  2  18           mrechg:	clc			;clear carry
00C683  2  8A           	txa			;get offset
00C684  2  6D A9 CB     	adc	chrcnt		;compute index
00C687  2  A8           	tay			;and set
00C688  2  C0 0C        	cpy	#12		;see if at extent
00C68A  2  F0 04        	beq	docare		;if so do special
00C68C  2  C0 0F        	cpy	#15		;see if at number rec
00C68E  2  D0 05        	bne	dntcar		;if not skip
00C690  2  2C 86 CB     docare:	bit	skpdir		;check flag
00C693  2  10 0D        	bpl	nochng		;skip if ok
00C695  2  B1 02        dntcar:	lda	(addinp),y	;get char
00C697  2  48           	pha			;save it
00C698  2  AD A9 CB     	lda	chrcnt		;get count
00C69B  2  0D A5 CB     	ora	subrec		;add offset
00C69E  2  A8           	tay			;make an index
00C69F  2  68           	pla			;get char back
00C6A0  2  91 04        	sta	(bufadd),y	;and put in buffer
00C6A2  2  CE A9 CB     nochng:	dec	chrcnt		;count down
00C6A5  2  10 DB        	bpl	mrechg		;and loop
00C6A7  2  20 86 C4     	jsr	drrcsu		;set it up
00C6AA  2  4C 39 C8     	jmp	updtck		;and do change
00C6AD  2               ;execute create file
00C6AD  2  20 0E C3     xmake:	jsr	autodr		;auto drive select
00C6B0  2               ;create file
00C6B0  2               ; input:fcb@(addinp)
00C6B0  2               ; returns:n=1 if not valid,a=dirmod (255 if not valid)
00C6B0  2               ; alters:dirnum,dirmod,fcb@(addinp)
00C6B0  2  20 10 C8     mkefle:	jsr	tstron		;test for r/o
00C6B3  2  A5 02        	lda	addinp		;save fcb
00C6B5  2  48           	pha			;address
00C6B6  2  A5 03        	lda	addinp+1	;on
00C6B8  2  48           	pha			;stack
00C6B9  2  AD DF CA     	lda	empdvc		;then point
00C6BC  2  AC E0 CA     	ldy	empdvc+1	;to empty
00C6BF  2  85 02        	sta	addinp		;dummy
00C6C1  2  84 03        	sty	addinp+1	;fcb
00C6C3  2  A9 01        	lda	#1		;match only
00C6C5  2  20 0F C6     	jsr	frstsr		;first char
00C6C8  2  68           	pla			;restore
00C6C9  2  85 03        	sta	addinp+1	;fcb
00C6CB  2  68           	pla			;address
00C6CC  2  85 02        	sta	addinp		;from stack
00C6CE  2  AD AF CB     	lda	dirmod		;get number mod 4
00C6D1  2  30 15        	bmi	extmke		;quit if not found
00C6D3  2  A0 0D        	ldy	#13		;else set up
00C6D5  2  A9 00        	lda	#0		;to clear
00C6D7  2  91 02        mkeagn:	sta	(addinp),y	;rest of
00C6D9  2  C8           	iny			;fcb
00C6DA  2  C0 21        	cpy	#33		;including next
00C6DC  2  D0 F9        	bne	mkeagn		;record
00C6DE  2               ;the next two lines ensure that the extent and
00C6DE  2               ;number of records fields are updated
00C6DE  2  38           	sec
00C6DF  2  6E 86 CB     	ror	skpdir
00C6E2  2  20 78 C6     	jsr	updtdr		;update directory
00C6E5  2  AD AF CB     	lda	dirmod		;get number
00C6E8  2  60           extmke:	rts			;and quit
00C6E9  2               ;extend file
00C6E9  2               ; input:fcb@(addinp), x=1 read
00C6E9  2               ;		        0 write
00C6E9  2  8E 94 CB     extend:	stx	exrwfl		;save parameter
00C6EC  2  20 E9 C5     	jsr	clsfle		;close current extent
00C6EF  2  30 2A        	bmi	extext		;exit if not found
00C6F1  2  A0 0C        	ldy	#12		;else
00C6F3  2  B1 02        	lda	(addinp),y	;get extent
00C6F5  2  18           	clc			;and
00C6F6  2  69 01        	adc	#1		;add one
00C6F8  2  29 1F        	and	#%00011111	;see if overflow
00C6FA  2  F0 17        	beq	exteof		;eof if so
00C6FC  2  91 02        	sta	(addinp),y	;and save
00C6FE  2  20 0D C6     	jsr	fndf13		;see if next extent exists
00C701  2  10 0B        	bpl	opnext		;if so open
00C703  2  AD 94 CB     	lda	exrwfl		;if not and is write then create
00C706  2  D0 13        	bne	extext		;else return as eof
00C708  2  20 B0 C6     dwrtex:	jsr	mkefle		;create file
00C70B  2  4C 11 C7     	jmp	tstext		;and test
00C70E  2  20 AE C5     opnext:	jsr	opnfle		;open
00C711  2  10 03        tstext:	bpl	extnok		;continue if ok
00C713  2  A9 01        exteof:	lda	#1		;else set eof
00C715  2  60           	rts			;and return
00C716  2  20 8B C5     extnok:	jsr	inrcct		;initialize counters
00C719  2  A9 00        	lda	#0		;good
00C71B  2  60           extext:	rts			;return
00C71C  2               ;set up next directory block
00C71C  2               ; input:dirnum,x=1 for update checksum
00C71C  2               ; returns:a=dirmod (255 if invalid),n=1 if invalid
00C71C  2               ; alters:alll,dirnum,dirmod
00C71C  2  8A           nxtdir:	txa			;save operation
00C71D  2  48           	pha			;on stack
00C71E  2  EE A3 CB     	inc	dirnum		;bump directory
00C721  2  D0 03        	bne	*+5
00C723  2  EE A4 CB     	inc	dirnum+1
00C726  2  AD C8 CB     	lda	maxdir		;if not at limit continue
00C729  2  CD A3 CB     	cmp	dirnum
00C72C  2  AD C9 CB     	lda	maxdir+1
00C72F  2  ED A4 CB     	sbc	dirnum+1
00C732  2  B0 05        	bcs	gtnxdr		;then continue
00C734  2  68           	pla			;else clear stack
00C735  2  AA           	tax			;and set x
00C736  2  4C D4 C7     	jmp	cldrnm		;set to invalid
00C739  2  AD A3 CB     gtnxdr:	lda	dirnum		;get low again
00C73C  2  29 03        	and	#%00000011	;look at 2 lsbs
00C73E  2  8D AF CB     	sta	dirmod		;save mod 4
00C741  2  0A           	asl	a		;multiply
00C742  2  0A           	asl	a		;by
00C743  2  0A           	asl	a		;32 to
00C744  2  0A           	asl	a		;get pointer
00C745  2  0A           	asl	a		;offset
00C746  2  8D A5 CB     	sta	subrec		;and save
00C749  2  F0 05        	beq	getdir		;if zero read new
00C74B  2  68           	pla			;else clear stack
00C74C  2  AA           	tax			;set x
00C74D  2  4C 58 C7     	jmp	gotdir		;and exit
00C750  2  20 86 C4     getdir:	jsr	drrcsu		;set up to read
00C753  2  20 33 C8     	jsr	rdesec		;do read
00C756  2  68           	pla			;get operation
00C757  2  AA           	tax			;code
00C758  2               ;;;;;;	jsr	chksop		;do it
00C758  2  AD AF CB     gotdir:	lda	dirmod		;and return
00C75B  2  60           exnxdr:	rts			;with number
00C75C  2               ;checksum operation
00C75C  2               ;this routine assumes calling routine has checked for
00C75C  2               ;valid dirnum and hence valid dirrec
00C75C  2               ; input:chkflg,dirrec,x (1=update else check)
00C75C  2               ; returns:none
00C75C  2               ; alters:map@(chkmap)
00C75C  2  2C CC CB     chksop:	bit	chkflg		;check flag
00C75F  2  30 FA        	bmi	exnxdr		;done if set
00C761  2  CA           	dex			;dec code
00C762  2  D0 09        	bne	tstchk		;if not zero test
00C764  2  20 76 C5     	jsr	clcchk		;else calculate
00C767  2  20 BE C7     	jsr	clcckp		;calculate pointer
00C76A  2  91 08        	sta	(chkpnt),y	;and save
00C76C  2  60           	rts			;then return
00C76D  2  20 76 C5     tstchk:	jsr	clcchk		;do calculation
00C770  2  20 BE C7     	jsr	clcckp		;calculate pointer
00C773  2  D1 08        	cmp	(chkpnt),y	;compare to old
00C775  2  F0 E4        	beq	exnxdr		;if equal ok
00C777  2  4C 69 C5     	jmp	setron		;else set to r/o
00C77A  2               ;get block number
00C77A  2               ; input:nxtrec,blmode,fcb@(addinp),sxb,exm
00C77A  2               ; returns:none
00C77A  2               ; alters:all,blknum
00C77A  2  AE BA CB     getblk:	ldx	sxb		;set x according to blkscd
00C77D  2  AD AB CB     	lda	nxtrec		;get next record
00C780  2  4A           gblp:	lsr	a		;divide by 2 x times
00C781  2  CA           	dex
00C782  2  D0 FC        	bne	gblp
00C784  2  8D A6 CB     	sta	blknum		;save previous as temp
00C787  2               ;use extent as offset but first use sxb to create param
00C787  2  38           	sec
00C788  2  A9 08        	lda	#8
00C78A  2  ED BA CB     	sbc	sxb
00C78D  2  AA           	tax
00C78E  2               ;now get extent from fcb
00C78E  2  A0 0C        	ldy	#12
00C790  2  B1 02        	lda	(addinp),y
00C792  2  2D D0 CB     	and	exm		;and with mask
00C795  2  4A           	lsr	a		;shift with lsb to c
00C796  2  2A           gbxlp:	rol	a		;now go other way
00C797  2  CA           	dex
00C798  2  D0 FC        	bne	gbxlp
00C79A  2  18           	clc			;now add saved value
00C79B  2  6D A6 CB     	adc	blknum		;back
00C79E  2  2C B6 CB     	bit	blmode		;test mode
00C7A1  2  10 01        	bpl	*+3		;skip if byte
00C7A3  2  0A           	asl	a		;else times two
00C7A4  2  18           	clc			;then add
00C7A5  2  69 10        	adc	#16		;offset into fcb
00C7A7  2  8D 87 CB     	sta	fcbind		;save for later
00C7AA  2  A8           	tay			;set index
00C7AB  2  B1 02        	lda	(addinp),y	;get number
00C7AD  2  8D A6 CB     	sta	blknum		;store
00C7B0  2  C8           	iny
00C7B1  2  A9 00        	lda	#0		;clear
00C7B3  2  2C B6 CB     	bit	blmode		;test mode
00C7B6  2  10 02        	bpl	*+4		;skip if byte
00C7B8  2  B1 02        	lda	(addinp),y	;else get high
00C7BA  2  8D A7 CB     	sta	blknum+1	;high byte
00C7BD  2  60           	rts			;and return
00C7BE  2               ;calculate chkpnt as function of dirrec and chkmap
00C7BE  2               ; input:dirrec,chkmap
00C7BE  2               ; returns:y=0
00C7BE  2               ; alters:y,p,chkpnt
00C7BE  2  48           clcckp:	pha			;save a
00C7BF  2  18           	clc
00C7C0  2  AD AD CB     	lda	dirrec		;add record number
00C7C3  2  6D CD CB     	adc	chkmap		;to start
00C7C6  2  85 08        	sta	chkpnt
00C7C8  2  AD AE CB     	lda	dirrec+1
00C7CB  2  6D CE CB     	adc	chkmap+1
00C7CE  2  85 09        	sta	chkpnt+1
00C7D0  2  A0 00        	ldy	#0
00C7D2  2  68           	pla			;get a back
00C7D3  2  60           	rts
00C7D4  2               ;clear directory number to $ffff
00C7D4  2               ; input:none
00C7D4  2               ; returns:a=$ff,n=1,z=0
00C7D4  2               ; alters:a,p,dirnum,dirmod
00C7D4  2  A9 FF        cldrnm:	lda	#$ff		;set to $ff
00C7D6  2  8D A3 CB     	sta	dirnum
00C7D9  2  8D A4 CB     	sta	dirnum+1
00C7DC  2  8D AF CB     	sta	dirmod
00C7DF  2  60           	rts
00C7E0  2               ;change allocation map
00C7E0  2               ; input:subrec,directory record @ (bufadd)
00C7E0  2               ; returns:none
00C7E0  2               ; alters:all,allocation map
00C7E0  2  18           mapdir:	clc			;add 16 to
00C7E1  2  AD A5 CB     	lda	subrec		;to subrec to point
00C7E4  2  69 10        	adc	#16		;to block number field
00C7E6  2  A8           	tay			;make index
00C7E7  2  8C B4 CB     lpmpdr:	sty	mpdrsy		;save index
00C7EA  2  8A           	txa			;save x
00C7EB  2  48           	pha			;operation
00C7EC  2  B1 04        	lda	(bufadd),y	;get block number
00C7EE  2  8D B5 CB     	sta	mpdrtm		;save in temp
00C7F1  2  C8           	iny			;bump index for word
00C7F2  2  20 74 C8     	jsr	gthibn		;get high part of number
00C7F5  2  0D B5 CB     mpdrnw:	ora	mpdrtm		;see if zero
00C7F8  2  F0 0A        	beq	skpedr		;skip if zero
00C7FA  2  20 74 C8     	jsr	gthibn		;get high again
00C7FD  2  A8           	tay			;move to y
00C7FE  2  AD B5 CB     	lda	mpdrtm		;get low again
00C801  2  20 53 C5     	jsr	altalc		;else alter map
00C804  2  68           skpedr:	pla			;get operation
00C805  2  AA           	tax			;back
00C806  2  AC B4 CB     	ldy	mpdrsy		;get index back
00C809  2  C8           	iny			;bump it
00C80A  2  98           	tya			;if still
00C80B  2  29 0F        	and	#%00001111	;in field
00C80D  2  D0 D8        	bne	lpmpdr		;then loop
00C80F  2  60           	rts			;else quit
00C810  2               ;test r/w status
00C810  2               ;does warm boot if r/o
00C810  2               ; input:curdrv,ronlst
00C810  2               ; returns:none
00C810  2               ; alters:a,x,p
00C810  2  20 81 C5     tstron:	jsr	chkron		;test bit
00C813  2  F0 1D        	beq	exttro		;exit if r/w
00C815  2  20 62 C8     	jsr	errout		;else send error
00C818  2  AD E2 CA     	lda	rommvc		;point to r/o
00C81B  2  AC E3 CA     	ldy	rommvc+1	;message
00C81E  2  20 C6 C8     	jsr	sndstr		;send it
00C821  2  4C E6 C0     	jmp	xwboot		;then abort
00C824  2               ;set current drive to r/w
00C824  2               ; input:curdrv,ronlst
00C824  2               ; returns:ronlst
00C824  2               ; alters:a,x,p,ronlst
00C824  2  AE A0 CB     setrw:	ldx	curdrv		;get drive
00C827  2  BD 76 CB     	lda	bitmap,x	;and mask
00C82A  2  49 FF        	eor	#$ff		;complement
00C82C  2  2D A2 CB     	and	ronlst		;and with status
00C82F  2  8D A2 CB     	sta	ronlst		;save
00C832  2  60           exttro:	rts			;return
00C833  2               ;read sector
00C833  2  20 6C CC     rdesec:	jsr	sim+39		;do read
00C836  2               
00C836  2  4C 45 C8     	jmp	chkrwe		;check for error
00C839  2               ;update checksum and directory
00C839  2  A2 01        updtck:	ldx	#1		;set for update
00C83B  2               ;;;;;	jsr	chksop		;do it
00C83B  2  A9 01        	lda	#1		;say is directory op
00C83D  2  D0 03        	bne	secwrt		;do it
00C83F  2               ;write sector
00C83F  2  AD CF CB     wrtsec:	lda	pemwrtype		;get write type
00C842  2  20 6F CC     secwrt:	jsr	sim+42		;do write
00C845  2               
00C845  2  C9 00        chkrwe:	cmp	#0		;if not ok
00C847  2  F0 E9        	beq	exttro		;done if zero
00C849  2               ;read/write error
00C849  2  20 62 C8     rwerrt:	jsr	errout		;send error message
00C84C  2  AD E5 CA     	lda	bdsmvc		;point to
00C84F  2  AC E6 CA     	ldy	bdsmvc+1	;bad sector message
00C852  2  20 C6 C8     	jsr	sndstr		;and send
00C855  2  20 81 C8     	jsr	getcon		;get input
00C858  2  C9 0D        	cmp	#cr		;if a cr
00C85A  2  F0 03        	beq	ignerr		;then continue
00C85C  2  4C E6 C0     	jmp	xwboot		;else abort
00C85F  2  4C 5D CA     ignerr:	jmp	pcrlf		;crlf and return
00C862  2               ;error output routine
00C862  2               ; input:curdrv,pemmvc
00C862  2               ; returns:none
00C862  2               ; alters:all
00C862  2  AD E8 CA     errout:	lda	pemmvc		;point to
00C865  2  AC E9 CA     	ldy	pemmvc+1	;error message
00C868  2  20 C6 C8     	jsr	sndstr		;send it
00C86B  2  AD A0 CB     	lda	curdrv		;get drive number
00C86E  2  18           	clc			;add
00C86F  2  69 41        	adc	#'A'		;ascii a
00C871  2  4C 0F C9     	jmp	sndchr		;and send it
00C874  2               ;get high part of block number if word (zero if byte)
00C874  2               ; input:y=index to high,blmode,directory@(bufadd)+subrec
00C874  2               ; returns:a=high part of block number
00C874  2               ; alters:a,p,mpdrsy iff word
00C874  2  A9 00        gthibn:	lda	#0		;preset for byte
00C876  2  2C B6 CB     	bit	blmode		;test mode
00C879  2  10 05        	bpl	gthiex		;done if byte
00C87B  2  B1 04        	lda	(bufadd),y	;get high
00C87D  2  8C B4 CB     	sty	mpdrsy		;alter y
00C880  2  60           gthiex:	rts
00C881  2               ;get console input
00C881  2               ; input:pndkey
00C881  2               ; returns:a=character
00C881  2               ; alters:all,pndkey
00C881  2               getcon:
00C881  2  AD 8A CB     	lda	pndkey		;get pending
00C884  2  48           	pha			;save it
00C885  2  A9 00        	lda	#0		;clear
00C887  2  8D 8A CB     	sta	pndkey		;pending
00C88A  2  68           	pla			;restore
00C88B  2  D0 03        	bne	extget		;exit if not null
00C88D  2  20 4E CC     	jsr	sim+9		;else get new
00C890  2               
00C890  2  60           extget:	rts			;and return
00C891  2               ;check keyboard status
00C891  2               ;handles <ctl-s> for freeze and <ctl-c> for boot
00C891  2               ; input:pndkey
00C891  2               ; returns:a=0 if no input or <>0 if input
00C891  2               ; alters:all,pndkey
00C891  2               kbdsts:
00C891  2  AD 8A CB     	lda	pndkey		;get pending
00C894  2  D0 20        	bne	extkbd		;if there quit
00C896  2  20 4B CC     	jsr	sim+6		;else test
00C899  2  C9 00        	CMP	#$00		;if zero
00C89B  2  F0 19        	beq	extkbd		;exit
00C89D  2  20 4E CC     	jsr	sim+9		;else get input
00C8A0  2  C9 13        	cmp	#ctls		;if not freeze
00C8A2  2  D0 0D        	bne	newpnd		;save input
00C8A4  2  20 4E CC     	jsr	sim+9		;else wait for more
00C8A7  2  C9 03        	cmp	#ctlc		;if not abort
00C8A9  2  D0 03        	bne	nowarm		;then jump
00C8AB  2  4C E6 C0     	jmp	xwboot		;else do warm boot
00C8AE  2  A9 00        nowarm:	lda	#0		;clear
00C8B0  2  60           	rts			;and return
00C8B1  2  8D 8A CB     newpnd:	sta	pndkey		;save
00C8B4  2  A9 FF        	lda	#$ff		;set ready
00C8B6  2               extkbd:
00C8B6  2  60           	rts			;and return
00C8B7  2               ;test character
00C8B7  2               ; input:a=character
00C8B7  2               ; returns:c=0 if control or c=1 if printing
00C8B7  2               ; alters:p
00C8B7  2  C9 0D        tstchr:	cmp	#cr		;if cr
00C8B9  2  F0 0A        	beq	chtext		;quit
00C8BB  2  C9 0A        	cmp	#lf		;if linefeed
00C8BD  2  F0 06        	beq	chtext		;quit
00C8BF  2  C9 09        	cmp	#ctli		;if tab
00C8C1  2  F0 02        	beq	chtext		;quit
00C8C3  2  C9 20        	cmp	#' '		;see if control
00C8C5  2  60           chtext:	rts			;and return
00C8C6  2               ;send string ending in $
00C8C6  2               ; input:ay=string address
00C8C6  2               ; returns:none
00C8C6  2               ; alters:all,index,sndlpe+1 and +2
00C8C6  2  8D CF C8     sndstr:	sta	sndlpe+1	;set pointer
00C8C9  2  8C D0 C8     	sty	sndlpe+2
00C8CC  2  A0 00        	ldy	#0
00C8CE  2  B9 FF FF     sndlpe:	lda	$ffff,y		;get char
00C8D1  2  C9 24        	cmp	#'$'		;if terminator
00C8D3  2  F0 0C        	beq	sndext		;then exit
00C8D5  2  C8           	iny			;else bump
00C8D6  2  8C B0 CB     	sty	index		;and save
00C8D9  2  20 0F C9     	jsr	sndchr		;send char
00C8DC  2  AC B0 CB     	ldy	index		;get index
00C8DF  2  D0 ED        	bne	sndlpe		;and loop
00C8E1  2  60           sndext:	rts			;return
00C8E2  2               ;send char to printer if enabled
00C8E2  2               ; input:a=character,lstflg
00C8E2  2               ; returns:a=character
00C8E2  2               ; alters:x,y,p
00C8E2  2               lstout:
00C8E2  2  2C 8B CB     	bit	lstflg		;test flag
00C8E5  2  10 0A        	bpl	extlst		;exit if off
00C8E7  2  2C B2 CB     	bit	outflg		;test output flag
00C8EA  2  30 05        	bmi	extlst		;done if set
00C8EC  2  48           	pha			;save char
00C8ED  2  20 54 CC     	jsr	sim+15		;send
00C8F0  2  68           	pla			;get char
00C8F1  2  60           extlst:	rts			;and done
00C8F2  2               ;output a character
00C8F2  2               ; input:a=character,console definition block in sim
00C8F2  2               ; returns:none
00C8F2  2               ; alters:all,positn
00C8F2  2  20 B7 C8     output:	jsr	tstchr		;test it
00C8F5  2  B0 18        	bcs	sndchr		;if not control jump
00C8F7  2  48           	pha			;else save
00C8F8  2  AD 7F CC     	lda	sysdef+4	;get invert
00C8FB  2  20 28 C9     	jsr	nolist		;send to console
00C8FE  2  A9 5E        	lda	#'^'		;get arrow
00C900  2  20 E2 C8     	jsr	lstout		;send to printer
00C903  2  68           	pla			;get character
00C904  2  09 40        	ora	#'A'-1		;convert to ascii
00C906  2  20 20 C9     	jsr	pchrot		;send to all
00C909  2  AD 7E CC     	lda	sysdef+3	;get normal
00C90C  2  4C 28 C9     	jmp	nolist		;to console
00C90F  2  C9 09        sndchr:	cmp	#ctli		;if not tab
00C911  2  D0 0D        	bne	pchrot		;send
00C913  2  A9 20        tabspc:	lda	#' '		;else get space
00C915  2  20 20 C9     	jsr	pchrot		;send
00C918  2  AD 8C CB     	lda	positn		;get count
00C91B  2  29 07        	and	#7		;if not mod 8
00C91D  2  D0 F4        	bne	tabspc		;loop
00C91F  2  60           	rts			;else exit
00C920  2  48           pchrot:	pha			;save char
00C921  2  20 91 C8     	jsr	kbdsts		;test input
00C924  2  68           	pla			;restore
00C925  2  20 E2 C8     	jsr	lstout		;to printer if on
00C928  2  48           nolist:	pha			;save again
00C929  2  2C B2 CB     	bit	outflg		;test flag
00C92C  2  30 03        	bmi	*+5		;done if set
00C92E  2  20 51 CC     	jsr	sim+12		;to console
00C931  2  68           	pla			;restore
00C932  2  EE 8C CB     	inc	positn		;bump col
00C935  2  C9 20        	cmp	#' '		;if space or more
00C937  2  B0 26        	bcs	extchr		;is ok
00C939  2  CD 7D CC     	cmp	sysdef+2	;also ok
00C93C  2  F0 21        	beq	extchr		;if forward
00C93E  2  CE 8C CB     	dec	positn		;else drop back
00C941  2  CD 7B CC     	cmp	sysdef+0	;see if bs
00C944  2  D0 06        	bne	tryotr		;branch if not
00C946  2  CE 8C CB     	dec	positn		;else drop again
00C949  2  30 0F        	bmi	zrocol		;zero if <0
00C94B  2  60           	rts			;else ok
00C94C  2  C9 0D        tryotr:	cmp	#cr		;if a cr
00C94E  2  F0 0A        	beq	zrocol		;clear col
00C950  2  CD 82 CC     	cmp	sysdef+7	;if a formfeed
00C953  2  F0 05        	beq	zrocol		;also clear
00C955  2  CD 83 CC     	cmp	sysdef+8	;if not home
00C958  2  D0 05        	bne	extchr		;then done
00C95A  2  A9 00        zrocol:	lda	#0		;clear
00C95C  2  8D 8C CB     	sta	positn		;column
00C95F  2  60           extchr:	rts			;and exit
00C960  2               ;go to left and space past prompt
00C960  2               ; input:frscol,positn
00C960  2               ; returns:none
00C960  2               ; alters:positn
00C960  2  A9 0D        spcovr:	lda	#cr		;get cr
00C962  2  20 20 C9     	jsr	pchrot		;send to all
00C965  2  A9 0A        	lda	#lf		;send lf
00C967  2  20 E2 C8     	jsr	lstout		;only to printer
00C96A  2  AD 89 CB     mreovr:	lda	frscol		;get first
00C96D  2  CD 8C CB     	cmp	positn		;see if there
00C970  2  F0 ED        	beq	extchr		;done if is
00C972  2  AD 7D CC     	lda	sysdef+2	;get forward
00C975  2  20 28 C9     	jsr	nolist		;send it
00C978  2  4C 6A C9     	jmp	mreovr		;and loop
00C97B  2               ;buffered read
00C97B  2               ; input:buffer@(addinp)
00C97B  2               ; returns:none
00C97B  2               ; alters:all,buffer@(addinp)
00C97B  2  A9 00        bufinp:	lda	#0		;clear
00C97D  2  A0 01        	ldy	#1		;length
00C97F  2  91 02        	sta	(addinp),y	;position in buffer
00C981  2  8C 93 CB     	sty	bufpsn		;set point to 1
00C984  2  AD 8C CB     	lda	positn		;get current
00C987  2  8D 89 CB     	sta	frscol		;and save
00C98A  2  20 81 C8     nxtinp:	jsr	getcon		;get input
00C98D  2  AC 93 CB     	ldy	bufpsn		;get index
00C990  2  C9 0D        	cmp	#cr		;if not a cr
00C992  2  D0 03        	bne	notcr		;then jump
00C994  2  4C 5A CA     	jmp	endlin		;else done
00C997  2  C9 08        notcr:	cmp	#delete		;if not delete
00C999  2  D0 5E        	bne	ntdelt		;then jump
00C99B  2  C0 01        	cpy	#1		;else if start
00C99D  2  F0 EB        	beq	nxtinp		;then loop
00C99F  2  B1 02        	lda	(addinp),y	;get last
00C9A1  2  48           	pha			;save char
00C9A2  2  A0 01        	ldy	#1		;point to count
00C9A4  2  38           	sec			;set carry
00C9A5  2  B1 02        	lda	(addinp),y	;get count
00C9A7  2  E9 01        	sbc	#1		;decrement
00C9A9  2  91 02        	sta	(addinp),y	;then save
00C9AB  2  68           	pla			;restore char
00C9AC  2  CE 93 CB     	dec	bufpsn		;backup pointer
00C9AF  2  C9 20        	cmp	#' '		;if space or more
00C9B1  2  B0 40        	bcs	nrmbs		;just backspace
00C9B3  2  C9 09        	cmp	#ctli		;see if tab
00C9B5  2  D0 30        	bne	ctlbs		;if not is control
00C9B7  2  38           	sec			;set flag
00C9B8  2  6E B2 CB     	ror	outflg
00C9BB  2  AD 8C CB     	lda	positn		;get position and save
00C9BE  2  8D B3 CB     	sta	lstcol
00C9C1  2  20 60 C9     	jsr	spcovr		;else go back
00C9C4  2  20 67 CA     	jsr	rptlne		;and retype
00C9C7  2  AD 8C CB     	lda	positn		;get new last position
00C9CA  2  48           	pha			;save on stack
00C9CB  2  38           	sec			;subtract to get delta
00C9CC  2  AD B3 CB     	lda	lstcol
00C9CF  2  ED 8C CB     	sbc	positn
00C9D2  2  8D B3 CB     	sta	lstcol		;and save
00C9D5  2  0E B2 CB     	asl	outflg		;clear flag
00C9D8  2  20 87 CA     bstab:	jsr	dobs		;do one
00C9DB  2  CE B3 CB     	dec	lstcol		;drop count
00C9DE  2  D0 F8        	bne	bstab		;loop if more
00C9E0  2  68           	pla			;get position
00C9E1  2  8D 8C CB     	sta	positn		;and set
00C9E4  2  4C 8A C9     	jmp	nxtinp		;then loop
00C9E7  2  AD 7E CC     ctlbs:	lda	sysdef+3	;get normal
00C9EA  2  20 83 CA     	jsr	chkbs		;bs if printing
00C9ED  2  AD 7F CC     	lda	sysdef+4	;same for invert
00C9F0  2  20 83 CA     	jsr	chkbs		;then delete char itself
00C9F3  2  20 87 CA     nrmbs:	jsr	dobs		;do a backspace
00C9F6  2  4C 8A C9     	jmp	nxtinp		;and loop
00C9F9  2  C9 10        ntdelt:	cmp	#ctlp		;if not ctl-p
00C9FB  2  D0 0B        	bne	ntctlp		;then jump
00C9FD  2  AD 8B CB     	lda	lstflg		;else get printer flag
00CA00  2  49 FF        	eor	#$ff		;complement
00CA02  2  8D 8B CB     	sta	lstflg		;save
00CA05  2  4C 8A C9     	jmp	nxtinp		;and loop
00CA08  2  C9 18        ntctlp:	cmp	#ctlx		;if not ctl-x
00CA0A  2  D0 0C        	bne	ntctlx		;then jump
00CA0C  2  20 60 C9     	jsr	spcovr		;restart
00CA0F  2  AD 7C CC     	lda	sysdef+1	;get clear to eol
00CA12  2  20 28 C9     	jsr	nolist		;send it
00CA15  2  4C 7B C9     	jmp	bufinp		;and start over
00CA18  2  C9 12        ntctlx:	cmp	#ctlr		;if not ctl-r
00CA1A  2  D0 09        	bne	ntctlr		;then jump
00CA1C  2  20 60 C9     	jsr	spcovr		;restart
00CA1F  2  20 67 CA     	jsr	rptlne		;retype line
00CA22  2  4C 8A C9     	jmp	nxtinp		;and start over
00CA25  2  C8           ntctlr:	iny			;next position
00CA26  2  91 02        	sta	(addinp),y	;store char
00CA28  2  48           	pha			;and save
00CA29  2  8C 93 CB     	sty	bufpsn		;index
00CA2C  2  A0 01        	ldy	#1		;point to count
00CA2E  2  98           	tya			;set a to 1
00CA2F  2  18           	clc			;then
00CA30  2  71 02        	adc	(addinp),y	;add count
00CA32  2  91 02        	sta	(addinp),y	;and save
00CA34  2  68           	pla			;restore char
00CA35  2  20 F2 C8     dontsv:	jsr	output		;send char
00CA38  2  AC 93 CB     	ldy	bufpsn		;get index
00CA3B  2  B1 02        	lda	(addinp),y	;get char
00CA3D  2  C9 03        	cmp	#ctlc		;if not ctl-c
00CA3F  2  D0 0B        	bne	ignrcc		;ignore
00CA41  2  A0 01        	ldy	#1		;get count
00CA43  2  B1 02        	lda	(addinp),y	;from buffer
00CA45  2  C9 01        	cmp	#1		;if not at start
00CA47  2  D0 03        	bne	ignrcc		;ignore
00CA49  2  4C E6 C0     	jmp	xwboot		;else do warm boot
00CA4C  2  A0 01        ignrcc:	ldy	#1		;get
00CA4E  2  B1 02        	lda	(addinp),y	;count
00CA50  2  88           	dey			;point to max
00CA51  2  D1 02        	cmp	(addinp),y	;if length
00CA53  2  B0 03        	bcs	lineen		;at max jump
00CA55  2  4C 8A C9     	jmp	nxtinp		;else loop
00CA58  2  A9 0D        lineen:	lda	#cr		;get a cr
00CA5A  2  4C 20 C9     endlin:	jmp	pchrot		;and send
00CA5D  2               ;cr and lf
00CA5D  2  A9 0D        pcrlf:	lda	#cr		;then a
00CA5F  2  20 20 C9     	jsr	pchrot		;cr
00CA62  2  A9 0A        	lda	#lf		;and a
00CA64  2  4C 20 C9     	jmp	pchrot		;lf
00CA67  2               ;retype line
00CA67  2  AD 93 CB     rptlne:	lda	bufpsn		;save point
00CA6A  2  8D B1 CB     	sta	numcnt		;as count
00CA6D  2  A9 01        	lda	#1		;start position
00CA6F  2  48           	pha			;save
00CA70  2  68           mrerpt:	pla			;get position
00CA71  2  CE B1 CB     	dec	numcnt		;count down
00CA74  2  D0 01        	bne	*+3		;continue if more
00CA76  2  60           	rts			;else done
00CA77  2  A8           	tay			;else make index
00CA78  2  C8           	iny			;and bump
00CA79  2  98           	tya			;save
00CA7A  2  48           	pha			;on stack
00CA7B  2  B1 02        	lda	(addinp),y	;get char
00CA7D  2  20 F2 C8     	jsr	output		;send
00CA80  2  4C 70 CA     	jmp	mrerpt		;and loop
00CA83  2               ;check for printing and backspace if needed
00CA83  2  C9 20        chkbs:	cmp	#' '		;compare to space
00CA85  2  90 19        	bcc	extdec		;not printing so done
00CA87  2               ;do a backspace
00CA87  2  AD 7B CC     dobs:	lda	sysdef+0	;get backspace
00CA8A  2  48           	pha			;save it
00CA8B  2  20 28 C9     	jsr	nolist		;send
00CA8E  2  A9 20        	lda	#' '		;get space
00CA90  2  20 28 C9     	jsr	nolist		;send
00CA93  2  68           	pla			;get backspace
00CA94  2  4C 28 C9     	jmp	nolist		;send it
00CA97  2               ;test for decimal digit
00CA97  2               ;if decimal then c=0 else c=1
00CA97  2  C9 30        tstdec:	cmp	#'0'		;if under 0
00CA99  2  90 04        	bcc	notdec		;then not decimal
00CA9B  2  C9 3A        	cmp	#'9'+1		;if 9 or under is ok
00CA9D  2  90 01        	bcc	extdec
00CA9F  2  38           notdec:	sec			;else not a match
00CAA0  2  60           extdec:	rts
00CAA1  2               ;test for hexadecimal digit
00CAA1  2               ;if hex then c=0 else c=1
00CAA1  2  20 97 CA     tsthex:	jsr	tstdec		;first try decimal
00CAA4  2  90 FA        	bcc	extdec		;ok if dec
00CAA6  2  C9 41        	cmp	#'A'		;if under A
00CAA8  2  90 F5        	bcc	notdec		;then not hex
00CAAA  2  C9 47        	cmp	#'F'+1		;set c in F compare
00CAAC  2  60           	rts
00CAAD  2               ;bump load address by 128 and return in ay
00CAAD  2  AD EF BF     adjdb:	lda	dskbuf		;get old
00CAB0  2  AC F0 BF     	ldy	dskbuf+1	;address
00CAB3  2  18           	clc			;and bump
00CAB4  2  69 80        	adc	#128		;by 128
00CAB6  2  8D EF BF     	sta	dskbuf		;save low
00CAB9  2  90 04        	bcc	*+6		;then bump
00CABB  2  C8           	iny			;and save
00CABC  2  8C F0 BF     	sty	dskbuf+1	;high as needed
00CABF  2  60           	rts
00CAC0  2               ;move record from disk buffer to default buffer
00CAC0  2  AD EF BF     mv128:	lda	dskbuf		;get address
00CAC3  2  AC F0 BF     	ldy	dskbuf+1
00CAC6  2  8D CF CA     	sta	mvfrom+1	;and set pointer
00CAC9  2  8C D0 CA     	sty	mvfrom+2
00CACC  2  A2 00        	ldx	#0		;clear index
00CACE  2  BD FF FF     mvfrom:	lda	$ffff,x		;get byte
00CAD1  2  9D 28 01     	sta	dflbuf,x	;move it
00CAD4  2  E8           	inx
00CAD5  2  10 F7        	bpl	mvfrom		;loop until done
00CAD7  2  60           	rts
00CAD8  2               
00CAD8  2               ;relocatable vectors
00CAD8  2  4C           	.byte	$4c
00CAD9  2  45 C0        extevc:	.word	extexq-1
00CADB  2  4C           	.byte	$4c
00CADC  2  38 CB        sltmvc:	.word	sltmsg
00CADE  2  4C           	.byte	$4c
00CADF  2  49 CB        empdvc:	.word	empty
00CAE1  2  4C           	.byte	$4c
00CAE2  2  EE CA        rommvc:	.word	romsg
00CAE4  2  4C           	.byte	$4c
00CAE5  2  F5 CA        bdsmvc:	.word	bdsmsg
00CAE7  2  4C           	.byte	$4c
00CAE8  2  28 CB        pemmvc:	.word	pemmsg
00CAEA  2  4C           	.byte	$4c
00CAEB  2  C1 CB        dcbevc:	.word	dcb
00CAED  2               ;relocation stopper
00CAED  2  FF           	.byte	$ff
00CAEE  2               ;messages
00CAEE  2  20 2D 20 52  romsg:	.byte	" - R/O$"
00CAF2  2  2F 4F 24     
00CAF5  2  20 2D 20 42  bdsmsg:	.byte	" - BAD SECTOR"
00CAF9  2  41 44 20 53  
00CAFD  2  45 43 54 4F  
00CB02  2  0D 0A 3C 52  	.byte	cr,lf,"<RET> TO IGNORE -- <OTHER> "
00CB06  2  45 54 3E 20  
00CB0A  2  54 4F 20 49  
00CB1F  2  54 4F 20 41  	.byte	"TO ABORT$"
00CB23  2  42 4F 52 54  
00CB27  2  24           
00CB28  2  0D 0A 50 45  pemmsg:	.byte	cr,lf,"PEM ERROR ON $"
00CB2C  2  4D 20 45 52  
00CB30  2  52 4F 52 20  
00CB38  2  20 2D 20 49  sltmsg:	.byte	" - INVALID DRIVE$"
00CB3C  2  4E 56 41 4C  
00CB40  2  49 44 20 44  
00CB49  2               
00CB49  2               ;dummy fcb
00CB49  2  E5           empty:	.byte	$e5
00CB4A  2               ;zero page switch enable table
00CB4A  2  00 00 00 00  swctbl:	.byte	0,0,0,0,0,0,0,0
00CB4E  2  00 00 00 00  
00CB52  2  00 00 01 00  	.byte	0,0,1,0,0,1,1,1
00CB56  2  00 01 01 01  
00CB5A  2  01 01 01 01  	.byte	1,1,1,1,1,1,1,1
00CB5E  2  01 01 01 01  
00CB62  2  00 00 01 00  	.byte	0,0,1,0,0,0,0,0
00CB66  2  00 00 00 00  
00CB6A  2  00 00 00 00  	.byte	0,0,0,0
00CB6E  2               ;bit mask table
00CB6E  2  80 40 20 10  bitmsk:	.byte	128,64,32,16,8,4,2,1
00CB72  2  08 04 02 01  
00CB76  2               ;bit map table
00CB76  2  01 02 04 08  bitmap:	.byte	1,2,4,8,16,32,64,128
00CB7A  2  10 20 40 80  
00CB7E  2               ;extent mask table (also uses 3 bytes in sabtbl
00CB7E  2  00 01 03     exmtbl:	.byte	0,1,3
00CB81  2               ;sab table
00CB81  2  07 0F 1F 3F  sabtbl:	.byte	7,15,31,63,127
00CB85  2  7F           
00CB86  2               ;variable storage
00CB86  2  00           skpdir:	.byte	0		;positive if no change
00CB87  2  00           fcbind:	.byte	0		;index to block number
00CB88  2  00           savext:	.byte	0		;save extent
00CB89  2  00           frscol:	.byte	0		;first col
00CB8A  2  00           pndkey:	.byte	0		;pending input
00CB8B  2  00           lstflg:	.byte	0		;printer flag
00CB8C  2  00           positn:	.byte	0		;print position
00CB8D  2  00           swcflg:	.byte	0		;zero page switch flag
00CB8E  2  00 00        bytinp:	.word	0		;input value
00CB90  2  00           cmdinp:	.byte	0		;input command
00CB91  2  00 00        addout:	.word	0		;output address
00CB93  2               bytout	=	addout		;output value
00CB93  2  00           bufpsn:	.byte	0		;input buffer position
00CB94  2  00           exrwfl:	.byte	0		;extend flag
00CB95  2  00           tmpdrv:	.byte	0		;temporary drive number
00CB96  2               ;align xqtvec on word boundary
00CB96  2               	.align 2
00CB96  2  00 00        xqtvec:	.word	0		;command vector
00CB98  2  00 00        countr:	.word	0		;record counter
00CB9A  2  00           	.byte	0		;overflow
00CB9B  2  00 00        lkdown:	.word	0		;down pnt. for block search
00CB9D  2  00 00        lookup:	.word	0		;up pnt. for block search
00CB9F  2  00           olddrv:	.byte	0		;old drive number
00CBA0  2  00           curdrv:	.byte	0		;current drive
00CBA1  2  00           lginvc:	.byte	0		;log in status
00CBA2  2  00           ronlst:	.byte	0		;read write status
00CBA3  2  00 00        dirnum:	.word	0		;directory number
00CBA5  2  00           subrec:	.byte	0		;directory offset
00CBA6  2  00 00        recnum:	.word	0		;record number
00CBA8  2               blknum	=	recnum		;block number
00CBA8  2  00           	.byte	0		;overflow
00CBA9  2  00           chrcnt:	.byte	0		;character count
00CBAA  2  00           cmppnt:	.byte	0		;comparison pointer
00CBAB  2  00           nxtrec:	.byte	0		;next record
00CBAC  2  00           numrec:	.byte	0		;number records
00CBAD  2  00 00        dirrec:	.word	0		;directory record
00CBAF  2  00           dirmod:	.byte	0		;directory mod 4
00CBB0  2  00           index:	.byte	0		;buffer index
00CBB1  2  00           numcnt:	.byte	0		;counter
00CBB2  2  00           outflg:	.byte	0		;output enable flag
00CBB3  2  00           lstcol:	.byte	0		;last column
00CBB4  2  00           mpdrsy:	.byte	0		;save for y in mapdir
00CBB5  2  00           mpdrtm:	.byte	0		;temp in mapdir
00CBB6  2  00           blmode:	.byte	0		;<128 if byte else word
00CBB7  2  00 00        maxdrc:	.word	0		;max directory record
00CBB9  2  00           sab:	.byte	0		;mask for block
00CBBA  2  00           sxb:	.byte	0		;shift for block
00CBBB  2  00 00 00     rtclk:	.byte	0,0,0		;real time clock
00CBBE  2  00 00        gpcnt:	.word	0		;gp counter
00CBC0  2  00           trkctr:	.byte	0		;track counter
00CBC1  2               ;following region is used to capture dcb
00CBC1  2               dcb:
00CBC1  2  00 00        maxblk:	.word	0		;maximum block number
00CBC3  2  00 00        sectrk:	.word	0		;sectors per track
00CBC5  2  00 00        nsystr:	.word	0		;number system tracks
00CBC7  2  00           blkscd:	.byte	0		;block size code
00CBC8  2  00 00        maxdir:	.word	0		;maximum directory number
00CBCA  2  00 00        alcmap:	.word	0		;address of allocation map
00CBCC  2  00           chkflg:	.byte	0		;check flag
00CBCD  2  00 00        chkmap:	.word	0		;address of checksum map
00CBCF  2  00           pemwrtype:	.byte	0		;write type 0=norm,1=dir,2=unalloc
00CBD0  2  00           exm:	.byte	0		;extent mask
00CBD1  2  00           cexm1f:	.byte	0		;exm complemented and 1f
00CBD2  2               ;zero page save block
00CBD2  2               varblk:
00CBD2  2  00 00        lowin:	.word	0
00CBD4  2  00 00        	.word	0		;save bufadd
00CBD6  2  00 00        	.word	0		;save alcpnt
00CBD8  2  00 00        	.word	0		;save chkpnt
00CBDA  2               
00CBDA  1               		.include "SIMNHY.ASM"
00CBDA  2               ;--------------------------------
00CBDA  2               ;dos/65 system interface module (sim)
00CBDA  2               ;--------------------------------
00CBDA  2               
00CBDA  2               		.include "MACRO.ASM"
00CBDA  3               ;__MACRO___________________________________________________________________________________________________________________
00CBDA  3               ;
00CBDA  3               ; 	Macros for the betterment of Mankind
00CBDA  3               ;________________________________________________________________________________________________________________________________
00CBDA  3               ;
00CBDA  3               
00CBDA  3               .macro          PRTDBG      message
00CBDA  3               .LOCAL p1
00CBDA  3               .LOCAL p2
00CBDA  3               .LOCAL p3
00CBDA  3               .LOCAL p4
00CBDA  3               .LOCAL p5
00CBDA  3                 .if     .paramcount <> 1
00CBDA  3                       .error  "Too few parameters for macro PRTDBG"
00CBDA  3                       .endif
00CBDA  3                       .if DEBUG=1
00CBDA  3                       PHA
00CBDA  3                       PHX
00CBDA  3                       PHY
00CBDA  3                       LDX #$00
00CBDA  3               p1:
00CBDA  3                       LDA p4,x
00CBDA  3                       INX
00CBDA  3                       CMP #'$'
00CBDA  3                       BEQ p2
00CBDA  3                       JSR conwrt
00CBDA  3                       JMP p1
00CBDA  3               p2:
00CBDA  3                       LDA #13
00CBDA  3                       jsr conwrt
00CBDA  3                       LDA #10
00CBDA  3                       jsr conwrt
00CBDA  3                       PLY
00CBDA  3                       plx
00CBDA  3                       pla
00CBDA  3                       JMP p5
00CBDA  3               p4:
00CBDA  3                       .BYTE message
00CBDA  3               p5:
00CBDA  3                       .endif
00CBDA  3               .endmacro
00CBDA  3               
00CBDA  3               .macro          PRTS      message
00CBDA  3               .LOCAL p1
00CBDA  3               .LOCAL p2
00CBDA  3               .LOCAL p3
00CBDA  3               .LOCAL p4
00CBDA  3               .LOCAL p5
00CBDA  3                 .if     .paramcount <> 1
00CBDA  3                       .error  "Too few parameters for macro PRTS"
00CBDA  3                       .endif
00CBDA  3                       PHA
00CBDA  3                       PHX
00CBDA  3                       PHY
00CBDA  3                       LDX #$00
00CBDA  3               p1:
00CBDA  3                       LDA p4,x
00CBDA  3                       INX
00CBDA  3                       CMP #'$'
00CBDA  3                       BEQ p2
00CBDA  3                       JSR conwrt
00CBDA  3                       JMP p1
00CBDA  3               p2:
00CBDA  3                       PLY
00CBDA  3                       plx
00CBDA  3                       pla
00CBDA  3                       JMP p5
00CBDA  3               p4:
00CBDA  3                       .BYTE message
00CBDA  3               p5:
00CBDA  3               .endmacro
00CBDA  3               
00CBDA  3               
00CBDA  3               
00CBDA  3               
00CBDA  3               ;__PRTHEXBYTE__________________________________________________
00CBDA  3               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
00CBDA  3               ;______________________________________________________________
00CBDA  3               PRTHEXBYTE:
00CBDA  3  48                   PHA
00CBDB  3  DA                   PHX
00CBDC  3  5A                   PHY
00CBDD  3  AA                   TAX				; SAVE A REGISTER
00CBDE  3  4A                   LSR 				; SHIFT HIGH NIBBLE TO LOW NIBBLE
00CBDF  3  4A                   LSR 				;
00CBE0  3  4A                   LSR 				;
00CBE1  3  4A                   LSR 				;
00CBE2  3  18                   CLC               		; CLEAR CARRY
00CBE3  3  20 EE CB             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
00CBE6  3  8A                   TXA				; RESTORE ACCUMULATOR
00CBE7  3  20 EE CB             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
00CBEA  3  7A                   PLY
00CBEB  3  FA                   plx
00CBEC  3  68                   PLA
00CBED  3  60                   RTS
00CBEE  3               
00CBEE  3               ;__PRINT_DIGIT_________________________________________________
00CBEE  3               ;
00CBEE  3               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
00CBEE  3               ;
00CBEE  3               ;______________________________________________________________
00CBEE  3               PRINT_DIGIT:
00CBEE  3  29 0F                       AND #$0F				; STRIP OFF HIGH NIBBLE
00CBF0  3  09 30                       ORA #$30				; ADD $30 TO PRODUCE ASCII
00CBF2  3  C9 3A                       CMP #$3A               		; IS GREATER THAN 9
00CBF4  3  30 03                       BMI PRINT_DIGIT_OUT		; NO, SKIP ADD
00CBF6  3  18                          CLC				; CLEAR CARRY
00CBF7  3  69 07                       ADC #$07				; ADD ON FOR LETTER VALUES
00CBF9  3               PRINT_DIGIT_OUT:					;
00CBF9  3  4C 95 CE                    JMP conwrt              		; PRINT OUT CHAR
00CBFC  3               
00CBFC  3               NEWLINE:
00CBFC  3  A9 0D                        LDA #$0D
00CBFE  3  20 95 CE                     JSR conwrt
00CC01  3  A9 0A                        LDA #$0A
00CC03  3  4C 95 CE                     JMP conwrt
00CC06  3               
00CC06  3               PRTDEC:
00CC06  3  5A                           phy
00CC07  3  DA                           PHX
00CC08  3  48                           PHA
00CC09  3  A0 00                        ldy #00
00CC0B  3  A2 FF                        LDX #$FF
00CC0D  3  38                           SEC
00CC0E  3               PrDec100:
00CC0E  3  E8                           INX
00CC0F  3  E9 64                        SBC #100
00CC11  3  B0 FB                        BCS PrDec100            ;Count how many 100s
00CC13  3  69 64                        ADC #100
00CC15  3  20 2F CC                     JSR PrDecDigit          ;Print the 100s
00CC18  3  A2 FF                        LDX #$FF
00CC1A  3  38                           SEC                     ;Prepare for subtraction
00CC1B  3               PrDec10:
00CC1B  3  E8                           INX
00CC1C  3  E9 0A                        SBC #10
00CC1E  3  B0 FB                        BCS PrDec10             ;Count how many 10s
00CC20  3  69 0A                        ADC #10
00CC22  3  20 2F CC                     JSR PrDecDigit          ;Print the 10s
00CC25  3  AA                           TAX                     ;Pass 1s into X
00CC26  3  A0 01                        ldy #1
00CC28  3  20 2F CC                     JSR PrDecDigit          ;Print the 1s
00CC2B  3  68                           PLA
00CC2C  3  FA                           PLX
00CC2D  3  7A                           ply
00CC2E  3  60                           RTS
00CC2F  3               PrDecDigit:
00CC2F  3  48                           PHA
00CC30  3  C0 00                        cpy #$00
00CC32  3  D0 09                        bne PrDecDigit1
00CC34  3  8A                           txa
00CC35  3  A8                           tay
00CC36  3  C0 00                        cpy #$00
00CC38  3  D0 03                        bne PrDecDigit1
00CC3A  3  4C 43 CC                     jmp PrDecDigit2
00CC3D  3               PrDecDigit1:
00CC3D  3  8A                           TXA                     ;Save A, pass digit to A
00CC3E  3  09 30                        ORA #'0'
00CC40  3  20 95 CE                     JSR  conwrt             ;Convert to character and print it
00CC43  3               PrDecDigit2:
00CC43  3  68                           PLA
00CC44  3  60                           RTS                     ;Restore A and return
00CC45  3               
00CC45  2               
00CC45  2               USESERIAL 	= 	1	; SET TO ONE SERIAL CONSOLE IO
00CC45  2               USEFLOPPYA 	= 	0	; SET TO ONE FOR FLOPPY = "A"
00CC45  2               USEFLOPPYB 	= 	0	; SET TO ONE FOR FLOPPY = "B"
00CC45  2               USEIDEC 	= 	1	; SET TO ONE FOR IDE HDD="C"
00CC45  2               USEDSKY 	= 	0	; SEND INFO TO DSKY
00CC45  2               USEDSKYNG 	= 	1	; SEND INFO TO DSKYNG
00CC45  2               DSKY_KBD	=	1	; USE DSKY KEYBOARD?
00CC45  2               DEFDRV  	=	2	; SET TO DEFAULT DRIVE LETTER
00CC45  2               USEDISKIOV1     = 	0	; Floppy and IDE card is  DISK IO V1
00CC45  2               USEDISKIOV3     = 	0	; Floppy and IDE card is  DISK IO V3
00CC45  2               
00CC45  2               FLPA35		=	0	; set to 1 if floppy a is A 3.5" 80 track drive (0= 5.25" 40 track drive)
00CC45  2               FLPB35		=	0	; set to 1 if floppy a is B 3.5" 80 track drive (0= 5.25" 40 track drive)
00CC45  2               
00CC45  2               DSKYOSC         =	100000
00CC45  2               
00CC45  2               ;dos/65 system interface module (sim)
00CC45  2               ;version 3.00
00CC45  2               ;this version is designed to work with the N8VEM Host Processor
00CC45  2               
00CC45  2               ;fixed parameters
00CC45  2               simstart:
00CC45  2               
00CC45  2               ;my system i/o routines in rom
00CC45  2               
00CC45  2               ;pem constants on entry to write
00CC45  2               wrall	=	0		;write to allocated
00CC45  2               wrdir	=	1		;write to directory
00CC45  2               wrual	=	2		;write to unallocated
00CC45  2               ;page zero and system ram assignments
00CC45  2               dmaadr	=	$f4		;pointer for r/w
00CC45  2               mvepnt	=	$f2		;host buffer location
00CC45  2               OUTMSG_W =	$F0		;pointer for OutMsg
00CC45  2               SRC	 =	$EE		;pointer for OutMsg
00CC45  2               DEST	 =	$EC		;pointer for OutMsg
00CC45  2               
00CC45  2               nsects	=	(simstart-ccm)/128	;number sectors
00CC45  2               
00CC45  2               ;main program
00CC45  2               ;jump vector used by pem
00CC45  2  4C 6D CD     sim:	jmp	boot		;from cold start
00CC48  2  4C C8 CD     wboote:	jmp	wboot		;from warm boot
00CC4B  2  4C 8F CE     	jmp	consts		;check for input
00CC4E  2  4C 92 CE     	jmp	conrde		;get input
00CC51  2  4C 95 CE     	jmp	conwrt		;send to terminal
00CC54  2  4C 98 CE     	jmp	prnwrt		;printer output
00CC57  2  4C 99 CE     	jmp	punwrt		;punch output
00CC5A  2  4C 9A CE     	jmp	rdrinp		;reader input
00CC5D  2  4C 00 CE     	jmp	home		;home drive
00CC60  2  4C CF CD     	jmp	seldsk		;select disk
00CC63  2  4C 04 CE     	jmp	seltrk		;set track
00CC66  2  4C 0C CE     	jmp	selsec		;set sector
00CC69  2  4C 8A CE     	jmp	setdma		;set buffer address
00CC6C  2  4C 13 CE     	jmp	read		;read sector
00CC6F  2  4C 51 CE     	jmp	write		;write sector
00CC72  2  A9 01        	lda	#1		;printer always ready
00CC74  2  60           	rts
00CC75  2  4C 9B CE     	jmp	rdtime		;clock entry
00CC78  2  4C 9C CE     	jmp	xlate		;translate
00CC7B  2               
00CC7B  2               ;console definition block
00CC7B  2               sysdef:
00CC7B  2  08           	.byte	8		;backspace
00CC7C  2  01           	.byte	1		;clear to end of line
00CC7D  2  0C           	.byte	$c		;forward space
00CC7E  2  00           	.byte	0		;normal video
00CC7F  2  5E           	.byte	'^'		;invert video
00CC80  2  18           	.byte	24		;lines per screen
00CC81  2  50           	.byte	80		;char per line
00CC82  2  0C           	.byte	$c		;formfeed
00CC83  2  1E           	.byte	$1e		;home
00CC84  2  02           	.byte	2		;clear to end of screen
00CC85  2               
00CC85  2               ;opening id message
00CC85  2  0D 0A        opnmsg:	.byte	cr,lf
00CC87  2  20 20 20 20      	.BYTE "     ____  ____  _____    _______ ______",cr,lf
00CC8B  2  20 5F 5F 5F  
00CC8F  2  5F 20 20 5F  
00CCB1  2  20 20 20 2F     	.BYTE "   / __ \/ __ \/ ___/  _/_/ ___// ____/",cr,lf
00CCB5  2  20 5F 5F 20  
00CCB9  2  5C 2F 20 5F  
00CCDA  2  20 20 2F 20    	.BYTE "  / / / / / / /\__ \ _/_// __ \/___ \",cr,lf
00CCDE  2  2F 20 2F 20  
00CCE2  2  2F 20 2F 20  
00CD01  2  20 2F 20 2F   	.BYTE " / /_/ / /_/ /___/ //_/ / /_/ /___/ /",cr,lf
00CD05  2  5F 2F 20 2F  
00CD09  2  20 2F 5F 2F  
00CD28  2  2F 5F 5F 5F  	.BYTE "/_____/\____//____/_/   \____/_____/",cr,lf
00CD2C  2  5F 5F 2F 5C  
00CD30  2  5F 5F 5F 5F  
00CD4E  2  11 44 4F 53  	.byte 17,"DOS/65 ON THE NHYODYNE 3.00",cr,lf,0
00CD52  2  2F 36 35 20  
00CD56  2  4F 4E 20 54  
00CD6D  2               
00CD6D  2               
00CD6D  2               ;cold entry from loader
00CD6D  2               boot:
00CD6D  2  A2 FF        	ldx	#$ff		;set stack
00CD6F  2  9A           	txs			;pointer
00CD70  2  D8           	cld			;set binary mode
00CD71  2               
00CD71  2               	PRTDBG "OS Starting$"
00CD71  2               
00CD71  2  A9 85         	lda	#<opnmsg	;point to message
00CD73  2  A0 CC        	ldy	#>opnmsg
00CD75  2  20 9D CE     	jsr	outmsg		;send it
00CD78  2               				;set up jumps into dos/65 in page one
00CD78  2  A2 00        setup:	ldx	#0		;clear index
00CD7A  2               				;first clear key dba variables
00CD7A  2  8E 60 D8     	stx	hstact		;host buffer inactive
00CD7D  2  8E 61 D8     	stx	unacnt		;clear unalloc count
00CD80  2  BD C2 CD     setupl:	lda	inttbl,x	;get byte
00CD83  2  9D 00 01     	sta	$100,x		;insert at start
00CD86  2  E8           	inx
00CD87  2  E0 06        	cpx	#6
00CD89  2  D0 F5        	bne	setupl		;loop until done
00CD8B  2  A9 28        	lda	#<dflbuf	;get low buffer
00CD8D  2  A0 01        	ldy	#>dflbuf	;and high
00CD8F  2  20 8A CE     	jsr	setdma		;and set
00CD92  2  AD 5A D8     	lda	sekdsk		;get disk
00CD95  2               
00CD95  2  20 FC CB     	JSR 	NEWLINE
00CD98  2               
00CD98  2                 .IF USEFLOPPYA=1
00CD98  2                 	PRTDBG "Init floppy A$"
00CD98  2                 	lda	#0			;set zero
00CD98  2               	jsr	seldsk		;and select drive zero
00CD98  2               	JSR	SETUPDRIVE
00CD98  2                 .ENDIF
00CD98  2               
00CD98  2                 .IF USEFLOPPYB=1
00CD98  2                 	PRTDBG "Init floppy B$"
00CD98  2                 	lda	#1		;set 1
00CD98  2               	jsr	seldsk		;and select drive zero
00CD98  2               	JSR	SETUPDRIVE
00CD98  2                 .ENDIF
00CD98  2               
00CD98  2                   .IF USEIDEC=1
00CD98  2  20 2E D1         	JSR	PPIDE_INIT
00CD9B  2                 .ENDIF
00CD9B  2               
00CD9B  2                 .IF USEDSKY=1
00CD9B  2                 	PRTDBG "Init DSKY$"
00CD9B  2                 	JSR	DSKYINIT
00CD9B  2                 	JSR	SEGDISPLAY
00CD9B  2                 .ENDIF
00CD9B  2               
00CD9B  2                  .IF USEDSKYNG=1
00CD9B  2  20 D9 D4       	JSR	DSKY_INIT
00CD9E  2  20 38 D7       	JSR	DSKY_PUTLED
00CDA1  2  54 6E 5C 5E  	.BYTE 	$54,$6E,$5C,$5E,$6E,$54,$79,$40
00CDA5  2  6E 54 79 40  
00CDA9  2  20 74 D7     	JSR 	DSKY_BEEP
00CDAC  2                 .ENDIF
00CDAC  2               
00CDAC  2  A9 F0        	LDA 	#<dskcfg	; STORE POINTER TO DISK CONFIG TABLE FOR APPS
00CDAE  2  85 2E        	STA 	dskcfpc
00CDB0  2  A9 CD        	LDA 	#>dskcfg
00CDB2  2  85 2F        	STA 	dskcfpc+1
00CDB4  2  20 B5 CF     	JSR 	DSPL_DSK_CFG	; DISPLAY DISK CONFIG TO USERS
00CDB7  2               
00CDB7  2  A9 02        	lda	#DEFDRV		;set zero
00CDB9  2  20 CF CD     	jsr	seldsk		;and select drive zero
00CDBC  2  20 00 CE     	jsr	home		;home that drive
00CDBF  2               
00CDBF  2               	PRTDBG "Start CCM$"
00CDBF  2  4C 00 B8     	jmp	ccm		;and go to ccm
00CDC2  2               ;initialization table
00CDC2  2  4C 48 CC 4C  inttbl:	.byte	$4c,<wboote,>wboote,$4c,<pem,>pem
00CDC6  2  FA BF        
00CDC8  2               ;warm boot-read dos/65 back except sim and then
00CDC8  2               ; jump to ccm.
00CDC8  2               
00CDC8  2               
00CDC8  2               wboot:
00CDC8  2  A2 FF        	ldx	#$ff		;set stack
00CDCA  2  9A           	txs			;pointer
00CDCB  2  D8           	cld			;set binary mode
00CDCC  2               
00CDCC  2  4C 78 CD     	jmp	setup		;go setup
00CDCF  2               
00CDCF  2               
00CDCF  2               
00CDCF  2               ;__SELDSK_________________________________________________________________________________________________
00CDCF  2               ;
00CDCF  2               ; 	PERFORM DOS/65 DISK DRIVE SELECT
00CDCF  2               ;________________________________________________________________________________________________________
00CDCF  2               ;select disk
00CDCF  2               seldsk:
00CDCF  2  29 07        	and	#7		;three lsbs only
00CDD1  2  8D 5A D8     	sta	sekdsk		;save for later
00CDD4  2                .IF (USEFLOPPYA=1 | USEFLOPPYB=1)
00CDD4  2               	jsr	MOTOROFF	; TURN OFF ALL FLOPPY MOTORS
00CDD4  2                .ENDIF
00CDD4  2  AD 5A D8     	LDA	sekdsk		;save for later
00CDD7  2  0A           	asl	a		;multiply by two
00CDD8  2  AA           	tax			;make an Index
00CDD9  2  BD E0 CD     	lda	dcbtbl,x	;get address
00CDDC  2  BC E1 CD     	ldy	dcbtbl+1,x
00CDDF  2  60           	rts
00CDE0  2               
00CDE0  2               ;table of dcb addresses
00CDE0  2  30 D8        dcbtbl:	.word	dcba		; A
00CDE2  2  3E D8        	.word	dcbb		; B
00CDE4  2  4C D8        	.word	dcbwbw		; C
00CDE6  2  4C D8        	.word	dcbwbw		; D
00CDE8  2  4C D8        	.word	dcbwbw		; E
00CDEA  2  4C D8        	.word	dcbwbw		; F
00CDEC  2  4C D8        	.word	dcbwbw		; G
00CDEE  2  4C D8        	.word	dcbwbw		; H
00CDF0  2               
00CDF0  2               ; disk configuration table
00CDF0  2               dskcfg:
00CDF0  2  00 00        	.byte $00,$00		;  disk A: unit,slice  (invalid for floppy and RAM disks)
00CDF2  2  10 00        	.byte $10,$00		;  disk B: unit,slice  (invalid for floppy and RAM disks)
00CDF4  2  30 00        	.byte $30,$00		;  disk C: unit,slice
00CDF6  2  30 01        	.byte $30,$01		;  disk D: unit,slice
00CDF8  2  30 02        	.byte $30,$02		;  disk E: unit,slice
00CDFA  2  30 03        	.byte $30,$03		;  disk F: unit,slice
00CDFC  2  30 04        	.byte $30,$04		;  disk G: unit,slice
00CDFE  2  30 05        	.byte $30,$05		;  disk H: unit,slice
00CE00  2               
00CE00  2               ;__HOME__________________________________________________________________________________________________
00CE00  2               ;
00CE00  2               ; 	PERFORM DOS/65 HEAD HOME
00CE00  2               ;________________________________________________________________________________________________________
00CE00  2               home:
00CE00  2  A9 00        	lda	#$00
00CE02  2  A0 00        	ldy	#$00
00CE04  2               
00CE04  2               ;__SELTRK________________________________________________________________________________________________
00CE04  2               ;
00CE04  2               ; 	PERFORM DOS/65 SELECT TRACK
00CE04  2               ;
00CE04  2               ;	A=TRACK LOW BYTE
00CE04  2               ;	Y=TRACK HIGH BYTE
00CE04  2               ;________________________________________________________________________________________________________
00CE04  2               seltrk:
00CE04  2  18           	CLC
00CE05  2  8D 62 D8     	sta	sektrk		;save number
00CE08  2  8C 63 D8     	sty	sektrk+1
00CE0B  2  60           	rts
00CE0C  2               
00CE0C  2               ;__SELSEC________________________________________________________________________________________________
00CE0C  2               ;
00CE0C  2               ; 	PERFORM DOS/65 SECTOR SELECT
00CE0C  2               ;
00CE0C  2               ;	A=SECTOR LOW BYTE
00CE0C  2               ;	Y=SECTOR HIGH BYTE
00CE0C  2               ;________________________________________________________________________________________________________
00CE0C  2               selsec:
00CE0C  2  8D 64 D8     	sta	seksec		;save low and high
00CE0F  2  8C 65 D8     	sty	seksec+1
00CE12  2  60           	rts
00CE13  2               
00CE13  2               ;__READ__________________________________________________________________________________________________
00CE13  2               ;
00CE13  2               ; 	PERFORM DOS/65 SECTOR READ
00CE13  2               ;________________________________________________________________________________________________________
00CE13  2               read:
00CE13  2               
00CE13  2  20 B1 CE     	JSR	CONVERT_SECTOR_DOS	;
00CE16  2  20 26 CE     	JSR	READlow			;
00CE19  2  C9 00        	CMP	#$00			;
00CE1B  2  D0 06        	BNE	RDABEND			;
00CE1D  2  20 62 CF     	JSR	DEBSECR			;
00CE20  2  A9 00        	LDA	#$00			;
00CE22  2  60           	RTS				;
00CE23  2               RDABEND:				;
00CE23  2  A9 FF        	LDA	#$FF			;
00CE25  2  60           	RTS				;
00CE26  2               
00CE26  2               ;__READlow_______________________________________________________________________________________________
00CE26  2               ;
00CE26  2               ; 	PERFORM LOW LEVEL SECTOR READ
00CE26  2               ;________________________________________________________________________________________________________
00CE26  2               READlow:
00CE26  2  AD 5A D8     	LDA	sekdsk			; GET DRIVE
00CE29  2  29 07        	AND 	#7			; ONLY FIRST 8 DEVICES SUPPORTED
00CE2B  2  0A           	asl	a			; DOUBLE NUMBER FOR TABLE LOOKUP
00CE2C  2  AA           	TAX 				; MOVE TO X REGISTER
00CE2D  2  BD F0 CD     	LDA 	dskcfg,X 		; GET device
00CE30  2  29 F0        	and 	#$F0			; only want first nybble
00CE32  2               
00CE32  2  C9 00        	CMP 	#$00
00CE34  2  D0 03        	BNE 	READlow1		; not RAM drive
00CE36  2               	;PRTS "RAM$"
00CE36  2  A9 FF        	LDA	#$FF			;
00CE38  2  60           	RTS				;
00CE39  2               READlow1:
00CE39  2  C9 10        	CMP 	#$10
00CE3B  2  D0 03        	BNE 	READlow2		; not ROM drive
00CE3D  2               	;PRTS "ROM$"
00CE3D  2  A9 FF        	LDA	#$FF			;
00CE3F  2  60           	RTS				;
00CE40  2               READlow2:
00CE40  2  C9 20        	CMP 	#$20
00CE42  2  D0 03        	BNE 	READlow3		; not floppy drive
00CE44  2               	;PRTS "FD$"
00CE44  2                 	.IF USEFLOPPYA=1 || USEFLOPPYB=1
00CE44  2                 	JMP	READFL			;
00CE44  2                 	.else
00CE44  2  A9 FF          	LDA	#$FF			;
00CE46  2  60           	RTS				;
00CE47  2                 	.ENDIF
00CE47  2               READlow3:
00CE47  2  C9 30        	CMP 	#$30
00CE49  2  D0 03        	BNE 	READlowx		; invalid drive
00CE4B  2               	;PRTS "PPIDE$"
00CE4B  2                 	.IF USEIDEC=1
00CE4B  2  4C EF D2     	JMP	IDE_READ_SECTOR		;
00CE4E  2                 	.ENDIF
00CE4E  2               READlowx:
00CE4E  2  A9 FF        	LDA	#$FF			; signal error
00CE50  2  60           	RTS				;
00CE51  2               
00CE51  2               
00CE51  2               ;__WRITE_________________________________________________________________________________________________
00CE51  2               ;
00CE51  2               ; 	PERFORM DOS/65 SECTOR WRITE
00CE51  2               ;________________________________________________________________________________________________________
00CE51  2               write:
00CE51  2  20 B1 CE     	JSR	CONVERT_SECTOR_DOS	; determine physical sector
00CE54  2  20 26 CE     	JSR	READlow			; read physical sector
00CE57  2  C9 00        	CMP	#$00			;
00CE59  2  D0 2C        	BNE	writex			; on error abort
00CE5B  2  20 89 CF     	JSR	BLKSECR			; block sector for writing
00CE5E  2               					;
00CE5E  2  AD 5A D8     	LDA	sekdsk			; GET DRIVE
00CE61  2  29 07        	AND 	#7			; ONLY FIRST 8 DEVICES SUPPORTED
00CE63  2  0A           	asl	a			; DOUBLE NUMBER FOR TABLE LOOKUP
00CE64  2  AA           	TAX 				; MOVE TO X REGISTER
00CE65  2  BD F0 CD     	LDA 	dskcfg,X 		; GET device
00CE68  2  29 F0        	and 	#$F0			; only want first nybble
00CE6A  2               
00CE6A  2  C9 00        	CMP 	#$00
00CE6C  2  D0 03        	BNE 	write1			; not RAM Drive
00CE6E  2               	;PRTS "RAM$"
00CE6E  2  A9 FF        	LDA	#$FF			;
00CE70  2  60           	RTS				;
00CE71  2               write1:
00CE71  2  C9 10        	CMP 	#$10
00CE73  2  D0 03        	BNE 	write2			; not ROM Drive
00CE75  2               	;PRTS "ROM$"
00CE75  2  A9 FF        	LDA	#$FF			; always invalid to write to ROM Drive
00CE77  2  60           	RTS				;
00CE78  2               write2:
00CE78  2  C9 20        	CMP 	#$20
00CE7A  2  D0 03        	BNE 	write3			; not floppy drive
00CE7C  2               	;PRTS "FD$"
00CE7C  2                 	.IF USEFLOPPYA=1 || USEFLOPPYB=1
00CE7C  2                 	Jsr	WRITEFL			;
00CE7C  2               	RTS				;
00CE7C  2                 	.else
00CE7C  2  A9 FF          	LDA	#$FF			;
00CE7E  2  60           	RTS				;
00CE7F  2                 	.ENDIF
00CE7F  2               write3:
00CE7F  2  C9 30        	CMP 	#$30
00CE81  2  D0 04        	BNE 	writex			; not ppide
00CE83  2               	;PRTS "PPIDE$"
00CE83  2                 	.IF USEIDEC=1
00CE83  2  20 39 D3     	JSR	IDE_WRITE_SECTOR
00CE86  2  60           	RTS				;
00CE87  2                 	.ENDIF
00CE87  2               writex:
00CE87  2  A9 FF        	LDA	#$FF			; signal error
00CE89  2  60           	RTS				;
00CE8A  2               
00CE8A  2               
00CE8A  2               ;__SETDMA________________________________________________________________________________________________
00CE8A  2               ;
00CE8A  2               ; 	PERFORM DOS/65 BUFFER ADDRESS SELECTION
00CE8A  2               ;
00CE8A  2               ;	A=BUFFER LOW BYTE
00CE8A  2               ;	Y=BUFFER HIGH BYTE
00CE8A  2               ;________________________________________________________________________________________________________
00CE8A  2               setdma:
00CE8A  2  85 F4        	sta	dmaadr		;store low
00CE8C  2  84 F5        	sty	dmaadr+1	;and high
00CE8E  2  60           	rts
00CE8F  2               
00CE8F  2               
00CE8F  2               ;__CONSTS________________________________________________________________________________________________
00CE8F  2               ;
00CE8F  2               ; 	GET DOS/65 CONSOLE STATUS
00CE8F  2               ;________________________________________________________________________________________________________
00CE8F  2               consts:
00CE8F  2  4C 1C D1     	jmp	SERIALSTATUS
00CE92  2               
00CE92  2               ;__CONRDE________________________________________________________________________________________________
00CE92  2               ;
00CE92  2               ; 	PERFORM DOS/65 CONSOLE READ
00CE92  2               ;________________________________________________________________________________________________________
00CE92  2               conrde:
00CE92  2  4C 0D D1     	jmp 	RDSER1W
00CE95  2               
00CE95  2               ;__CONWRT________________________________________________________________________________________________
00CE95  2               ;
00CE95  2               ; 	PERFORM DOS/65 CONSOLE WRITE
00CE95  2               ;________________________________________________________________________________________________________
00CE95  2               conwrt:
00CE95  2  4C EE D0     	jmp 	WRSER1
00CE98  2               
00CE98  2               prnwrt:
00CE98  2  60           	rts			;printer
00CE99  2               punwrt:
00CE99  2  60           	rts			;punch output
00CE9A  2               rdrinp:
00CE9A  2  60           	rts			;reader input
00CE9B  2               rdtime:
00CE9B  2  60           	rts			;read clock
00CE9C  2               xlate:
00CE9C  2  60           	rts			;sector translate
00CE9D  2               
00CE9D  2               
00CE9D  2               ;__OUTMSG________________________________________________________________________________________________
00CE9D  2               ;
00CE9D  2               ; 	WRITE A NULL TERMINATED STRING TO THE CONSOLE
00CE9D  2               ;
00CE9D  2               ;	A=POINTER LOW BYTE
00CE9D  2               ;	Y=POINTER HIGH BYTE
00CE9D  2               ;________________________________________________________________________________________________________
00CE9D  2               outmsg:				;output message
00CE9D  2  85 F0        	STA OUTMSG_W
00CE9F  2  84 F1        	STY OUTMSG_W+1
00CEA1  2  A0 00        	LDY #$00
00CEA3  2               OUTSTRLP:
00CEA3  2  B1 F0               	LDA (OUTMSG_W),Y 	; LOAD NEXT CHAR FROM STRING INTO ACC
00CEA5  2  C9 00               	CMP #$00		; IS NULL?
00CEA7  2  F0 07               	BEQ ENDOUTSTR		; YES, END PRINT OUT
00CEA9  2  20 95 CE            	JSR conwrt  		; PRINT CHAR IN ACC
00CEAC  2  C8                  	INY      		; Y=Y+1 (BUMP INDEX)
00CEAD  2  4C A3 CE            	JMP OUTSTRLP		; DO NEXT CHAR
00CEB0  2               ENDOUTSTR:
00CEB0  2  60                  	RTS			; RETURN
00CEB1  2               
00CEB1  2               
00CEB1  2               ;___CONVERT_SECTOR_DOS________________________________________________________________________________
00CEB1  2               ;
00CEB1  2               ; 	TRANSLATE SECTORS INTO ECB SERVER FORMAT
00CEB1  2               ;________________________________________________________________________________________________________
00CEB1  2               CONVERT_SECTOR_DOS:
00CEB1  2  AD 62 D8     	LDA	sektrk			; LOAD TRACK # (LOW BYTE)
00CEB4  2  29 0F        	AND 	#$0F			; ISOLATE HEAD IN LOW 4 BITS
00CEB6  2  0A           	asl	a			; MOVE TO HIGH BYTE
00CEB7  2  0A           	asl	a
00CEB8  2  0A           	asl	a
00CEB9  2  0A           	asl	a
00CEBA  2  AA           	TAX 				; PARK IN X
00CEBB  2  AD 64 D8     	LDA	seksec			; LOAD SECTOR # (LOW BYTE)
00CEBE  2  4A           	LSR	A			;
00CEBF  2  4A           	LSR	A			; DIVIDE BY 4 (FOR BLOCKING)
00CEC0  2  29 0F        	AND 	#$0F 			; CLEAR UPPER 4 BITS (JUST 'CAUSE)
00CEC2  2  8D 68 D8     	STA	debsehd			; STORE IN SECTOR/HEAD
00CEC5  2  8A           	TXA 				; GET HEAD BACK
00CEC6  2  0D 68 D8     	ORA 	debsehd
00CEC9  2  8D 68 D8     	STA	debsehd			; STORE IN SECTOR/HEAD
00CECC  2               
00CECC  2  AD 62 D8     	LDA 	sektrk
00CECF  2  8D 66 D8     	STA	debcyll			; STORE IN TRACK (lsb)
00CED2  2  AD 63 D8     	LDA 	sektrk+1
00CED5  2  8D 67 D8     	STA	debcylm			; STORE IN TRACK (msb)
00CED8  2               					; REMOVE HEAD FROM TRACK VALUE (DIV/4)
00CED8  2  AD 67 D8     	LDA	debcylm
00CEDB  2  4A           	LSR 	A
00CEDC  2  8D 67 D8     	STA	debcylm
00CEDF  2  AD 66 D8     	LDA	debcyll
00CEE2  2  6A           	ROR 	A
00CEE3  2  8D 66 D8     	STA	debcyll
00CEE6  2               
00CEE6  2  AD 67 D8     	LDA	debcylm
00CEE9  2  4A           	LSR 	A
00CEEA  2  8D 67 D8     	STA	debcylm
00CEED  2  AD 66 D8     	LDA	debcyll
00CEF0  2  6A           	ROR 	A
00CEF1  2  8D 66 D8     	STA	debcyll
00CEF4  2               
00CEF4  2  AD 67 D8     	LDA	debcylm
00CEF7  2  4A           	LSR 	A
00CEF8  2  8D 67 D8     	STA	debcylm
00CEFB  2  AD 66 D8     	LDA	debcyll
00CEFE  2  6A           	ROR 	A
00CEFF  2  8D 66 D8     	STA	debcyll
00CF02  2               
00CF02  2  AD 67 D8     	LDA	debcylm
00CF05  2  4A           	LSR 	A
00CF06  2  8D 67 D8     	STA	debcylm
00CF09  2  AD 66 D8     	LDA	debcyll
00CF0C  2  6A           	ROR 	A
00CF0D  2  8D 66 D8     	STA	debcyll
00CF10  2               
00CF10  2               ;	ADD SLICE OFFSET
00CF10  2  AD 5A D8     	LDA	sekdsk			; GET DRIVE#
00CF13  2  29 07        	AND 	#7			; ONLY FIRST 8 DEVICES SUPPORTED
00CF15  2  0A           	asl	a			; DOUBLE NUMBER FOR TABLE LOOKUP
00CF16  2  AA           	TAX 				; MOVE TO X REGISTER
00CF17  2  E8           	INX				; WANT SECOND BYTE OF ENTRY
00CF18  2  BD F0 CD     	LDA 	dskcfg,X 		; GET SLICE#
00CF1B  2  8D 70 D8     	STA 	slicetmp+1 		; SLICE OFFSET MSB
00CF1E  2  A9 00        	LDA 	#0	 		; GET SLICE#
00CF20  2  8D 6F D8     	STA 	slicetmp		; SLICE OFFSET LSB
00CF23  2  18           	CLC				; VOODOO MATH TO TAKE SLICE*$4000
00CF24  2  6E 70 D8     	ROR 	slicetmp+1
00CF27  2  6E 6F D8     	ROR	slicetmp
00CF2A  2  6E 70 D8     	ROR 	slicetmp+1
00CF2D  2  6E 6F D8     	ROR	slicetmp
00CF30  2               					; ADD SLICE OFFSET TO TRACK #
00CF30  2  18           	clc				; clear carry
00CF31  2  AD 6F D8     	lda slicetmp
00CF34  2  6D 66 D8     	adc debcyll
00CF37  2  8D 66 D8     	sta debcyll			; store sum of LSBs
00CF3A  2  AD 70 D8     	lda slicetmp+1
00CF3D  2  6D 67 D8     	adc debcylm			; add the MSBs using carry from
00CF40  2  8D 67 D8     	sta debcylm			; the previous calculation
00CF43  2               
00CF43  2               
00CF43  2                 .IF USEDSKY=1 || USEDSKYNG=1
00CF43  2                 	PRTDBG "DSKY OUTPUT 1$"
00CF43  2  AD 5A D8       	lda	sekdsk
00CF46  2  8D 2C D8       	sta	DSKY_HEXBUF
00CF49  2  AD 67 D8      	lda	debcylm
00CF4C  2  8D 2D D8       	sta	DSKY_HEXBUF+1
00CF4F  2  AD 66 D8      	lda	debcyll
00CF52  2  8D 2E D8       	sta	DSKY_HEXBUF+2
00CF55  2  AD 68 D8         	lda	debsehd
00CF58  2  8D 2F D8       	sta	DSKY_HEXBUF+3
00CF5B  2  20 4B D6       	JSR	DSKY_BIN2SEG
00CF5E  2  20 80 D6     	JSR	DSKY_SHOW
00CF61  2                 .ENDIF
00CF61  2  60           	RTS
00CF62  2               
00CF62  2               ;___DEBSECR______________________________________________________________________________________________
00CF62  2               ;
00CF62  2               ;	DEBLOCK 512 BYTE SECTOR FOR DOS/65
00CF62  2               ;
00CF62  2               ;________________________________________________________________________________________________________
00CF62  2               DEBSECR:
00CF62  2  AD 64 D8     	LDA	seksec			;
00CF65  2  29 03        	AND	#$03			; GET SECTOR INDEX
00CF67  2  18           	CLC				;
00CF68  2  2A           	ROL	A			;
00CF69  2  AA           	TAX				;
00CF6A  2  BD 81 CF     	LDA	DEBTAB,X		;
00CF6D  2  85 EE        	STA     SRC
00CF6F  2  E8           	INX
00CF70  2  BD 81 CF     	LDA	DEBTAB,X		;
00CF73  2  85 EF        	STA	SRC+1			;
00CF75  2  A5 F4        	LDA	dmaadr			;
00CF77  2  85 EC        	STA	DEST			;
00CF79  2  A5 F5        	LDA	dmaadr+1		;
00CF7B  2  85 ED        	STA	DEST+1			;
00CF7D  2  20 A8 CF     	JSR	COPY_DOS_SECTOR		;
00CF80  2  60           	RTS
00CF81  2               
00CF81  2               DEBTAB:
00CF81  2  BA DB        	.word	hstbuf			;
00CF83  2  3A DC        	.word	hstbuf+128		;
00CF85  2  BA DC        	.word	hstbuf+256		;
00CF87  2  3A DD        	.word	hstbuf+384		;
00CF89  2               
00CF89  2               
00CF89  2               ;___BLKSECR______________________________________________________________________________________________
00CF89  2               ;
00CF89  2               ;	BLOCK 512 BYTE SECTOR FOR DOS/65
00CF89  2               ;
00CF89  2               ;________________________________________________________________________________________________________
00CF89  2               BLKSECR:
00CF89  2  AD 64 D8     	LDA	seksec			;
00CF8C  2  29 03        	AND	#$03			; GET SECTOR INDEX
00CF8E  2  18           	CLC				;
00CF8F  2  2A           	ROL	A			;
00CF90  2  AA           	TAX				;
00CF91  2  BD 81 CF     	LDA	DEBTAB,X		;
00CF94  2  85 EC        	STA     DEST
00CF96  2  E8           	INX
00CF97  2  BD 81 CF     	LDA	DEBTAB,X		;
00CF9A  2  85 ED        	STA	DEST+1			;
00CF9C  2  A5 F4        	LDA	dmaadr			;
00CF9E  2  85 EE        	STA	SRC			;
00CFA0  2  A5 F5        	LDA	dmaadr+1		;
00CFA2  2  85 EF        	STA	SRC+1			;
00CFA4  2  20 A8 CF     	JSR	COPY_DOS_SECTOR		;
00CFA7  2  60           	RTS
00CFA8  2               
00CFA8  2               
00CFA8  2               ;___COPY_DOS_SECTOR______________________________________________________________________________________
00CFA8  2               ;
00CFA8  2               ;	COPY 128 BYTE SECTOR FOR DOS/65
00CFA8  2               ;
00CFA8  2               ;________________________________________________________________________________________________________
00CFA8  2               COPY_DOS_SECTOR:
00CFA8  2  A0 00        	LDY	#$00			;
00CFAA  2               COPY_DOS_SECTOR1:
00CFAA  2  B1 EE        	LDA	(SRC),Y			;
00CFAC  2  91 EC        	STA	(DEST),Y		;
00CFAE  2  C8           	INY				;
00CFAF  2  98           	TYA				;
00CFB0  2  C9 80        	CMP	#$80			;
00CFB2  2  D0 F6        	BNE	COPY_DOS_SECTOR1	;
00CFB4  2  60           	RTS
00CFB5  2               
00CFB5  2               ;___DSPL_DSK_CFG_________________________________________________________________________________________
00CFB5  2               ;
00CFB5  2               ;	DISPLAY THE DISK CONFIGURATION FOR THE USER
00CFB5  2               ;
00CFB5  2               ;________________________________________________________________________________________________________
00CFB5  2               DSPL_DSK_CFG:
00CFB5  2  20 FC CB     	JSR 	NEWLINE
00CFB8  2  48 DA 5A A2  	PRTS "Disk Configuration:$"
00CFBC  2  00 BD D1 CF  
00CFC0  2  E8 C9 24 F0  
00CFE5  2  20 FC CB     	JSR 	NEWLINE
00CFE8  2  A2 00        	ldx 	#0
00CFEA  2               DSPL_DSK_CFG_1:
00CFEA  2  48 DA 5A A2  	PRTS "    $"		; MAKE IT PRETTY :)
00CFEE  2  00 BD 03 D0  
00CFF2  2  E8 C9 24 F0  
00D008  2  8A           	TXA
00D009  2  4A           	LSR	A
00D00A  2  18           	CLC
00D00B  2  69 41        	ADC 	#'A'
00D00D  2  20 95 CE     	JSR 	conwrt
00D010  2  A9 3A        	LDA 	#':'
00D012  2  20 95 CE     	JSR 	conwrt
00D015  2  A9 3D        	LDA 	#'='
00D017  2  20 95 CE     	JSR 	conwrt
00D01A  2  20 32 D0     	JSR 	prtdevice	; PRINT DEVICE NAME FROM TABLE (X)
00D01D  2  A9 3A        	LDA 	#':'
00D01F  2  20 95 CE     	JSR 	conwrt
00D022  2  E8           	INX				; WANT SECOND BYTE OF ENTRY
00D023  2  BD F0 CD     	LDA 	dskcfg,x 		; GET SLICE
00D026  2  20 06 CC     	JSR 	PRTDEC 			; PRINT SLICE IN DECIMAL (A)
00D029  2  E8           	INX
00D02A  2  20 FC CB     	JSR 	NEWLINE
00D02D  2  E0 10        	CPX 	#16
00D02F  2  D0 B9        	BNE 	DSPL_DSK_CFG_1
00D031  2  60           	RTS
00D032  2               
00D032  2               ; 	DEVICE TABLE:
00D032  2               ;	$00	RAM
00D032  2               ;	$10	ROM
00D032  2               ;	$2x	FLOPPY
00D032  2               ;	$3x	IDE
00D032  2               prtdevice:
00D032  2  BD F0 CD     	LDA 	dskcfg,X 		; GET DEVICE TYPE
00D035  2  48           	PHA
00D036  2  29 F0        	AND 	#$F0 			; FILTER OUT UNIT
00D038  2  C9 00        	CMP 	#$00
00D03A  2  D0 20        	BNE 	prtdevice1
00D03C  2  48 DA 5A A2  	PRTS "RAM$"
00D040  2  00 BD 55 D0  
00D044  2  E8 C9 24 F0  
00D059  2  4C E6 D0     	jmp 	prtdevice_done
00D05C  2               prtdevice1:
00D05C  2  C9 10        	CMP 	#$10
00D05E  2  D0 20        	BNE 	prtdevice2
00D060  2  48 DA 5A A2  	PRTS "ROM$"
00D064  2  00 BD 79 D0  
00D068  2  E8 C9 24 F0  
00D07D  2  4C E6 D0     	jmp 	prtdevice_done
00D080  2               prtdevice2:
00D080  2  C9 20        	CMP 	#$20
00D082  2  D0 1F        	BNE 	prtdevice3
00D084  2  48 DA 5A A2  	PRTS "FD$"
00D088  2  00 BD 9D D0  
00D08C  2  E8 C9 24 F0  
00D0A0  2  4C E6 D0     	jmp 	prtdevice_done
00D0A3  2               prtdevice3:
00D0A3  2  C9 30        	CMP 	#$30
00D0A5  2  D0 22        	BNE 	prtdevicex
00D0A7  2  48 DA 5A A2  	PRTS "PPIDE$"
00D0AB  2  00 BD C0 D0  
00D0AF  2  E8 C9 24 F0  
00D0C6  2  4C E6 D0     	jmp 	prtdevice_done
00D0C9  2               prtdevicex:
00D0C9  2  48 DA 5A A2  	PRTS "UNK$"
00D0CD  2  00 BD E2 D0  
00D0D1  2  E8 C9 24 F0  
00D0E6  2               prtdevice_done:
00D0E6  2  68           	PLA
00D0E7  2  29 0F        	AND 	#$0F 			; FILTER OUT DEVICE
00D0E9  2  20 06 CC     	JSR 	PRTDEC
00D0EC  2  60           	RTS
00D0ED  2               
00D0ED  2               
00D0ED  2                 .IF USESERIAL=1
00D0ED  2               	.INCLUDE "DOSSER.ASM"
00D0ED  3               ;__SERIAL DRIVERS________________________________________________________________________________________________________________
00D0ED  3               ;
00D0ED  3               ; 	Nhyodyne serial drivers for single serial port card
00D0ED  3               ;
00D0ED  3               ;	Entry points:
00D0ED  3               ;		SERIALINIT  - called during OS init
00D0ED  3               ;		RDSER1	    - read a byte from serial port ('A' POINTS TO BYTE)
00D0ED  3               ;		WRSER1	    - write a byte from serial port  ('A' POINTS TO BYTE)
00D0ED  3               ;		RDSER1W	    - read a byte from serial port ('A' POINTS TO BYTE, WAIT FOR INPUT)
00D0ED  3               ;		SERIALSTATUS- GET UART STATUS
00D0ED  3               ;________________________________________________________________________________________________________________________________
00D0ED  3               ;
00D0ED  3               
00D0ED  3               
00D0ED  3               ;*
00D0ED  3               ;* HARDWARE I/O ADDRESSES
00D0ED  3               ;*
00D0ED  3               
00D0ED  3               ; UART 16C550 SERIAL
00D0ED  3               UART0       	=    	$0368           ; DATA IN/OUT
00D0ED  3               UART1       	=    	$0369           ; CHECK RX
00D0ED  3               UART2       	=    	$036A           ; INTERRUPTS
00D0ED  3               UART3       	=    	$036B           ; LINE CONTROL
00D0ED  3               UART4       	=    	$036C           ; MODEM CONTROL
00D0ED  3               UART5          	=    	$036D           ; LINE STATUS
00D0ED  3               UART6          	=    	$036E           ; MODEM STATUS
00D0ED  3               UART7	       	=    	$036F           ; SCRATCH REG.
00D0ED  3               
00D0ED  3               
00D0ED  3               ;__SERIALINIT____________________________________________________________________________________________________________________
00D0ED  3               ;
00D0ED  3               ;	INITIALIZE SERIAL PORTS
00D0ED  3               ;________________________________________________________________________________________________________________________________
00D0ED  3               ;
00D0ED  3               SERIALINIT:
00D0ED  3               ;	LDA	#$80			;
00D0ED  3               ;	STA	UART3			; SET DLAB FLAG
00D0ED  3               ;	LDA	#12			; SET TO 12 = 9600 BAUD
00D0ED  3               ;	STA	UART0			; save baud rate
00D0ED  3               ;	LDA	#00			;
00D0ED  3               ;	STA	UART1			;
00D0ED  3               ;	LDA	#03			;
00D0ED  3               ;	STA	UART3			; SET 8 BIT DATA, 1 STOPBIT
00D0ED  3               ;	STA	UART4			;
00D0ED  3               
00D0ED  3  60           	RTS
00D0EE  3               
00D0EE  3               
00D0EE  3               
00D0EE  3               ;__WRSER1________________________________________________________________________________________________________________________
00D0EE  3               ;
00D0EE  3               ;	WRITE CHARACTER(A) TO UART
00D0EE  3               ;________________________________________________________________________________________________________________________________
00D0EE  3               ;
00D0EE  3               WRSER1:
00D0EE  3  48           	PHA
00D0EF  3               WRSER1a:
00D0EF  3  AD 6D 03     	LDA	UART5			; READ LINE STATUS REGISTER
00D0F2  3  29 20        	AND	#$20			; TEST IF UART IS READY TO SEND (BIT 5)
00D0F4  3  C9 00        	CMP     #$00
00D0F6  3  F0 F7        	BEQ	WRSER1a			; NO, WAIT FOR IT
00D0F8  3  68           	PLA
00D0F9  3  8D 68 03     	STA	UART0			; THEN WRITE THE CHAR TO UART
00D0FC  3  60           	RTS
00D0FD  3               
00D0FD  3               ;__RDSER1________________________________________________________________________________________________________________________
00D0FD  3               ;
00D0FD  3               ;	READ CHARACTER FROM UART TO (A)
00D0FD  3               ;________________________________________________________________________________________________________________________________
00D0FD  3               ;
00D0FD  3               RDSER1:
00D0FD  3  AD 6D 03     	LDA	UART5			; READ LINE STATUS REGISTER
00D100  3  29 01        	AND	#$01			; TEST IF DATA IN RECEIVE BUFFER
00D102  3  C9 00        	CMP 	#$00
00D104  3  F0 04        	BEQ	RDSER1N			; LOOP UNTIL DATA IS READY
00D106  3  AD 68 03     	LDA	UART0			; THEN READ THE CHAR FROM THE UART
00D109  3  60           	RTS
00D10A  3               RDSER1N:
00D10A  3  A9 00        	LDA	#$00			;
00D10C  3  60           	RTS				;
00D10D  3               
00D10D  3               ;__RDSER1W_______________________________________________________________________________________________________________________
00D10D  3               ;
00D10D  3               ;	READ CHARACTER FROM UART TO (A) - WAIT FOR CHAR
00D10D  3               ;________________________________________________________________________________________________________________________________
00D10D  3               ;
00D10D  3               
00D10D  3               RDSER1W:
00D10D  3  AD 6D 03     		LDA	UART5			; READ LINE STATUS REGISTER
00D110  3  29 01        		AND	#$01			; TEST IF DATA IN RECEIVE BUFFER
00D112  3  C9 00        		CMP 	#$00
00D114  3  F0 F7        		BEQ	RDSER1W			; LOOP UNTIL DATA IS READY
00D116  3  AD 68 03     		LDA	UART0			; THEN READ THE CHAR FROM THE UART
00D119  3  29 7F        		AND #$7F
00D11B  3  60           		RTS
00D11C  3               
00D11C  3               ;__SERIALSTATUS__________________________________________________________________________________________________________________
00D11C  3               ;
00D11C  3               ;	READ UARD STATUS
00D11C  3               ;________________________________________________________________________________________________________________________________
00D11C  3               ;
00D11C  3               SERIALSTATUS:
00D11C  3  AD 6D 03     	LDA	UART5			; READ LINE STATUS REGISTER
00D11F  3  29 01        	AND	#$01			; TEST IF DATA IN RECEIVE BUFFER
00D121  3  C9 00        	CMP 	#$00
00D123  3  F0 03        	BEQ	RDSTAT1			; NO, INDICATE NO CHAR
00D125  3  A9 FF        	LDA	#$FF			; GET DATA CHAR
00D127  3  60           	RTS
00D128  3               RDSTAT1:
00D128  3  A9 00        	LDA	#$00			; GET DATA CHAR
00D12A  3  60           	RTS
00D12B  3               
00D12B  3               ; end
00D12B  3               
00D12B  2                 .ENDIF
00D12B  2               
00D12B  2               
00D12B  2                   .IF USEIDEC=1
00D12B  2               	.INCLUDE "DOSIDE.ASM"
00D12B  3               ;__IDE DRIVERS___________________________________________________________________________________________________________________
00D12B  3               ;
00D12B  3               ; 	Nhyodyne IDE disk drivers for Z80PPIDE card
00D12B  3               ;
00D12B  3               ;	Entry points:
00D12B  3               ;		IDE_SOFT_RESET   - called during OS init
00D12B  3               ;		IDE_READ_SECTOR  - read a sector from drive
00D12B  3               ;		IDE_WRITE_SECTOR - write a sector to drive
00D12B  3               ;________________________________________________________________________________________________________________________________
00D12B  3               ;
00D12B  3               PPIDE_PPI	=	$0360		; PORT A
00D12B  3               ;
00D12B  3               PPIDELO		=	PPIDE_PPI+0	; LSB
00D12B  3               PPIDEHI		=	PPIDE_PPI+1	; MSB
00D12B  3               PPIDECNTRL	=	PPIDE_PPI+2	; Control Signals
00D12B  3               PPIDEPPIC	=	PPIDE_PPI+3	; CONTROL BYTE PPI 82C55
00D12B  3               
00D12B  3               PPIDE_A0_LINE	=	$01		;DIRECT FROM 8255 TO IDE INTERFACE
00D12B  3               PPIDE_A1_LINE	=	$02		;DIRECT FROM 8255 TO IDE INTERFACE
00D12B  3               PPIDE_A2_LINE	=	$04		;DIRECT FROM 8255 TO IDE INTERFACE
00D12B  3               PPIDE_CS0_LINE	=	$08		;INVERTER BETWEEN 8255 AND IDE INTERFACE
00D12B  3               PPIDE_CS1_LINE	=	$10		;INVERTER BETWEEN 8255 AND IDE INTERFACE
00D12B  3               PPIDE_WR_LINE	=	$20		;INVERTER BETWEEN 8255 AND IDE INTERFACE
00D12B  3               PPIDE_RD_LINE	=	$40		;INVERTER BETWEEN 8255 AND IDE INTERFACE
00D12B  3               PPIDE_RST_LINE	=	$80		;INVERTER BETWEEN 8255 AND IDE INTERFACE
00D12B  3               
00D12B  3               PPIDE_DATA	=	PPIDE_CS0_LINE
00D12B  3               PPIDE_ERR	=	PPIDE_CS0_LINE + PPIDE_A0_LINE
00D12B  3               PPIDE_SEC_CNT	=	PPIDE_CS0_LINE + PPIDE_A1_LINE
00D12B  3               PPIDE_LBALOW	=	PPIDE_CS0_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00D12B  3               PPIDE_LBAMID	=	PPIDE_CS0_LINE + PPIDE_A2_LINE
00D12B  3               PPIDE_LBAHI	=	PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A0_LINE
00D12B  3               PPIDE_DEVICE	=	PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
00D12B  3               PPIDE_COMMAND	=	PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00D12B  3               PPIDE_STATUS	=	PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00D12B  3               PPIDE_CONTROL	=	PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
00D12B  3               PPIDE_ASTATUS	=	PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
00D12B  3               
00D12B  3               
00D12B  3               ;IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
00D12B  3               PPIDE_CMD_RECAL	=	$10
00D12B  3               PPIDE_CMD_READ	=	$20
00D12B  3               PPIDE_CMD_WRITE	=	$30
00D12B  3               PPIDE_CMD_INIT	=	$91
00D12B  3               PPIDE_CMD_ID	=	$EC
00D12B  3               PPIDE_CMD_SPINDOWN=	$E0
00D12B  3               PPIDE_CMD_SPINUP=	$E1
00D12B  3               
00D12B  3               
00D12B  3               PPRD_IDE_8255	=	%10010010	;IDE_8255_CTL OUT, IDE_8255_LSB/MSB INPUT
00D12B  3               PPWR_IDE_8255	=	%10000000	;ALL THREE PORTS OUTPUT
00D12B  3               
00D12B  3               
00D12B  3  00           PPIDEINDEX:	.byte	$00
00D12C  3  00 00        PPIDETIMEOUT:	.byte	$00,$00
00D12E  3               
00D12E  3               ;__PPIDE_INIT_________________________________________________________________________________________
00D12E  3               ;
00D12E  3               ;  INIT AND DISPLAY IDE INFO
00D12E  3               ;____________________________________________________________________________________________________
00D12E  3               ;
00D12E  3               PPIDE_INIT:
00D12E  3                       PRTDBG "PPIDE INIT:$"
00D12E  3  48 DA 5A A2  	PRTS "PPIDE :$"
00D132  3  00 BD 47 D1  
00D136  3  E8 C9 24 F0  
00D14F  3  20 FC CB            	JSR	NEWLINE
00D152  3  20 E1 D2     	JSR	IDE_PPIDETECT		; TEST FOR PPI HARDWARE
00D155  3  D0 35                BNE     IDE_ABORT      		; BAIL OUT IF NOT THERE
00D157  3               ;
00D157  3  48 DA 5A A2  	PRTS    " IO=0x$"
00D15B  3  00 BD 70 D1  
00D15F  3  E8 C9 24 F0  
00D177  3  A9 03        	LDA	#>PPIDE_PPI		; GET BASE PORT
00D179  3  20 DA CB     	JSR	PRTHEXBYTE		; PRINT BASE PORT
00D17C  3  A9 60               	LDA	#<PPIDE_PPI		; GET BASE PORT
00D17E  3  20 DA CB     	JSR	PRTHEXBYTE		; PRINT BASE PORT
00D181  3               ;
00D181  3  20 66 D3     	JSR	PPIDE_RESET		; RESET THE BUS
00D184  3  20 1A D2     	JSR	PPIDE_PROBE		; DETECT AN ATA DEVICE, ABORT IF NOT FOUND
00D187  3  B0 03        	BCS 	IDE_ABORT
00D189  3  4C B5 D1     	JMP 	IDE_PRINT_INFO
00D18C  3               IDE_ABORT:
00D18C  3  48 DA 5A A2  	PRTS    " NOT PRESENT$"		; NOT PRESENT
00D190  3  00 BD A5 D1  
00D194  3  E8 C9 24 F0  
00D1B2  3  4C 16 D2     	JMP 	IDE_INITA
00D1B5  3               IDE_PRINT_INFO:
00D1B5  3  20 FC CB     	JSR	NEWLINE
00D1B8  3  48 DA 5A A2  	PRTS    " PPIDE0: Blocks=$"
00D1BC  3  00 BD D1 D1  
00D1C0  3  E8 C9 24 F0  
00D1E2  3  A9 00        	LDA	#$00
00D1E4  3  20 5A D2     	JSR	IDE_READ_INFO		; GET DRIVE INFO, ABORT IF ERROR
00D1E7  3  48 DA 5A A2  	PRTS    " PPIDE1: Blocks=$"
00D1EB  3  00 BD 00 D2  
00D1EF  3  E8 C9 24 F0  
00D211  3  A9 01        	LDA	#$01
00D213  3  20 5A D2     	JSR	IDE_READ_INFO		; GET DRIVE INFO, ABORT IF ERROR
00D216  3               IDE_INITA:
00D216  3  20 FC CB     	JSR	NEWLINE
00D219  3  60           	RTS				; DONE
00D21A  3               ;
00D21A  3               ;__PPIDE_PROBE_______________________________________________________________________________________
00D21A  3               ;
00D21A  3               ;  PROBE FOR IDE HARDWARE
00D21A  3               ;____________________________________________________________________________________________________
00D21A  3               ;
00D21A  3               PPIDE_PROBE:
00D21A  3               ;
00D21A  3               	; BELOW TESTS FOR EXISTENCE OF AN IDE CONTROLLER ON THE
00D21A  3               	; PPIDE INTERFACE.  WE WRITE A VALUE OF ZERO FIRST SO THAT
00D21A  3               	; THE PPI BUS HOLD WILL RETURN A VALUE OF ZERO IF THERE IS
00D21A  3               	; NOTHING CONNECTED TO PPI PORT A.  THEN WE READ THE STATUS
00D21A  3               	; REGISTER.  IF AN IDE CONTROLLER IS THERE, IT SHOULD ALWAYS
00D21A  3               	; RETURN SOMETHING OTHER THAN ZERO.  IF AN IDE CONTROLLER IS
00D21A  3               	; THERE, THEN THE VALUE WRITTEN TO PPI PORT A IS IGNORED
00D21A  3               	; BECAUSE THE WRITE SIGNAL IS NEVER PULSED.
00D21A  3               
00D21A  3  A9 00        	LDA 	#$00
00D21C  3  8D 60 03     	STA 	PPIDELO 		; PPI PORT A, DATALO
00D21F  3               
00D21F  3  20 91 D3     	JSR	IDE_WAIT_NOT_BUSY	; WAIT FOR BUSY TO CLEAR
00D222  3  B0 34        	BCS 	PPIDE_PROBE_FAIL	; IF TIMEOUT, REPORT NO IDE PRESENT
00D224  3  A9 0F        	LDA	#PPIDE_STATUS		; GET STATUS
00D226  3  20 8F D4     	JSR	IDE_READ
00D229  3  8A           	TXA
00D22A  3  29 40        	AND 	#%01000000
00D22C  3  C9 00        	CMP 	#$00
00D22E  3  F0 28        	BEQ 	PPIDE_PROBE_FAIL	; IF NOT RDY BIT (BIT 6) THEN REPORT NO IDE PRESENT
00D230  3               
00D230  3               	; CHECK SIGNATURE
00D230  3  A9 0A        	LDA	#PPIDE_SEC_CNT
00D232  3  20 8F D4     	JSR	IDE_READ
00D235  3  E0 01        	CPX 	#$01
00D237  3  D0 1F        	BNE 	PPIDE_PROBE_FAIL	; IF not '01' THEN REPORT NO IDE PRESENT
00D239  3  A9 0B        	LDA	#PPIDE_LBALOW
00D23B  3  20 8F D4     	JSR	IDE_READ
00D23E  3  E0 01        	CPX 	#$01
00D240  3  D0 16        	BNE 	PPIDE_PROBE_FAIL	; IF not '01' THEN REPORT NO IDE PRESENT
00D242  3  A9 0C        	LDA	#PPIDE_LBAMID
00D244  3  20 8F D4     	JSR	IDE_READ
00D247  3  E0 00        	CPX 	#$00
00D249  3  D0 0D        	BNE 	PPIDE_PROBE_FAIL	; IF not '00' THEN REPORT NO IDE PRESENT
00D24B  3  A9 0D        	LDA	#PPIDE_LBAHI
00D24D  3  20 8F D4     	JSR	IDE_READ
00D250  3  E0 00        	CPX 	#$00
00D252  3  D0 04        	BNE 	PPIDE_PROBE_FAIL	; IF not '00' THEN REPORT NO IDE PRESENT
00D254  3  18           	CLC
00D255  3  4C 59 D2     	JMP 	PPIDE_PROBE_SUCCESS
00D258  3               PPIDE_PROBE_FAIL:
00D258  3  38           	SEC
00D259  3               PPIDE_PROBE_SUCCESS:
00D259  3  60           	RTS				; DONE, NOTE THAT A=0 AND Z IS SET
00D25A  3               
00D25A  3               ;*__IDE_READ_INFO___________________________________________________________________________________
00D25A  3               ;*
00D25A  3               ;*  READ IDE INFORMATION
00D25A  3               ;*	CARRY SET ON ERROR
00D25A  3               ;* 	A=MST/SLV
00D25A  3               ;*____________________________________________________________________________________________________
00D25A  3               IDE_READ_INFO:
00D25A  3               		PRTDBG "IDE Read INFORMATION$"
00D25A  3               
00D25A  3               		; SET DRIVE BIT
00D25A  3  29 01        		AND 	#$01			; ONLY WANT THE 1 BIT (MST/SLV)
00D25C  3  0A           		asl	a			; SHIFT 4
00D25D  3  0A           		asl	a			;
00D25E  3  0A           		asl	a			;
00D25F  3  0A           		asl	a			;
00D260  3  09 E0        		ORA 	#$E0			; E0=MST  F0=SLV
00D262  3  AA           		TAX
00D263  3  A0 00        		LDY	#$00
00D265  3  A9 0E        		LDA	#PPIDE_DEVICE
00D267  3  20 AD D4     		JSR	IDE_WRITE
00D26A  3               
00D26A  3               
00D26A  3  20 91 D3     		JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
00D26D  3  B0 48        		BCS	IDE_READ_INFO_ABORT
00D26F  3  A9 0F        		LDA	#PPIDE_COMMAND		;SELECT IDE REGISTER
00D271  3  A2 EC        		LDX	#PPIDE_CMD_ID
00D273  3  20 AD D4     		JSR	IDE_WRITE		;ASK THE DRIVE TO READ IT
00D276  3  20 B9 D3     		JSR	IDE_WAIT_DRQ		;WAIT UNTIL IT'S GOT THE DATA
00D279  3  B0 3C        		BCS	IDE_READ_INFO_ABORT
00D27B  3  20 E9 D3     		JSR	IDE_READ_BUFFER		; GRAB THE 256 WORDS FROM THE BUFFER
00D27E  3  48 DA 5A A2  		PRTS    "0x$"
00D282  3  00 BD 97 D2  
00D286  3  E8 C9 24 F0  
00D29A  3  AD 35 DC     		LDA 	hstbuf+123
00D29D  3  20 DA CB     		JSR 	PRTHEXBYTE
00D2A0  3  AD 34 DC     		LDA 	hstbuf+122
00D2A3  3  20 DA CB     		JSR 	PRTHEXBYTE
00D2A6  3  AD 33 DC     		LDA 	hstbuf+121
00D2A9  3  20 DA CB     		JSR 	PRTHEXBYTE
00D2AC  3  AD 32 DC     		LDA 	hstbuf+120
00D2AF  3  20 DA CB     		JSR 	PRTHEXBYTE
00D2B2  3  20 FC CB     		JSR	NEWLINE
00D2B5  3  18           		CLC
00D2B6  3  60           		RTS
00D2B7  3               IDE_READ_INFO_ABORT:
00D2B7  3  48 DA 5A A2  		PRTS    "NOT PRESENT$"		; NOT PRESENT
00D2BB  3  00 BD D0 D2  
00D2BF  3  E8 C9 24 F0  
00D2DC  3  20 FC CB     		JSR	NEWLINE
00D2DF  3  38           		SEC
00D2E0  3  60           		RTS				;
00D2E1  3               
00D2E1  3               
00D2E1  3               ;__IDE_PPIDETECT____________________________________________________________________________________
00D2E1  3               ;
00D2E1  3               ;  PROBE FOR PPI HARDWARE
00D2E1  3               ;____________________________________________________________________________________________________
00D2E1  3               ;
00D2E1  3               IDE_PPIDETECT:
00D2E1  3               ;
00D2E1  3               	; TEST FOR PPI EXISTENCE
00D2E1  3               	; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
00D2E1  3               	; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
00D2E1  3               	; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
00D2E1  3               	; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
00D2E1  3               	; INTERFERE WITH THE VALUE BEING READ.
00D2E1  3  20 D1 D4     	JSR	SET_PPI_WR
00D2E4  3               ;
00D2E4  3  A9 00        	LDA     #$00			; VALUE ZERO
00D2E6  3  8D 60 03     	STA	PPIDELO			; PUSH VALUE TO PORT
00D2E9  3  AD 60 03     	LDA	PPIDELO			; GET PORT VALUE
00D2EC  3  C9 00                CMP     #$00
00D2EE  3  60           	RTS				; AND RETURN
00D2EF  3               ;
00D2EF  3               
00D2EF  3               
00D2EF  3               ;*__IDE_READ_SECTOR___________________________________________________________________________________
00D2EF  3               ;*
00D2EF  3               ;*  READ IDE SECTOR (IN LBA) INTO BUFFER
00D2EF  3               ;*
00D2EF  3               ;*____________________________________________________________________________________________________
00D2EF  3               IDE_READ_SECTOR:
00D2EF  3               		PRTDBG "IDE Read Sector$"
00D2EF  3  AD 68 D8     		LDA	debsehd			; STORE CURRENT PARMS
00D2F2  3  CD 6D D8     		CMP	Cdebsehd		;
00D2F5  3  D0 13        		BNE	IDE_READ_SECTOR_DIRTY
00D2F7  3  AD 67 D8     		LDA	debcylm			;
00D2FA  3  CD 6C D8     		CMP	Cdebcylm		;
00D2FD  3  D0 0B        		BNE	IDE_READ_SECTOR_DIRTY
00D2FF  3  AD 66 D8     		LDA	debcyll			;
00D302  3  CD 6B D8     		CMP	Cdebcyll		;
00D305  3  D0 03        		BNE	IDE_READ_SECTOR_DIRTY
00D307  3  A9 00        		LDA	#$00			; ZERO = 1 ON RETURN = OPERATION OK
00D309  3  60           		RTS
00D30A  3               
00D30A  3               IDE_READ_SECTOR_DIRTY:
00D30A  3               		PRTDBG "IDE Read Sector Buffer Dirty$"
00D30A  3  20 91 D3     		JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
00D30D  3  B0 27        		BCS 	IDE_READ_SECTOR_DIRTY_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
00D30F  3  20 55 D4     		JSR	IDE_SETUP_LBA		;TELL IT WHICH SECTOR WE WANT
00D312  3  A9 0F        		LDA	#PPIDE_COMMAND		;SELECT IDE REGISTER
00D314  3  A2 20        		LDX	#PPIDE_CMD_READ
00D316  3  20 AD D4     		JSR	IDE_WRITE		;ASK THE DRIVE TO READ IT
00D319  3  20 B9 D3     		JSR	IDE_WAIT_DRQ		;WAIT UNTIL IT'S GOT THE DATA
00D31C  3  B0 18        		BCS 	IDE_READ_SECTOR_DIRTY_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
00D31E  3  20 E9 D3     		JSR	IDE_READ_BUFFER		; GRAB THE 256 WORDS FROM THE BUFFER
00D321  3  AD 68 D8     		LDA	debsehd			; STORE CURRENT PARMS
00D324  3  8D 6D D8     		STA	Cdebsehd		;
00D327  3  AD 66 D8     		LDA	debcyll			;
00D32A  3  8D 6B D8     		STA	Cdebcyll		;
00D32D  3  AD 67 D8     		LDA	debcylm			;
00D330  3  8D 6C D8     		STA	Cdebcylm		;
00D333  3               
00D333  3  A9 00        		LDA	#$00			; ZERO = 1 ON RETURN = OPERATION OK
00D335  3  60           		RTS
00D336  3               IDE_READ_SECTOR_DIRTY_ERROR:
00D336  3  A9 01        		LDA	#$01			; ZERO = 1 ON RETURN = OPERATION OK
00D338  3  60           		RTS
00D339  3               
00D339  3               ;*__IDE_WRITE_SECTOR__________________________________________________________________________________
00D339  3               ;*
00D339  3               ;*  WRITE IDE SECTOR (IN LBA) FROM BUFFER
00D339  3               ;*
00D339  3               ;*____________________________________________________________________________________________________
00D339  3               IDE_WRITE_SECTOR:
00D339  3               		PRTDBG "IDE Write Sector$"
00D339  3  20 91 D3     		JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
00D33C  3  B0 25        		BCS 	IDE_WRITE_SECTOR_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
00D33E  3               
00D33E  3  20 55 D4     		JSR	IDE_SETUP_LBA		;TELL IT WHICH SECTOR WE WANT
00D341  3  A9 0F        		LDA	#PPIDE_COMMAND
00D343  3  A2 30        		LDX	#PPIDE_CMD_WRITE
00D345  3  20 AD D4     		JSR	IDE_WRITE		;TELL DRIVE TO WRITE A SECTOR
00D348  3  20 B9 D3     		JSR	IDE_WAIT_DRQ		;WAIT UNIT IT WANTS THE DATA
00D34B  3  B0 16        		BCS 	IDE_WRITE_SECTOR_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
00D34D  3  20 1E D4     		JSR	IDE_WRITE_BUFFER	;GIVE THE DATA TO THE DRIVE
00D350  3  20 91 D3     		JSR	IDE_WAIT_NOT_BUSY	;WAIT UNTIL THE WRITE IS COMPLETE
00D353  3  B0 0E        		BCS 	IDE_WRITE_SECTOR_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
00D355  3  A9 FF        		LDA	#$FF			; STORE CURRENT PARMS
00D357  3  8D 6D D8     		STA	Cdebsehd		;
00D35A  3  8D 6B D8     		STA	Cdebcyll		;
00D35D  3  8D 6C D8     		STA	Cdebcylm		;
00D360  3               
00D360  3  A9 00        		LDA	#$00			; ZERO ON RETURN = OPERATION OK
00D362  3  60           		RTS
00D363  3               IDE_WRITE_SECTOR_ERROR:
00D363  3  A9 01        		LDA	#$01			; 1 ON RETURN = OPERATION FAIL
00D365  3  60           		RTS
00D366  3               
00D366  3               ;*__PPIDE_RESET____________________________________________________________________________________
00D366  3               ;*
00D366  3               ;*  SOFT RESET IDE CHANNEL
00D366  3               ;*
00D366  3               ;*____________________________________________________________________________________________________
00D366  3               PPIDE_RESET:
00D366  3                 	PRTDBG "IDE Reset$"
00D366  3  A9 00        		LDA	#$00
00D368  3  8D 68 D8     		STA	debsehd
00D36B  3  8D 66 D8     		STA	debcyll
00D36E  3  8D 67 D8     		STA	debcylm
00D371  3  A9 FF        		LDA	#$FF			;
00D373  3  8D 6D D8     		STA	Cdebsehd		;
00D376  3  8D 6B D8     		STA	Cdebcyll		;
00D379  3  8D 6C D8     		STA	Cdebcylm		;
00D37C  3               
00D37C  3  A9 80        		LDA	#PPIDE_RST_LINE
00D37E  3  8D 62 03     		STA	PPIDECNTRL			; ASSERT RST LINE ON IDE INTERFACE
00D381  3  A2 00        		LDX	#$00
00D383  3               	PRTDBG "IDE Reset Delay$"
00D383  3               RST_DLY:
00D383  3  CA           		DEX
00D384  3  E0 00        		CPX	#$00
00D386  3  D0 FB        		BNE	RST_DLY
00D388  3  A9 00        		LDA	#$00
00D38A  3  8D 62 03     		STA	PPIDECNTRL			; DEASSERT RST LINE ON IDE INTERFACE
00D38D  3               
00D38D  3               ; IF A DSKYNG IS ACTIVE AND IS ON THE SAME PPI PORT AS THE PPISD BEING
00D38D  3               ; RESET, THEN THE DSKYNG WILL ALSO BE RESET.  SO, THE DSKY IS ALSO INITIALIZED.
00D38D  3               	.IF (USEDSKYNG=1)
00D38D  3  20 C5 D5     	JSR 	DSKY_REINIT
00D390  3               	.ENDIF
00D390  3               
00D390  3  60           		RTS
00D391  3               
00D391  3               
00D391  3               ;*__IDE_WAIT_NOT_BUSY_______________________________________________________________________________
00D391  3               ;*
00D391  3               ;*  WAIT FOR IDE CHANNEL TO BECOME READY
00D391  3               ;*
00D391  3               ;*____________________________________________________________________________________________________
00D391  3               IDE_WAIT_NOT_BUSY:
00D391  3  DA           		PHX
00D392  3  5A           		PHY
00D393  3  48           		PHA
00D394  3  A9 00        		LDA #$00
00D396  3  8D 2C D1     		STA PPIDETIMEOUT
00D399  3  8D 2D D1     		STA PPIDETIMEOUT+1
00D39C  3               IDE_WAIT_NOT_BUSY1:
00D39C  3  A9 0F        		LDA	#PPIDE_STATUS		;WAIT FOR RDY BIT TO BE SET
00D39E  3  20 8F D4     		JSR	IDE_READ
00D3A1  3  8A           		TXA
00D3A2  3  29 80        		AND	#$80
00D3A4  3  F0 0E        		BEQ	IDE_WAIT_NOT_BUSY2
00D3A6  3  EE 2C D1     		INC 	PPIDETIMEOUT
00D3A9  3  D0 F1        		BNE 	IDE_WAIT_NOT_BUSY1
00D3AB  3  EE 2D D1     		INC 	PPIDETIMEOUT+1
00D3AE  3  D0 EC        		BNE 	IDE_WAIT_NOT_BUSY1
00D3B0  3  38           		SEC
00D3B1  3  4C B5 D3     		JMP	IDE_WAIT_NOT_BUSY3
00D3B4  3               IDE_WAIT_NOT_BUSY2:
00D3B4  3  18           		CLC
00D3B5  3               IDE_WAIT_NOT_BUSY3:
00D3B5  3  68           		PLA
00D3B6  3  7A           		PLY
00D3B7  3  FA           		PLX
00D3B8  3  60           		RTS
00D3B9  3               
00D3B9  3               ;*__IDE_WAIT_DRQ______________________________________________________________________________________
00D3B9  3               ;*
00D3B9  3               ;*	WAIT FOR THE DRIVE TO BE READY TO TRANSFER DATA.
00D3B9  3               ;*
00D3B9  3               ;*____________________________________________________________________________________________________
00D3B9  3               IDE_WAIT_DRQ:
00D3B9  3  DA           		PHX
00D3BA  3  5A           		PHY
00D3BB  3  48           		PHA
00D3BC  3  A9 00        		LDA #$00
00D3BE  3  8D 2C D1     		STA PPIDETIMEOUT
00D3C1  3  8D 2D D1     		STA PPIDETIMEOUT+1
00D3C4  3               IDE_WAIT_DRQ1:
00D3C4  3  A9 0F        		LDA	#PPIDE_STATUS		;WAIT FOR DRQ BIT TO BE SET
00D3C6  3  20 8F D4     		JSR	IDE_READ
00D3C9  3  8A           		TXA
00D3CA  3  29 88        		AND	#%10001000		; MASK OFF BUSY(7) AND DRQ(3)
00D3CC  3  C9 08        		CMP	#%00001000		; WE WANT BUSY(7) TO BE 0 AND DRQ (3) TO BE 1
00D3CE  3  F0 14        		BEQ	IDE_WAIT_DRQ2
00D3D0  3  29 01        		AND	#%00000001		; IS ERROR?
00D3D2  3  C9 01        		CMP	#%00000001		;
00D3D4  3  F0 0A        		BEQ	IDE_WAIT_DRQE
00D3D6  3  EE 2C D1     		INC 	PPIDETIMEOUT
00D3D9  3  D0 E9        		BNE 	IDE_WAIT_DRQ1
00D3DB  3  EE 2D D1     		INC 	PPIDETIMEOUT+1
00D3DE  3  D0 E4        		BNE 	IDE_WAIT_DRQ1
00D3E0  3               IDE_WAIT_DRQE:
00D3E0  3  38           		SEC
00D3E1  3  4C E5 D3     		JMP	IDE_WAIT_DRQ3
00D3E4  3               IDE_WAIT_DRQ2:
00D3E4  3  18           		CLC
00D3E5  3               IDE_WAIT_DRQ3:
00D3E5  3  68           		PLA
00D3E6  3  7A           		PLY
00D3E7  3  FA           		PLX
00D3E8  3  60           		RTS
00D3E9  3               
00D3E9  3               
00D3E9  3               
00D3E9  3               ;*__IDE_READ_BUFFER___________________________________________________________________________________
00D3E9  3               ;*
00D3E9  3               ;*  READ IDE BUFFER LITTLE ENDIAN
00D3E9  3               ;*
00D3E9  3               ;*____________________________________________________________________________________________________
00D3E9  3               IDE_READ_BUFFER:
00D3E9  3  A2 00        		LDX    	#$00			; INDEX
00D3EB  3               IDEBUFRD:
00D3EB  3  8E 2B D1     		STX	PPIDEINDEX
00D3EE  3  A9 08        		LDA	#PPIDE_DATA
00D3F0  3  20 8F D4     		JSR	IDE_READ
00D3F3  3  8A           		TXA
00D3F4  3  AE 2B D1     		LDX	PPIDEINDEX
00D3F7  3  9D BA DB     		STA	hstbuf,X		;
00D3FA  3  E8           		INX				;
00D3FB  3  98           		TYA				; THEN HIGH BYTE OF WORD
00D3FC  3  9D BA DB     		STA	hstbuf,X		;
00D3FF  3  E8           		INX
00D400  3  E0 00        		CPX    	#$00			;
00D402  3  D0 E7        		BNE	IDEBUFRD		;
00D404  3               IDEBUFRD1:
00D404  3  8E 2B D1     		STX	PPIDEINDEX
00D407  3  A9 08        		LDA	#PPIDE_DATA
00D409  3  20 8F D4     		JSR	IDE_READ
00D40C  3  8A           		TXA
00D40D  3  AE 2B D1     		LDX	PPIDEINDEX
00D410  3  9D BA DC     		STA	hstbuf+256,X		;
00D413  3  E8           		INX				;
00D414  3  98           		TYA				; THEN HIGH BYTE OF WORD
00D415  3  9D BA DC     		STA	hstbuf+256,X		;
00D418  3  E8           		INX				;
00D419  3  E0 00        		CPX    	#$00			;
00D41B  3  D0 E7        		BNE	IDEBUFRD1		;
00D41D  3  60           		RTS				;
00D41E  3               
00D41E  3               ;*__IDE_WRITE_BUFFER___________________________________________________________________________________
00D41E  3               ;*
00D41E  3               ;*  WRITE IDE BUFFER LITTLE ENDIAN
00D41E  3               ;*
00D41E  3               ;*____________________________________________________________________________________________________
00D41E  3               IDE_WRITE_BUFFER:
00D41E  3  A2 00        		LDX    	#$00			; INDEX
00D420  3               IDEBUFWT:
00D420  3  8E 2B D1     		STX	PPIDEINDEX
00D423  3  BD BB DB     		LDA     hstbuf+1,X		; SECTORS ARE BIG ENDIAN
00D426  3  A8           		TAY				;
00D427  3  BD BA DB     		LDA     hstbuf,X		; SECTORS ARE BIG ENDIAN
00D42A  3  AA           		TAX
00D42B  3  A9 08        		LDA	#PPIDE_DATA
00D42D  3  20 AD D4     		JSR	IDE_WRITE
00D430  3  AE 2B D1     		LDX	PPIDEINDEX
00D433  3  E8           		INX				;
00D434  3  E8           		INX				;
00D435  3  E0 00        		CPX    	#$00			;
00D437  3  D0 E7        		BNE	IDEBUFWT		;
00D439  3  A2 00        		LDX    	#$00			; INDEX
00D43B  3               IDEBUFWT1:
00D43B  3  8E 2B D1     		STX	PPIDEINDEX
00D43E  3  BD BB DC     		LDA     hstbuf+257,X		; SECTORS ARE BIG ENDIAN
00D441  3  A8           		TAY
00D442  3  BD BA DC     		LDA     hstbuf+256,X		; SECTORS ARE BIG ENDIAN
00D445  3  AA           		TAX
00D446  3  A9 08        		LDA	#PPIDE_DATA
00D448  3  20 AD D4     		JSR	IDE_WRITE
00D44B  3  AE 2B D1     		LDX	PPIDEINDEX
00D44E  3  E8           		INX				;
00D44F  3  E8           		INX				;
00D450  3  E0 00        		CPX    	#$00			;
00D452  3  D0 E7        		BNE	IDEBUFWT1		;
00D454  3  60           		RTS				;
00D455  3               
00D455  3               ;*__IDE_SETUP_LBA_____________________________________________________________________________________
00D455  3               ;*
00D455  3               ;*  SETUP LBA DATA
00D455  3               ;*
00D455  3               ;*____________________________________________________________________________________________________
00D455  3               IDE_SETUP_LBA:
00D455  3               		PRTDBG "PPIDE SETUP LBA$"
00D455  3               
00D455  3  AD 5A D8     		LDA	sekdsk			; GET DRIVE
00D458  3  29 07        		AND 	#7			; ONLY FIRST 8 DEVICES SUPPORTED
00D45A  3  0A           		asl	a			; DOUBLE NUMBER FOR TABLE LOOKUP
00D45B  3  AA           		TAX 				; MOVE TO X REGISTER
00D45C  3  BD F0 CD     		LDA 	dskcfg,X 		; GET device
00D45F  3  29 01        		and 	#$01			; only want drive cfg
00D461  3  0A           		asl	a			; SHIFT 4
00D462  3  0A           		asl	a			;
00D463  3  0A           		asl	a			;
00D464  3  0A           		asl	a			;
00D465  3  09 E0        		ORA 	#$E0			; E0=MST  F0=SLV
00D467  3  AA           		TAX
00D468  3  A0 00        		LDY	#$00
00D46A  3  A9 0E        		LDA	#PPIDE_DEVICE
00D46C  3  20 AD D4     		JSR	IDE_WRITE
00D46F  3               
00D46F  3  AE 67 D8     		LDX    	debcylm
00D472  3  A9 0D        		LDA	#PPIDE_LBAHI
00D474  3  20 AD D4     		JSR	IDE_WRITE
00D477  3               
00D477  3  AE 66 D8     		LDX    	debcyll			;
00D47A  3  A9 0C        		LDA	#PPIDE_LBAMID
00D47C  3  20 AD D4     		JSR	IDE_WRITE
00D47F  3               
00D47F  3  AE 68 D8     		LDX    	debsehd			;
00D482  3  A9 0B        		LDA	#PPIDE_LBALOW
00D484  3  20 AD D4     		JSR	IDE_WRITE
00D487  3               
00D487  3  A2 01        		LDX	#$01
00D489  3  A9 0A        		LDA	#PPIDE_SEC_CNT
00D48B  3  20 AD D4     		JSR	IDE_WRITE
00D48E  3               
00D48E  3  60           		RTS
00D48F  3               
00D48F  3               
00D48F  3               ;-------------------------------------------------------------------------------
00D48F  3               
00D48F  3               ; LOW LEVEL I/O TO THE DRIVE.  THESE ARE THE ROUTINES THAT TALK
00D48F  3               ; DIRECTLY TO THE DRIVE, VIA THE 8255 CHIP.  NORMALLY A MAIN
00D48F  3               ; PROGRAM WOULD NOT CALL TO THESE.
00D48F  3               
00D48F  3               	;DO A READ BUS CYCLE TO THE DRIVE, USING THE 8255.
00D48F  3               	;INPUT A = IDE REGSITER ADDRESS
00D48F  3               	;OUTPUT X = LOWER BYTE READ FROM IDE DRIVE
00D48F  3               	;OUTPUT Y = UPPER BYTE READ FROM IDE DRIVE
00D48F  3               
00D48F  3               IDE_READ:
00D48F  3  20 C9 D4     	JSR	SET_PPI_RD		; SETUP FOR A READ CYCLE
00D492  3               
00D492  3  8D 62 03     	STA	PPIDECNTRL		;DRIVE ADDRESS ONTO CONTROL LINES
00D495  3  09 40        	ORA	#PPIDE_RD_LINE		; ASSERT RD PIN
00D497  3  8D 62 03     	STA	PPIDECNTRL
00D49A  3  48           	PHA
00D49B  3               
00D49B  3  AE 60 03     	LDX	PPIDELO			; READ LOWER BYTE
00D49E  3  AC 61 03     	LDY	PPIDEHI			; READ UPPER BYTE
00D4A1  3               
00D4A1  3  68           	PLA				; RESTORE REGISTER VALUE
00D4A2  3  49 40        	EOR	#PPIDE_RD_LINE		; DE-ASSERT RD SIGNAL
00D4A4  3  8D 62 03     	STA	PPIDECNTRL
00D4A7  3  A9 00        	LDA	#$00
00D4A9  3  8D 62 03     	STA	PPIDECNTRL		;DEASSERT ALL CONTROL PINS
00D4AC  3  60           	RTS
00D4AD  3               
00D4AD  3               
00D4AD  3               
00D4AD  3               
00D4AD  3               	;DO A WRITE BUS CYCLE TO THE DRIVE, VIA THE 8255
00D4AD  3               	;INPUT A = IDE REGISTER ADDRESS
00D4AD  3               	;INPUT REGISTER X = LSB TO WRITE
00D4AD  3               	;INPUT REGISTER Y = MSB TO WRITE
00D4AD  3               	;
00D4AD  3               
00D4AD  3               
00D4AD  3               IDE_WRITE:
00D4AD  3  20 D1 D4     	JSR	SET_PPI_WR		; SETUP FOR A WRITE CYCLE
00D4B0  3               
00D4B0  3  8E 60 03     	STX	PPIDELO			; WRITE LOWER BYTE
00D4B3  3  8C 61 03     	STY	PPIDEHI			; WRITE UPPER BYTE
00D4B6  3               
00D4B6  3  8D 62 03     	STA	PPIDECNTRL		;DRIVE ADDRESS ONTO CONTROL LINES
00D4B9  3               
00D4B9  3  09 20        	ORA	#PPIDE_WR_LINE		; ASSERT WRITE PIN
00D4BB  3  8D 62 03     	STA	PPIDECNTRL
00D4BE  3               
00D4BE  3  49 20        	EOR	#PPIDE_WR_LINE		; DE ASSERT WR PIN
00D4C0  3  8D 62 03     	STA	PPIDECNTRL
00D4C3  3               
00D4C3  3  A9 00        	LDA	#$00
00D4C5  3  8D 62 03     	STA	PPIDECNTRL		;DEASSERT ALL CONTROL PINS
00D4C8  3  60           	RTS
00D4C9  3               
00D4C9  3               
00D4C9  3               ;-----------------------------------------------------------------------------------
00D4C9  3               ; PPI SETUP ROUTINE TO CONFIGURE THE APPROPRIATE PPI MODE
00D4C9  3               ;
00D4C9  3               ;------------------------------------------------------------------------------------
00D4C9  3               
00D4C9  3               SET_PPI_RD:
00D4C9  3  48           	PHA
00D4CA  3  A9 92        	LDA	#PPRD_IDE_8255
00D4CC  3  8D 63 03     	STA	PPIDEPPIC				;CONFIG 8255 CHIP, READ MODE
00D4CF  3  68           	PLA
00D4D0  3  60           	RTS
00D4D1  3               
00D4D1  3               SET_PPI_WR:
00D4D1  3  48           	PHA
00D4D2  3  A9 80        	LDA	#PPWR_IDE_8255
00D4D4  3  8D 63 03     	STA	PPIDEPPIC				;CONFIG 8255 CHIP, WRITE MODE
00D4D7  3  68           	PLA
00D4D8  3  60           	RTS
00D4D9  3               
00D4D9  2                   .ENDIF
00D4D9  2               
00D4D9  2                   .IF USEFLOPPYA=1 | USEFLOPPYB=1
00D4D9  2               	.INCLUDE "DOS65\\DOSFLPV3.ASM"
00D4D9  2                   .ENDIF
00D4D9  2               
00D4D9  2                   .IF USEDSKY=1
00D4D9  2                    .INCLUDE "DOSDSKY.ASM"
00D4D9  2                   .ENDIF
00D4D9  2               
00D4D9  2                   .IF USEDSKYNG=1
00D4D9  2                    .INCLUDE "DOSDSKYN.ASM"
00D4D9  3               ;__DSKYNG DRIVERS_________________________________________________________________________________________________________________
00D4D9  3               ;
00D4D9  3               ; 	Nhyodyne DSKY/NG drivers
00D4D9  3               ;
00D4D9  3               ;	Entry points:
00D4D9  3               ;               DSKY_INIT
00D4D9  3               ;               DSKY_SHOW
00D4D9  3               ;               DSKY_BIN2SEG
00D4D9  3               ;               DSKY_RESET
00D4D9  3               ;               DSKY_STAT
00D4D9  3               ;               DSKY_GETKEY
00D4D9  3               ;               DSKY_BEEP
00D4D9  3               ;               DSKY_L1ON
00D4D9  3               ;               DSKY_L2ON
00D4D9  3               ;               DSKY_L1OFF
00D4D9  3               ;               DSKY_L2OFF
00D4D9  3               ;               DSKY_PUTLED
00D4D9  3               ;               DSKY_BLANK
00D4D9  3               ;________________________________________________________________________________________________________________________________
00D4D9  3               ;
00D4D9  3               ;
00D4D9  3               ; A DSKYNG CAN SHARE A PPI BUS WITH EITHER A PPIDE OR PPISD.
00D4D9  3               ;
00D4D9  3               ; LED SEGMENTS (BIT VALUES)
00D4D9  3               ;
00D4D9  3               ;	+--01--+
00D4D9  3               ;	20    02
00D4D9  3               ;	+--40--+
00D4D9  3               ;	10    04
00D4D9  3               ;	+--08--+  80
00D4D9  3               ;
00D4D9  3               ; KEY CODE MAP (KEY CODES) CSCCCRRR
00D4D9  3               ;                          ||||||||
00D4D9  3               ;                          |||||+++-- ROW
00D4D9  3               ;                          ||+++----- COL
00D4D9  3               ;                          |+-------- SHIFT
00D4D9  3               ;                          +--------- CONTROL
00D4D9  3               ;
00D4D9  3               ;	00	08	10	18	23
00D4D9  3               ;	01	09	11	19	22
00D4D9  3               ;	02	0A	12	1A	21
00D4D9  3               ;	03	0B	13	1B	20
00D4D9  3               ;	04	0C	14	1C	SHIFT
00D4D9  3               ;	05	0D	15	1D	CTRL
00D4D9  3               ;
00D4D9  3               ; LED BIT MAP (BIT VALUES)
00D4D9  3               ;
00D4D9  3               ;	$08	$09	$0A	$0B	$0C	$0D	$0E	$0F
00D4D9  3               ;	---	---	---	---	---	---	---	---
00D4D9  3               ;	01	01	01	01	01
00D4D9  3               ;	02	02	02	02	02
00D4D9  3               ;	04      04      04      04	04
00D4D9  3               ;	08      08      08      08	08
00D4D9  3               ;	10      10      10      10	10
00D4D9  3               ;	20      20      20      20	20	L1	L2 	BUZZ
00D4D9  3               ;
00D4D9  3               DSKY_PPI	=	$0360		; PORT
00D4D9  3               DSKY_PPIA	= 	DSKY_PPI + 0 	; PORT A
00D4D9  3               DSKY_PPIB	= 	DSKY_PPI + 1 	; PORT B
00D4D9  3               DSKY_PPIC	= 	DSKY_PPI + 2    ; PORT C
00D4D9  3               DSKY_PPIX 	= 	DSKY_PPI + 3    ; PPI CONTROL PORT
00D4D9  3               ;
00D4D9  3               DSKY_PPIX_RD	=	%10010010	; PPIX VALUE FOR READS
00D4D9  3               DSKY_PPIX_WR	=	%10000010	; PPIX VALUE FOR WRITES
00D4D9  3               ;
00D4D9  3               ; PIO CHANNEL C:
00D4D9  3               ;
00D4D9  3               ;	7	6	5	4	3	2	1	0
00D4D9  3               ;	RES	0	0	CS	CS	/RD	/WR	A0
00D4D9  3               ;
00D4D9  3               ; SETTING BITS 3 & 4 WILL ASSERT /CS ON 3279
00D4D9  3               ; CLEAR BITS 1 OR 2 TO ASSERT READ/WRITE
00D4D9  3               ;
00D4D9  3               DSKY_PPI_IDLE	=	%00000110
00D4D9  3               ;
00D4D9  3               DSKY_CMD_CLR	=	%11011111	; CLEAR (ALL OFF)
00D4D9  3               DSKY_CMD_CLRX	=	%11010011	; CLEAR (ALL ON)
00D4D9  3               DSKY_CMD_WDSP	=	%10010000	; WRITE DISPLAY RAM
00D4D9  3               DSKY_CMD_RDSP	=	%01110000	; READ DISPLAY RAM
00D4D9  3               DSKY_CMD_CLK	=	%00100000	; SET CLK PRESCALE
00D4D9  3               DSKY_CMD_FIFO	=	%01000000	; READ FIFO
00D4D9  3               ;
00D4D9  3               DSKY_PRESCL	=	DSKYOSC/100000	; PRESCALER
00D4D9  3               ;
00D4D9  3               ;__DSKY_INIT_________________________________________________________________________________________
00D4D9  3               ;
00D4D9  3               ;  DISPLAY DSKY INFO
00D4D9  3               ;____________________________________________________________________________________________________
00D4D9  3               ;
00D4D9  3               DSKY_INIT:
00D4D9  3                       PRTDBG "DSKY INIT:$"
00D4D9  3  20 95 D5             JSR     DSKY_PREINIT
00D4DC  3  48 DA 5A A2  	PRTS "DSKY:$"
00D4E0  3  00 BD F5 D4  
00D4E4  3  E8 C9 24 F0  
00D4FB  3  20 FC CB            	JSR	NEWLINE
00D4FE  3               
00D4FE  3               ;
00D4FE  3  48 DA 5A A2  	PRTS    " IO=0x$"
00D502  3  00 BD 17 D5  
00D506  3  E8 C9 24 F0  
00D51E  3  A9 03        	LDA	#>DSKY_PPI		; GET BASE PORT
00D520  3  20 DA CB     	JSR	PRTHEXBYTE		; PRINT BASE PORT
00D523  3  A9 60               	LDA	#<DSKY_PPI		; GET BASE PORT
00D525  3  20 DA CB     	JSR	PRTHEXBYTE		; PRINT BASE PORT
00D528  3  48 DA 5A A2  	PRTS    " MODE=$"
00D52C  3  00 BD 41 D5  
00D530  3  E8 C9 24 F0  
00D548  3  48 DA 5A A2  	PRTS    "NG$"			; PRINT DSKY TYPE
00D54C  3  00 BD 61 D5  
00D550  3  E8 C9 24 F0  
00D564  3               ;
00D564  3  AD 23 D8     	LDA	DSKY_PRESENT	        ; PRESENT?
00D567  3  C9 FF        	CMP     #$FF		        ; SET FLAGS
00D569  3  F0 26                BEQ     DSKY_INITA
00D56B  3  48 DA 5A A2  	PRTS    " NOT PRESENT$"		; NOT PRESENT
00D56F  3  00 BD 84 D5  
00D573  3  E8 C9 24 F0  
00D591  3               DSKY_INITA:
00D591  3  20 FC CB     	JSR	NEWLINE
00D594  3  60           	RTS				; DONE
00D595  3               ;
00D595  3               ;__DSKY_PREINIT______________________________________________________________________________________
00D595  3               ;
00D595  3               ;  CONFIGURE PARALLEL PORT AND INITIALIZE 8279
00D595  3               ;____________________________________________________________________________________________________
00D595  3               ; HARDWARE RESET 8279 BY PULSING RESET LINE
00D595  3               DSKY_PREINIT:
00D595  3               	; CHECK FOR PPI
00D595  3  20 DA D5     	JSR	DSKY_PPIDETECT		; TEST FOR PPI HARDWARE
00D598  3  D0 2A                BNE     DSKY_ABORT      	; BAIL OUT IF NOT THERE
00D59A  3               
00D59A  3               	; SETUP PPI TO DEFAULT MODE
00D59A  3  20 FC D7     	JSR	DSKY_PPIRD
00D59D  3               	; INIT 8279 VALUES TO IDLE STATE
00D59D  3  A9 06        	LDA	#DSKY_PPI_IDLE
00D59F  3  8D 62 03     	STA	DSKY_PPIC
00D5A2  3               	; PULSE RESET SIGNAL ON 8279
00D5A2  3  09 80        	ORA 	#%10000000
00D5A4  3  8D 62 03     	STA	DSKY_PPIC
00D5A7  3  29 7F        	AND 	#%01111111
00D5A9  3  8D 62 03     	STA	DSKY_PPIC
00D5AC  3               	; INITIALIZE 8279
00D5AC  3  20 C5 D5     	JSR	DSKY_REINIT
00D5AF  3               	; NOW SEE IF A DSKYNG IS REALLY THERE...
00D5AF  3  A9 A5        	LDA     #$A5
00D5B1  3  A0 00                LDY     #$00
00D5B3  3  20 16 D7     	JSR	DSKY_PUTBYTE
00D5B6  3  A0 00                LDY     #$00
00D5B8  3  20 2A D7     	JSR	DSKY_GETBYTE
00D5BB  3  C9 A5        	CMP	#$A5
00D5BD  3  D0 05        	BNE     DSKY_ABORT			; BAIL OUT IF MISCOMPARE
00D5BF  3  A9 FF        	LDA	#$FF
00D5C1  3  8D 23 D8     	STA	DSKY_PRESENT
00D5C4  3               DSKY_ABORT:
00D5C4  3  60           	RTS
00D5C5  3               ;
00D5C5  3               DSKY_REINIT:
00D5C5  3  20 0E D8     	JSR	DSKY_PPIIDLE
00D5C8  3               	; SET CLOCK SCALER TO 20
00D5C8  3  A9 21        	LDA	#DSKY_CMD_CLK | DSKY_PRESCL
00D5CA  3  20 96 D6     	JSR	DSKY_CMD
00D5CD  3               	; FALL THRU
00D5CD  3               ;
00D5CD  3               DSKY_RESET:
00D5CD  3               	; RESET DSKY -- CLEAR RAM AND FIFO
00D5CD  3  A9 DF        	LDA	#DSKY_CMD_CLR
00D5CF  3  20 96 D6     	JSR	DSKY_CMD
00D5D2  3               ;
00D5D2  3               	; 8259 TAKES ~160US TO CLEAR RAM DURING WHICH TIME WRITES TO
00D5D2  3               	; DISPLAY RAM ARE INHIBITED.  HIGH BIT OF STATUS BYTE IS SET
00D5D2  3               	; DURING THIS WINDOW.  TO PREVENT A DEADLOCK, A LOOP COUNTER
00D5D2  3               	; IS USED TO IMPLEMENT A TIMEOUT.
00D5D2  3  A2 00        	LDX	#0			; TIMEOUT LOOP COUNTER
00D5D4  3               DSKY_RESET1:
00D5D4  3  DA           	PHX     			; SAVE COUNTER
00D5D5  3               	;JSR	DSKY_ST			; GET STATUS BYTE
00D5D5  3  FA           	PLX				; RECOVER COUNTER
00D5D6  3                     ;  AND     #%10000000
00D5D6  3                     ;  BEQ     DSKY_RESET2		; MOVE ON IF DONE
00D5D6  3  CA                   DEX
00D5D7  3  D0 FB                BNE     DSKY_RESET1		; LOOP TILL TIMEOUT
00D5D9  3               ;
00D5D9  3               DSKY_RESET2:
00D5D9  3  60           	RTS
00D5DA  3               ;
00D5DA  3               ;
00D5DA  3               ;
00D5DA  3               ;__DSKY_PPIDETECT____________________________________________________________________________________
00D5DA  3               ;
00D5DA  3               ;  PROBE FOR PPI HARDWARE
00D5DA  3               ;____________________________________________________________________________________________________
00D5DA  3               ;
00D5DA  3               DSKY_PPIDETECT:
00D5DA  3               ;
00D5DA  3               	; TEST FOR PPI EXISTENCE
00D5DA  3               	; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
00D5DA  3               	; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
00D5DA  3               	; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
00D5DA  3               	; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
00D5DA  3               	; INTERFERE WITH THE VALUE BEING READ.
00D5DA  3  20 E5 D7     	JSR	DSKY_PPIWR
00D5DD  3               ;
00D5DD  3  A9 00        	LDA     #$00			; VALUE ZERO
00D5DF  3  8D 60 03     	STA	DSKY_PPIA		; PUSH VALUE TO PORT
00D5E2  3  AD 60 03     	LDA	DSKY_PPIA		; GET PORT VALUE
00D5E5  3  C9 00                CMP     #$00
00D5E7  3  60           	RTS				; AND RETURN
00D5E8  3               ;
00D5E8  3                .IF DSKY_KBD=1
00D5E8  3               ;
00D5E8  3               KY_0	=	$00
00D5E8  3               KY_1	=	$01
00D5E8  3               KY_2	=	$02
00D5E8  3               KY_3	=	$03
00D5E8  3               KY_4	=	$04
00D5E8  3               KY_5	=	$05
00D5E8  3               KY_6	=	$06
00D5E8  3               KY_7	=	$07
00D5E8  3               KY_8	=	$08
00D5E8  3               KY_9	=	$09
00D5E8  3               KY_A	=	$0A
00D5E8  3               KY_B	=	$0B
00D5E8  3               KY_C	=	$0C
00D5E8  3               KY_D	=	$0D
00D5E8  3               KY_E	=	$0E
00D5E8  3               KY_F	=	$0F
00D5E8  3               KY_FW	=	$10	; FORWARD
00D5E8  3               KY_BK	=	$11	; BACKWARD
00D5E8  3               KY_CL	=	$12	; CLEAR
00D5E8  3               KY_EN	=	$13	; ENTER
00D5E8  3               KY_DE	=	$14	; DEPOSIT
00D5E8  3               KY_EX	=	$15	; EXAMINE
00D5E8  3               KY_GO	=	$16	; GO
00D5E8  3               KY_BO	=	$17	; BOOT
00D5E8  3               KY_F4	=	$18	; F4
00D5E8  3               KY_F3	=	$19	; F3
00D5E8  3               KY_F2	=	$20	; F2
00D5E8  3               KY_F1	=	$21	; F1
00D5E8  3               ;
00D5E8  3               ;__DSKY_STAT_________________________________________________________________________________________
00D5E8  3               ;
00D5E8  3               ;  CHECK FOR KEY PRESS, SAVE RAW VALUE, RETURN STATUS
00D5E8  3               ;____________________________________________________________________________________________________
00D5E8  3               ;
00D5E8  3               DSKY_STAT:
00D5E8  3  AD 23 D8     	LDA	DSKY_PRESENT            ; DOES IT EXIST?
00D5EB  3  C9 FF        	CMP     #$FF			; SET FLAGS
00D5ED  3  D0 05                BNE     DSKY_STATA		; ABORT WITH A=0 IF NOT THERE
00D5EF  3  20 CF D6     	JSR	DSKY_ST
00D5F2  3  29 0F        	AND	#$0F			; ISOLATE THE CUR FIFO LEN
00D5F4  3               DSKY_STATA:
00D5F4  3  60           	RTS
00D5F5  3               ;
00D5F5  3               ;__DSKY_GETKEY_____________________________________________________________________________________
00D5F5  3               ;
00D5F5  3               ;  WAIT FOR A DSKY KEYPRESS AND RETURN
00D5F5  3               ;____________________________________________________________________________________________________
00D5F5  3               ;
00D5F5  3               DSKY_GETKEY:
00D5F5  3  AD 23 D8     	LDA	DSKY_PRESENT    	; DOES IT EXIST?
00D5F8  3  C9 FF               	CMP     #$FF			; SET FLAGS
00D5FA  3  D0 24                BNE     DSKY_GETKEY1A		; ABORT WITH A=0 IF NOT THERE
00D5FC  3  20 E8 D5     	JSR	DSKY_STAT
00D5FF  3  F0 F4                BEQ     DSKY_GETKEY		; LOOP IF NOTHING THERE
00D601  3  A9 40        	LDA	#DSKY_CMD_FIFO
00D603  3  20 96 D6     	JSR	DSKY_CMD
00D606  3  20 D4 D6     	JSR	DSKY_DIN
00D609  3  49 C0        	EOR	#%11000000		; FLIP POLARITY OF SHIFT/CTL BITS
00D60B  3  48                   PHA
00D60C  3  29 3F        	AND	#$3F			; STRIP SHIFT/CTL BITS FOR LOOKUP
00D60E  3  8D 21 D8     	STA     DSKY_TEMP_VAL
00D611  3  A2 00        	LDX	#0			; INDEX
00D613  3               DSKY_GETKEY1:
00D613  3  BD 2F D6             LDA     DSKY_KEYMAP,X
00D616  3  CD 21 D8     	CMP	DSKY_TEMP_VAL		; MATCH?
00D619  3  F0 09                BEQ     DSKY_GETKEY2		; FOUND, DONE
00D61B  3  E8           	INX
00D61C  3  E0 1C                CPX     #28
00D61E  3  D0 F3                BNE	DSKY_GETKEY1		; LOOP UNTIL EOT
00D620  3               DSKY_GETKEY1A:
00D620  3  68                   PLA
00D621  3  A9 FF        	LDA	#$FF			; NOT FOUND ERR, RETURN $FF
00D623  3  60           	RTS
00D624  3               DSKY_GETKEY2:
00D624  3               	; RETURN THE INDEX POSITION WHERE THE SCAN CODE WAS FOUND
00D624  3               	; THE ORIGINAL SHIFT/CTRL BITS ARE RESTORED
00D624  3  68           	PLA				; RESTORE RAW VALUE
00D625  3  25 C0        	AND	%11000000		; ISOLATE SHIFT/CTRL BITS
00D627  3  8D 21 D8             STA     DSKY_TEMP_VAL
00D62A  3  8A                   TXA
00D62B  3  0D 21 D8     	ORA	DSKY_TEMP_VAL		; COMBINE WITH INDEX VALUE
00D62E  3  60           	RTS
00D62F  3               ;
00D62F  3               ;_KEYMAP_TABLE_____________________________________________________________________________________________________________
00D62F  3               ;
00D62F  3               DSKY_KEYMAP:
00D62F  3               	; POS	$00  $01  $02  $03  $04  $05  $06  $07
00D62F  3               	; KEY   [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]
00D62F  3  0D 04 0C 14  	.BYTE	$0D, $04, $0C, $14, $03, $0B, $13, $02
00D633  3  03 0B 13 02  
00D637  3               ;
00D637  3               	; POS	$08  $09  $0A  $0B  $0C  $0D  $0E  $0F
00D637  3               	; KEY   [8]  [9]  [A]  [B]  [C]  [D]  [E]  [F]
00D637  3  0A 12 01 09  	.BYTE	$0A, $12, $01, $09, $11, $00, $08, $10
00D63B  3  11 00 08 10  
00D63F  3               ;
00D63F  3               	; POS	$10  $11  $12  $13  $14  $15  $16  $17
00D63F  3               	; KEY   [FW] [BK] [CL] [EN] [DE] [EX] [GO] [BO]
00D63F  3  05 15 1D 1C  	.BYTE	$05, $15, $1D, $1C, $1B, $1A, $19, $18
00D643  3  1B 1A 19 18  
00D647  3               
00D647  3               	; POS	$18  $19  $20  $21
00D647  3               	; KEY   [F4] [F3] [F2] [F1]
00D647  3  23 22 21 20  	.BYTE	$23, $22, $21, $20
00D64B  3               
00D64B  3               ;
00D64B  3                       .ENDIF	; DSKY_KBD
00D64B  3               ;
00D64B  3               ;__DSKY_BIN2SEG________________________________________________________________________________________
00D64B  3               ;
00D64B  3               ; CONVERT 32 BIT BINARY TO 8 BYTE HEX SEGMENT DISPLAY
00D64B  3               ;
00D64B  3               ; DSKY_BUF: 32 BIT BINARY
00D64B  3               ; DSKY_HEXBUF: DEST LED SEGMENT DISPLAY BUFFER (8 BYTES)
00D64B  3               ;____________________________________________________________________________________________________
00D64B  3               ;
00D64B  3               DSKY_BIN2SEG:
00D64B  3  A2 00        	LDX	#$00
00D64D  3               DSKY_BIN2SEG1:
00D64D  3  BD 2C D8     	LDA	DSKY_HEXBUF,X			; FIRST NIBBLE
00D650  3  4A           	LSR	A
00D651  3  4A                   LSR	A
00D652  3  4A                   LSR	A
00D653  3  4A                   LSR	A
00D654  3  DA           	PHX                                     ; STORE READ INDEX
00D655  3  AA                   TAX					; MOVE DIGIT TO LOOKUP INDEX
00D656  3  BD 11 D8     	LDA	DSKY_HEXMAP,X                   ; GET DECODED DIGIT INTO A
00D659  3  FA           	PLX                                     ; GET READ INDEX
00D65A  3  DA           	PHX
00D65B  3  48           	PHA
00D65C  3  8A           	TXA
00D65D  3  0A           	asl	a
00D65E  3  AA           	TAX
00D65F  3  68           	PLA
00D660  3  9D 24 D8             STA     DSKY_BUF,X    		        ;STORE HIGH BYTE IN OUT BUFFER
00D663  3  FA           	PLX
00D664  3  BD 2C D8     	LDA	DSKY_HEXBUF,X			; SECOND NIBBLE
00D667  3               
00D667  3  29 0F        	AND	#$0F
00D669  3  DA                   PHX
00D66A  3  AA                   TAX
00D66B  3  BD 11 D8     	LDA	DSKY_HEXMAP,X                   ; GET DECODED DIGIT INTO A
00D66E  3  FA           	PLX
00D66F  3  DA           	PHX
00D670  3  48           	PHA
00D671  3  8A           	TXA		                        ; GET READ INDEX
00D672  3  0A           	asl	a
00D673  3  AA           	TAX
00D674  3  E8           	INX
00D675  3  68           	PLA
00D676  3  9D 24 D8             STA     DSKY_BUF,X	                ;STORE HIGH BYTE IN OUT BUFFER
00D679  3  FA           	PLX
00D67A  3  E8                   INX
00D67B  3  E0 04                CPX     #4
00D67D  3  D0 CE                BNE     DSKY_BIN2SEG1
00D67F  3  60           	RTS
00D680  3               ;
00D680  3               ;__DSKY_SHOW___________________________________________________________________________________________
00D680  3               ; DSKY SHOW BUFFER
00D680  3               ;______________________________________________________________________________________________________
00D680  3               ;
00D680  3               DSKY_SHOW:
00D680  3  48                   PHA
00D681  3  DA                   PHX
00D682  3  5A                   PHY
00D683  3  A2 00                LDX     #0
00D685  3               DSKY_SHOW1:
00D685  3  BD 24 D8     	LDA     DSKY_BUF,X
00D688  3  DA                   PHX
00D689  3  7A                   PLY
00D68A  3  20 16 D7     	JSR	DSKY_PUTBYTE
00D68D  3  E8           	INX
00D68E  3  E0 08                CPX     #8
00D690  3  D0 F3                BNE     DSKY_SHOW1
00D692  3  7A                   PLY
00D693  3  FA                   PLX
00D694  3  68                   PLA
00D695  3  60           	RTS
00D696  3               
00D696  3               ;______________________________________________________________________________________________________
00D696  3               ; DSKYNG OUTPUT ROUTINES
00D696  3               ;______________________________________________________________________________________________________
00D696  3               
00D696  3               ; SEND DSKY COMMAND BYTE IN REGISTER A
00D696  3               DSKY_CMD:
00D696  3  48                   PHA
00D697  3  A9 01        	LDA	#$01
00D699  3  4C 9F D6     	JMP	DSKY_DOUT2
00D69C  3               ;
00D69C  3               ; SEND DSKY DATA BYTE IN REGISTER A
00D69C  3               ; TRASHES BC
00D69C  3               ;
00D69C  3               DSKY_DOUT:
00D69C  3  48                   PHA
00D69D  3  A9 00        	LDA	#$00
00D69F  3               ;
00D69F  3               DSKY_DOUT2:
00D69F  3               	; SET PPI LINE CONFIG TO WRITE MODE
00D69F  3  20 E5 D7     	JSR	DSKY_PPIWR
00D6A2  3               ;
00D6A2  3               	; SET ADDRESS FIRST
00D6A2  3  09 06                ORA     #DSKY_PPI_IDLE
00D6A4  3  8D 62 03     	STA	DSKY_PPIC
00D6A7  3               ;
00D6A7  3               	; ASSERT 8279 /CS
00D6A7  3  09 18        	ORA     #%00011000
00D6A9  3  8D 62 03     	STA	DSKY_PPIC
00D6AC  3               ;
00D6AC  3               	; PPIC WORKING VALUE TO DSKY_TEMP_VAL
00D6AC  3  8D 21 D8     	STA     DSKY_TEMP_VAL
00D6AF  3               ;
00D6AF  3               	; ASSERT DATA BYTE VALUE
00D6AF  3  68                   PLA
00D6B0  3  8D 60 03     	STA	DSKY_PPIA
00D6B3  3               ;
00D6B3  3               	; PULSE /WR
00D6B3  3  AD 21 D8             LDA     DSKY_TEMP_VAL
00D6B6  3  29 FD                AND     #%11111101
00D6B8  3  8D 62 03     	STA	DSKY_PPIC
00D6BB  3  EA           	NOP			; MAY NOT BE NEEDED
00D6BC  3  09 02                ORA     #%00000010
00D6BE  3  8D 62 03     	STA	DSKY_PPIC
00D6C1  3               ;
00D6C1  3               	; DEASSERT /CS
00D6C1  3  29 E7                AND     #%11100111
00D6C3  3  8D 62 03     	STA	DSKY_PPIC
00D6C6  3               ;
00D6C6  3               	; CLEAR ADDRESS BIT
00D6C6  3  29 E6                AND     #%11100110
00D6C8  3  8D 62 03     	STA	DSKY_PPIC
00D6CB  3               ;
00D6CB  3               	; DONE
00D6CB  3  20 0E D8     	JSR	DSKY_PPIIDLE
00D6CE  3  60           	RTS
00D6CF  3               ;
00D6CF  3               ;==================================================================================================
00D6CF  3               ; DSKYNG OUTPUT ROUTINES
00D6CF  3               ;==================================================================================================
00D6CF  3               ;
00D6CF  3               ; RETURN DSKY STATUS VALUE IN A
00D6CF  3               ;
00D6CF  3               DSKY_ST:
00D6CF  3  A9 01        	LDA	#$01
00D6D1  3  4C D6 D6     	JMP	DSKY_DIN2
00D6D4  3               ;
00D6D4  3               ; RETURN NEXT DATA VALUE IN A
00D6D4  3               ;
00D6D4  3               DSKY_DIN:
00D6D4  3  A9 00        	LDA	#$00
00D6D6  3               ;
00D6D6  3               DSKY_DIN2:
00D6D6  3               	; SET PPI LINE CONFIG TO READ MODE
00D6D6  3  20 FC D7     	JSR	DSKY_PPIRD
00D6D9  3               ;
00D6D9  3               	; SET ADDRESS FIRST
00D6D9  3  09 06        	ORA	#DSKY_PPI_IDLE
00D6DB  3  8D 62 03     	STA	DSKY_PPIC
00D6DE  3               ;
00D6DE  3               	; ASSERT 8279 /CS
00D6DE  3  09 18        	ORA     #%00011000
00D6E0  3  8D 62 03     	STA	DSKY_PPIC
00D6E3  3               ;
00D6E3  3               	; ASSERT /RD
00D6E3  3  29 7B        	AND     #%01111011
00D6E5  3  8D 62 03     	STA	DSKY_PPIC
00D6E8  3               ;
00D6E8  3  8D 21 D8     	STA 	DSKY_TEMP_VAL
00D6EB  3               	; GET VALUE
00D6EB  3  AD 60 03     	LDA	DSKY_PPIA
00D6EE  3  48                   PHA
00D6EF  3               
00D6EF  3  AD 21 D8     	LDA 	DSKY_TEMP_VAL
00D6F2  3               	; DEASSERT /RD
00D6F2  3  09 04        	ORA     #%00000100
00D6F4  3  8D 62 03     	STA	DSKY_PPIC
00D6F7  3               ;
00D6F7  3               	; DEASSERT /CS
00D6F7  3  29 E7                AND     #%11100111
00D6F9  3  8D 62 03     	STA	DSKY_PPIC
00D6FC  3               ;
00D6FC  3               	; CLEAR ADDRESS BIT
00D6FC  3  29 E6                AND     #%11100110
00D6FE  3  8D 62 03     	STA	DSKY_PPIC
00D701  3               ;
00D701  3               	; DONE
00D701  3  20 0E D8     	JSR	DSKY_PPIIDLE
00D704  3  68                   PLA
00D705  3  60           	RTS
00D706  3               
00D706  3               ;__DSKY_BLANK_____________________________________________________________________________________
00D706  3               ;
00D706  3               ; BLANK DSKYNG DISPLAY  (WITHOUT USING CLEAR)
00D706  3               ;
00D706  3               ;_________________________________________________________________________________________________
00D706  3               ;
00D706  3               DSKY_BLANK:
00D706  3  A9 90        	LDA	#DSKY_CMD_WDSP
00D708  3  20 96 D6     	JSR	DSKY_CMD
00D70B  3  A2 10        	LDX	#16
00D70D  3               DSKY_BLANK1:
00D70D  3  A9 FF        	LDA	#$FF
00D70F  3  20 9C D6     	JSR	DSKY_DOUT
00D712  3  CA                   DEX
00D713  3  D0 F8        	BNE	DSKY_BLANK1
00D715  3  60           	RTS
00D716  3               ;
00D716  3               ;__DSKY_PUTBYTE____________________________________________________________________________________
00D716  3               ;
00D716  3               ; WRITE A RAW BYTE VALUE TO DSKY DISPLAY RAM
00D716  3               ; AT LOCATION IN REGISTER Y, VALUE IN A.
00D716  3               ;
00D716  3               ;__________________________________________________________________________________________________
00D716  3               ;
00D716  3               DSKY_PUTBYTE:
00D716  3  5A                   PHY
00D717  3  48                   PHA
00D718  3  48                   PHA
00D719  3  18           	CLC
00D71A  3  98                   TYA
00D71B  3  69 90        	ADC	#DSKY_CMD_WDSP
00D71D  3  A8                   TAY
00D71E  3  20 96 D6     	JSR	DSKY_CMD
00D721  3  68                   PLA
00D722  3  49 FF        	EOR	#$FF
00D724  3  20 9C D6     	JSR	DSKY_DOUT
00D727  3  68                   PLA
00D728  3  7A                   PLY
00D729  3  60           	RTS
00D72A  3               ;
00D72A  3               ;__DSKY_GETBYTE___________________________________________________________________________________
00D72A  3               ; READ A RAW BYTE VALUE FROM DSKY DISPLAY RAM
00D72A  3               ; AT LOCATION IN REGISTER Y, VALUE RETURNED IN A
00D72A  3               ;
00D72A  3               ;_________________________________________________________________________________________________
00D72A  3               ;
00D72A  3               DSKY_GETBYTE:
00D72A  3  18           	CLC
00D72B  3  98                   TYA
00D72C  3  69 70        	ADC	#DSKY_CMD_RDSP
00D72E  3  A8                   TAY
00D72F  3  20 96 D6     	JSR	DSKY_CMD
00D732  3  20 D4 D6     	JSR	DSKY_DIN
00D735  3  49 FF        	EOR	#$FF
00D737  3  60           	RTS
00D738  3               
00D738  3               ;
00D738  3               ;__DSKY_PUTLED____________________________________________________________________________________
00D738  3               ;
00D738  3               ;	This function is intended to update the LEDs.  It expects 8 bytes
00D738  3               ;	following the call, and	updates the entire matrix.
00D738  3               ;
00D738  3               ;  EXAMPLE:
00D738  3               ;	JSR 	DSKY_PUTLED
00D738  3               ;	.BYTE 	$00,$00,$00,$00,$00,$00,$00,$00
00D738  3               ;_________________________________________________________________________________________________
00D738  3               ;
00D738  3               DSKY_PUTLED:
00D738  3  8E 21 D8             STX     DSKY_TEMP_VAL           ; STORE X
00D73B  3  BA                   TSX                             ; STORE STACK POINTER
00D73C  3  68                   PLA                             ; GET ADDRESS OF BYTES
00D73D  3  85 14                STA     pointr                  ; STORE ADDRESS IN POINTR
00D73F  3  68                   PLA
00D740  3  85 15                STA     pointr+1
00D742  3  9A                   TXS                             ; RESTORE STACK
00D743  3  AE 21 D8             LDX     DSKY_TEMP_VAL           ; RESTORE X
00D746  3  DA                   PHX                             ; STASH REGISTERS
00D747  3  5A                   PHY
00D748  3  48                   PHA
00D749  3  18                   CLC                             ; REMEMBER ADDRESS IN STACK IS BEFORE STRING
00D74A  3  E6 14                INC     pointr                  ; SO, INC 16BIT POINTER BY 1
00D74C  3  90 02                BCC     @1
00D74E  3  E6 15                INC     pointr+1
00D750  3  A0 00        @1:	LDY 	#$00
00D752  3               DSKY_PUTLED_1:
00D752  3  B1 14                LDA     (pointr),Y              ; GET BYTE
00D754  3  20 16 D7     	JSR	DSKY_PUTBYTE            ; SEND IT TO DSKY
00D757  3  C8                   INY                             ; LOOP TIL DONE
00D758  3  C0 08                CPY     #8
00D75A  3  D0 F6                BNE     DSKY_PUTLED_1
00D75C  3  68                   PLA                             ; RESTORE REGISTERS
00D75D  3  7A                   PLY
00D75E  3  FA                   PLX
00D75F  3  8D 21 D8             STA     DSKY_TEMP_VAL           ; STASH A
00D762  3  18                   CLC                             ; INC RETURN ADDRESS BY 8
00D763  3  68                   PLA
00D764  3  69 08                ADC     #8
00D766  3  85 14                STA     pointr
00D768  3  90 03                BCC     DSKY_PUTLED_2
00D76A  3  68                   PLA
00D76B  3  1A                   INC     A
00D76C  3  48                   PHA
00D76D  3               DSKY_PUTLED_2:
00D76D  3  A5 14                LDA     pointr
00D76F  3  48                   PHA
00D770  3  AD 21 D8             LDA     DSKY_TEMP_VAL           ; RESTORE A
00D773  3  60           	RTS
00D774  3               ;
00D774  3               ;__DSKY_BEEP______________________________________________________________________________________
00D774  3               ;	This function is intended to beep the speaker on the DSKY
00D774  3               ;_________________________________________________________________________________________________
00D774  3               ;
00D774  3               DSKY_BEEP:
00D774  3  5A           	PHY
00D775  3  DA                   PHX
00D776  3  48           	PHA
00D777  3  A0 0F        	LDY 	#$0F
00D779  3  20 2A D7     	JSR	DSKY_GETBYTE
00D77C  3  09 20        	ORA 	#$20
00D77E  3  A9 20        			LDA 	#$20
00D780  3  A0 0F        	LDY	#$0F
00D782  3  20 16 D7     	JSR	DSKY_PUTBYTE
00D785  3               
00D785  3               ;;; 	timer . . .
00D785  3  A2 8F        	LDX 	#$8F
00D787  3  A0 FF                LDY     #$FF
00D789  3               DSKY_BEEP1:
00D789  3  88                   DEY
00D78A  3  D0 FD                BNE     DSKY_BEEP1
00D78C  3  CA                   DEX
00D78D  3  D0 FA                BNE     DSKY_BEEP1
00D78F  3               
00D78F  3  A0 0F        	LDY 	#$0F
00D791  3  20 2A D7     	JSR	DSKY_GETBYTE
00D794  3  29 DF        	AND 	#$DF
00D796  3  A9 DF        			LDA 	#$DF
00D798  3  A0 0F        	LDY	#$0F
00D79A  3  20 16 D7     	JSR	DSKY_PUTBYTE
00D79D  3               
00D79D  3  68                   PLA
00D79E  3  FA                   PLX
00D79F  3  7A                   PLY
00D7A0  3  60           	RTS
00D7A1  3               ;
00D7A1  3               ;__DSKY_L1ON______________________________________________________________________________________
00D7A1  3               ;	This function is intended to turn on DSKY L1
00D7A1  3               ;_________________________________________________________________________________________________
00D7A1  3               ;
00D7A1  3               DSKY_L1ON:
00D7A1  3  5A           	PHY
00D7A2  3  48           	PHA
00D7A3  3  A0 0D        	LDY 	#$0D
00D7A5  3  20 2A D7     	JSR	DSKY_GETBYTE
00D7A8  3  09 20        	ORA 	#$20
00D7AA  3  A0 0D        	LDY	#$0D
00D7AC  3  20 16 D7     	JSR	DSKY_PUTBYTE
00D7AF  3  68           	PLA
00D7B0  3  7A                   PLY
00D7B1  3  60           	RTS
00D7B2  3               ;
00D7B2  3               ;__DSKY_L2ON______________________________________________________________________________________
00D7B2  3               ;	This function is intended to turn on DSKY L2
00D7B2  3               ;_________________________________________________________________________________________________
00D7B2  3               ;
00D7B2  3               DSKY_L2ON:
00D7B2  3  5A           	PHY
00D7B3  3  48           	PHA
00D7B4  3  A0 0E        	LDY 	#$0E
00D7B6  3  20 2A D7     	JSR	DSKY_GETBYTE
00D7B9  3  09 20        	ORA 	#$20
00D7BB  3  A0 0E        	LDY	#$0E
00D7BD  3  20 16 D7     	JSR	DSKY_PUTBYTE
00D7C0  3  68           	PLA
00D7C1  3  7A                   PLY
00D7C2  3  60           	RTS
00D7C3  3               ;
00D7C3  3               ;__DSKY_L1OFF_____________________________________________________________________________________
00D7C3  3               ;	This function is intended to turn off DSKY L1
00D7C3  3               ;_________________________________________________________________________________________________
00D7C3  3               ;
00D7C3  3               DSKY_L1OFF:
00D7C3  3  5A           	PHY
00D7C4  3  48           	PHA
00D7C5  3  A0 0D        	LDY 	#$0D
00D7C7  3  20 2A D7     	JSR	DSKY_GETBYTE
00D7CA  3  29 DF        	AND 	#$DF
00D7CC  3  A0 0D        	LDY	#$0D
00D7CE  3  20 16 D7     	JSR	DSKY_PUTBYTE
00D7D1  3  68           	PLA
00D7D2  3  7A                   PLY
00D7D3  3  60           	RTS
00D7D4  3               ;
00D7D4  3               ;__DSKY_L2OFF_____________________________________________________________________________________
00D7D4  3               ;	This function is intended to turn off DSKY L2
00D7D4  3               ;_________________________________________________________________________________________________
00D7D4  3               ;
00D7D4  3               DSKY_L2OFF:
00D7D4  3  5A           	PHY
00D7D5  3  48           	PHA
00D7D6  3  A0 0E        	LDY 	#$0E
00D7D8  3  20 2A D7     	JSR	DSKY_GETBYTE
00D7DB  3  29 DF        	AND 	#$DF
00D7DD  3  A0 0E        	LDY	#$0E
00D7DF  3  20 16 D7     	JSR	DSKY_PUTBYTE
00D7E2  3  68           	PLA
00D7E3  3  7A                   PLY
00D7E4  3  60           	RTS
00D7E5  3               ;
00D7E5  3               ;_________________________________________________________________________________________________
00D7E5  3               ; DSKYNG LINE CONTROL ROUTINES
00D7E5  3               ;
00D7E5  3               ; SETUP PPI FOR WRITING: PUT PPI PORT A IN OUTPUT MODE
00D7E5  3               ; AVOID REWRTING PPIX IF ALREADY IN OUTPUT MODE
00D7E5  3               ;
00D7E5  3               ;_________________________________________________________________________________________________
00D7E5  3               ;
00D7E5  3               DSKY_PPIWR:
00D7E5  3  48           	PHA
00D7E6  3               ;
00D7E6  3               	; CHECK FOR WRITE MODE
00D7E6  3  AD 22 D8     	LDA     DSKY_PPIX_VAL
00D7E9  3  C9 82        	CMP	#DSKY_PPIX_WR
00D7EB  3  F0 0D        	BEQ	DSKY_PPIWR1
00D7ED  3               ;
00D7ED  3               	; SET PPI TO WRITE MODE
00D7ED  3  A9 82        	LDA	#DSKY_PPIX_WR
00D7EF  3  8D 63 03     	STA	DSKY_PPIX
00D7F2  3  8D 22 D8     	STA	DSKY_PPIX_VAL
00D7F5  3               ;
00D7F5  3               	; RESTORE PORT C (MAY NOT BE NEEDED)
00D7F5  3  A9 06        	LDA     #DSKY_PPI_IDLE
00D7F7  3  8D 62 03     	STA	DSKY_PPIC
00D7FA  3               ;
00D7FA  3               DSKY_PPIWR1:
00D7FA  3               ;
00D7FA  3  68           	PLA
00D7FB  3  60           	RTS
00D7FC  3               ;
00D7FC  3               ; SETUP PPI FOR READING: PUT PPI PORT A IN INPUT MODE
00D7FC  3               ; AVOID REWRTING PPIX IF ALREADY IN INPUT MODE
00D7FC  3               ;
00D7FC  3               DSKY_PPIRD:
00D7FC  3  48           	PHA
00D7FD  3               ;
00D7FD  3               	; CHECK FOR READ MODE
00D7FD  3  AD 22 D8     	LDA	DSKY_PPIX_VAL
00D800  3  C9 92        	CMP	#DSKY_PPIX_RD
00D802  3  F0 08        	BEQ	DSKY_PPIRD1
00D804  3               ;
00D804  3               	; SET PPI TO READ MODE
00D804  3  A9 92        	LDA	#DSKY_PPIX_RD
00D806  3  8D 63 03     	STA	DSKY_PPIX
00D809  3  8D 22 D8     	STA	DSKY_PPIX_VAL
00D80C  3               ;
00D80C  3               DSKY_PPIRD1:
00D80C  3  68           	PLA
00D80D  3  60           	RTS
00D80E  3               ;
00D80E  3               ; RELEASE USE OF PPI
00D80E  3               ;
00D80E  3               DSKY_PPIIDLE:
00D80E  3  4C FC D7     	JMP	DSKY_PPIRD		; SAME AS READ MODE
00D811  3               ;
00D811  3               ;__STORAGE_________________________________________________________________________________________
00D811  3               ; CODES FOR NUMERICS
00D811  3               ; HIGH BIT ALWAYS CLEAR TO SUPPRESS DECIMAL POINT
00D811  3               ; SET HIGH BIT TO SHOW DECIMAL POINT
00D811  3               ;_________________________________________________________________________________________________
00D811  3               ;
00D811  3               DSKY_HEXMAP:
00D811  3  3F           	.BYTE	$3F	; 0
00D812  3  06           	.BYTE	$06	; 1
00D813  3  5B           	.BYTE	$5B	; 2
00D814  3  4F           	.BYTE	$4F	; 3
00D815  3  66           	.BYTE	$66	; 4
00D816  3  6D           	.BYTE	$6D	; 5
00D817  3  7D           	.BYTE	$7D	; 6
00D818  3  07           	.BYTE	$07	; 7
00D819  3  7F           	.BYTE	$7F	; 8
00D81A  3  67           	.BYTE	$67	; 9
00D81B  3  77           	.BYTE	$77	; A
00D81C  3  7C           	.BYTE	$7C	; B
00D81D  3  39           	.BYTE	$39	; C
00D81E  3  5E           	.BYTE	$5E	; D
00D81F  3  79           	.BYTE	$79	; E
00D820  3  71           	.BYTE	$71	; F
00D821  3               ;
00D821  3  00           DSKY_TEMP_VAL:	.BYTE	0
00D822  3  00           DSKY_PPIX_VAL:	.BYTE	0
00D823  3  00           DSKY_PRESENT:	.BYTE	0
00D824  3               ;
00D824  3               ; SEG DISPLAY WORKING STORAGE
00D824  3               ;
00D824  3  00 00 00 00  DSKY_BUF:	.BYTE	0,0,0,0,0,0,0,0
00D828  3  00 00 00 00  
00D82C  3               DSKY_BUFLEN	=	* - DSKY_BUF
00D82C  3  00 00 00 00  DSKY_HEXBUF:	.BYTE	0,0,0,0
00D830  3               DSKY_HEXBUFLEN	=	* - DSKY_HEXBUF
00D830  3               
00D830  2                   .ENDIF
00D830  2               
00D830  2               
00D830  2               ;------------------------------------------------------------------------------------
00D830  2               
00D830  2               
00D830  2               ;disk control blocks
00D830  2               ;drive a (3.5" FDD)
00D830  2               	.IF FLPA35=1
00D830  2               dcba:	.word	350		;max block number
00D830  2               	.word	36		;sectors per track
00D830  2               	.word	4		;number system tracks
00D830  2               	.byte	1		;block size = 2048
00D830  2               	.word	127		;max directory number
00D830  2               	.word	almpa		;address of map for a
00D830  2               	.byte	80		;do checksums
00D830  2               	.word	ckmpa		;checksum map
00D830  2               	.ELSE
00D830  2  AF 00        dcba:	.word	175		;max block number
00D832  2  24 00        	.word	36		;sectors per track
00D834  2  04 00        	.word	4		;number system tracks
00D836  2  01           	.byte	1		;block size = 2048
00D837  2  7F 00        	.word	127		;max directory number
00D839  2  71 D8        	.word	almpa		;address of map for a
00D83B  2  50           	.byte	80		;do checksums
00D83C  2  9A DA        	.word	ckmpa		;checksum map
00D83E  2               	.endif
00D83E  2               
00D83E  2               	.IF FLPB35=1
00D83E  2               dcbb:	.word	350		;max block number
00D83E  2               	.word	36		;sectors per track
00D83E  2               	.word	4		;number system tracks
00D83E  2               	.byte	1		;block size = 2048
00D83E  2               	.word	127		;max directory number
00D83E  2               	.word	almpa		;address of map for a
00D83E  2               	.byte	80		;do checksums
00D83E  2               	.word	ckmpa		;checksum map
00D83E  2               	.ELSE
00D83E  2  AF 00        dcbb:	.word	175		;max block number
00D840  2  24 00        	.word	36		;sectors per track
00D842  2  04 00        	.word	4		;number system tracks
00D844  2  01           	.byte	1		;block size = 2048
00D845  2  7F 00        	.word	127		;max directory number
00D847  2  71 D8        	.word	almpa		;address of map for a
00D849  2  50           	.byte	80		;do checksums
00D84A  2  9A DA        	.word	ckmpa		;checksum map
00D84C  2               	.endif
00D84C  2               
00D84C  2               ;RBW drives (FIXED IDE/LBA DRIVES)
00D84C  2  FF 07        dcbwbw:	.word	2047		;max block number
00D84E  2  40 00        	.word	64		;sectors per track
00D850  2  82 00        	.word	130		;number system tracks
00D852  2  02           	.byte	2		;block size = 4096
00D853  2  FF 01        	.word	511		;max directory number
00D855  2  9C D9        	.word	almpwbw		;address of map for C
00D857  2  00           	.byte	0		;do checksums
00D858  2  3A DB        	.word	ckmpwbw		;checksum map
00D85A  2               ;data area
00D85A  2               
00D85A  2               
00D85A  2  02           sekdsk:	.byte	2		;seek disk number
00D85B  2  00           hstwrt:	.byte	0		;0=written,1=pending host write
00D85C  2               
00D85C  2               ;allocate the following data areas to unused ram space
00D85C  2  00           LASTCHAR: 	.byte 0		;save sector for warm boot
00D85D  2  00           savsec:		.byte 0		;save sector for warm boot
00D85E  2  00           count:		.byte 0		;counter in warm boot
00D85F  2  00           temp:		.byte 0		;save hstdsk for warm boot
00D860  2  00           hstact:		.byte 0		;host active flag
00D861  2  00           unacnt:		.byte 0		;unalloc rec cnt
00D862  2  00 00        sektrk:		.word 0		;seek track number
00D864  2  00 00        seksec:		.word 0		;seek sector number
00D866  2  00           debcyll:	.byte 0		; DEBLOCKED CYLINDER LSB
00D867  2  00           debcylm:	.byte 0		; DEBLOCKED CYLINDER MSB
00D868  2  00           debsehd:	.byte 0		; DEBLOCKED SECTOR AND HEAD (HS)
00D869  2  00 00        debtmp:		.word 0		; DEBLOCK TEMP VAR
00D86B  2  00           Cdebcyll:	.byte 0		; DEBLOCKED CYLINDER LSB
00D86C  2  00           Cdebcylm:	.byte 0		; DEBLOCKED CYLINDER MSB
00D86D  2  00           Cdebsehd:	.byte 0		; DEBLOCKED SECTOR AND HEAD (HS)
00D86E  2  00           DEBDIRTY:	.byte 0		; DIRTY FLAG
00D86F  2  00 00        slicetmp:	.word 0		; USED TO CALCULATE SLICE OFFSET
00D871  2               
00D871  2               ;allocation maps
00D871  2               ;drive a
00D871  2  xx xx xx xx  almpa:		.res	45
00D875  2  xx xx xx xx  
00D879  2  xx xx xx xx  
00D89E  2               ;drive b
00D89E  2  xx xx xx xx  almpb:		.res	254
00D8A2  2  xx xx xx xx  
00D8A6  2  xx xx xx xx  
00D99C  2               ;drive c
00D99C  2  xx xx xx xx  almpwbw:	.res	254
00D9A0  2  xx xx xx xx  
00D9A4  2  xx xx xx xx  
00DA9A  2               ;checksum maps
00DA9A  2               
00DA9A  2               
00DA9A  2               ;drive a
00DA9A  2  xx xx xx xx  ckmpa:		.res	32
00DA9E  2  xx xx xx xx  
00DAA2  2  xx xx xx xx  
00DABA  2               ;drive b
00DABA  2  xx xx xx xx  ckmpb:		.res	128
00DABE  2  xx xx xx xx  
00DAC2  2  xx xx xx xx  
00DB3A  2               ;drive c
00DB3A  2  xx xx xx xx  ckmpwbw:	.res	128
00DB3E  2  xx xx xx xx  
00DB42  2  xx xx xx xx  
00DBBA  2               ;deblocking buffer for dba
00DBBA  2  xx xx xx xx  hstbuf:		.res	512		;256 or 512 byte sectors
00DBBE  2  xx xx xx xx  
00DBC2  2  xx xx xx xx  
00DDBA  2               
00DDBA  1               
00DDBA  1               	.end
