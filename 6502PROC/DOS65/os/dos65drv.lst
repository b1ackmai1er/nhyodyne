ca65 V2.18 - Ubuntu 2.19-1
Main file   : dos65drv.asm
Current file: dos65drv.asm

000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               ;
000000r 1               ;	Nhyodyne dos/65 banked driver code
000000r 1               ;       Intended for RAM BANK $0D
000000r 1               ;
000000r 1               ;  DWERNER 04/24/2022 	Initial
000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               		.PC02
000000r 1               .include "dosdefn.asm" 		; base addresses and definitions
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               ;
000000r 2               ;	Nhyodyne dos/65 base addresses and definitions
000000r 2               ;
000000r 2               ;  DWERNER 04/24/2022 	Initial
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               
000000r 2               ;base addresses and definitions
000000r 2               btejmp	=	$100		;warm boot jump
000000r 2               pemjmp	=	$103		;jump to pem
000000r 2               iostat	=	$106		;i/o status
000000r 2               dflfcb	=	$107		;default fcb
000000r 2               dflbuf	=	$128		;default buffer
000000r 2               memmovr =	$200		;subr to move data from ram/rom disks
000000r 2               
000000r 2               ;
000000r 2               ; DSKY DISPLAY WORKING STORAGE
000000r 2               ;
000000r 2               DSKY_BUF        =       $0300	        ; Eight Bytes DSKY display buffer
000000r 2               DSKY_BUFLEN	=       8               ;
000000r 2               DSKY_HEXBUF     =       $0308           ; Four Bytes DSKY hex buffer
000000r 2               DSKY_HEXBUFLEN	=       4               ;
000000r 2               sektrk          =       $030C		;seek track number
000000r 2               seksec          =       $030E		;seek sector number
000000r 2               debcyll         =       $0310	        ; DEBLOCKED CYLINDER LSB
000000r 2               debcylm         =	$0311           ; DEBLOCKED CYLINDER MSB
000000r 2               debsehd         =	$0312           ; DEBLOCKED SECTOR AND HEAD (HS)
000000r 2               sekdsk          =       $0313           ;seek disk number
000000r 2               dskcfg          =       $0314           ; 16 bytes disk configuration table
000000r 2               
000000r 2               MPCL_ROM	=	$037C		; ROM MAPPER
000000r 2               MPCL_RAM	=	$0378		; RAM MAPPER
000000r 2               MD_PAGERA       =       $0200           ; PAGE DRIVER ADDRESS
000000r 2               MD_PAGEBU       =       $0400           ; PAGE BUFFER ADDRESS
000000r 2               MD_PAGESE       =       pointr          ; PAGE SECTOR STORAGE
000000r 2               
000000r 2               
000000r 2               tea	=	$800		;tea start
000000r 2               
000000r 2               ;zero page for setup
000000r 2               trknum	=	$02			;current track
000000r 2               dcbadd	=	$04			;dcb address
000000r 2               nmsstr	=	$06			;number system tracks
000000r 2               nsectr	=	$08			;number sectors per track
000000r 2               ttlsec	=	$0A			;total sectors to write
000000r 2               trkcnt	=	ttlsec
000000r 2               size	=	$0B			;ascii size
000000r 2               lokim	=	$0D			;low kim limit
000000r 2               hikim	=	$0F			;high kim limit
000000r 2               offset	=	$11			;relocation offset
000000r 2               kimcnt	=	$13			;kim counter
000000r 2               pointr	=	$14			;pointer
000000r 2               lengt	=	$16			;inst length
000000r 2               point	=	$17			;relocate pointer
000000r 2               adjust	=	$19			;relocate distance
000000r 2               kimpnt	=	$1B			;kim file index
000000r 2               savex	=	$1C			;save for x
000000r 2               savey	=	$1D			;save for y
000000r 2               number	=	$1E			;input pack buffer
000000r 2               dstdrv	=	$20			;destination drive
000000r 2               defalt	=	$21			;default drive
000000r 2               seccnt	=	$22			;sector count
000000r 2               secnum	=	$24			;sector number
000000r 2               curccm	=	$26			;start of current ccm
000000r 2               simlng	=	$28			;length of sim
000000r 2               room	=	$2A			;memory needed for sysgen
000000r 2               stksav	=	$2C			;save stack register
000000r 2               frstsc	=	$2D			;first sector number of disk
000000r 2               dskcfpc	=	$2E			;pointer to disk configuration table
000000r 2               cmdlnp	=	$30			;pointer to command line buffer
000000r 2               farfunct=       $32                     ;function to call in driver area
000000r 2               farpointer=     $33                     ;WORD POINTER to call in driver area
000000r 2               lastzp	=	$35
000000r 2               
000000r 2               ;pem constants on entry to write
000000r 2               wrall	=	0		;write to allocated
000000r 2               wrdir	=	1		;write to directory
000000r 2               wrual	=	2		;write to unallocated
000000r 2               
000000r 2               ;page zero and system ram assignments
000000r 2               DEST	 =	$EC		;pointer for OutMsg
000000r 2               SRC	 =	$EE		;pointer for OutMsg
000000r 2               OUTMSG_W =	$F0		;pointer for OutMsg
000000r 2               mvepnt	=	$f2		;host buffer location
000000r 2               dmaadr	=	$f4		;pointer for r/w
000000r 2               
000000r 2               ;fixed parameters
000000r 2               lf	=	$a		;linefeeed
000000r 2               cr	=	$d		;return
000000r 2               eof	=	$1a		;end of file
000000r 2               null	=	0		;null
000000r 2               ctlc	=	3		;abort
000000r 2               ctle	=	5		;physical cr lf
000000r 2               ctli	=	9		;tab character
000000r 2               ctlp	=	$10		;toggle printer
000000r 2               ctlr	=	$12		;repeat line
000000r 2               ctls	=	$13		;freeze
000000r 2               ctlx	=	$18		;cancel
000000r 2               semico	=	$3b		;semicolon
000000r 2               delete	=	$08		;delete character
000000r 2               numcmd	=	36		;number commands
000000r 2               
000000r 2               BANKED_DRIVER_DISPATCHER=$8800  ; LOCATION OF DRIVER DISPATCHER
000000r 2               DEBUG	=	0		; assemble with debug information on
000000r 2               
000000r 2               
000000r 2               USESERIAL 	= 	1	; SET TO ONE SERIAL CONSOLE IO
000000r 2               USEFLOPPYA 	= 	0	; SET TO ONE FOR FLOPPY = "A"
000000r 2               USEFLOPPYB 	= 	0	; SET TO ONE FOR FLOPPY = "B"
000000r 2               USEIDEC 	= 	1	; SET TO ONE FOR IDE HDD="C"
000000r 2               USEDSKY 	= 	0	; SEND INFO TO DSKY
000000r 2               USEDSKYNG 	= 	1	; SEND INFO TO DSKYNG
000000r 2               DSKY_KBD	=	1	; USE DSKY KEYBOARD?
000000r 2               DEFDRV  	=	2	; SET TO DEFAULT DRIVE LETTER
000000r 2               USEDISKIOV1     = 	0	; Floppy and IDE card is  DISK IO V1
000000r 2               USEDISKIOV3     = 	0	; Floppy and IDE card is  DISK IO V3
000000r 2               
000000r 2               FLPA35		=	0	; set to 1 if floppy a is A 3.5" 80 track drive (0= 5.25" 40 track drive)
000000r 2               FLPB35		=	0	; set to 1 if floppy a is B 3.5" 80 track drive (0= 5.25" 40 track drive)
000000r 2               
000000r 2               DSKYOSC         =	100000
000000r 2               
000000r 1               .include "drvmacro.asm" 		; base addresses and definitions
000000r 2               ;__MACRO___________________________________________________________________________________________________________________
000000r 2               ;
000000r 2               ; 	Macros for the betterment of Mankind
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               ;
000000r 2               
000000r 2               .macro          PRTDBG      message
000000r 2               .LOCAL p1
000000r 2               .LOCAL p2
000000r 2               .LOCAL p3
000000r 2               .LOCAL p4
000000r 2               .LOCAL p5
000000r 2                 .if     .paramcount <> 1
000000r 2                       .error  "Too few parameters for macro PRTDBG"
000000r 2                       .endif
000000r 2                       .if DEBUG=1
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       PHY
000000r 2                       LDX #$00
000000r 2               p1:
000000r 2                       LDA p4,x
000000r 2                       INX
000000r 2                       CMP #'$'
000000r 2                       BEQ p2
000000r 2                       JSR CONSOLE_OUT
000000r 2                       JMP p1
000000r 2               p2:
000000r 2                       LDA #13
000000r 2                       jsr CONSOLE_OUT
000000r 2                       LDA #10
000000r 2                       jsr CONSOLE_OUT
000000r 2                       PLY
000000r 2                       plx
000000r 2                       pla
000000r 2                       JMP p5
000000r 2               p4:
000000r 2                       .BYTE message
000000r 2               p5:
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               
000000r 2               .macro          PRTS      message
000000r 2               .LOCAL p1
000000r 2               .LOCAL p2
000000r 2               .LOCAL p3
000000r 2               .LOCAL p4
000000r 2               .LOCAL p5
000000r 2                 .if     .paramcount <> 1
000000r 2                       .error  "Too few parameters for macro PRTS"
000000r 2                       .endif
000000r 2                       PHA
000000r 2                       PHX
000000r 2                       PHY
000000r 2                       LDX #$00
000000r 2               p1:
000000r 2                       LDA p4,x
000000r 2                       INX
000000r 2                       CMP #'$'
000000r 2                       BEQ p2
000000r 2                       JSR CONSOLE_OUT
000000r 2                       JMP p1
000000r 2               p2:
000000r 2                       PLY
000000r 2                       plx
000000r 2                       pla
000000r 2                       JMP p5
000000r 2               p4:
000000r 2                       .BYTE message
000000r 2               p5:
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               
000000r 2               
000000r 2               ;__PRTHEXBYTE__________________________________________________
000000r 2               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
000000r 2               ;______________________________________________________________
000000r 2               PRTHEXBYTE:
000000r 2  48                   PHA
000001r 2  DA                   PHX
000002r 2  5A                   PHY
000003r 2  AA                   TAX				; SAVE A REGISTER
000004r 2  4A                   LSR 				; SHIFT HIGH NIBBLE TO LOW NIBBLE
000005r 2  4A                   LSR 				;
000006r 2  4A                   LSR 				;
000007r 2  4A                   LSR 				;
000008r 2  18                   CLC               		; CLEAR CARRY
000009r 2  20 rr rr             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
00000Cr 2  8A                   TXA				; RESTORE ACCUMULATOR
00000Dr 2  20 rr rr             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
000010r 2  7A                   PLY
000011r 2  FA                   plx
000012r 2  68                   PLA
000013r 2  60                   RTS
000014r 2               
000014r 2               ;__PRINT_DIGIT_________________________________________________
000014r 2               ;
000014r 2               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
000014r 2               ;
000014r 2               ;______________________________________________________________
000014r 2               PRINT_DIGIT:
000014r 2  29 0F                       AND #$0F				; STRIP OFF HIGH NIBBLE
000016r 2  09 30                       ORA #$30				; ADD $30 TO PRODUCE ASCII
000018r 2  C9 3A                       CMP #$3A               		; IS GREATER THAN 9
00001Ar 2  30 03                       BMI PRINT_DIGIT_OUT		; NO, SKIP ADD
00001Cr 2  18                          CLC				; CLEAR CARRY
00001Dr 2  69 07                       ADC #$07				; ADD ON FOR LETTER VALUES
00001Fr 2               PRINT_DIGIT_OUT:					;
00001Fr 2  4C 9A 94                    JMP CONSOLE_OUT              		; PRINT OUT CHAR
000022r 2               
000022r 2               NEWLINE:
000022r 2  48                           pha
000023r 2  DA                           PHX
000024r 2  5A                           phy
000025r 2  A9 0D                        LDA #$0D
000027r 2  20 9A 94                     JSR CONSOLE_OUT
00002Ar 2  A9 0A                        LDA #$0A
00002Cr 2  20 9A 94                     Jsr CONSOLE_OUT
00002Fr 2  7A                           ply
000030r 2  FA                           plx
000031r 2  68                           pla
000032r 2  60                           rts
000033r 2               
000033r 2               PRTDEC:
000033r 2  5A                           phy
000034r 2  DA                           PHX
000035r 2  48                           PHA
000036r 2  A0 00                        ldy #00
000038r 2  A2 FF                        LDX #$FF
00003Ar 2  38                           SEC
00003Br 2               PrDec100:
00003Br 2  E8                           INX
00003Cr 2  E9 64                        SBC #100
00003Er 2  B0 FB                        BCS PrDec100            ;Count how many 100s
000040r 2  69 64                        ADC #100
000042r 2  20 rr rr                     JSR PrDecDigit          ;Print the 100s
000045r 2  A2 FF                        LDX #$FF
000047r 2  38                           SEC                     ;Prepare for subtraction
000048r 2               PrDec10:
000048r 2  E8                           INX
000049r 2  E9 0A                        SBC #10
00004Br 2  B0 FB                        BCS PrDec10             ;Count how many 10s
00004Dr 2  69 0A                        ADC #10
00004Fr 2  20 rr rr                     JSR PrDecDigit          ;Print the 10s
000052r 2  AA                           TAX                     ;Pass 1s into X
000053r 2  A0 01                        ldy #1
000055r 2  20 rr rr                     JSR PrDecDigit          ;Print the 1s
000058r 2  68                           PLA
000059r 2  FA                           PLX
00005Ar 2  7A                           ply
00005Br 2  60                           RTS
00005Cr 2               PrDecDigit:
00005Cr 2  48                           PHA
00005Dr 2  C0 00                        cpy #$00
00005Fr 2  D0 09                        bne PrDecDigit1
000061r 2  8A                           txa
000062r 2  A8                           tay
000063r 2  C0 00                        cpy #$00
000065r 2  D0 03                        bne PrDecDigit1
000067r 2  4C rr rr                     jmp PrDecDigit2
00006Ar 2               PrDecDigit1:
00006Ar 2  8A                           TXA                     ;Save A, pass digit to A
00006Br 2  09 30                        ORA #'0'
00006Dr 2  20 9A 94                     JSR  CONSOLE_OUT        ;Convert to character and print it
000070r 2               PrDecDigit2:
000070r 2  68                           PLA
000071r 2  60                           RTS                     ;Restore A and return
000072r 2               
000072r 1               
000072r 1               
000072r 1               ; for Nhyodyne:
000072r 1               ; RAM BANK $0C is RAM area for Drivers
000072r 1               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
000072r 1               ; RAM BANK $0F is fixed bank $0000-$7FFF
000072r 1               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
000072r 1               
000072r 1               ;       Area from $0D:8000 to $0D:8800 reserved for work RAM for drivers
000072r 1               ;
000072r 1               
000072r 1               
000072r 1               
000072r 1                               .segment "DRIVERS"
000000r 1               		.ORG $8800
008800  1               
008800  1               
008800  1               ;__DISPATCHER________________________________________________________________________________________
008800  1               ;
008800  1               ;  Function dispatcher
008800  1               ;  function to call is located in "farfunct"
008800  1               ;____________________________________________________________________________________________________
008800  1               ;
008800  1               
008800  1  48           		PHA
008801  1  DA           		PHX
008802  1  A5 32        		LDA     farfunct
008804  1  0A           		ASL	A			; DOUBLE NUMBER FOR TABLE LOOKUP
008805  1  AA           		TAX
008806  1  BD 15 88     		LDA 	DISPATCHTABLE,X
008809  1  85 33        		STA	farpointer
00880B  1  BD 16 88     		LDA 	DISPATCHTABLE+1,X
00880E  1  85 34        		STA	farpointer+1
008810  1  FA           		PLX
008811  1  68           		PLA
008812  1  6C 33 00     		JMP (farpointer)
008815  1               
008815  1               
008815  1               DISPATCHTABLE:
008815  1  44 88        		.WORD 	WRSER1			; FUNCTION 00 - WRITE SERIAL PORT
008817  1  53 88        		.WORD 	RDSER1			; FUNCTION 01 - READ SERIAL PORT
008819  1  63 88        		.WORD 	RDSER1W			; FUNCTION 02 - READ SERIAL PORT (BLOCKING)
00881B  1  72 88        		.WORD 	SERIALSTATUS		; FUNCTION 03 - GET SERIAL STATUS
00881D  1               
00881D  1  84 88        		.WORD 	PPIDE_INIT   		; FUNCTION 04 - called during OS init
00881F  1  28 8B        		.WORD 	IDE_READ_SECTOR 	; FUNCTION 05 - read a sector from drive
008821  1  7F 8B        		.WORD 	IDE_WRITE_SECTOR	; FUNCTION 06 - write a sector to drive
008823  1               
008823  1  49 90        		.WORD 	DSKY_INIT		; FUNCTION 07 -
008825  1  F0 91        		.WORD 	DSKY_SHOW		; FUNCTION 08 -
008827  1  BB 91        		.WORD 	DSKY_BIN2SEG		; FUNCTION 09 -
008829  1  3D 91        		.WORD 	DSKY_RESET		; FUNCTION 10 -
00882B  1  58 91        		.WORD 	DSKY_STAT		; FUNCTION 11 -
00882D  1  65 91        		.WORD 	DSKY_GETKEY		; FUNCTION 12 -
00882F  1  BF 92        		.WORD 	DSKY_BEEP		; FUNCTION 13 -
008831  1  EC 92        		.WORD 	DSKY_L1ON		; FUNCTION 14 -
008833  1  FD 92        		.WORD 	DSKY_L2ON		; FUNCTION 15 -
008835  1  0E 93        		.WORD 	DSKY_L1OFF		; FUNCTION 16 -
008837  1  1F 93        		.WORD 	DSKY_L2OFF		; FUNCTION 17 -
008839  1  A8 92        		.WORD 	DSKY_PUTLED		; FUNCTION 18 -
00883B  1  76 92        		.WORD 	DSKY_BLANK		; FUNCTION 19 -
00883D  1               
00883D  1  B4 93        		.WORD 	MD_READ_SECTOR 		; FUNCTION 20 - read a sector from memory device
00883F  1  E8 93        		.WORD 	MD_WRITE_SECTOR		; FUNCTION 21 - write a sector to memory device
008841  1  6F 93        		.WORD 	MD_SHOW			; FUNCTION 22 - md show information
008843  1               
008843  1               
008843  1               ;__DRIVERS___________________________________________________________________________________________
008843  1               ;
008843  1               		.INCLUDE "dosser.asm"
008843  2               ;__SERIAL DRIVERS________________________________________________________________________________________________________________
008843  2               ;
008843  2               ; 	Nhyodyne serial drivers for single serial port card
008843  2               ;
008843  2               ;	Entry points:
008843  2               ;		SERIALINIT  - called during OS init
008843  2               ;		RDSER1	    - read a byte from serial port ('A' POINTS TO BYTE)
008843  2               ;		WRSER1	    - write a byte from serial port  ('A' POINTS TO BYTE)
008843  2               ;		RDSER1W	    - read a byte from serial port ('A' POINTS TO BYTE, WAIT FOR INPUT)
008843  2               ;		SERIALSTATUS- GET UART STATUS
008843  2               ;________________________________________________________________________________________________________________________________
008843  2               ;
008843  2               
008843  2               
008843  2               ;*
008843  2               ;* HARDWARE I/O ADDRESSES
008843  2               ;*
008843  2               
008843  2               ; UART 16C550 SERIAL
008843  2               UART0       	=    	$0368           ; DATA IN/OUT
008843  2               UART1       	=    	$0369           ; CHECK RX
008843  2               UART2       	=    	$036A           ; INTERRUPTS
008843  2               UART3       	=    	$036B           ; LINE CONTROL
008843  2               UART4       	=    	$036C           ; MODEM CONTROL
008843  2               UART5          	=    	$036D           ; LINE STATUS
008843  2               UART6          	=    	$036E           ; MODEM STATUS
008843  2               UART7	       	=    	$036F           ; SCRATCH REG.
008843  2               
008843  2               
008843  2               ;__SERIALINIT____________________________________________________________________________________________________________________
008843  2               ;
008843  2               ;	INITIALIZE SERIAL PORTS
008843  2               ;________________________________________________________________________________________________________________________________
008843  2               ;
008843  2               SERIALINIT:
008843  2               ;	LDA	#$80			;
008843  2               ;	STA	UART3			; SET DLAB FLAG
008843  2               ;	LDA	#12			; SET TO 12 = 9600 BAUD
008843  2               ;	STA	UART0			; save baud rate
008843  2               ;	LDA	#00			;
008843  2               ;	STA	UART1			;
008843  2               ;	LDA	#03			;
008843  2               ;	STA	UART3			; SET 8 BIT DATA, 1 STOPBIT
008843  2               ;	STA	UART4			;
008843  2               
008843  2  60           	RTS
008844  2               
008844  2               
008844  2               
008844  2               ;__WRSER1________________________________________________________________________________________________________________________
008844  2               ;
008844  2               ;	WRITE CHARACTER(A) TO UART
008844  2               ;________________________________________________________________________________________________________________________________
008844  2               ;
008844  2               WRSER1:
008844  2  48           	PHA
008845  2               WRSER1a:
008845  2  AD 6D 03     	LDA	UART5			; READ LINE STATUS REGISTER
008848  2  29 20        	AND	#$20			; TEST IF UART IS READY TO SEND (BIT 5)
00884A  2  C9 00        	CMP     #$00
00884C  2  F0 F7        	BEQ	WRSER1a			; NO, WAIT FOR IT
00884E  2  68           	PLA
00884F  2  8D 68 03     	STA	UART0			; THEN WRITE THE CHAR TO UART
008852  2  60           	RTS
008853  2               
008853  2               ;__RDSER1________________________________________________________________________________________________________________________
008853  2               ;
008853  2               ;	READ CHARACTER FROM UART TO (A)
008853  2               ;________________________________________________________________________________________________________________________________
008853  2               ;
008853  2               RDSER1:
008853  2  AD 6D 03     	LDA	UART5			; READ LINE STATUS REGISTER
008856  2  29 01        	AND	#$01			; TEST IF DATA IN RECEIVE BUFFER
008858  2  C9 00        	CMP 	#$00
00885A  2  F0 04        	BEQ	RDSER1N			; LOOP UNTIL DATA IS READY
00885C  2  AD 68 03     	LDA	UART0			; THEN READ THE CHAR FROM THE UART
00885F  2  60           	RTS
008860  2               RDSER1N:
008860  2  A9 00        	LDA	#$00			;
008862  2  60           	RTS				;
008863  2               
008863  2               ;__RDSER1W_______________________________________________________________________________________________________________________
008863  2               ;
008863  2               ;	READ CHARACTER FROM UART TO (A) - WAIT FOR CHAR
008863  2               ;________________________________________________________________________________________________________________________________
008863  2               ;
008863  2               
008863  2               RDSER1W:
008863  2  AD 6D 03     		LDA	UART5			; READ LINE STATUS REGISTER
008866  2  29 01        		AND	#$01			; TEST IF DATA IN RECEIVE BUFFER
008868  2  C9 00        		CMP 	#$00
00886A  2  F0 F7        		BEQ	RDSER1W			; LOOP UNTIL DATA IS READY
00886C  2  AD 68 03     		LDA	UART0			; THEN READ THE CHAR FROM THE UART
00886F  2  29 7F        		AND #$7F
008871  2  60           		RTS
008872  2               
008872  2               ;__SERIALSTATUS__________________________________________________________________________________________________________________
008872  2               ;
008872  2               ;	READ UARD STATUS
008872  2               ;________________________________________________________________________________________________________________________________
008872  2               ;
008872  2               SERIALSTATUS:
008872  2  AD 6D 03     	LDA	UART5			; READ LINE STATUS REGISTER
008875  2  29 01        	AND	#$01			; TEST IF DATA IN RECEIVE BUFFER
008877  2  C9 00        	CMP 	#$00
008879  2  F0 03        	BEQ	RDSTAT1			; NO, INDICATE NO CHAR
00887B  2  A9 FF        	LDA	#$FF			; GET DATA CHAR
00887D  2  60           	RTS
00887E  2               RDSTAT1:
00887E  2  A9 00        	LDA	#$00			; GET DATA CHAR
008880  2  60           	RTS
008881  2               
008881  2               ; end
008881  2               
008881  1               		.INCLUDE "doside.asm"
008881  2               ;__IDE DRIVERS___________________________________________________________________________________________________________________
008881  2               ;
008881  2               ; 	Nhyodyne IDE disk drivers for Z80PPIDE card
008881  2               ;
008881  2               ;	Entry points:
008881  2               ;		PPIDE_INIT   	- called during OS init
008881  2               ;		IDE_READ_SECTOR - read a sector from drive
008881  2               ;		IDE_WRITE_SECTOR- write a sector to drive
008881  2               ;________________________________________________________________________________________________________________________________
008881  2               ;
008881  2               PPIDE_PPI	=	$0360		; PORT A
008881  2               ;
008881  2               PPIDELO		=	PPIDE_PPI+0	; LSB
008881  2               PPIDEHI		=	PPIDE_PPI+1	; MSB
008881  2               PPIDECNTRL	=	PPIDE_PPI+2	; Control Signals
008881  2               PPIDEPPIC	=	PPIDE_PPI+3	; CONTROL BYTE PPI 82C55
008881  2               
008881  2               PPIDE_A0_LINE	=	$01		;DIRECT FROM 8255 TO IDE INTERFACE
008881  2               PPIDE_A1_LINE	=	$02		;DIRECT FROM 8255 TO IDE INTERFACE
008881  2               PPIDE_A2_LINE	=	$04		;DIRECT FROM 8255 TO IDE INTERFACE
008881  2               PPIDE_CS0_LINE	=	$08		;INVERTER BETWEEN 8255 AND IDE INTERFACE
008881  2               PPIDE_CS1_LINE	=	$10		;INVERTER BETWEEN 8255 AND IDE INTERFACE
008881  2               PPIDE_WR_LINE	=	$20		;INVERTER BETWEEN 8255 AND IDE INTERFACE
008881  2               PPIDE_RD_LINE	=	$40		;INVERTER BETWEEN 8255 AND IDE INTERFACE
008881  2               PPIDE_RST_LINE	=	$80		;INVERTER BETWEEN 8255 AND IDE INTERFACE
008881  2               
008881  2               PPIDE_DATA	=	PPIDE_CS0_LINE
008881  2               PPIDE_ERR	=	PPIDE_CS0_LINE + PPIDE_A0_LINE
008881  2               PPIDE_SEC_CNT	=	PPIDE_CS0_LINE + PPIDE_A1_LINE
008881  2               PPIDE_LBALOW	=	PPIDE_CS0_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
008881  2               PPIDE_LBAMID	=	PPIDE_CS0_LINE + PPIDE_A2_LINE
008881  2               PPIDE_LBAHI	=	PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A0_LINE
008881  2               PPIDE_DEVICE	=	PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
008881  2               PPIDE_COMMAND	=	PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
008881  2               PPIDE_STATUS	=	PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
008881  2               PPIDE_CONTROL	=	PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
008881  2               PPIDE_ASTATUS	=	PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
008881  2               
008881  2               
008881  2               ;IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
008881  2               PPIDE_CMD_RECAL	=	$10
008881  2               PPIDE_CMD_READ	=	$20
008881  2               PPIDE_CMD_WRITE	=	$30
008881  2               PPIDE_CMD_INIT	=	$91
008881  2               PPIDE_CMD_ID	=	$EC
008881  2               PPIDE_CMD_SPINDOWN=	$E0
008881  2               PPIDE_CMD_SPINUP=	$E1
008881  2               
008881  2               
008881  2               PPRD_IDE_8255	=	%10010010	;IDE_8255_CTL OUT, IDE_8255_LSB/MSB INPUT
008881  2               PPWR_IDE_8255	=	%10000000	;ALL THREE PORTS OUTPUT
008881  2               
008881  2               
008881  2  00           PPIDEINDEX:	.byte	$00
008882  2  00 00        PPIDETIMEOUT:	.byte	$00,$00
008884  2               
008884  2               ;__PPIDE_INIT_________________________________________________________________________________________
008884  2               ;
008884  2               ;  INIT AND DISPLAY IDE INFO
008884  2               ;____________________________________________________________________________________________________
008884  2               ;
008884  2               PPIDE_INIT:
008884  2                       PRTDBG "PPIDE INIT:$"
008884  2  48 DA 5A A2  	PRTS "PPIDE :$"
008888  2  00 BD 9D 88  
00888C  2  E8 C9 24 F0  
0088A5  2  20 rr rr            	JSR	NEWLINE
0088A8  2  20 1A 8B     	JSR	IDE_PPIDETECT		; TEST FOR PPI HARDWARE
0088AB  2  D0 35                BNE     IDE_ABORT      		; BAIL OUT IF NOT THERE
0088AD  2               ;
0088AD  2  48 DA 5A A2  	PRTS    " IO=0x$"
0088B1  2  00 BD C6 88  
0088B5  2  E8 C9 24 F0  
0088CD  2  A9 03        	LDA	#>PPIDE_PPI		; GET BASE PORT
0088CF  2  20 rr rr     	JSR	PRTHEXBYTE		; PRINT BASE PORT
0088D2  2  A9 60               	LDA	#<PPIDE_PPI		; GET BASE PORT
0088D4  2  20 rr rr     	JSR	PRTHEXBYTE		; PRINT BASE PORT
0088D7  2               ;
0088D7  2  20 B5 8B     	JSR	PPIDE_RESET		; RESET THE BUS
0088DA  2  20 70 89     	JSR	PPIDE_PROBE		; DETECT AN ATA DEVICE, ABORT IF NOT FOUND
0088DD  2  B0 03        	BCS 	IDE_ABORT
0088DF  2  4C 0B 89     	JMP 	IDE_PRINT_INFO
0088E2  2               IDE_ABORT:
0088E2  2  48 DA 5A A2  	PRTS    " NOT PRESENT$"		; NOT PRESENT
0088E6  2  00 BD FB 88  
0088EA  2  E8 C9 24 F0  
008908  2  4C 6C 89     	JMP 	IDE_INITA
00890B  2               IDE_PRINT_INFO:
00890B  2  20 rr rr     	JSR	NEWLINE
00890E  2  48 DA 5A A2  	PRTS    " PPIDE0: Blocks=$"
008912  2  00 BD 27 89  
008916  2  E8 C9 24 F0  
008938  2  A9 00        	LDA	#$00
00893A  2  20 F9 89     	JSR	IDE_READ_INFO		; GET DRIVE INFO, ABORT IF ERROR
00893D  2  48 DA 5A A2  	PRTS    " PPIDE1: Blocks=$"
008941  2  00 BD 56 89  
008945  2  E8 C9 24 F0  
008967  2  A9 01        	LDA	#$01
008969  2  20 F9 89     	JSR	IDE_READ_INFO		; GET DRIVE INFO, ABORT IF ERROR
00896C  2               IDE_INITA:
00896C  2  20 rr rr     	JSR	NEWLINE
00896F  2  60           	RTS				; DONE
008970  2               ;
008970  2               ;__PPIDE_PROBE_______________________________________________________________________________________
008970  2               ;
008970  2               ;  PROBE FOR IDE HARDWARE
008970  2               ;____________________________________________________________________________________________________
008970  2               ;
008970  2               PPIDE_PROBE:
008970  2               ;
008970  2               	; BELOW TESTS FOR EXISTENCE OF AN IDE CONTROLLER ON THE
008970  2               	; PPIDE INTERFACE.  WE WRITE A VALUE OF ZERO FIRST SO THAT
008970  2               	; THE PPI BUS HOLD WILL RETURN A VALUE OF ZERO IF THERE IS
008970  2               	; NOTHING CONNECTED TO PPI PORT A.  THEN WE READ THE STATUS
008970  2               	; REGISTER.  IF AN IDE CONTROLLER IS THERE, IT SHOULD ALWAYS
008970  2               	; RETURN SOMETHING OTHER THAN ZERO.  IF AN IDE CONTROLLER IS
008970  2               	; THERE, THEN THE VALUE WRITTEN TO PPI PORT A IS IGNORED
008970  2               	; BECAUSE THE WRITE SIGNAL IS NEVER PULSED.
008970  2               
008970  2  A9 00        	LDA 	#$00
008972  2  8D 60 03     	STA 	PPIDELO 		; PPI PORT A, DATALO
008975  2               
008975  2  20 E0 8B     	JSR	IDE_WAIT_NOT_BUSY	; WAIT FOR BUSY TO CLEAR
008978  2  B0 34        	BCS 	PPIDE_PROBE_FAIL	; IF TIMEOUT, REPORT NO IDE PRESENT
00897A  2  A9 0F        	LDA	#PPIDE_STATUS		; GET STATUS
00897C  2  20 8F 8D     	JSR	IDE_READ
00897F  2  8A           	TXA
008980  2  29 40        	AND 	#%01000000
008982  2  C9 00        	CMP 	#$00
008984  2  F0 28        	BEQ 	PPIDE_PROBE_FAIL	; IF NOT RDY BIT (BIT 6) THEN REPORT NO IDE PRESENT
008986  2               
008986  2               	; CHECK SIGNATURE
008986  2  A9 0A        	LDA	#PPIDE_SEC_CNT
008988  2  20 8F 8D     	JSR	IDE_READ
00898B  2  E0 01        	CPX 	#$01
00898D  2  D0 1F        	BNE 	PPIDE_PROBE_FAIL	; IF not '01' THEN REPORT NO IDE PRESENT
00898F  2  A9 0B        	LDA	#PPIDE_LBALOW
008991  2  20 8F 8D     	JSR	IDE_READ
008994  2  E0 01        	CPX 	#$01
008996  2  D0 16        	BNE 	PPIDE_PROBE_FAIL	; IF not '01' THEN REPORT NO IDE PRESENT
008998  2  A9 0C        	LDA	#PPIDE_LBAMID
00899A  2  20 8F 8D     	JSR	IDE_READ
00899D  2  E0 00        	CPX 	#$00
00899F  2  D0 0D        	BNE 	PPIDE_PROBE_FAIL	; IF not '00' THEN REPORT NO IDE PRESENT
0089A1  2  A9 0D        	LDA	#PPIDE_LBAHI
0089A3  2  20 8F 8D     	JSR	IDE_READ
0089A6  2  E0 00        	CPX 	#$00
0089A8  2  D0 04        	BNE 	PPIDE_PROBE_FAIL	; IF not '00' THEN REPORT NO IDE PRESENT
0089AA  2  18           	CLC
0089AB  2  4C AF 89     	JMP 	PPIDE_PROBE_SUCCESS
0089AE  2               PPIDE_PROBE_FAIL:
0089AE  2  38           	SEC
0089AF  2               PPIDE_PROBE_SUCCESS:
0089AF  2  60           	RTS				; DONE, NOTE THAT A=0 AND Z IS SET
0089B0  2               
0089B0  2               
0089B0  2               ;___IDE_IDENTIFY_TYPE____________________________________________________________________________________
0089B0  2               ;
0089B0  2               ; 	READ THE DISK TYPE AND DETERMINE IF IT IS USABLE BY DOS/65
0089B0  2               ; 	A=IDE DEVICE (0=MST,1=SLV)
0089B0  2               ;________________________________________________________________________________________________________
0089B0  2               
0089B0  2               IDE_IDENTIFY_TYPE:
0089B0  2  48           	PHA
0089B1  2  20 E0 8B     	JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
0089B4  2  B0 40        	BCS 	IDE_IDENTIFY_TYPE_ERROR	; IF TIMEOUT, REPORT ERROR
0089B6  2  A9 00        	LDA 	#$00
0089B8  2  8D 12 03     	STA	debsehd
0089BB  2  8D 10 03     	STA	debcyll			; STORE IN TRACK (lsb)
0089BE  2  8D 11 03     	STA	debcylm			; STORE IN TRACK (msb)
0089C1  2  68           	PLA				; GET DRIVE TYPE
0089C2  2  20 55 8B     	JSR 	IDE_READ_SECTOR_DIRTY1
0089C5  2  C9 FF        	CMP 	#$FF			; IS THERE A READ ERROR?
0089C7  2  F0 2D        	BEQ 	IDE_IDENTIFY_TYPE_ERROR
0089C9  2  AD 47 90     	LDA 	hstbuf+$01FE
0089CC  2  C9 55        	CMP 	#$55
0089CE  2  D0 23        	BNE 	IDE_IDENTIFY_TYPE_OK
0089D0  2  AD 48 90     	LDA 	hstbuf+$01FF
0089D3  2  C9 AA        	CMP 	#$AA
0089D5  2  D0 1C        	BNE 	IDE_IDENTIFY_TYPE_OK
0089D7  2  AD 0B 90     	LDA 	hstbuf+$01C2
0089DA  2  C9 00        	CMP 	#$00
0089DC  2  D0 18        	BNE 	IDE_IDENTIFY_TYPE_ERROR
0089DE  2  AD 1B 90     	LDA 	hstbuf+$01D2
0089E1  2  C9 00        	CMP 	#$00
0089E3  2  D0 11        	BNE 	IDE_IDENTIFY_TYPE_ERROR
0089E5  2  AD 2B 90     	LDA 	hstbuf+$01E2
0089E8  2  C9 00        	CMP 	#$00
0089EA  2  D0 0A        	BNE 	IDE_IDENTIFY_TYPE_ERROR
0089EC  2  AD 3B 90     	LDA 	hstbuf+$01F2
0089EF  2  C9 00        	CMP 	#$00
0089F1  2  D0 03        	BNE 	IDE_IDENTIFY_TYPE_ERROR
0089F3  2               IDE_IDENTIFY_TYPE_OK:
0089F3  2  A9 00        	LDA 	#$00			; EVERYTHING IS AWESOME
0089F5  2  60           	RTS
0089F6  2               IDE_IDENTIFY_TYPE_ERROR:
0089F6  2  A9 FF        	LDA 	#$FF			; SIGNIFY ERROR
0089F8  2  60           	RTS
0089F9  2               
0089F9  2               
0089F9  2               ;*__IDE_READ_INFO___________________________________________________________________________________
0089F9  2               ;*
0089F9  2               ;*  READ IDE INFORMATION
0089F9  2               ;*	CARRY SET ON ERROR
0089F9  2               ;* 	A=MST/SLV
0089F9  2               ;*____________________________________________________________________________________________________
0089F9  2               IDE_READ_INFO:
0089F9  2               		PRTDBG "IDE Read INFORMATION$"
0089F9  2  48           		PHA
0089FA  2  48           		PHA
0089FB  2               		; SET DRIVE BIT
0089FB  2  29 01        		AND 	#$01			; ONLY WANT THE 1 BIT (MST/SLV)
0089FD  2  0A           		asl	a			; SHIFT 4
0089FE  2  0A           		asl	a			;
0089FF  2  0A           		asl	a			;
008A00  2  0A           		asl	a			;
008A01  2  09 E0        		ORA 	#$E0			; E0=MST  F0=SLV
008A03  2  AA           		TAX
008A04  2  A0 00        		LDY	#$00
008A06  2  A9 0E        		LDA	#PPIDE_DEVICE
008A08  2  20 AD 8D     		JSR	IDE_WRITE
008A0B  2               
008A0B  2               
008A0B  2  20 E0 8B     		JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
008A0E  2  B0 4E        		BCS	IDE_READ_INFO_ABORT
008A10  2  A9 0F        		LDA	#PPIDE_COMMAND		;SELECT IDE REGISTER
008A12  2  A2 EC        		LDX	#PPIDE_CMD_ID
008A14  2  20 AD 8D     		JSR	IDE_WRITE		;ASK THE DRIVE TO READ IT
008A17  2  20 08 8C     		JSR	IDE_WAIT_DRQ		;WAIT UNTIL IT'S GOT THE DATA
008A1A  2  B0 42        		BCS	IDE_READ_INFO_ABORT
008A1C  2  20 38 8C     		JSR	IDE_READ_BUFFER		; GRAB THE 256 WORDS FROM THE BUFFER
008A1F  2  48 DA 5A A2  		PRTS    "0x$"
008A23  2  00 BD 38 8A  
008A27  2  E8 C9 24 F0  
008A3B  2  AD C4 8E     		LDA 	hstbuf+123
008A3E  2  20 rr rr     		JSR 	PRTHEXBYTE
008A41  2  AD C3 8E     		LDA 	hstbuf+122
008A44  2  20 rr rr     		JSR 	PRTHEXBYTE
008A47  2  AD C2 8E     		LDA 	hstbuf+121
008A4A  2  20 rr rr     		JSR 	PRTHEXBYTE
008A4D  2  AD C1 8E     		LDA 	hstbuf+120
008A50  2  20 rr rr     		JSR 	PRTHEXBYTE
008A53  2  68           		PLA
008A54  2  20 B0 89     		JSR 	IDE_IDENTIFY_TYPE
008A57  2  C9 00        		CMP 	#$00
008A59  2  D0 32        		BNE 	IDE_READ_INFO_BADFS
008A5B  2  4C BF 8A     		JMP 	IDE_READ_INFO_OK
008A5E  2               IDE_READ_INFO_ABORT:
008A5E  2  68           		PLA
008A5F  2  48 DA 5A A2  		PRTS    "NOT PRESENT$"		; NOT PRESENT
008A63  2  00 BD 78 8A  
008A67  2  E8 C9 24 F0  
008A84  2  20 rr rr     		JSR	NEWLINE
008A87  2  68           		PLA
008A88  2  20 F6 8A     		JSR 	IDE_REMOVE_DRIVE_ASSIGNMENTS
008A8B  2  38           		SEC
008A8C  2  60           		RTS				;
008A8D  2               IDE_READ_INFO_BADFS:
008A8D  2  48 DA 5A A2  		PRTS    " BAD FILESYSTEM$"	; NOT PRESENT
008A91  2  00 BD A6 8A  
008A95  2  E8 C9 24 F0  
008AB6  2  20 rr rr     		JSR	NEWLINE
008AB9  2  68           		PLA
008ABA  2  20 F6 8A     		JSR 	IDE_REMOVE_DRIVE_ASSIGNMENTS
008ABD  2  38           		SEC
008ABE  2  60           		RTS				;
008ABF  2               IDE_READ_INFO_OK:
008ABF  2  48 DA 5A A2  		PRTS    " FILE SYSTEM COMPATIBLE$" ; NOT PRESENT
008AC3  2  00 BD D8 8A  
008AC7  2  E8 C9 24 F0  
008AF0  2  20 rr rr     		JSR	NEWLINE
008AF3  2  68           		PLA
008AF4  2  18           		CLC
008AF5  2  60           		RTS
008AF6  2               
008AF6  2               IDE_REMOVE_DRIVE_ASSIGNMENTS:
008AF6  2  18           		CLC
008AF7  2  69 30        		ADC	#$30
008AF9  2  A2 00        		LDX 	#$00
008AFB  2               @1:
008AFB  2  DD 14 03     		CMP 	dskcfg,X 		; GET device
008AFE  2  F0 09        		BEQ 	@2
008B00  2  E8           		INX
008B01  2  E8           		INX
008B02  2  E0 10        		CPX 	#16
008B04  2  D0 F5        		bne 	@1
008B06  2  4C 19 8B     		jmp 	@3
008B09  2               @2:
008B09  2  48           		PHA
008B0A  2  A9 00        		LDA 	#$00
008B0C  2  9D 14 03     		STA 	dskcfg,X 		; SET device
008B0F  2  E8           		INX
008B10  2  9D 14 03     		STA 	dskcfg,X 		; SET device
008B13  2  68           		pla
008B14  2  E8           		INX
008B15  2  E0 10        		CPX 	#16
008B17  2  D0 E2        		bne 	@1
008B19  2               @3:
008B19  2  60           		rts
008B1A  2               
008B1A  2               ;__IDE_PPIDETECT____________________________________________________________________________________
008B1A  2               ;
008B1A  2               ;  PROBE FOR PPI HARDWARE
008B1A  2               ;____________________________________________________________________________________________________
008B1A  2               ;
008B1A  2               IDE_PPIDETECT:
008B1A  2               ;
008B1A  2               	; TEST FOR PPI EXISTENCE
008B1A  2               	; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
008B1A  2               	; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
008B1A  2               	; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
008B1A  2               	; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
008B1A  2               	; INTERFERE WITH THE VALUE BEING READ.
008B1A  2  20 D1 8D     	JSR	SET_PPI_WR
008B1D  2               ;
008B1D  2  A9 00        	LDA     #$00			; VALUE ZERO
008B1F  2  8D 60 03     	STA	PPIDELO			; PUSH VALUE TO PORT
008B22  2  AD 60 03     	LDA	PPIDELO			; GET PORT VALUE
008B25  2  C9 00                CMP     #$00
008B27  2  60           	RTS				; AND RETURN
008B28  2               ;
008B28  2               
008B28  2               
008B28  2               ;*__IDE_READ_SECTOR___________________________________________________________________________________
008B28  2               ;*
008B28  2               ;*  READ IDE SECTOR (IN LBA) INTO BUFFER
008B28  2               ;*
008B28  2               ;*____________________________________________________________________________________________________
008B28  2               IDE_READ_SECTOR:
008B28  2               		PRTDBG "IDE Read Sector$"
008B28  2  20 2F 8B     		JSR 	IDE_READ_RAW_SECTOR
008B2B  2  20 D9 8D     		JSR 	DEBSECR512
008B2E  2  60           		RTS
008B2F  2               
008B2F  2               IDE_READ_RAW_SECTOR:
008B2F  2               		PRTDBG "IDE Read Raw Sector$"
008B2F  2  20 D4 8C     	  	JSR	IDE_CONVERT_SECTOR	;
008B32  2               
008B32  2  AD 12 03     		LDA	debsehd			; STORE CURRENT PARMS
008B35  2  CD 45 8E     		CMP	Cdebsehd		;
008B38  2  D0 13        		BNE	IDE_READ_SECTOR_DIRTY
008B3A  2  AD 11 03     		LDA	debcylm			;
008B3D  2  CD 44 8E     		CMP	Cdebcylm		;
008B40  2  D0 0B        		BNE	IDE_READ_SECTOR_DIRTY
008B42  2  AD 10 03     		LDA	debcyll			;
008B45  2  CD 43 8E     		CMP	Cdebcyll		;
008B48  2  D0 03        		BNE	IDE_READ_SECTOR_DIRTY
008B4A  2  A9 00        		LDA	#$00			; ZERO = 1 ON RETURN = OPERATION OK
008B4C  2  60           		RTS
008B4D  2               
008B4D  2               IDE_READ_SECTOR_DIRTY:
008B4D  2               		PRTDBG "IDE Read Sector Buffer Dirty$"
008B4D  2  20 E0 8B     		JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
008B50  2  B0 2A        		BCS 	IDE_READ_SECTOR_DIRTY_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
008B52  2  20 23 8E     		JSR 	GET_DRIVE_DEVICE
008B55  2               IDE_READ_SECTOR_DIRTY1:
008B55  2  20 A4 8C     		JSR	IDE_SETUP_LBA		;TELL IT WHICH SECTOR WE WANT
008B58  2  A9 0F        		LDA	#PPIDE_COMMAND		;SELECT IDE REGISTER
008B5A  2  A2 20        		LDX	#PPIDE_CMD_READ
008B5C  2  20 AD 8D     		JSR	IDE_WRITE		;ASK THE DRIVE TO READ IT
008B5F  2  20 08 8C     		JSR	IDE_WAIT_DRQ		;WAIT UNTIL IT'S GOT THE DATA
008B62  2  B0 18        		BCS 	IDE_READ_SECTOR_DIRTY_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
008B64  2  20 38 8C     		JSR	IDE_READ_BUFFER		; GRAB THE 256 WORDS FROM THE BUFFER
008B67  2  AD 12 03     		LDA	debsehd			; STORE CURRENT PARMS
008B6A  2  8D 45 8E     		STA	Cdebsehd		;
008B6D  2  AD 10 03     		LDA	debcyll			;
008B70  2  8D 43 8E     		STA	Cdebcyll		;
008B73  2  AD 11 03     		LDA	debcylm			;
008B76  2  8D 44 8E     		STA	Cdebcylm		;
008B79  2               
008B79  2  A9 00        		LDA	#$00			; ZERO = 1 ON RETURN = OPERATION OK
008B7B  2  60           		RTS
008B7C  2               IDE_READ_SECTOR_DIRTY_ERROR:
008B7C  2  A9 FF        		LDA	#$FF			; ZERO = 1 ON RETURN = OPERATION OK
008B7E  2  60           		RTS
008B7F  2               
008B7F  2               ;*__IDE_WRITE_SECTOR__________________________________________________________________________________
008B7F  2               ;*
008B7F  2               ;*  WRITE IDE SECTOR (IN LBA) FROM BUFFER
008B7F  2               ;*
008B7F  2               ;*____________________________________________________________________________________________________
008B7F  2               IDE_WRITE_SECTOR:
008B7F  2               		PRTDBG "IDE Write Sector$"
008B7F  2  20 2F 8B     	  	JSR	IDE_READ_RAW_SECTOR	; determine physical sector
008B82  2  20 02 8E     	  	JSR	BLKSECR512		; block sector for writing
008B85  2  20 E0 8B     		JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
008B88  2  B0 28        		BCS 	IDE_WRITE_SECTOR_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
008B8A  2  20 23 8E     		JSR 	GET_DRIVE_DEVICE
008B8D  2  20 A4 8C     		JSR	IDE_SETUP_LBA		;TELL IT WHICH SECTOR WE WANT
008B90  2  A9 0F        		LDA	#PPIDE_COMMAND
008B92  2  A2 30        		LDX	#PPIDE_CMD_WRITE
008B94  2  20 AD 8D     		JSR	IDE_WRITE		;TELL DRIVE TO WRITE A SECTOR
008B97  2  20 08 8C     		JSR	IDE_WAIT_DRQ		;WAIT UNIT IT WANTS THE DATA
008B9A  2  B0 16        		BCS 	IDE_WRITE_SECTOR_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
008B9C  2  20 6D 8C     		JSR	IDE_WRITE_BUFFER	;GIVE THE DATA TO THE DRIVE
008B9F  2  20 E0 8B     		JSR	IDE_WAIT_NOT_BUSY	;WAIT UNTIL THE WRITE IS COMPLETE
008BA2  2  B0 0E        		BCS 	IDE_WRITE_SECTOR_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
008BA4  2  A9 FF        		LDA	#$FF			; STORE CURRENT PARMS
008BA6  2  8D 45 8E     		STA	Cdebsehd		;
008BA9  2  8D 43 8E     		STA	Cdebcyll		;
008BAC  2  8D 44 8E     		STA	Cdebcylm		;
008BAF  2               
008BAF  2  A9 00        		LDA	#$00			; ZERO ON RETURN = OPERATION OK
008BB1  2  60           		RTS
008BB2  2               IDE_WRITE_SECTOR_ERROR:
008BB2  2  A9 FF        		LDA	#$FF			; 1 ON RETURN = OPERATION FAIL
008BB4  2  60           		RTS
008BB5  2               
008BB5  2               ;*__PPIDE_RESET____________________________________________________________________________________
008BB5  2               ;*
008BB5  2               ;*  SOFT RESET IDE CHANNEL
008BB5  2               ;*
008BB5  2               ;*____________________________________________________________________________________________________
008BB5  2               PPIDE_RESET:
008BB5  2                 	PRTDBG "IDE Reset$"
008BB5  2  A9 00        		LDA	#$00
008BB7  2  8D 12 03     		STA	debsehd
008BBA  2  8D 10 03     		STA	debcyll
008BBD  2  8D 11 03     		STA	debcylm
008BC0  2  A9 FF        		LDA	#$FF			;
008BC2  2  8D 45 8E     		STA	Cdebsehd		;
008BC5  2  8D 43 8E     		STA	Cdebcyll		;
008BC8  2  8D 44 8E     		STA	Cdebcylm		;
008BCB  2               
008BCB  2  A9 80        		LDA	#PPIDE_RST_LINE
008BCD  2  8D 62 03     		STA	PPIDECNTRL			; ASSERT RST LINE ON IDE INTERFACE
008BD0  2  A2 00        		LDX	#$00
008BD2  2               	PRTDBG "IDE Reset Delay$"
008BD2  2               RST_DLY:
008BD2  2  CA           		DEX
008BD3  2  E0 00        		CPX	#$00
008BD5  2  D0 FB        		BNE	RST_DLY
008BD7  2  A9 00        		LDA	#$00
008BD9  2  8D 62 03     		STA	PPIDECNTRL			; DEASSERT RST LINE ON IDE INTERFACE
008BDC  2               
008BDC  2               ; IF A DSKYNG IS ACTIVE AND IS ON THE SAME PPI PORT AS THE PPISD BEING
008BDC  2               ; RESET, THEN THE DSKYNG WILL ALSO BE RESET.  SO, THE DSKY IS ALSO INITIALIZED.
008BDC  2               	.IF (USEDSKYNG=1)
008BDC  2  20 35 91     	JSR 	DSKY_REINIT
008BDF  2               	.ENDIF
008BDF  2               
008BDF  2  60           		RTS
008BE0  2               
008BE0  2               
008BE0  2               ;*__IDE_WAIT_NOT_BUSY_______________________________________________________________________________
008BE0  2               ;*
008BE0  2               ;*  WAIT FOR IDE CHANNEL TO BECOME READY
008BE0  2               ;*
008BE0  2               ;*____________________________________________________________________________________________________
008BE0  2               IDE_WAIT_NOT_BUSY:
008BE0  2  DA           		PHX
008BE1  2  5A           		PHY
008BE2  2  48           		PHA
008BE3  2  A9 00        		LDA #$00
008BE5  2  8D 82 88     		STA PPIDETIMEOUT
008BE8  2  8D 83 88     		STA PPIDETIMEOUT+1
008BEB  2               IDE_WAIT_NOT_BUSY1:
008BEB  2  A9 0F        		LDA	#PPIDE_STATUS		;WAIT FOR RDY BIT TO BE SET
008BED  2  20 8F 8D     		JSR	IDE_READ
008BF0  2  8A           		TXA
008BF1  2  29 80        		AND	#$80
008BF3  2  F0 0E        		BEQ	IDE_WAIT_NOT_BUSY2
008BF5  2  EE 82 88     		INC 	PPIDETIMEOUT
008BF8  2  D0 F1        		BNE 	IDE_WAIT_NOT_BUSY1
008BFA  2  EE 83 88     		INC 	PPIDETIMEOUT+1
008BFD  2  D0 EC        		BNE 	IDE_WAIT_NOT_BUSY1
008BFF  2  38           		SEC
008C00  2  4C 04 8C     		JMP	IDE_WAIT_NOT_BUSY3
008C03  2               IDE_WAIT_NOT_BUSY2:
008C03  2  18           		CLC
008C04  2               IDE_WAIT_NOT_BUSY3:
008C04  2  68           		PLA
008C05  2  7A           		PLY
008C06  2  FA           		PLX
008C07  2  60           		RTS
008C08  2               
008C08  2               ;*__IDE_WAIT_DRQ______________________________________________________________________________________
008C08  2               ;*
008C08  2               ;*	WAIT FOR THE DRIVE TO BE READY TO TRANSFER DATA.
008C08  2               ;*
008C08  2               ;*____________________________________________________________________________________________________
008C08  2               IDE_WAIT_DRQ:
008C08  2  DA           		PHX
008C09  2  5A           		PHY
008C0A  2  48           		PHA
008C0B  2  A9 00        		LDA #$00
008C0D  2  8D 82 88     		STA PPIDETIMEOUT
008C10  2  8D 83 88     		STA PPIDETIMEOUT+1
008C13  2               IDE_WAIT_DRQ1:
008C13  2  A9 0F        		LDA	#PPIDE_STATUS		;WAIT FOR DRQ BIT TO BE SET
008C15  2  20 8F 8D     		JSR	IDE_READ
008C18  2  8A           		TXA
008C19  2  29 88        		AND	#%10001000		; MASK OFF BUSY(7) AND DRQ(3)
008C1B  2  C9 08        		CMP	#%00001000		; WE WANT BUSY(7) TO BE 0 AND DRQ (3) TO BE 1
008C1D  2  F0 14        		BEQ	IDE_WAIT_DRQ2
008C1F  2  29 01        		AND	#%00000001		; IS ERROR?
008C21  2  C9 01        		CMP	#%00000001		;
008C23  2  F0 0A        		BEQ	IDE_WAIT_DRQE
008C25  2  EE 82 88     		INC 	PPIDETIMEOUT
008C28  2  D0 E9        		BNE 	IDE_WAIT_DRQ1
008C2A  2  EE 83 88     		INC 	PPIDETIMEOUT+1
008C2D  2  D0 E4        		BNE 	IDE_WAIT_DRQ1
008C2F  2               IDE_WAIT_DRQE:
008C2F  2  38           		SEC
008C30  2  4C 34 8C     		JMP	IDE_WAIT_DRQ3
008C33  2               IDE_WAIT_DRQ2:
008C33  2  18           		CLC
008C34  2               IDE_WAIT_DRQ3:
008C34  2  68           		PLA
008C35  2  7A           		PLY
008C36  2  FA           		PLX
008C37  2  60           		RTS
008C38  2               
008C38  2               
008C38  2               
008C38  2               ;*__IDE_READ_BUFFER___________________________________________________________________________________
008C38  2               ;*
008C38  2               ;*  READ IDE BUFFER LITTLE ENDIAN
008C38  2               ;*
008C38  2               ;*____________________________________________________________________________________________________
008C38  2               IDE_READ_BUFFER:
008C38  2  A2 00        		LDX    	#$00			; INDEX
008C3A  2               IDEBUFRD:
008C3A  2  8E 81 88     		STX	PPIDEINDEX
008C3D  2  A9 08        		LDA	#PPIDE_DATA
008C3F  2  20 8F 8D     		JSR	IDE_READ
008C42  2  8A           		TXA
008C43  2  AE 81 88     		LDX	PPIDEINDEX
008C46  2  9D 49 8E     		STA	hstbuf,X		;
008C49  2  E8           		INX				;
008C4A  2  98           		TYA				; THEN HIGH BYTE OF WORD
008C4B  2  9D 49 8E     		STA	hstbuf,X		;
008C4E  2  E8           		INX
008C4F  2  E0 00        		CPX    	#$00			;
008C51  2  D0 E7        		BNE	IDEBUFRD		;
008C53  2               IDEBUFRD1:
008C53  2  8E 81 88     		STX	PPIDEINDEX
008C56  2  A9 08        		LDA	#PPIDE_DATA
008C58  2  20 8F 8D     		JSR	IDE_READ
008C5B  2  8A           		TXA
008C5C  2  AE 81 88     		LDX	PPIDEINDEX
008C5F  2  9D 49 8F     		STA	hstbuf+256,X		;
008C62  2  E8           		INX				;
008C63  2  98           		TYA				; THEN HIGH BYTE OF WORD
008C64  2  9D 49 8F     		STA	hstbuf+256,X		;
008C67  2  E8           		INX				;
008C68  2  E0 00        		CPX    	#$00			;
008C6A  2  D0 E7        		BNE	IDEBUFRD1		;
008C6C  2  60           		RTS				;
008C6D  2               
008C6D  2               ;*__IDE_WRITE_BUFFER___________________________________________________________________________________
008C6D  2               ;*
008C6D  2               ;*  WRITE IDE BUFFER LITTLE ENDIAN
008C6D  2               ;*
008C6D  2               ;*____________________________________________________________________________________________________
008C6D  2               IDE_WRITE_BUFFER:
008C6D  2  A2 00        		LDX    	#$00			; INDEX
008C6F  2               IDEBUFWT:
008C6F  2  8E 81 88     		STX	PPIDEINDEX
008C72  2  BD 4A 8E     		LDA     hstbuf+1,X		; SECTORS ARE BIG ENDIAN
008C75  2  A8           		TAY				;
008C76  2  BD 49 8E     		LDA     hstbuf,X		; SECTORS ARE BIG ENDIAN
008C79  2  AA           		TAX
008C7A  2  A9 08        		LDA	#PPIDE_DATA
008C7C  2  20 AD 8D     		JSR	IDE_WRITE
008C7F  2  AE 81 88     		LDX	PPIDEINDEX
008C82  2  E8           		INX				;
008C83  2  E8           		INX				;
008C84  2  E0 00        		CPX    	#$00			;
008C86  2  D0 E7        		BNE	IDEBUFWT		;
008C88  2  A2 00        		LDX    	#$00			; INDEX
008C8A  2               IDEBUFWT1:
008C8A  2  8E 81 88     		STX	PPIDEINDEX
008C8D  2  BD 4A 8F     		LDA     hstbuf+257,X		; SECTORS ARE BIG ENDIAN
008C90  2  A8           		TAY
008C91  2  BD 49 8F     		LDA     hstbuf+256,X		; SECTORS ARE BIG ENDIAN
008C94  2  AA           		TAX
008C95  2  A9 08        		LDA	#PPIDE_DATA
008C97  2  20 AD 8D     		JSR	IDE_WRITE
008C9A  2  AE 81 88     		LDX	PPIDEINDEX
008C9D  2  E8           		INX				;
008C9E  2  E8           		INX				;
008C9F  2  E0 00        		CPX    	#$00			;
008CA1  2  D0 E7        		BNE	IDEBUFWT1		;
008CA3  2  60           		RTS				;
008CA4  2               
008CA4  2               ;*__IDE_SETUP_LBA_____________________________________________________________________________________
008CA4  2               ;*
008CA4  2               ;*  SETUP LBA DATA
008CA4  2               ;*  A= DRIVE DEVICE
008CA4  2               ;*____________________________________________________________________________________________________
008CA4  2               IDE_SETUP_LBA:
008CA4  2               		PRTDBG "PPIDE SETUP LBA$"
008CA4  2  29 01        		and 	#$01			; only want drive cfg
008CA6  2  0A           		asl	a			; SHIFT 4
008CA7  2  0A           		asl	a			;
008CA8  2  0A           		asl	a			;
008CA9  2  0A           		asl	a			;
008CAA  2  09 E0        		ORA 	#$E0			; E0=MST  F0=SLV
008CAC  2  AA           		TAX
008CAD  2  A0 00        		LDY	#$00
008CAF  2  A9 0E        		LDA	#PPIDE_DEVICE
008CB1  2  20 AD 8D     		JSR	IDE_WRITE
008CB4  2               
008CB4  2  AE 11 03     		LDX    	debcylm
008CB7  2  A9 0D        		LDA	#PPIDE_LBAHI
008CB9  2  20 AD 8D     		JSR	IDE_WRITE
008CBC  2               
008CBC  2  AE 10 03     		LDX    	debcyll			;
008CBF  2  A9 0C        		LDA	#PPIDE_LBAMID
008CC1  2  20 AD 8D     		JSR	IDE_WRITE
008CC4  2               
008CC4  2  AE 12 03     		LDX    	debsehd			;
008CC7  2  A9 0B        		LDA	#PPIDE_LBALOW
008CC9  2  20 AD 8D     		JSR	IDE_WRITE
008CCC  2               
008CCC  2  A2 01        		LDX	#$01
008CCE  2  A9 0A        		LDA	#PPIDE_SEC_CNT
008CD0  2  20 AD 8D     		JSR	IDE_WRITE
008CD3  2               
008CD3  2  60           		RTS
008CD4  2               
008CD4  2               ;___IDE_CONVERT_SECTOR___________________________________________________________________________________
008CD4  2               ;
008CD4  2               ; 	TRANSLATE SECTORS INTO IDE FORMAT
008CD4  2               ;________________________________________________________________________________________________________
008CD4  2               IDE_CONVERT_SECTOR:
008CD4  2  AD 0C 03     	LDA	sektrk			; LOAD TRACK # (LOW BYTE)
008CD7  2  29 0F        	AND 	#$0F			; ISOLATE HEAD IN LOW 4 BITS
008CD9  2  0A           	asl	a			; MOVE TO HIGH BYTE
008CDA  2  0A           	asl	a
008CDB  2  0A           	asl	a
008CDC  2  0A           	asl	a
008CDD  2  AA           	TAX 				; PARK IN X
008CDE  2  AD 0E 03     	LDA	seksec			; LOAD SECTOR # (LOW BYTE)
008CE1  2  4A           	LSR	A			;
008CE2  2  4A           	LSR	A			; DIVIDE BY 4 (FOR BLOCKING)
008CE3  2  29 0F        	AND 	#$0F 			; CLEAR UPPER 4 BITS (JUST 'CAUSE)
008CE5  2  8D 12 03     	STA	debsehd			; STORE IN SECTOR/HEAD
008CE8  2  8A           	TXA 				; GET HEAD BACK
008CE9  2  0D 12 03     	ORA 	debsehd
008CEC  2  8D 12 03     	STA	debsehd			; STORE IN SECTOR/HEAD
008CEF  2               
008CEF  2  AD 0C 03     	LDA 	sektrk
008CF2  2  8D 10 03     	STA	debcyll			; STORE IN TRACK (lsb)
008CF5  2  AD 0D 03     	LDA 	sektrk+1
008CF8  2  8D 11 03     	STA	debcylm			; STORE IN TRACK (msb)
008CFB  2               					; REMOVE HEAD FROM TRACK VALUE (DIV/4)
008CFB  2  AD 11 03     	LDA	debcylm
008CFE  2  4A           	LSR 	A
008CFF  2  8D 11 03     	STA	debcylm
008D02  2  AD 10 03     	LDA	debcyll
008D05  2  6A           	ROR 	A
008D06  2  8D 10 03     	STA	debcyll
008D09  2               
008D09  2  AD 11 03     	LDA	debcylm
008D0C  2  4A           	LSR 	A
008D0D  2  8D 11 03     	STA	debcylm
008D10  2  AD 10 03     	LDA	debcyll
008D13  2  6A           	ROR 	A
008D14  2  8D 10 03     	STA	debcyll
008D17  2               
008D17  2  AD 11 03     	LDA	debcylm
008D1A  2  4A           	LSR 	A
008D1B  2  8D 11 03     	STA	debcylm
008D1E  2  AD 10 03     	LDA	debcyll
008D21  2  6A           	ROR 	A
008D22  2  8D 10 03     	STA	debcyll
008D25  2               
008D25  2  AD 11 03     	LDA	debcylm
008D28  2  4A           	LSR 	A
008D29  2  8D 11 03     	STA	debcylm
008D2C  2  AD 10 03     	LDA	debcyll
008D2F  2  6A           	ROR 	A
008D30  2  8D 10 03     	STA	debcyll
008D33  2               
008D33  2               ;	ADD SLICE OFFSET
008D33  2  AD 13 03     	LDA	sekdsk			; GET DRIVE#
008D36  2  29 07        	AND 	#7			; ONLY FIRST 8 DEVICES SUPPORTED
008D38  2  0A           	asl	a			; DOUBLE NUMBER FOR TABLE LOOKUP
008D39  2  AA           	TAX 				; MOVE TO X REGISTER
008D3A  2  E8           	INX				; WANT SECOND BYTE OF ENTRY
008D3B  2  BD 14 03     	LDA 	dskcfg,X 		; GET SLICE#
008D3E  2  8D 48 8E     	STA 	slicetmp+1 		; SLICE OFFSET MSB
008D41  2  A9 00        	LDA 	#0	 		; GET SLICE#
008D43  2  8D 47 8E     	STA 	slicetmp		; SLICE OFFSET LSB
008D46  2  18           	CLC				; VOODOO MATH TO TAKE SLICE*$4000
008D47  2  6E 48 8E     	ROR 	slicetmp+1
008D4A  2  6E 47 8E     	ROR	slicetmp
008D4D  2  6E 48 8E     	ROR 	slicetmp+1
008D50  2  6E 47 8E     	ROR	slicetmp
008D53  2               
008D53  2  BD 14 03     	LDA 	dskcfg,X 		; GET SLICE#
008D56  2  18           	clc
008D57  2  6D 47 8E     	adc 	slicetmp
008D5A  2  8D 47 8E     	sta 	slicetmp
008D5D  2               					; ADD SLICE OFFSET TO TRACK #
008D5D  2  18           	clc				; clear carry
008D5E  2  AD 47 8E     	lda slicetmp
008D61  2  6D 10 03     	adc debcyll
008D64  2  8D 10 03     	sta debcyll			; store sum of LSBs
008D67  2  AD 48 8E     	lda slicetmp+1
008D6A  2  6D 11 03     	adc debcylm			; add the MSBs using carry from
008D6D  2  8D 11 03     	sta debcylm			; the previous calculation
008D70  2               
008D70  2               
008D70  2               
008D70  2               
008D70  2                 .IF USEDSKY=1 || USEDSKYNG=1
008D70  2                 	PRTDBG "DSKY OUTPUT 1$"
008D70  2  AD 13 03       	lda	sekdsk
008D73  2  8D 08 03       	sta	DSKY_HEXBUF
008D76  2  AD 11 03      	lda	debcylm
008D79  2  8D 09 03       	sta	DSKY_HEXBUF+1
008D7C  2  AD 10 03      	lda	debcyll
008D7F  2  8D 0A 03       	sta	DSKY_HEXBUF+2
008D82  2  AD 12 03         	lda	debsehd
008D85  2  8D 0B 03       	sta	DSKY_HEXBUF+3
008D88  2  20 BB 91       	JSR	DSKY_BIN2SEG
008D8B  2  20 F0 91     	JSR	DSKY_SHOW
008D8E  2                 .ENDIF
008D8E  2  60           	RTS
008D8F  2               
008D8F  2               
008D8F  2               ;-------------------------------------------------------------------------------
008D8F  2               
008D8F  2               ; LOW LEVEL I/O TO THE DRIVE.  THESE ARE THE ROUTINES THAT TALK
008D8F  2               ; DIRECTLY TO THE DRIVE, VIA THE 8255 CHIP.  NORMALLY A MAIN
008D8F  2               ; PROGRAM WOULD NOT CALL TO THESE.
008D8F  2               
008D8F  2               	;DO A READ BUS CYCLE TO THE DRIVE, USING THE 8255.
008D8F  2               	;INPUT A = IDE REGSITER ADDRESS
008D8F  2               	;OUTPUT X = LOWER BYTE READ FROM IDE DRIVE
008D8F  2               	;OUTPUT Y = UPPER BYTE READ FROM IDE DRIVE
008D8F  2               
008D8F  2               IDE_READ:
008D8F  2  20 C9 8D     	JSR	SET_PPI_RD		; SETUP FOR A READ CYCLE
008D92  2               
008D92  2  8D 62 03     	STA	PPIDECNTRL		;DRIVE ADDRESS ONTO CONTROL LINES
008D95  2  09 40        	ORA	#PPIDE_RD_LINE		; ASSERT RD PIN
008D97  2  8D 62 03     	STA	PPIDECNTRL
008D9A  2  48           	PHA
008D9B  2               
008D9B  2  AE 60 03     	LDX	PPIDELO			; READ LOWER BYTE
008D9E  2  AC 61 03     	LDY	PPIDEHI			; READ UPPER BYTE
008DA1  2               
008DA1  2  68           	PLA				; RESTORE REGISTER VALUE
008DA2  2  49 40        	EOR	#PPIDE_RD_LINE		; DE-ASSERT RD SIGNAL
008DA4  2  8D 62 03     	STA	PPIDECNTRL
008DA7  2  A9 00        	LDA	#$00
008DA9  2  8D 62 03     	STA	PPIDECNTRL		;DEASSERT ALL CONTROL PINS
008DAC  2  60           	RTS
008DAD  2               
008DAD  2               
008DAD  2               
008DAD  2               
008DAD  2               	;DO A WRITE BUS CYCLE TO THE DRIVE, VIA THE 8255
008DAD  2               	;INPUT A = IDE REGISTER ADDRESS
008DAD  2               	;INPUT REGISTER X = LSB TO WRITE
008DAD  2               	;INPUT REGISTER Y = MSB TO WRITE
008DAD  2               	;
008DAD  2               
008DAD  2               
008DAD  2               IDE_WRITE:
008DAD  2  20 D1 8D     	JSR	SET_PPI_WR		; SETUP FOR A WRITE CYCLE
008DB0  2               
008DB0  2  8E 60 03     	STX	PPIDELO			; WRITE LOWER BYTE
008DB3  2  8C 61 03     	STY	PPIDEHI			; WRITE UPPER BYTE
008DB6  2               
008DB6  2  8D 62 03     	STA	PPIDECNTRL		;DRIVE ADDRESS ONTO CONTROL LINES
008DB9  2               
008DB9  2  09 20        	ORA	#PPIDE_WR_LINE		; ASSERT WRITE PIN
008DBB  2  8D 62 03     	STA	PPIDECNTRL
008DBE  2               
008DBE  2  49 20        	EOR	#PPIDE_WR_LINE		; DE ASSERT WR PIN
008DC0  2  8D 62 03     	STA	PPIDECNTRL
008DC3  2               
008DC3  2  A9 00        	LDA	#$00
008DC5  2  8D 62 03     	STA	PPIDECNTRL		;DEASSERT ALL CONTROL PINS
008DC8  2  60           	RTS
008DC9  2               
008DC9  2               
008DC9  2               ;-----------------------------------------------------------------------------------
008DC9  2               ; PPI SETUP ROUTINE TO CONFIGURE THE APPROPRIATE PPI MODE
008DC9  2               ;
008DC9  2               ;------------------------------------------------------------------------------------
008DC9  2               
008DC9  2               SET_PPI_RD:
008DC9  2  48           	PHA
008DCA  2  A9 92        	LDA	#PPRD_IDE_8255
008DCC  2  8D 63 03     	STA	PPIDEPPIC				;CONFIG 8255 CHIP, READ MODE
008DCF  2  68           	PLA
008DD0  2  60           	RTS
008DD1  2               
008DD1  2               SET_PPI_WR:
008DD1  2  48           	PHA
008DD2  2  A9 80        	LDA	#PPWR_IDE_8255
008DD4  2  8D 63 03     	STA	PPIDEPPIC				;CONFIG 8255 CHIP, WRITE MODE
008DD7  2  68           	PLA
008DD8  2  60           	RTS
008DD9  2               
008DD9  2               ;___DEBSECR512________________________________________________________________________________________
008DD9  2               ;
008DD9  2               ;	DEBLOCK 512 BYTE SECTOR FOR DOS/65
008DD9  2               ;
008DD9  2               ;________________________________________________________________________________________________________
008DD9  2               DEBSECR512:
008DD9  2  48           	PHA
008DDA  2  AD 0E 03     	LDA	seksec			;
008DDD  2  29 03        	AND	#$03			; GET SECTOR INDEX
008DDF  2  18           	CLC				;
008DE0  2  2A           	ROL	A			;
008DE1  2  AA           	TAX				;
008DE2  2  BD FA 8D     	LDA	DEBTAB,X		;
008DE5  2  85 EE        	STA     SRC
008DE7  2  E8           	INX
008DE8  2  BD FA 8D     	LDA	DEBTAB,X		;
008DEB  2  85 EF        	STA	SRC+1			;
008DED  2  A5 F4        	LDA	dmaadr			;
008DEF  2  85 EC        	STA	DEST			;
008DF1  2  A5 F5        	LDA	dmaadr+1		;
008DF3  2  85 ED        	STA	DEST+1			;
008DF5  2  20 30 8E     	JSR	COPY_DOS_SECTOR		;
008DF8  2  68           	PLA
008DF9  2  60           	RTS
008DFA  2               
008DFA  2               DEBTAB:
008DFA  2  49 8E        	.word	hstbuf			;
008DFC  2  C9 8E        	.word	hstbuf+128		;
008DFE  2  49 8F        	.word	hstbuf+256		;
008E00  2  C9 8F        	.word	hstbuf+384		;
008E02  2               
008E02  2               
008E02  2               ;___BLKSECR512___________________________________________________________________________________________
008E02  2               ;
008E02  2               ;	BLOCK 512 SECTOR FOR DOS/65
008E02  2               ;
008E02  2               ;________________________________________________________________________________________________________
008E02  2               BLKSECR512:
008E02  2  48           	PHA
008E03  2  AD 0E 03     	LDA	seksec			;
008E06  2  29 03        	AND	#$03			; GET SECTOR INDEX
008E08  2  18           	CLC				;
008E09  2  2A           	ROL	A			;
008E0A  2  AA           	TAX				;
008E0B  2  BD FA 8D     	LDA	DEBTAB,X		;
008E0E  2  85 EC        	STA     DEST
008E10  2  E8           	INX
008E11  2  BD FA 8D     	LDA	DEBTAB,X		;
008E14  2  85 ED        	STA	DEST+1			;
008E16  2  A5 F4        	LDA	dmaadr			;
008E18  2  85 EE        	STA	SRC			;
008E1A  2  A5 F5        	LDA	dmaadr+1		;
008E1C  2  85 EF        	STA	SRC+1			;
008E1E  2  20 30 8E     	JSR	COPY_DOS_SECTOR		;
008E21  2  68           	PLA
008E22  2  60           	RTS
008E23  2               
008E23  2               ;___GET_DRIVE_DEVICE_____________________________________________________________________________________
008E23  2               ;
008E23  2               ;	GET SELECTED DEVICE TYPE AND UNIT, RETURN IN "A"
008E23  2               ;
008E23  2               ;________________________________________________________________________________________________________
008E23  2               GET_DRIVE_DEVICE:
008E23  2  DA           	PHX
008E24  2  AD 13 03     	LDA	sekdsk			; GET DRIVE
008E27  2  29 07        	AND 	#7			; ONLY FIRST 8 DEVICES SUPPORTED
008E29  2  0A           	asl	a			; DOUBLE NUMBER FOR TABLE LOOKUP
008E2A  2  AA           	TAX 				; MOVE TO X REGISTER
008E2B  2  BD 14 03     	LDA 	dskcfg,X 		; GET device
008E2E  2  FA           	PLX
008E2F  2  60           	RTS
008E30  2               
008E30  2               
008E30  2               ;___COPY_DOS_SECTOR______________________________________________________________________________________
008E30  2               ;
008E30  2               ;	COPY 128 BYTE SECTOR FOR DOS/65
008E30  2               ;
008E30  2               ;________________________________________________________________________________________________________
008E30  2               COPY_DOS_SECTOR:
008E30  2  5A           	PHY
008E31  2  A0 00        	LDY	#$00			;
008E33  2               COPY_DOS_SECTOR1:
008E33  2  B1 EE        	LDA	(SRC),Y			;
008E35  2  91 EC        	STA	(DEST),Y		;
008E37  2  C8           	INY				;
008E38  2  98           	TYA				;
008E39  2  C9 80        	CMP	#$80			;
008E3B  2  D0 F6        	BNE	COPY_DOS_SECTOR1	;
008E3D  2  7A           	PLY
008E3E  2  60           	RTS
008E3F  2               
008E3F  2               
008E3F  2               
008E3F  2               ;allocate the following data areas to unused ram space
008E3F  2  00           LASTCHAR: 	.byte 0		;save sector for warm boot
008E40  2  00           savsec:		.byte 0		;save sector for warm boot
008E41  2  00           count:		.byte 0		;counter in warm boot
008E42  2  00           temp:		.byte 0		;save hstdsk for warm boot
008E43  2  00           Cdebcyll:	.byte 0		; DEBLOCKED CYLINDER LSB
008E44  2  00           Cdebcylm:	.byte 0		; DEBLOCKED CYLINDER MSB
008E45  2  00           Cdebsehd:	.byte 0		; DEBLOCKED SECTOR AND HEAD (HS)
008E46  2  00           DEBDIRTY:	.byte 0		; DIRTY FLAG
008E47  2  00 00        slicetmp:	.word 0		; USED TO CALCULATE SLICE OFFSET
008E49  2               
008E49  2               ;deblocking buffer for dba
008E49  2  xx xx xx xx  hstbuf:		.res	512		;256 or 512 byte sectors
008E4D  2  xx xx xx xx  
008E51  2  xx xx xx xx  
009049  2               
009049  1               		.INCLUDE "dosdskyn.asm"
009049  2               ;__DSKYNG DRIVERS_________________________________________________________________________________________________________________
009049  2               ;
009049  2               ; 	Nhyodyne DSKY/NG drivers
009049  2               ;
009049  2               ;	Entry points:
009049  2               ;               DSKY_INIT
009049  2               ;               DSKY_SHOW
009049  2               ;               DSKY_BIN2SEG
009049  2               ;               DSKY_RESET
009049  2               ;               DSKY_STAT
009049  2               ;               DSKY_GETKEY
009049  2               ;               DSKY_BEEP
009049  2               ;               DSKY_L1ON
009049  2               ;               DSKY_L2ON
009049  2               ;               DSKY_L1OFF
009049  2               ;               DSKY_L2OFF
009049  2               ;               DSKY_PUTLED
009049  2               ;               DSKY_BLANK
009049  2               ;________________________________________________________________________________________________________________________________
009049  2               ;
009049  2               ;
009049  2               ; A DSKYNG CAN SHARE A PPI BUS WITH EITHER A PPIDE OR PPISD.
009049  2               ;
009049  2               ; LED SEGMENTS (BIT VALUES)
009049  2               ;
009049  2               ;	+--01--+
009049  2               ;	20    02
009049  2               ;	+--40--+
009049  2               ;	10    04
009049  2               ;	+--08--+  80
009049  2               ;
009049  2               ; KEY CODE MAP (KEY CODES) CSCCCRRR
009049  2               ;                          ||||||||
009049  2               ;                          |||||+++-- ROW
009049  2               ;                          ||+++----- COL
009049  2               ;                          |+-------- SHIFT
009049  2               ;                          +--------- CONTROL
009049  2               ;
009049  2               ;	00	08	10	18	23
009049  2               ;	01	09	11	19	22
009049  2               ;	02	0A	12	1A	21
009049  2               ;	03	0B	13	1B	20
009049  2               ;	04	0C	14	1C	SHIFT
009049  2               ;	05	0D	15	1D	CTRL
009049  2               ;
009049  2               ; LED BIT MAP (BIT VALUES)
009049  2               ;
009049  2               ;	$08	$09	$0A	$0B	$0C	$0D	$0E	$0F
009049  2               ;	---	---	---	---	---	---	---	---
009049  2               ;	01	01	01	01	01
009049  2               ;	02	02	02	02	02
009049  2               ;	04      04      04      04	04
009049  2               ;	08      08      08      08	08
009049  2               ;	10      10      10      10	10
009049  2               ;	20      20      20      20	20	L1	L2 	BUZZ
009049  2               ;
009049  2               DSKY_PPI	=	$0360		; PORT
009049  2               DSKY_PPIA	= 	DSKY_PPI + 0 	; PORT A
009049  2               DSKY_PPIB	= 	DSKY_PPI + 1 	; PORT B
009049  2               DSKY_PPIC	= 	DSKY_PPI + 2    ; PORT C
009049  2               DSKY_PPIX 	= 	DSKY_PPI + 3    ; PPI CONTROL PORT
009049  2               ;
009049  2               DSKY_PPIX_RD	=	%10010010	; PPIX VALUE FOR READS
009049  2               DSKY_PPIX_WR	=	%10000010	; PPIX VALUE FOR WRITES
009049  2               ;
009049  2               ; PIO CHANNEL C:
009049  2               ;
009049  2               ;	7	6	5	4	3	2	1	0
009049  2               ;	RES	0	0	CS	CS	/RD	/WR	A0
009049  2               ;
009049  2               ; SETTING BITS 3 & 4 WILL ASSERT /CS ON 3279
009049  2               ; CLEAR BITS 1 OR 2 TO ASSERT READ/WRITE
009049  2               ;
009049  2               DSKY_PPI_IDLE	=	%00000110
009049  2               ;
009049  2               DSKY_CMD_CLR	=	%11011111	; CLEAR (ALL OFF)
009049  2               DSKY_CMD_CLRX	=	%11010011	; CLEAR (ALL ON)
009049  2               DSKY_CMD_WDSP	=	%10010000	; WRITE DISPLAY RAM
009049  2               DSKY_CMD_RDSP	=	%01110000	; READ DISPLAY RAM
009049  2               DSKY_CMD_CLK	=	%00100000	; SET CLK PRESCALE
009049  2               DSKY_CMD_FIFO	=	%01000000	; READ FIFO
009049  2               ;
009049  2               DSKY_PRESCL	=	DSKYOSC/100000	; PRESCALER
009049  2               ;
009049  2               ;__DSKY_INIT_________________________________________________________________________________________
009049  2               ;
009049  2               ;  DISPLAY DSKY INFO
009049  2               ;____________________________________________________________________________________________________
009049  2               ;
009049  2               DSKY_INIT:
009049  2                       PRTDBG "DSKY INIT:$"
009049  2  20 05 91             JSR     DSKY_PREINIT
00904C  2  48 DA 5A A2  	PRTS "DSKY:$"
009050  2  00 BD 65 90  
009054  2  E8 C9 24 F0  
00906B  2  20 rr rr            	JSR	NEWLINE
00906E  2               
00906E  2               ;
00906E  2  48 DA 5A A2  	PRTS    " IO=0x$"
009072  2  00 BD 87 90  
009076  2  E8 C9 24 F0  
00908E  2  A9 03        	LDA	#>DSKY_PPI		; GET BASE PORT
009090  2  20 rr rr     	JSR	PRTHEXBYTE		; PRINT BASE PORT
009093  2  A9 60               	LDA	#<DSKY_PPI		; GET BASE PORT
009095  2  20 rr rr     	JSR	PRTHEXBYTE		; PRINT BASE PORT
009098  2  48 DA 5A A2  	PRTS    " MODE=$"
00909C  2  00 BD B1 90  
0090A0  2  E8 C9 24 F0  
0090B8  2  48 DA 5A A2  	PRTS    "NG$"			; PRINT DSKY TYPE
0090BC  2  00 BD D1 90  
0090C0  2  E8 C9 24 F0  
0090D4  2               ;
0090D4  2  AD 6E 93     	LDA	DSKY_PRESENT	        ; PRESENT?
0090D7  2  C9 FF        	CMP     #$FF		        ; SET FLAGS
0090D9  2  F0 26                BEQ     DSKY_INITA
0090DB  2  48 DA 5A A2  	PRTS    " NOT PRESENT$"		; NOT PRESENT
0090DF  2  00 BD F4 90  
0090E3  2  E8 C9 24 F0  
009101  2               DSKY_INITA:
009101  2  20 rr rr     	JSR	NEWLINE
009104  2  60           	RTS				; DONE
009105  2               ;
009105  2               ;__DSKY_PREINIT______________________________________________________________________________________
009105  2               ;
009105  2               ;  CONFIGURE PARALLEL PORT AND INITIALIZE 8279
009105  2               ;____________________________________________________________________________________________________
009105  2               ; HARDWARE RESET 8279 BY PULSING RESET LINE
009105  2               DSKY_PREINIT:
009105  2               	; CHECK FOR PPI
009105  2  20 4A 91     	JSR	DSKY_PPIDETECT		; TEST FOR PPI HARDWARE
009108  2  D0 2A                BNE     DSKY_ABORT      	; BAIL OUT IF NOT THERE
00910A  2               
00910A  2               	; SETUP PPI TO DEFAULT MODE
00910A  2  20 47 93     	JSR	DSKY_PPIRD
00910D  2               	; INIT 8279 VALUES TO IDLE STATE
00910D  2  A9 06        	LDA	#DSKY_PPI_IDLE
00910F  2  8D 62 03     	STA	DSKY_PPIC
009112  2               	; PULSE RESET SIGNAL ON 8279
009112  2  09 80        	ORA 	#%10000000
009114  2  8D 62 03     	STA	DSKY_PPIC
009117  2  29 7F        	AND 	#%01111111
009119  2  8D 62 03     	STA	DSKY_PPIC
00911C  2               	; INITIALIZE 8279
00911C  2  20 35 91     	JSR	DSKY_REINIT
00911F  2               	; NOW SEE IF A DSKYNG IS REALLY THERE...
00911F  2  A9 A5        	LDA     #$A5
009121  2  A0 00                LDY     #$00
009123  2  20 86 92     	JSR	DSKY_PUTBYTE
009126  2  A0 00                LDY     #$00
009128  2  20 9A 92     	JSR	DSKY_GETBYTE
00912B  2  C9 A5        	CMP	#$A5
00912D  2  D0 05        	BNE     DSKY_ABORT			; BAIL OUT IF MISCOMPARE
00912F  2  A9 FF        	LDA	#$FF
009131  2  8D 6E 93     	STA	DSKY_PRESENT
009134  2               DSKY_ABORT:
009134  2  60           	RTS
009135  2               ;
009135  2               DSKY_REINIT:
009135  2  20 59 93     	JSR	DSKY_PPIIDLE
009138  2               	; SET CLOCK SCALER TO 20
009138  2  A9 21        	LDA	#DSKY_CMD_CLK | DSKY_PRESCL
00913A  2  20 06 92     	JSR	DSKY_CMD
00913D  2               	; FALL THRU
00913D  2               ;
00913D  2               DSKY_RESET:
00913D  2               	; RESET DSKY -- CLEAR RAM AND FIFO
00913D  2  A9 DF        	LDA	#DSKY_CMD_CLR
00913F  2  20 06 92     	JSR	DSKY_CMD
009142  2               ;
009142  2               	; 8259 TAKES ~160US TO CLEAR RAM DURING WHICH TIME WRITES TO
009142  2               	; DISPLAY RAM ARE INHIBITED.  HIGH BIT OF STATUS BYTE IS SET
009142  2               	; DURING THIS WINDOW.  TO PREVENT A DEADLOCK, A LOOP COUNTER
009142  2               	; IS USED TO IMPLEMENT A TIMEOUT.
009142  2  A2 00        	LDX	#0			; TIMEOUT LOOP COUNTER
009144  2               DSKY_RESET1:
009144  2  DA           	PHX     			; SAVE COUNTER
009145  2               	;JSR	DSKY_ST			; GET STATUS BYTE
009145  2  FA           	PLX				; RECOVER COUNTER
009146  2                     ;  AND     #%10000000
009146  2                     ;  BEQ     DSKY_RESET2		; MOVE ON IF DONE
009146  2  CA                   DEX
009147  2  D0 FB                BNE     DSKY_RESET1		; LOOP TILL TIMEOUT
009149  2               ;
009149  2               DSKY_RESET2:
009149  2  60           	RTS
00914A  2               ;
00914A  2               ;
00914A  2               ;
00914A  2               ;__DSKY_PPIDETECT____________________________________________________________________________________
00914A  2               ;
00914A  2               ;  PROBE FOR PPI HARDWARE
00914A  2               ;____________________________________________________________________________________________________
00914A  2               ;
00914A  2               DSKY_PPIDETECT:
00914A  2               ;
00914A  2               	; TEST FOR PPI EXISTENCE
00914A  2               	; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
00914A  2               	; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
00914A  2               	; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
00914A  2               	; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
00914A  2               	; INTERFERE WITH THE VALUE BEING READ.
00914A  2  20 30 93     	JSR	DSKY_PPIWR
00914D  2               ;
00914D  2  A9 00        	LDA     #$00			; VALUE ZERO
00914F  2  8D 60 03     	STA	DSKY_PPIA		; PUSH VALUE TO PORT
009152  2  AD 60 03     	LDA	DSKY_PPIA		; GET PORT VALUE
009155  2  C9 00                CMP     #$00
009157  2  60           	RTS				; AND RETURN
009158  2               ;
009158  2                .IF DSKY_KBD=1
009158  2               ;
009158  2               KY_0	=	$00
009158  2               KY_1	=	$01
009158  2               KY_2	=	$02
009158  2               KY_3	=	$03
009158  2               KY_4	=	$04
009158  2               KY_5	=	$05
009158  2               KY_6	=	$06
009158  2               KY_7	=	$07
009158  2               KY_8	=	$08
009158  2               KY_9	=	$09
009158  2               KY_A	=	$0A
009158  2               KY_B	=	$0B
009158  2               KY_C	=	$0C
009158  2               KY_D	=	$0D
009158  2               KY_E	=	$0E
009158  2               KY_F	=	$0F
009158  2               KY_FW	=	$10	; FORWARD
009158  2               KY_BK	=	$11	; BACKWARD
009158  2               KY_CL	=	$12	; CLEAR
009158  2               KY_EN	=	$13	; ENTER
009158  2               KY_DE	=	$14	; DEPOSIT
009158  2               KY_EX	=	$15	; EXAMINE
009158  2               KY_GO	=	$16	; GO
009158  2               KY_BO	=	$17	; BOOT
009158  2               KY_F4	=	$18	; F4
009158  2               KY_F3	=	$19	; F3
009158  2               KY_F2	=	$20	; F2
009158  2               KY_F1	=	$21	; F1
009158  2               ;
009158  2               ;__DSKY_STAT_________________________________________________________________________________________
009158  2               ;
009158  2               ;  CHECK FOR KEY PRESS, SAVE RAW VALUE, RETURN STATUS
009158  2               ;____________________________________________________________________________________________________
009158  2               ;
009158  2               DSKY_STAT:
009158  2  AD 6E 93     	LDA	DSKY_PRESENT            ; DOES IT EXIST?
00915B  2  C9 FF        	CMP     #$FF			; SET FLAGS
00915D  2  D0 05                BNE     DSKY_STATA		; ABORT WITH A=0 IF NOT THERE
00915F  2  20 3F 92     	JSR	DSKY_ST
009162  2  29 0F        	AND	#$0F			; ISOLATE THE CUR FIFO LEN
009164  2               DSKY_STATA:
009164  2  60           	RTS
009165  2               ;
009165  2               ;__DSKY_GETKEY_____________________________________________________________________________________
009165  2               ;
009165  2               ;  WAIT FOR A DSKY KEYPRESS AND RETURN
009165  2               ;____________________________________________________________________________________________________
009165  2               ;
009165  2               DSKY_GETKEY:
009165  2  AD 6E 93     	LDA	DSKY_PRESENT    	; DOES IT EXIST?
009168  2  C9 FF               	CMP     #$FF			; SET FLAGS
00916A  2  D0 24                BNE     DSKY_GETKEY1A		; ABORT WITH A=0 IF NOT THERE
00916C  2  20 58 91     	JSR	DSKY_STAT
00916F  2  F0 F4                BEQ     DSKY_GETKEY		; LOOP IF NOTHING THERE
009171  2  A9 40        	LDA	#DSKY_CMD_FIFO
009173  2  20 06 92     	JSR	DSKY_CMD
009176  2  20 44 92     	JSR	DSKY_DIN
009179  2  49 C0        	EOR	#%11000000		; FLIP POLARITY OF SHIFT/CTL BITS
00917B  2  48                   PHA
00917C  2  29 3F        	AND	#$3F			; STRIP SHIFT/CTL BITS FOR LOOKUP
00917E  2  8D 6C 93     	STA     DSKY_TEMP_VAL
009181  2  A2 00        	LDX	#0			; INDEX
009183  2               DSKY_GETKEY1:
009183  2  BD 9F 91             LDA     DSKY_KEYMAP,X
009186  2  CD 6C 93     	CMP	DSKY_TEMP_VAL		; MATCH?
009189  2  F0 09                BEQ     DSKY_GETKEY2		; FOUND, DONE
00918B  2  E8           	INX
00918C  2  E0 1C                CPX     #28
00918E  2  D0 F3                BNE	DSKY_GETKEY1		; LOOP UNTIL EOT
009190  2               DSKY_GETKEY1A:
009190  2  68                   PLA
009191  2  A9 FF        	LDA	#$FF			; NOT FOUND ERR, RETURN $FF
009193  2  60           	RTS
009194  2               DSKY_GETKEY2:
009194  2               	; RETURN THE INDEX POSITION WHERE THE SCAN CODE WAS FOUND
009194  2               	; THE ORIGINAL SHIFT/CTRL BITS ARE RESTORED
009194  2  68           	PLA				; RESTORE RAW VALUE
009195  2  25 C0        	AND	%11000000		; ISOLATE SHIFT/CTRL BITS
009197  2  8D 6C 93             STA     DSKY_TEMP_VAL
00919A  2  8A                   TXA
00919B  2  0D 6C 93     	ORA	DSKY_TEMP_VAL		; COMBINE WITH INDEX VALUE
00919E  2  60           	RTS
00919F  2               ;
00919F  2               ;_KEYMAP_TABLE_____________________________________________________________________________________________________________
00919F  2               ;
00919F  2               DSKY_KEYMAP:
00919F  2               	; POS	$00  $01  $02  $03  $04  $05  $06  $07
00919F  2               	; KEY   [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]
00919F  2  0D 04 0C 14  	.BYTE	$0D, $04, $0C, $14, $03, $0B, $13, $02
0091A3  2  03 0B 13 02  
0091A7  2               ;
0091A7  2               	; POS	$08  $09  $0A  $0B  $0C  $0D  $0E  $0F
0091A7  2               	; KEY   [8]  [9]  [A]  [B]  [C]  [D]  [E]  [F]
0091A7  2  0A 12 01 09  	.BYTE	$0A, $12, $01, $09, $11, $00, $08, $10
0091AB  2  11 00 08 10  
0091AF  2               ;
0091AF  2               	; POS	$10  $11  $12  $13  $14  $15  $16  $17
0091AF  2               	; KEY   [FW] [BK] [CL] [EN] [DE] [EX] [GO] [BO]
0091AF  2  05 15 1D 1C  	.BYTE	$05, $15, $1D, $1C, $1B, $1A, $19, $18
0091B3  2  1B 1A 19 18  
0091B7  2               
0091B7  2               	; POS	$18  $19  $20  $21
0091B7  2               	; KEY   [F4] [F3] [F2] [F1]
0091B7  2  23 22 21 20  	.BYTE	$23, $22, $21, $20
0091BB  2               
0091BB  2               ;
0091BB  2                       .ENDIF	; DSKY_KBD
0091BB  2               ;
0091BB  2               ;__DSKY_BIN2SEG________________________________________________________________________________________
0091BB  2               ;
0091BB  2               ; CONVERT 32 BIT BINARY TO 8 BYTE HEX SEGMENT DISPLAY
0091BB  2               ;
0091BB  2               ; DSKY_BUF: 32 BIT BINARY
0091BB  2               ; DSKY_HEXBUF: DEST LED SEGMENT DISPLAY BUFFER (8 BYTES)
0091BB  2               ;____________________________________________________________________________________________________
0091BB  2               ;
0091BB  2               DSKY_BIN2SEG:
0091BB  2  A2 00        	LDX	#$00
0091BD  2               DSKY_BIN2SEG1:
0091BD  2  BD 08 03     	LDA	DSKY_HEXBUF,X			; FIRST NIBBLE
0091C0  2  4A           	LSR	A
0091C1  2  4A                   LSR	A
0091C2  2  4A                   LSR	A
0091C3  2  4A                   LSR	A
0091C4  2  DA           	PHX                                     ; STORE READ INDEX
0091C5  2  AA                   TAX					; MOVE DIGIT TO LOOKUP INDEX
0091C6  2  BD 5C 93     	LDA	DSKY_HEXMAP,X                   ; GET DECODED DIGIT INTO A
0091C9  2  FA           	PLX                                     ; GET READ INDEX
0091CA  2  DA           	PHX
0091CB  2  48           	PHA
0091CC  2  8A           	TXA
0091CD  2  0A           	asl	a
0091CE  2  AA           	TAX
0091CF  2  68           	PLA
0091D0  2  9D 00 03             STA     DSKY_BUF,X    		        ;STORE HIGH BYTE IN OUT BUFFER
0091D3  2  FA           	PLX
0091D4  2  BD 08 03     	LDA	DSKY_HEXBUF,X			; SECOND NIBBLE
0091D7  2               
0091D7  2  29 0F        	AND	#$0F
0091D9  2  DA                   PHX
0091DA  2  AA                   TAX
0091DB  2  BD 5C 93     	LDA	DSKY_HEXMAP,X                   ; GET DECODED DIGIT INTO A
0091DE  2  FA           	PLX
0091DF  2  DA           	PHX
0091E0  2  48           	PHA
0091E1  2  8A           	TXA		                        ; GET READ INDEX
0091E2  2  0A           	asl	a
0091E3  2  AA           	TAX
0091E4  2  E8           	INX
0091E5  2  68           	PLA
0091E6  2  9D 00 03             STA     DSKY_BUF,X	                ;STORE HIGH BYTE IN OUT BUFFER
0091E9  2  FA           	PLX
0091EA  2  E8                   INX
0091EB  2  E0 04                CPX     #4
0091ED  2  D0 CE                BNE     DSKY_BIN2SEG1
0091EF  2  60           	RTS
0091F0  2               ;
0091F0  2               ;__DSKY_SHOW___________________________________________________________________________________________
0091F0  2               ; DSKY SHOW BUFFER
0091F0  2               ;______________________________________________________________________________________________________
0091F0  2               ;
0091F0  2               DSKY_SHOW:
0091F0  2  48                   PHA
0091F1  2  DA                   PHX
0091F2  2  5A                   PHY
0091F3  2  A2 00                LDX     #0
0091F5  2               DSKY_SHOW1:
0091F5  2  BD 00 03     	LDA     DSKY_BUF,X
0091F8  2  DA                   PHX
0091F9  2  7A                   PLY
0091FA  2  20 86 92     	JSR	DSKY_PUTBYTE
0091FD  2  E8           	INX
0091FE  2  E0 08                CPX     #8
009200  2  D0 F3                BNE     DSKY_SHOW1
009202  2  7A                   PLY
009203  2  FA                   PLX
009204  2  68                   PLA
009205  2  60           	RTS
009206  2               
009206  2               ;______________________________________________________________________________________________________
009206  2               ; DSKYNG OUTPUT ROUTINES
009206  2               ;______________________________________________________________________________________________________
009206  2               
009206  2               ; SEND DSKY COMMAND BYTE IN REGISTER A
009206  2               DSKY_CMD:
009206  2  48                   PHA
009207  2  A9 01        	LDA	#$01
009209  2  4C 0F 92     	JMP	DSKY_DOUT2
00920C  2               ;
00920C  2               ; SEND DSKY DATA BYTE IN REGISTER A
00920C  2               ; TRASHES BC
00920C  2               ;
00920C  2               DSKY_DOUT:
00920C  2  48                   PHA
00920D  2  A9 00        	LDA	#$00
00920F  2               ;
00920F  2               DSKY_DOUT2:
00920F  2               	; SET PPI LINE CONFIG TO WRITE MODE
00920F  2  20 30 93     	JSR	DSKY_PPIWR
009212  2               ;
009212  2               	; SET ADDRESS FIRST
009212  2  09 06                ORA     #DSKY_PPI_IDLE
009214  2  8D 62 03     	STA	DSKY_PPIC
009217  2               ;
009217  2               	; ASSERT 8279 /CS
009217  2  09 18        	ORA     #%00011000
009219  2  8D 62 03     	STA	DSKY_PPIC
00921C  2               ;
00921C  2               	; PPIC WORKING VALUE TO DSKY_TEMP_VAL
00921C  2  8D 6C 93     	STA     DSKY_TEMP_VAL
00921F  2               ;
00921F  2               	; ASSERT DATA BYTE VALUE
00921F  2  68                   PLA
009220  2  8D 60 03     	STA	DSKY_PPIA
009223  2               ;
009223  2               	; PULSE /WR
009223  2  AD 6C 93             LDA     DSKY_TEMP_VAL
009226  2  29 FD                AND     #%11111101
009228  2  8D 62 03     	STA	DSKY_PPIC
00922B  2  EA           	NOP			; MAY NOT BE NEEDED
00922C  2  09 02                ORA     #%00000010
00922E  2  8D 62 03     	STA	DSKY_PPIC
009231  2               ;
009231  2               	; DEASSERT /CS
009231  2  29 E7                AND     #%11100111
009233  2  8D 62 03     	STA	DSKY_PPIC
009236  2               ;
009236  2               	; CLEAR ADDRESS BIT
009236  2  29 E6                AND     #%11100110
009238  2  8D 62 03     	STA	DSKY_PPIC
00923B  2               ;
00923B  2               	; DONE
00923B  2  20 59 93     	JSR	DSKY_PPIIDLE
00923E  2  60           	RTS
00923F  2               ;
00923F  2               ;==================================================================================================
00923F  2               ; DSKYNG OUTPUT ROUTINES
00923F  2               ;==================================================================================================
00923F  2               ;
00923F  2               ; RETURN DSKY STATUS VALUE IN A
00923F  2               ;
00923F  2               DSKY_ST:
00923F  2  A9 01        	LDA	#$01
009241  2  4C 46 92     	JMP	DSKY_DIN2
009244  2               ;
009244  2               ; RETURN NEXT DATA VALUE IN A
009244  2               ;
009244  2               DSKY_DIN:
009244  2  A9 00        	LDA	#$00
009246  2               ;
009246  2               DSKY_DIN2:
009246  2               	; SET PPI LINE CONFIG TO READ MODE
009246  2  20 47 93     	JSR	DSKY_PPIRD
009249  2               ;
009249  2               	; SET ADDRESS FIRST
009249  2  09 06        	ORA	#DSKY_PPI_IDLE
00924B  2  8D 62 03     	STA	DSKY_PPIC
00924E  2               ;
00924E  2               	; ASSERT 8279 /CS
00924E  2  09 18        	ORA     #%00011000
009250  2  8D 62 03     	STA	DSKY_PPIC
009253  2               ;
009253  2               	; ASSERT /RD
009253  2  29 7B        	AND     #%01111011
009255  2  8D 62 03     	STA	DSKY_PPIC
009258  2               ;
009258  2  8D 6C 93     	STA 	DSKY_TEMP_VAL
00925B  2               	; GET VALUE
00925B  2  AD 60 03     	LDA	DSKY_PPIA
00925E  2  48                   PHA
00925F  2               
00925F  2  AD 6C 93     	LDA 	DSKY_TEMP_VAL
009262  2               	; DEASSERT /RD
009262  2  09 04        	ORA     #%00000100
009264  2  8D 62 03     	STA	DSKY_PPIC
009267  2               ;
009267  2               	; DEASSERT /CS
009267  2  29 E7                AND     #%11100111
009269  2  8D 62 03     	STA	DSKY_PPIC
00926C  2               ;
00926C  2               	; CLEAR ADDRESS BIT
00926C  2  29 E6                AND     #%11100110
00926E  2  8D 62 03     	STA	DSKY_PPIC
009271  2               ;
009271  2               	; DONE
009271  2  20 59 93     	JSR	DSKY_PPIIDLE
009274  2  68                   PLA
009275  2  60           	RTS
009276  2               
009276  2               ;__DSKY_BLANK_____________________________________________________________________________________
009276  2               ;
009276  2               ; BLANK DSKYNG DISPLAY  (WITHOUT USING CLEAR)
009276  2               ;
009276  2               ;_________________________________________________________________________________________________
009276  2               ;
009276  2               DSKY_BLANK:
009276  2  A9 90        	LDA	#DSKY_CMD_WDSP
009278  2  20 06 92     	JSR	DSKY_CMD
00927B  2  A2 10        	LDX	#16
00927D  2               DSKY_BLANK1:
00927D  2  A9 FF        	LDA	#$FF
00927F  2  20 0C 92     	JSR	DSKY_DOUT
009282  2  CA                   DEX
009283  2  D0 F8        	BNE	DSKY_BLANK1
009285  2  60           	RTS
009286  2               ;
009286  2               ;__DSKY_PUTBYTE____________________________________________________________________________________
009286  2               ;
009286  2               ; WRITE A RAW BYTE VALUE TO DSKY DISPLAY RAM
009286  2               ; AT LOCATION IN REGISTER Y, VALUE IN A.
009286  2               ;
009286  2               ;__________________________________________________________________________________________________
009286  2               ;
009286  2               DSKY_PUTBYTE:
009286  2  5A                   PHY
009287  2  48                   PHA
009288  2  48                   PHA
009289  2  18           	CLC
00928A  2  98                   TYA
00928B  2  69 90        	ADC	#DSKY_CMD_WDSP
00928D  2  A8                   TAY
00928E  2  20 06 92     	JSR	DSKY_CMD
009291  2  68                   PLA
009292  2  49 FF        	EOR	#$FF
009294  2  20 0C 92     	JSR	DSKY_DOUT
009297  2  68                   PLA
009298  2  7A                   PLY
009299  2  60           	RTS
00929A  2               ;
00929A  2               ;__DSKY_GETBYTE___________________________________________________________________________________
00929A  2               ; READ A RAW BYTE VALUE FROM DSKY DISPLAY RAM
00929A  2               ; AT LOCATION IN REGISTER Y, VALUE RETURNED IN A
00929A  2               ;
00929A  2               ;_________________________________________________________________________________________________
00929A  2               ;
00929A  2               DSKY_GETBYTE:
00929A  2  18           	CLC
00929B  2  98                   TYA
00929C  2  69 70        	ADC	#DSKY_CMD_RDSP
00929E  2  A8                   TAY
00929F  2  20 06 92     	JSR	DSKY_CMD
0092A2  2  20 44 92     	JSR	DSKY_DIN
0092A5  2  49 FF        	EOR	#$FF
0092A7  2  60           	RTS
0092A8  2               
0092A8  2               ;
0092A8  2               ;__DSKY_PUTLED____________________________________________________________________________________
0092A8  2               ;
0092A8  2               ;	This function is intended to update the LEDs.
0092A8  2               ;	VALUES SHOULD BE IN DSKY_BUF
0092A8  2               ;_________________________________________________________________________________________________
0092A8  2               ;
0092A8  2               DSKY_PUTLED:
0092A8  2  DA           	PHX
0092A9  2  5A           	PHY
0092AA  2  48           	PHA
0092AB  2  A0 00        	LDY 	#$00
0092AD  2  A2 00        	LDX 	#$00
0092AF  2               DSKY_PUTLED_1:
0092AF  2  BD 00 03             LDA     DSKY_BUF,X              ; GET BYTE
0092B2  2  20 86 92     	JSR	DSKY_PUTBYTE            ; SEND IT TO DSKY
0092B5  2  C8                   INY                             ; LOOP TIL DONE
0092B6  2  E8           	INX
0092B7  2  C0 08                CPY     #8
0092B9  2  D0 F4                BNE     DSKY_PUTLED_1
0092BB  2  68                   PLA                             ; RESTORE REGISTERS
0092BC  2  7A                   PLY
0092BD  2  FA                   PLX
0092BE  2  60           	RTS
0092BF  2               ;
0092BF  2               ;__DSKY_BEEP______________________________________________________________________________________
0092BF  2               ;	This function is intended to beep the speaker on the DSKY
0092BF  2               ;_________________________________________________________________________________________________
0092BF  2               ;
0092BF  2               DSKY_BEEP:
0092BF  2  5A           	PHY
0092C0  2  DA                   PHX
0092C1  2  48           	PHA
0092C2  2  A0 0F        	LDY 	#$0F
0092C4  2  20 9A 92     	JSR	DSKY_GETBYTE
0092C7  2  09 20        	ORA 	#$20
0092C9  2  A9 20        			LDA 	#$20
0092CB  2  A0 0F        	LDY	#$0F
0092CD  2  20 86 92     	JSR	DSKY_PUTBYTE
0092D0  2               
0092D0  2               ;;; 	timer . . .
0092D0  2  A2 8F        	LDX 	#$8F
0092D2  2  A0 FF                LDY     #$FF
0092D4  2               DSKY_BEEP1:
0092D4  2  88                   DEY
0092D5  2  D0 FD                BNE     DSKY_BEEP1
0092D7  2  CA                   DEX
0092D8  2  D0 FA                BNE     DSKY_BEEP1
0092DA  2               
0092DA  2  A0 0F        	LDY 	#$0F
0092DC  2  20 9A 92     	JSR	DSKY_GETBYTE
0092DF  2  29 DF        	AND 	#$DF
0092E1  2  A9 DF        			LDA 	#$DF
0092E3  2  A0 0F        	LDY	#$0F
0092E5  2  20 86 92     	JSR	DSKY_PUTBYTE
0092E8  2               
0092E8  2  68                   PLA
0092E9  2  FA                   PLX
0092EA  2  7A                   PLY
0092EB  2  60           	RTS
0092EC  2               ;
0092EC  2               ;__DSKY_L1ON______________________________________________________________________________________
0092EC  2               ;	This function is intended to turn on DSKY L1
0092EC  2               ;_________________________________________________________________________________________________
0092EC  2               ;
0092EC  2               DSKY_L1ON:
0092EC  2  5A           	PHY
0092ED  2  48           	PHA
0092EE  2  A0 0D        	LDY 	#$0D
0092F0  2  20 9A 92     	JSR	DSKY_GETBYTE
0092F3  2  09 20        	ORA 	#$20
0092F5  2  A0 0D        	LDY	#$0D
0092F7  2  20 86 92     	JSR	DSKY_PUTBYTE
0092FA  2  68           	PLA
0092FB  2  7A                   PLY
0092FC  2  60           	RTS
0092FD  2               ;
0092FD  2               ;__DSKY_L2ON______________________________________________________________________________________
0092FD  2               ;	This function is intended to turn on DSKY L2
0092FD  2               ;_________________________________________________________________________________________________
0092FD  2               ;
0092FD  2               DSKY_L2ON:
0092FD  2  5A           	PHY
0092FE  2  48           	PHA
0092FF  2  A0 0E        	LDY 	#$0E
009301  2  20 9A 92     	JSR	DSKY_GETBYTE
009304  2  09 20        	ORA 	#$20
009306  2  A0 0E        	LDY	#$0E
009308  2  20 86 92     	JSR	DSKY_PUTBYTE
00930B  2  68           	PLA
00930C  2  7A                   PLY
00930D  2  60           	RTS
00930E  2               ;
00930E  2               ;__DSKY_L1OFF_____________________________________________________________________________________
00930E  2               ;	This function is intended to turn off DSKY L1
00930E  2               ;_________________________________________________________________________________________________
00930E  2               ;
00930E  2               DSKY_L1OFF:
00930E  2  5A           	PHY
00930F  2  48           	PHA
009310  2  A0 0D        	LDY 	#$0D
009312  2  20 9A 92     	JSR	DSKY_GETBYTE
009315  2  29 DF        	AND 	#$DF
009317  2  A0 0D        	LDY	#$0D
009319  2  20 86 92     	JSR	DSKY_PUTBYTE
00931C  2  68           	PLA
00931D  2  7A                   PLY
00931E  2  60           	RTS
00931F  2               ;
00931F  2               ;__DSKY_L2OFF_____________________________________________________________________________________
00931F  2               ;	This function is intended to turn off DSKY L2
00931F  2               ;_________________________________________________________________________________________________
00931F  2               ;
00931F  2               DSKY_L2OFF:
00931F  2  5A           	PHY
009320  2  48           	PHA
009321  2  A0 0E        	LDY 	#$0E
009323  2  20 9A 92     	JSR	DSKY_GETBYTE
009326  2  29 DF        	AND 	#$DF
009328  2  A0 0E        	LDY	#$0E
00932A  2  20 86 92     	JSR	DSKY_PUTBYTE
00932D  2  68           	PLA
00932E  2  7A                   PLY
00932F  2  60           	RTS
009330  2               ;
009330  2               ;_________________________________________________________________________________________________
009330  2               ; DSKYNG LINE CONTROL ROUTINES
009330  2               ;
009330  2               ; SETUP PPI FOR WRITING: PUT PPI PORT A IN OUTPUT MODE
009330  2               ; AVOID REWRTING PPIX IF ALREADY IN OUTPUT MODE
009330  2               ;
009330  2               ;_________________________________________________________________________________________________
009330  2               ;
009330  2               DSKY_PPIWR:
009330  2  48           	PHA
009331  2               ;
009331  2               	; CHECK FOR WRITE MODE
009331  2  AD 6D 93     	LDA     DSKY_PPIX_VAL
009334  2  C9 82        	CMP	#DSKY_PPIX_WR
009336  2  F0 0D        	BEQ	DSKY_PPIWR1
009338  2               ;
009338  2               	; SET PPI TO WRITE MODE
009338  2  A9 82        	LDA	#DSKY_PPIX_WR
00933A  2  8D 63 03     	STA	DSKY_PPIX
00933D  2  8D 6D 93     	STA	DSKY_PPIX_VAL
009340  2               ;
009340  2               	; RESTORE PORT C (MAY NOT BE NEEDED)
009340  2  A9 06        	LDA     #DSKY_PPI_IDLE
009342  2  8D 62 03     	STA	DSKY_PPIC
009345  2               ;
009345  2               DSKY_PPIWR1:
009345  2               ;
009345  2  68           	PLA
009346  2  60           	RTS
009347  2               ;
009347  2               ; SETUP PPI FOR READING: PUT PPI PORT A IN INPUT MODE
009347  2               ; AVOID REWRTING PPIX IF ALREADY IN INPUT MODE
009347  2               ;
009347  2               DSKY_PPIRD:
009347  2  48           	PHA
009348  2               ;
009348  2               	; CHECK FOR READ MODE
009348  2  AD 6D 93     	LDA	DSKY_PPIX_VAL
00934B  2  C9 92        	CMP	#DSKY_PPIX_RD
00934D  2  F0 08        	BEQ	DSKY_PPIRD1
00934F  2               ;
00934F  2               	; SET PPI TO READ MODE
00934F  2  A9 92        	LDA	#DSKY_PPIX_RD
009351  2  8D 63 03     	STA	DSKY_PPIX
009354  2  8D 6D 93     	STA	DSKY_PPIX_VAL
009357  2               ;
009357  2               DSKY_PPIRD1:
009357  2  68           	PLA
009358  2  60           	RTS
009359  2               ;
009359  2               ; RELEASE USE OF PPI
009359  2               ;
009359  2               DSKY_PPIIDLE:
009359  2  4C 47 93     	JMP	DSKY_PPIRD		; SAME AS READ MODE
00935C  2               ;
00935C  2               ;__STORAGE_________________________________________________________________________________________
00935C  2               ; CODES FOR NUMERICS
00935C  2               ; HIGH BIT ALWAYS CLEAR TO SUPPRESS DECIMAL POINT
00935C  2               ; SET HIGH BIT TO SHOW DECIMAL POINT
00935C  2               ;_________________________________________________________________________________________________
00935C  2               ;
00935C  2               DSKY_HEXMAP:
00935C  2  3F           	.BYTE	$3F	; 0
00935D  2  06           	.BYTE	$06	; 1
00935E  2  5B           	.BYTE	$5B	; 2
00935F  2  4F           	.BYTE	$4F	; 3
009360  2  66           	.BYTE	$66	; 4
009361  2  6D           	.BYTE	$6D	; 5
009362  2  7D           	.BYTE	$7D	; 6
009363  2  07           	.BYTE	$07	; 7
009364  2  7F           	.BYTE	$7F	; 8
009365  2  67           	.BYTE	$67	; 9
009366  2  77           	.BYTE	$77	; A
009367  2  7C           	.BYTE	$7C	; B
009368  2  39           	.BYTE	$39	; C
009369  2  5E           	.BYTE	$5E	; D
00936A  2  79           	.BYTE	$79	; E
00936B  2  71           	.BYTE	$71	; F
00936C  2               ;
00936C  2  00           DSKY_TEMP_VAL:	.BYTE	0
00936D  2  00           DSKY_PPIX_VAL:	.BYTE	0
00936E  2  00           DSKY_PRESENT:	.BYTE	0
00936F  2               
00936F  1               		.INCLUDE "dosmd.asm"
00936F  2               ;__MD DRIVERS____________________________________________________________________________________________________________________
00936F  2               ;
00936F  2               ; 	Nhyodyne Memory disk drivers
00936F  2               ;
00936F  2               ;	Entry points:
00936F  2               ;		MD_SHOW         - called during OS init
00936F  2               ;		MD_READ_SECTOR  - read a sector from drive
00936F  2               ;		MD_WRITE_SECTOR - write a sector to drive
00936F  2               ;________________________________________________________________________________________________________________________________
00936F  2               ;
00936F  2               ; RAM BANK $0C is RAM area for Drivers
00936F  2               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
00936F  2               ; RAM BANK $0F is fixed bank $0000-$7FFF
00936F  2               ;
00936F  2               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
00936F  2               ;
00936F  2               ; ROM MEMORY PAGE CONFIGURATION LATCH CONTROL PORT
00936F  2               ;       A15 IS INVERTED FOR THE NYHODYNE 65C02 CPU . . .
00936F  2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
00936F  2               ;	^ ^ ^ ^  ^ ^ ^ ^
00936F  2               ;	: : : :  : : : :--0 = A15 ROM ONLY ADDRESS LINE DEFAULT IS 0
00936F  2               ;	: : : :  : : :----0 = A16 ROM ONLY ADDRESS LINE DEFAULT IS 0
00936F  2               ;	: : : :  : :------0 = A17 ROM ONLY ADDRESS LINE DEFAULT IS 0
00936F  2               ;	: : : :  :--------0 = A18 ROM ONLY ADDRESS LINE DEFAULT IS 0
00936F  2               ;	: : : :-----------0 = A19 ROM ONLY ADDRESS LINE DEFAULT IS 0
00936F  2               ;	: : :-------------0 = A20 ROM ONLY ADDRESS LINE DEFAULT IS 0
00936F  2               ;	: :---------------0 = ROM BOOT OVERRIDE DEFAULT IS 0
00936F  2               ;	:-----------------0 = LOWER PAGE ROM SELECT (0=ROM, 1=NOTHING) DEFAULT IS 0
00936F  2               ;
00936F  2               ; RAM PAGE CONFIGURATION LATCH CONTROL PORT
00936F  2               ;
00936F  2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
00936F  2               ;	^ ^ ^ ^  ^ ^ ^ ^
00936F  2               ;	: : : :  : : : :--0 = A15 RAM ONLY ADDRESS LINE DEFAULT IS 0
00936F  2               ;	: : : :  : : :----0 = A16 RAM ONLY ADDRESS LINE DEFAULT IS 0
00936F  2               ;	: : : :  : :------0 = A17 RAM ONLY ADDRESS LINE DEFAULT IS 0
00936F  2               ;	: : : :  :--------0 = A18 RAM ONLY ADDRESS LINE DEFAULT IS 0
00936F  2               ;	: : : :-----------0 = A19 RAM ONLY ADDRESS LINE DEFAULT IS 0
00936F  2               ;	: : :-------------0 = UNDEFINED DEFAULT IS 0
00936F  2               ;	: :---------------0 = RAM BOOT OVERRIDE DEFAULT IS 0
00936F  2               ;	:-----------------0 = LOWER PAGE RAM SELECT (0=NOTHING, 1=RAM) DEFAULT IS 0;
00936F  2               
00936F  2               
00936F  2               ;__MD_SHOW___________________________________________________________________________________________
00936F  2               ;
00936F  2               ;  Display info on MD devices
00936F  2               ;____________________________________________________________________________________________________
00936F  2               ;
00936F  2               MD_SHOW:
00936F  2                       PRTDBG "MD INIT:$"
00936F  2  48 DA 5A A2          PRTS "MD: UNITS=2 RAMDISK=256KB ROMDISK=384KB$"
009373  2  00 BD 88 93  
009377  2  E8 C9 24 F0  
0093B0  2  20 rr rr            	JSR	NEWLINE
0093B3  2  60                   rts
0093B4  2               
0093B4  2               ;*__MD_READ_SECTOR____________________________________________________________________________________
0093B4  2               ;*
0093B4  2               ;*  READ MD SECTOR INTO BUFFER
0093B4  2               ;*
0093B4  2               ;*____________________________________________________________________________________________________
0093B4  2               MD_READ_SECTOR:
0093B4  2  20 BD 93                     JSR MD_READ_RAW_SECTOR
0093B7  2  20 4E 94                     JSR DEBSECR256
0093BA  2  A9 00                        LDA #$00                        ; SHOULD ALWAYS SUCCEED
0093BC  2  60                           RTS
0093BD  2               
0093BD  2               MD_READ_RAW_SECTOR:
0093BD  2               		PRTDBG "MD Read Sector$"
0093BD  2  20 23 8E                     JSR     GET_DRIVE_DEVICE
0093C0  2  29 01        		and 	#$01			; only want drive cfg
0093C2  2  0A           		asl	a			; SHIFT 6
0093C3  2  0A           		asl	a			;
0093C4  2  0A           		asl	a			;
0093C5  2  0A              		asl	a			;
0093C6  2  0A           		asl	a			;
0093C7  2  0A           		asl	a			;
0093C8  2  29 7F        		AND 	#%01111111              ; TOGGLE READ
0093CA  2  AA                           TAX                             ; STASH CONTROL WORD
0093CB  2  20 0B 94                     JSR     MD_CONVERT_SECTOR
0093CE  2  E0 00                        cpx     #$00                    ; read if ram
0093D0  2  F0 0C                        BEQ     :+
0093D2  2  EE 10 03                     inc     debcyll                 ; if rom, inc bank by 4 ()
0093D5  2  EE 10 03                     inc     debcyll
0093D8  2  EE 10 03                     inc     debcyll
0093DB  2  EE 10 03                     inc     debcyll
0093DE  2               :
0093DE  2  AD 10 03       	        LDA    	debcyll			; GET BANK
0093E1  2  AC 12 03     		LDY    	debsehd			; GET PAGE
0093E4  2                               PRTDBG "DO PAGER$"
0093E4  2  20 00 02                     JSR     MD_PAGERA
0093E7  2                               PRTDBG "PAGER RETURN$"
0093E7  2  60           		RTS
0093E8  2               
0093E8  2               
0093E8  2               ;*__MD_WRITE_SECTOR___________________________________________________________________________________
0093E8  2               ;*
0093E8  2               ;*  WRITE MD SECTOR FROM BUFFER
0093E8  2               ;*
0093E8  2               ;*____________________________________________________________________________________________________
0093E8  2               MD_WRITE_SECTOR:
0093E8  2               		PRTDBG "MD Write Sector$"
0093E8  2  20 23 8E                     JSR     GET_DRIVE_DEVICE
0093EB  2  29 01        		and 	#$01			; only want drive cfg
0093ED  2  C9 00                        CMP     #$00                    ; NO WRITE FOR ROM
0093EF  2  F0 03                        BEQ     MD_WRITE_SECTOR_RAM
0093F1  2  A9 FF                        LDA     #$FF
0093F3  2  60                           RTS
0093F4  2               MD_WRITE_SECTOR_RAM:
0093F4  2  20 BD 93                     JSR     MD_READ_RAW_SECTOR
0093F7  2  20 0B 94                     JSR     MD_CONVERT_SECTOR
0093FA  2  20 74 94                     JSR     BLKSECR256
0093FD  2  AD 10 03      	        LDA    	debcyll			; GET BANK
009400  2  AC 12 03     		LDY    	debsehd			; GET PAGE
009403  2  A2 80        		LDX 	#$80                    ; TOGGLE WRITE RAM
009405  2                               PRTDBG "DO PAGER$"
009405  2  20 00 02                     JSR     MD_PAGERA
009408  2                               PRTDBG "PAGER RETURN$"
009408  2  A9 00                        LDA     #$00
00940A  2  60           		RTS
00940B  2               
00940B  2               ;___MD_CONVERT_SECTOR___________________________________________________________________________________
00940B  2               ;
00940B  2               ; 	TRANSLATE SECTORS INTO MD FORMAT
00940B  2               ;________________________________________________________________________________________________________
00940B  2               MD_CONVERT_SECTOR:
00940B  2                       PRTDBG "CONVERT SECTOR$"
00940B  2  DA                   phx
00940C  2  AD 0E 03     	LDA	seksec			; LOAD SECTOR # (LOW BYTE)
00940F  2  4A           	LSR	A			; DIVIDE BY 2 (FOR BLOCKING)
009410  2  29 1F        	AND 	#$1F 			; CLEAR UPPER 3 BITS (JUST 'CAUSE)
009412  2  8D 12 03     	STA	debsehd			; STORE IN SECTOR/HEAD
009415  2  AD 0C 03     	LDA	sektrk			; LOAD TRACK # (LOW BYTE)
009418  2  29 03        	AND 	#$03			; BOTTOM 2 BITS ARE PART OF PAGE (PAGES ARE 32k)
00941A  2  0A           	asl	a			; MOVE TO HIGH BITS
00941B  2  0A           	asl	a
00941C  2  0A           	asl	a
00941D  2  0A           	asl	a
00941E  2  0A                  	asl	a
00941F  2  09 80                ORA     #$80                    ; PAGES ARE ALWAYS IN UPPER BANK
009421  2  0D 12 03     	ORA	debsehd			; STORE IN SECTOR/HEAD
009424  2  8D 12 03             STA     debsehd                 ; STORE IN SECTOR/HEAD
009427  2                                                       ; AT THIS POINT PAGE REGISTER SHOULD BE
009427  2                                                       ; SET
009427  2  AD 0C 03     	LDA	sektrk			; LOAD TRACK #
00942A  2  4A                  	LSR	a			; LOSE BOTTOM TWO BITS
00942B  2  4A           	LSR	a
00942C  2  8D 10 03     	STA	debcyll			; THIS SHOULD BE BANK#
00942F  2               
00942F  2               
00942F  2                 .IF USEDSKY=1 || USEDSKYNG=1
00942F  2                 	PRTDBG "DSKY OUTPUT 1$"
00942F  2  AD 13 03       	lda	sekdsk
009432  2  8D 08 03       	sta	DSKY_HEXBUF
009435  2  A9 00         	lda	#$00
009437  2  8D 09 03       	sta	DSKY_HEXBUF+1
00943A  2  AD 10 03      	lda	debcyll
00943D  2  8D 0A 03       	sta	DSKY_HEXBUF+2
009440  2  AD 12 03         	lda	debsehd
009443  2  8D 0B 03       	sta	DSKY_HEXBUF+3
009446  2  20 BB 91             jsr     DSKY_BIN2SEG
009449  2  20 F0 91             jsr     DSKY_SHOW
00944C  2                 .ENDIF
00944C  2  FA                   plx
00944D  2  60           	RTS
00944E  2               
00944E  2               ;___DEBSECR256________________________________________________________________________________________
00944E  2               ;
00944E  2               ;	DEBLOCK 256 BYTE SECTOR FOR DOS/65
00944E  2               ;
00944E  2               ;________________________________________________________________________________________________________
00944E  2               DEBSECR256:
00944E  2  48           	PHA
00944F  2  AD 0E 03     	LDA	seksec			;
009452  2  29 01        	AND	#$01			; GET SECTOR INDEX
009454  2  C9 00                CMP     #$00
009456  2  D0 07                BNE     DEBSECR256_H
009458  2  A9 00        	LDA	#$00                     ;
00945A  2  85 EE        	STA     SRC
00945C  2  4C 63 94             JMP     DEBSECR256_GO
00945F  2               DEBSECR256_H:
00945F  2  A9 80        	LDA	#$80                     ;
009461  2  85 EE        	STA     SRC
009463  2               DEBSECR256_GO:
009463  2  A9 04        	LDA	#>MD_PAGEBU             ;
009465  2  85 EF        	STA	SRC+1			;
009467  2  A5 F4        	LDA	dmaadr			;
009469  2  85 EC        	STA	DEST			;
00946B  2  A5 F5        	LDA	dmaadr+1		;
00946D  2  85 ED        	STA	DEST+1			;
00946F  2  20 30 8E     	JSR	COPY_DOS_SECTOR		;
009472  2  68           	PLA
009473  2  60                   RTS
009474  2               
009474  2               ;___BLKSECR256________________________________________________________________________________________
009474  2               ;
009474  2               ;	BLOCK 256 BYTE SECTOR FOR DOS/65
009474  2               ;
009474  2               ;________________________________________________________________________________________________________
009474  2               BLKSECR256:
009474  2  48           	PHA
009475  2  AD 0E 03     	LDA	seksec			;
009478  2  29 01        	AND	#$01			; GET SECTOR INDEX
00947A  2  C9 00                CMP     #$00
00947C  2  D0 07                BNE     BLKSECR256_H
00947E  2  A9 00        	LDA	#$00                     ;
009480  2  85 EC        	STA     DEST
009482  2  4C 89 94             JMP     BLKSECR256_GO
009485  2               BLKSECR256_H:
009485  2  A9 80        	LDA	#$80                     ;
009487  2  85 EC        	STA     DEST
009489  2               BLKSECR256_GO:
009489  2  A9 04        	LDA	#>MD_PAGEBU             ;
00948B  2  85 ED        	STA	DEST+1			;
00948D  2  A5 F4        	LDA	dmaadr			;
00948F  2  85 EE        	STA	SRC			;
009491  2  A5 F5        	LDA	dmaadr+1		;
009493  2  85 EF        	STA	SRC+1			;
009495  2  20 30 8E     	JSR	COPY_DOS_SECTOR		;
009498  2  68           	PLA
009499  2  60                   RTS
00949A  2               
00949A  1               
00949A  1               ;//	.IF USEFLOPPYA=1 | USEFLOPPYB=1
00949A  1               ;//		.INCLUDE "DOS65\\DOSFLPV3.ASM"
00949A  1               ;//	.ENDIF
00949A  1               
00949A  1               CONSOLE_OUT:
00949A  1               ;// TODO: this should be dependent on "active console. . ." and should be a driver call
00949A  1  4C 44 88     		JMP WRSER1
00949D  1               ;// TODO: CONSOLE_IN
00949D  1               
00949D  1               
00949D  1               
00949D  1               	.end
