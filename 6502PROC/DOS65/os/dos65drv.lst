ca65 V2.18 - Ubuntu 2.19-1
Main file   : dos65drv.asm
Current file: dos65drv.asm

000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               ;
000000r 1               ;	Nhyodyne dos/65 banked driver code
000000r 1               ;       Intended for RAM BANK $0D
000000r 1               ;
000000r 1               ;  DWERNER 04/24/2022 	Initial
000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               		.PC02
000000r 1                               .segment "DRIVERS"
000000r 1               		.ORG $8800
008800  1               .include "dosdefn.asm" 		; base addresses and definitions
008800  2               ;________________________________________________________________________________________________________________________________
008800  2               ;
008800  2               ;	Nhyodyne dos/65 base addresses and definitions
008800  2               ;
008800  2               ;  DWERNER 04/24/2022 	Initial
008800  2               ;________________________________________________________________________________________________________________________________
008800  2               
008800  2               ;base addresses and definitions
008800  2               btejmp	        =	$0100		;warm boot jump
008800  2               pemjmp	        =	$0103		;jump to pem
008800  2               iostat	        =	$0106		;i/o status
008800  2               dflfcb	        =	$0107		;default fcb
008800  2               dflbuf	        =	$0128		;default buffer
008800  2               memmovr         =	$0200		; 0200-02ff subr to move data from ram/rom disks
008800  2               MD_PAGERA       =       $0200           ; PAGE DRIVER ADDRESS
008800  2               
008800  2               IO              =       $0300           ; 0300-03FF Memory mapped IO
008800  2               MPCL_ROM	=	$037C		; ROM MAPPER
008800  2               MPCL_RAM	=	$0378		; RAM MAPPER
008800  2               
008800  2               MD_PAGEBU       =       $0400           ; 0400-04FF PAGE BUFFER ADDRESS
008800  2               MD_PAGESE       =       pointr          ; PAGE SECTOR STORAGE
008800  2               
008800  2               ;
008800  2               ; DRIVER WORKING STORAGE
008800  2               ;
008800  2               DSKY_BUF        =       $0500	        ; Eight Bytes DSKY display buffer
008800  2               DSKY_BUFLEN	=       8               ;
008800  2               DSKY_HEXBUF     =       $0508           ; Four Bytes DSKY hex buffer
008800  2               DSKY_HEXBUFLEN	=       4               ;
008800  2               sektrk          =       $050C		; seek track number
008800  2               seksec          =       $050E		; seek sector number
008800  2               debcyll         =       $0510	        ; DEBLOCKED CYLINDER LSB
008800  2               debcylm         =	$0511           ; DEBLOCKED CYLINDER MSB
008800  2               debsehd         =	$0512           ; DEBLOCKED SECTOR AND HEAD (HS)
008800  2               sekdsk          =       $0513           ; seek disk number
008800  2               dskcfg          =       $0514           ; 16 bytes disk configuration table
008800  2               
008800  2               
008800  2               
008800  2               tea	=	$800		;tea start
008800  2               
008800  2               ;zero page for setup
008800  2               trknum	=	$02			;current track
008800  2               dcbadd	=	$04			;dcb address
008800  2               nmsstr	=	$06			;number system tracks
008800  2               nsectr	=	$08			;number sectors per track
008800  2               ttlsec	=	$0A			;total sectors to write
008800  2               trkcnt	=	ttlsec
008800  2               size	=	$0B			;ascii size
008800  2               lokim	=	$0D			;low kim limit
008800  2               hikim	=	$0F			;high kim limit
008800  2               offset	=	$11			;relocation offset
008800  2               kimcnt	=	$13			;kim counter
008800  2               pointr	=	$14			;pointer
008800  2               lengt	=	$16			;inst length
008800  2               point	=	$17			;relocate pointer
008800  2               adjust	=	$19			;relocate distance
008800  2               kimpnt	=	$1B			;kim file index
008800  2               savex	=	$1C			;save for x
008800  2               savey	=	$1D			;save for y
008800  2               number	=	$1E			;input pack buffer
008800  2               dstdrv	=	$20			;destination drive
008800  2               defalt	=	$21			;default drive
008800  2               seccnt	=	$22			;sector count
008800  2               secnum	=	$24			;sector number
008800  2               curccm	=	$26			;start of current ccm
008800  2               simlng	=	$28			;length of sim
008800  2               room	=	$2A			;memory needed for sysgen
008800  2               stksav	=	$2C			;save stack register
008800  2               frstsc	=	$2D			;first sector number of disk
008800  2               dskcfpc	=	$2E			;pointer to disk configuration table
008800  2               cmdlnp	=	$30			;pointer to command line buffer
008800  2               farfunct=       $32                     ;function to call in driver area
008800  2               farpointer=     $33                     ;WORD POINTER to call in driver area
008800  2               lastzp	=	$35
008800  2               
008800  2               ;pem constants on entry to write
008800  2               wrall	=	0		;write to allocated
008800  2               wrdir	=	1		;write to directory
008800  2               wrual	=	2		;write to unallocated
008800  2               
008800  2               ;page zero and system ram assignments
008800  2               DEST	 =	$EC		;pointer for OutMsg
008800  2               SRC	 =	$EE		;pointer for OutMsg
008800  2               OUTMSG_W =	$F0		;pointer for OutMsg
008800  2               mvepnt	=	$f2		;host buffer location
008800  2               dmaadr	=	$f4		;pointer for r/w
008800  2               
008800  2               ;fixed parameters
008800  2               lf	=	$a		;linefeeed
008800  2               cr	=	$d		;return
008800  2               eof	=	$1a		;end of file
008800  2               null	=	0		;null
008800  2               ctlc	=	3		;abort
008800  2               ctle	=	5		;physical cr lf
008800  2               ctli	=	9		;tab character
008800  2               ctlp	=	$10		;toggle printer
008800  2               ctlr	=	$12		;repeat line
008800  2               ctls	=	$13		;freeze
008800  2               ctlx	=	$18		;cancel
008800  2               semico	=	$3b		;semicolon
008800  2               delete	=	$08		;delete character
008800  2               numcmd	=	36		;number commands
008800  2               
008800  2               BANKED_DRIVER_DISPATCHER=$8800  ; LOCATION OF DRIVER DISPATCHER
008800  2               DEBUG	=	1		; assemble with debug information on
008800  2               
008800  2               
008800  2               USESERIAL 	= 	1	; SET TO ONE SERIAL CONSOLE IO
008800  2               USEFLOPPYA 	= 	0	; SET TO ONE FOR FLOPPY = "A"
008800  2               USEFLOPPYB 	= 	0	; SET TO ONE FOR FLOPPY = "B"
008800  2               USEIDEC 	= 	1	; SET TO ONE FOR IDE HDD="C"
008800  2               USEDSKY 	= 	0	; SEND INFO TO DSKY
008800  2               USEDSKYNG 	= 	1	; SEND INFO TO DSKYNG
008800  2               DSKY_KBD	=	1	; USE DSKY KEYBOARD?
008800  2               DEFDRV  	=	2	; SET TO DEFAULT DRIVE LETTER
008800  2               USEDISKIOV1     = 	0	; Floppy and IDE card is  DISK IO V1
008800  2               USEDISKIOV3     = 	0	; Floppy and IDE card is  DISK IO V3
008800  2               
008800  2               FLPA35		=	0	; set to 1 if floppy a is A 3.5" 80 track drive (0= 5.25" 40 track drive)
008800  2               FLPB35		=	0	; set to 1 if floppy a is B 3.5" 80 track drive (0= 5.25" 40 track drive)
008800  2               
008800  2               DSKYOSC         =	100000
008800  2               
008800  1               
008800  1               ; for Nhyodyne:
008800  1               ; RAM BANK $0C is RAM area for Drivers
008800  1               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
008800  1               ; RAM BANK $0F is fixed bank $0000-$7FFF
008800  1               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
008800  1               
008800  1               ;       Area from $0D:8000 to $0D:8800 reserved for work RAM for drivers
008800  1               ;
008800  1               
008800  1               ;__DISPATCHER________________________________________________________________________________________
008800  1               ;
008800  1               ;  Function dispatcher
008800  1               ;  function to call is located in "farfunct"
008800  1               ;____________________________________________________________________________________________________
008800  1               ;
008800  1  48           		PHA
008801  1  DA           		PHX
008802  1  A5 32        		LDA     farfunct
008804  1  0A           		ASL	A			; DOUBLE NUMBER FOR TABLE LOOKUP
008805  1  AA           		TAX
008806  1  BD 15 88     		LDA 	DISPATCHTABLE,X
008809  1  85 33        		STA	farpointer
00880B  1  BD 16 88     		LDA 	DISPATCHTABLE+1,X
00880E  1  85 34        		STA	farpointer+1
008810  1               
008810  1  FA           		PLX
008811  1  68           		PLA
008812  1  6C 33 00     		JMP (farpointer)
008815  1               
008815  1               
008815  1               DISPATCHTABLE:
008815  1  BC 88        		.WORD 	WRSER1			; FUNCTION 00 - WRITE SERIAL PORT
008817  1  CB 88        		.WORD 	RDSER1			; FUNCTION 01 - READ SERIAL PORT
008819  1  DB 88        		.WORD 	RDSER1W			; FUNCTION 02 - READ SERIAL PORT (BLOCKING)
00881B  1  EA 88        		.WORD 	SERIALSTATUS		; FUNCTION 03 - GET SERIAL STATUS
00881D  1               
00881D  1  FC 88        		.WORD 	PPIDE_INIT   		; FUNCTION 04 - called during OS init
00881F  1  07 8C        		.WORD 	IDE_READ_SECTOR 	; FUNCTION 05 - read a sector from drive
008821  1  08 8D        		.WORD 	IDE_WRITE_SECTOR	; FUNCTION 06 - write a sector to drive
008823  1               
008823  1  64 90        		.WORD 	DSKY_INIT		; FUNCTION 07 -
008825  1  39 92        		.WORD 	DSKY_SHOW		; FUNCTION 08 -
008827  1  04 92        		.WORD 	DSKY_BIN2SEG		; FUNCTION 09 -
008829  1  86 91        		.WORD 	DSKY_RESET		; FUNCTION 10 -
00882B  1  A1 91        		.WORD 	DSKY_STAT		; FUNCTION 11 -
00882D  1  AE 91        		.WORD 	DSKY_GETKEY		; FUNCTION 12 -
00882F  1  08 93        		.WORD 	DSKY_BEEP		; FUNCTION 13 -
008831  1  35 93        		.WORD 	DSKY_L1ON		; FUNCTION 14 -
008833  1  46 93        		.WORD 	DSKY_L2ON		; FUNCTION 15 -
008835  1  57 93        		.WORD 	DSKY_L1OFF		; FUNCTION 16 -
008837  1  68 93        		.WORD 	DSKY_L2OFF		; FUNCTION 17 -
008839  1  F1 92        		.WORD 	DSKY_PUTLED		; FUNCTION 18 -
00883B  1  BF 92        		.WORD 	DSKY_BLANK		; FUNCTION 19 -
00883D  1               
00883D  1  29 94        		.WORD 	MD_READ_SECTOR 		; FUNCTION 20 - read a sector from memory device
00883F  1  F7 94        		.WORD 	MD_WRITE_SECTOR		; FUNCTION 21 - write a sector to memory device
008841  1  B8 93        		.WORD 	MD_SHOW			; FUNCTION 22 - md show information
008843  1               
008843  1  B5 99        		.WORD 	FL_READ_SECTOR 		; FUNCTION 23 - read a sector from floppy device
008845  1  79 9A        		.WORD 	FL_WRITE_SECTOR		; FUNCTION 24 - write a sector to floppy device
008847  1  BD 98        		.WORD 	FL_SETUP		; FUNCTION 25 - init floppy device
008849  1               
008849  1               
008849  1               ;__DRIVERS___________________________________________________________________________________________
008849  1               ;
008849  1               		.include "drvmacro.asm"
008849  2               ;__MACRO___________________________________________________________________________________________________________________
008849  2               ;
008849  2               ; 	Macros for the betterment of Mankind
008849  2               ;________________________________________________________________________________________________________________________________
008849  2               ;
008849  2               
008849  2               .macro          PRTDBG      message
008849  2               .LOCAL p1
008849  2               .LOCAL p2
008849  2               .LOCAL p3
008849  2               .LOCAL p4
008849  2               .LOCAL p5
008849  2                 .if     .paramcount <> 1
008849  2                       .error  "Too few parameters for macro PRTDBG"
008849  2                       .endif
008849  2                       .if DEBUG=1
008849  2                       PHA
008849  2                       PHX
008849  2                       PHY
008849  2                       LDX #$00
008849  2               p1:
008849  2                       LDA p4,x
008849  2                       INX
008849  2                       CMP #'$'
008849  2                       BEQ p2
008849  2                       JSR CONSOLE_OUT
008849  2                       JMP p1
008849  2               p2:
008849  2                       LDA #13
008849  2                       jsr CONSOLE_OUT
008849  2                       LDA #10
008849  2                       jsr CONSOLE_OUT
008849  2                       PLY
008849  2                       plx
008849  2                       pla
008849  2                       JMP p5
008849  2               p4:
008849  2                       .BYTE message
008849  2               p5:
008849  2                       .endif
008849  2               .endmacro
008849  2               
008849  2               .macro          PRTS      message
008849  2               .LOCAL p1
008849  2               .LOCAL p2
008849  2               .LOCAL p3
008849  2               .LOCAL p4
008849  2               .LOCAL p5
008849  2                 .if     .paramcount <> 1
008849  2                       .error  "Too few parameters for macro PRTS"
008849  2                       .endif
008849  2                       PHA
008849  2                       PHX
008849  2                       PHY
008849  2                       LDX #$00
008849  2               p1:
008849  2                       LDA p4,x
008849  2                       INX
008849  2                       CMP #'$'
008849  2                       BEQ p2
008849  2                       JSR CONSOLE_OUT
008849  2                       JMP p1
008849  2               p2:
008849  2                       PLY
008849  2                       plx
008849  2                       pla
008849  2                       JMP p5
008849  2               p4:
008849  2                       .BYTE message
008849  2               p5:
008849  2               .endmacro
008849  2               
008849  2               .macro          DBGFLAG      character
008849  2                 .if     .paramcount <> 1
008849  2                       .error  "Too few parameters for macro DBGFLAG"
008849  2                       .endif
008849  2                       .if DEBUG=1
008849  2                       PHA
008849  2                       LDA #character
008849  2                       JSR CONSOLE_OUT
008849  2                       pla
008849  2                       .endif
008849  2               .endmacro
008849  2               
008849  2               
008849  2               ;__PRTHEXBYTE__________________________________________________
008849  2               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
008849  2               ;______________________________________________________________
008849  2               PRTHEXBYTE:
008849  2  48                   PHA
00884A  2  DA                   PHX
00884B  2  5A                   PHY
00884C  2  AA                   TAX				; SAVE A REGISTER
00884D  2  4A                   LSR 				; SHIFT HIGH NIBBLE TO LOW NIBBLE
00884E  2  4A                   LSR 				;
00884F  2  4A                   LSR 				;
008850  2  4A                   LSR 				;
008851  2  18                   CLC               		; CLEAR CARRY
008852  2  20 5D 88             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
008855  2  8A                   TXA				; RESTORE ACCUMULATOR
008856  2  20 5D 88             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
008859  2  7A                   PLY
00885A  2  FA                   plx
00885B  2  68                   PLA
00885C  2  60                   RTS
00885D  2               
00885D  2               ;__PRINT_DIGIT_________________________________________________
00885D  2               ;
00885D  2               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
00885D  2               ;
00885D  2               ;______________________________________________________________
00885D  2               PRINT_DIGIT:
00885D  2  29 0F                       AND #$0F				; STRIP OFF HIGH NIBBLE
00885F  2  09 30                       ORA #$30				; ADD $30 TO PRODUCE ASCII
008861  2  C9 3A                       CMP #$3A               		; IS GREATER THAN 9
008863  2  30 03                       BMI PRINT_DIGIT_OUT		; NO, SKIP ADD
008865  2  18                          CLC				; CLEAR CARRY
008866  2  69 07                       ADC #$07				; ADD ON FOR LETTER VALUES
008868  2               PRINT_DIGIT_OUT:					;
008868  2  4C 26 9E                    JMP CONSOLE_OUT              		; PRINT OUT CHAR
00886B  2               
00886B  2               NEWLINE:
00886B  2  48                           pha
00886C  2  DA                           PHX
00886D  2  5A                           phy
00886E  2  A9 0D                        LDA #$0D
008870  2  20 26 9E                     JSR CONSOLE_OUT
008873  2  A9 0A                        LDA #$0A
008875  2  20 26 9E                     Jsr CONSOLE_OUT
008878  2  7A                           ply
008879  2  FA                           plx
00887A  2  68                           pla
00887B  2  60                           rts
00887C  2               
00887C  2               PRTDEC:
00887C  2  5A                           phy
00887D  2  DA                           PHX
00887E  2  48                           PHA
00887F  2  A0 00                        ldy #00
008881  2  A2 FF                        LDX #$FF
008883  2  38                           SEC
008884  2               PrDec100:
008884  2  E8                           INX
008885  2  E9 64                        SBC #100
008887  2  B0 FB                        BCS PrDec100            ;Count how many 100s
008889  2  69 64                        ADC #100
00888B  2  20 A5 88                     JSR PrDecDigit          ;Print the 100s
00888E  2  A2 FF                        LDX #$FF
008890  2  38                           SEC                     ;Prepare for subtraction
008891  2               PrDec10:
008891  2  E8                           INX
008892  2  E9 0A                        SBC #10
008894  2  B0 FB                        BCS PrDec10             ;Count how many 10s
008896  2  69 0A                        ADC #10
008898  2  20 A5 88                     JSR PrDecDigit          ;Print the 10s
00889B  2  AA                           TAX                     ;Pass 1s into X
00889C  2  A0 01                        ldy #1
00889E  2  20 A5 88                     JSR PrDecDigit          ;Print the 1s
0088A1  2  68                           PLA
0088A2  2  FA                           PLX
0088A3  2  7A                           ply
0088A4  2  60                           RTS
0088A5  2               PrDecDigit:
0088A5  2  48                           PHA
0088A6  2  C0 00                        cpy #$00
0088A8  2  D0 09                        bne PrDecDigit1
0088AA  2  8A                           txa
0088AB  2  A8                           tay
0088AC  2  C0 00                        cpy #$00
0088AE  2  D0 03                        bne PrDecDigit1
0088B0  2  4C B9 88                     jmp PrDecDigit2
0088B3  2               PrDecDigit1:
0088B3  2  8A                           TXA                     ;Save A, pass digit to A
0088B4  2  09 30                        ORA #'0'
0088B6  2  20 26 9E                     JSR  CONSOLE_OUT        ;Convert to character and print it
0088B9  2               PrDecDigit2:
0088B9  2  68                           PLA
0088BA  2  60                           RTS                     ;Restore A and return
0088BB  2               
0088BB  1               		.INCLUDE "dosser.asm"
0088BB  2               ;__SERIAL DRIVERS________________________________________________________________________________________________________________
0088BB  2               ;
0088BB  2               ; 	Nhyodyne serial drivers for single serial port card
0088BB  2               ;
0088BB  2               ;	Entry points:
0088BB  2               ;		SERIALINIT  - called during OS init
0088BB  2               ;		RDSER1	    - read a byte from serial port ('A' POINTS TO BYTE)
0088BB  2               ;		WRSER1	    - write a byte from serial port  ('A' POINTS TO BYTE)
0088BB  2               ;		RDSER1W	    - read a byte from serial port ('A' POINTS TO BYTE, WAIT FOR INPUT)
0088BB  2               ;		SERIALSTATUS- GET UART STATUS
0088BB  2               ;________________________________________________________________________________________________________________________________
0088BB  2               ;
0088BB  2               
0088BB  2               
0088BB  2               ;*
0088BB  2               ;* HARDWARE I/O ADDRESSES
0088BB  2               ;*
0088BB  2               
0088BB  2               ; UART 16C550 SERIAL
0088BB  2               UART0       	=    	$0368           ; DATA IN/OUT
0088BB  2               UART1       	=    	$0369           ; CHECK RX
0088BB  2               UART2       	=    	$036A           ; INTERRUPTS
0088BB  2               UART3       	=    	$036B           ; LINE CONTROL
0088BB  2               UART4       	=    	$036C           ; MODEM CONTROL
0088BB  2               UART5          	=    	$036D           ; LINE STATUS
0088BB  2               UART6          	=    	$036E           ; MODEM STATUS
0088BB  2               UART7	       	=    	$036F           ; SCRATCH REG.
0088BB  2               
0088BB  2               
0088BB  2               ;__SERIALINIT____________________________________________________________________________________________________________________
0088BB  2               ;
0088BB  2               ;	INITIALIZE SERIAL PORTS
0088BB  2               ;________________________________________________________________________________________________________________________________
0088BB  2               ;
0088BB  2               SERIALINIT:
0088BB  2               ;	LDA	#$80			;
0088BB  2               ;	STA	UART3			; SET DLAB FLAG
0088BB  2               ;	LDA	#12			; SET TO 12 = 9600 BAUD
0088BB  2               ;	STA	UART0			; save baud rate
0088BB  2               ;	LDA	#00			;
0088BB  2               ;	STA	UART1			;
0088BB  2               ;	LDA	#03			;
0088BB  2               ;	STA	UART3			; SET 8 BIT DATA, 1 STOPBIT
0088BB  2               ;	STA	UART4			;
0088BB  2               
0088BB  2  60           	RTS
0088BC  2               
0088BC  2               
0088BC  2               
0088BC  2               ;__WRSER1________________________________________________________________________________________________________________________
0088BC  2               ;
0088BC  2               ;	WRITE CHARACTER(A) TO UART
0088BC  2               ;________________________________________________________________________________________________________________________________
0088BC  2               ;
0088BC  2               WRSER1:
0088BC  2  48           	PHA
0088BD  2               WRSER1a:
0088BD  2  AD 6D 03     	LDA	UART5			; READ LINE STATUS REGISTER
0088C0  2  29 20        	AND	#$20			; TEST IF UART IS READY TO SEND (BIT 5)
0088C2  2  C9 00        	CMP     #$00
0088C4  2  F0 F7        	BEQ	WRSER1a			; NO, WAIT FOR IT
0088C6  2  68           	PLA
0088C7  2  8D 68 03     	STA	UART0			; THEN WRITE THE CHAR TO UART
0088CA  2  60           	RTS
0088CB  2               
0088CB  2               ;__RDSER1________________________________________________________________________________________________________________________
0088CB  2               ;
0088CB  2               ;	READ CHARACTER FROM UART TO (A)
0088CB  2               ;________________________________________________________________________________________________________________________________
0088CB  2               ;
0088CB  2               RDSER1:
0088CB  2  AD 6D 03     	LDA	UART5			; READ LINE STATUS REGISTER
0088CE  2  29 01        	AND	#$01			; TEST IF DATA IN RECEIVE BUFFER
0088D0  2  C9 00        	CMP 	#$00
0088D2  2  F0 04        	BEQ	RDSER1N			; LOOP UNTIL DATA IS READY
0088D4  2  AD 68 03     	LDA	UART0			; THEN READ THE CHAR FROM THE UART
0088D7  2  60           	RTS
0088D8  2               RDSER1N:
0088D8  2  A9 00        	LDA	#$00			;
0088DA  2  60           	RTS				;
0088DB  2               
0088DB  2               ;__RDSER1W_______________________________________________________________________________________________________________________
0088DB  2               ;
0088DB  2               ;	READ CHARACTER FROM UART TO (A) - WAIT FOR CHAR
0088DB  2               ;________________________________________________________________________________________________________________________________
0088DB  2               ;
0088DB  2               
0088DB  2               RDSER1W:
0088DB  2  AD 6D 03     		LDA	UART5			; READ LINE STATUS REGISTER
0088DE  2  29 01        		AND	#$01			; TEST IF DATA IN RECEIVE BUFFER
0088E0  2  C9 00        		CMP 	#$00
0088E2  2  F0 F7        		BEQ	RDSER1W			; LOOP UNTIL DATA IS READY
0088E4  2  AD 68 03     		LDA	UART0			; THEN READ THE CHAR FROM THE UART
0088E7  2  29 7F        		AND #$7F
0088E9  2  60           		RTS
0088EA  2               
0088EA  2               ;__SERIALSTATUS__________________________________________________________________________________________________________________
0088EA  2               ;
0088EA  2               ;	READ UARD STATUS
0088EA  2               ;________________________________________________________________________________________________________________________________
0088EA  2               ;
0088EA  2               SERIALSTATUS:
0088EA  2  AD 6D 03     	LDA	UART5			; READ LINE STATUS REGISTER
0088ED  2  29 01        	AND	#$01			; TEST IF DATA IN RECEIVE BUFFER
0088EF  2  C9 00        	CMP 	#$00
0088F1  2  F0 03        	BEQ	RDSTAT1			; NO, INDICATE NO CHAR
0088F3  2  A9 FF        	LDA	#$FF			; GET DATA CHAR
0088F5  2  60           	RTS
0088F6  2               RDSTAT1:
0088F6  2  A9 00        	LDA	#$00			; GET DATA CHAR
0088F8  2  60           	RTS
0088F9  2               
0088F9  2               ; end
0088F9  2               
0088F9  1               		.INCLUDE "doside.asm"
0088F9  2               ;__IDE DRIVERS___________________________________________________________________________________________________________________
0088F9  2               ;
0088F9  2               ; 	Nhyodyne IDE disk drivers for Z80PPIDE card
0088F9  2               ;
0088F9  2               ;	Entry points:
0088F9  2               ;		PPIDE_INIT   	- called during OS init
0088F9  2               ;		IDE_READ_SECTOR - read a sector from drive
0088F9  2               ;		IDE_WRITE_SECTOR- write a sector to drive
0088F9  2               ;________________________________________________________________________________________________________________________________
0088F9  2               ;
0088F9  2               PPIDE_PPI	=	$0360		; PORT A
0088F9  2               ;
0088F9  2               PPIDELO		=	PPIDE_PPI+0	; LSB
0088F9  2               PPIDEHI		=	PPIDE_PPI+1	; MSB
0088F9  2               PPIDECNTRL	=	PPIDE_PPI+2	; Control Signals
0088F9  2               PPIDEPPIC	=	PPIDE_PPI+3	; CONTROL BYTE PPI 82C55
0088F9  2               
0088F9  2               PPIDE_A0_LINE	=	$01		;DIRECT FROM 8255 TO IDE INTERFACE
0088F9  2               PPIDE_A1_LINE	=	$02		;DIRECT FROM 8255 TO IDE INTERFACE
0088F9  2               PPIDE_A2_LINE	=	$04		;DIRECT FROM 8255 TO IDE INTERFACE
0088F9  2               PPIDE_CS0_LINE	=	$08		;INVERTER BETWEEN 8255 AND IDE INTERFACE
0088F9  2               PPIDE_CS1_LINE	=	$10		;INVERTER BETWEEN 8255 AND IDE INTERFACE
0088F9  2               PPIDE_WR_LINE	=	$20		;INVERTER BETWEEN 8255 AND IDE INTERFACE
0088F9  2               PPIDE_RD_LINE	=	$40		;INVERTER BETWEEN 8255 AND IDE INTERFACE
0088F9  2               PPIDE_RST_LINE	=	$80		;INVERTER BETWEEN 8255 AND IDE INTERFACE
0088F9  2               
0088F9  2               PPIDE_DATA	=	PPIDE_CS0_LINE
0088F9  2               PPIDE_ERR	=	PPIDE_CS0_LINE + PPIDE_A0_LINE
0088F9  2               PPIDE_SEC_CNT	=	PPIDE_CS0_LINE + PPIDE_A1_LINE
0088F9  2               PPIDE_LBALOW	=	PPIDE_CS0_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
0088F9  2               PPIDE_LBAMID	=	PPIDE_CS0_LINE + PPIDE_A2_LINE
0088F9  2               PPIDE_LBAHI	=	PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A0_LINE
0088F9  2               PPIDE_DEVICE	=	PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
0088F9  2               PPIDE_COMMAND	=	PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
0088F9  2               PPIDE_STATUS	=	PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
0088F9  2               PPIDE_CONTROL	=	PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
0088F9  2               PPIDE_ASTATUS	=	PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
0088F9  2               
0088F9  2               
0088F9  2               ;IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
0088F9  2               PPIDE_CMD_RECAL	=	$10
0088F9  2               PPIDE_CMD_READ	=	$20
0088F9  2               PPIDE_CMD_WRITE	=	$30
0088F9  2               PPIDE_CMD_INIT	=	$91
0088F9  2               PPIDE_CMD_ID	=	$EC
0088F9  2               PPIDE_CMD_SPINDOWN=	$E0
0088F9  2               PPIDE_CMD_SPINUP=	$E1
0088F9  2               
0088F9  2               
0088F9  2               PPRD_IDE_8255	=	%10010010	;IDE_8255_CTL OUT, IDE_8255_LSB/MSB INPUT
0088F9  2               PPWR_IDE_8255	=	%10000000	;ALL THREE PORTS OUTPUT
0088F9  2               
0088F9  2               
0088F9  2  00           PPIDEINDEX:	.byte	$00
0088FA  2  00 00        PPIDETIMEOUT:	.byte	$00,$00
0088FC  2               
0088FC  2               ;__PPIDE_INIT_________________________________________________________________________________________
0088FC  2               ;
0088FC  2               ;  INIT AND DISPLAY IDE INFO
0088FC  2               ;____________________________________________________________________________________________________
0088FC  2               ;
0088FC  2               PPIDE_INIT:
0088FC  2  48 DA 5A A2          PRTDBG "PPIDE INIT:$"
008900  2  00 BD 1F 89  
008904  2  E8 C9 24 F0  
00892B  2  48 DA 5A A2  	PRTS "PPIDE :$"
00892F  2  00 BD 44 89  
008933  2  E8 C9 24 F0  
00894C  2  20 6B 88            	JSR	NEWLINE
00894F  2  20 F9 8B     	JSR	IDE_PPIDETECT		; TEST FOR PPI HARDWARE
008952  2  D0 35                BNE     IDE_ABORT      		; BAIL OUT IF NOT THERE
008954  2               ;
008954  2  48 DA 5A A2  	PRTS    " IO=0x$"
008958  2  00 BD 6D 89  
00895C  2  E8 C9 24 F0  
008974  2  A9 03        	LDA	#>PPIDE_PPI		; GET BASE PORT
008976  2  20 49 88     	JSR	PRTHEXBYTE		; PRINT BASE PORT
008979  2  A9 60               	LDA	#<PPIDE_PPI		; GET BASE PORT
00897B  2  20 49 88     	JSR	PRTHEXBYTE		; PRINT BASE PORT
00897E  2               ;
00897E  2  20 72 8D     	JSR	PPIDE_RESET		; RESET THE BUS
008981  2  20 17 8A     	JSR	PPIDE_PROBE		; DETECT AN ATA DEVICE, ABORT IF NOT FOUND
008984  2  B0 03        	BCS 	IDE_ABORT
008986  2  4C B2 89     	JMP 	IDE_PRINT_INFO
008989  2               IDE_ABORT:
008989  2  48 DA 5A A2  	PRTS    " NOT PRESENT$"		; NOT PRESENT
00898D  2  00 BD A2 89  
008991  2  E8 C9 24 F0  
0089AF  2  4C 13 8A     	JMP 	IDE_INITA
0089B2  2               IDE_PRINT_INFO:
0089B2  2  20 6B 88     	JSR	NEWLINE
0089B5  2  48 DA 5A A2  	PRTS    " PPIDE0: Blocks=$"
0089B9  2  00 BD CE 89  
0089BD  2  E8 C9 24 F0  
0089DF  2  A9 00        	LDA	#$00
0089E1  2  20 A0 8A     	JSR	IDE_READ_INFO		; GET DRIVE INFO, ABORT IF ERROR
0089E4  2  48 DA 5A A2  	PRTS    " PPIDE1: Blocks=$"
0089E8  2  00 BD FD 89  
0089EC  2  E8 C9 24 F0  
008A0E  2  A9 01        	LDA	#$01
008A10  2  20 A0 8A     	JSR	IDE_READ_INFO		; GET DRIVE INFO, ABORT IF ERROR
008A13  2               IDE_INITA:
008A13  2  20 6B 88     	JSR	NEWLINE
008A16  2  60           	RTS				; DONE
008A17  2               ;
008A17  2               ;__PPIDE_PROBE_______________________________________________________________________________________
008A17  2               ;
008A17  2               ;  PROBE FOR IDE HARDWARE
008A17  2               ;____________________________________________________________________________________________________
008A17  2               ;
008A17  2               PPIDE_PROBE:
008A17  2               ;
008A17  2               	; BELOW TESTS FOR EXISTENCE OF AN IDE CONTROLLER ON THE
008A17  2               	; PPIDE INTERFACE.  WE WRITE A VALUE OF ZERO FIRST SO THAT
008A17  2               	; THE PPI BUS HOLD WILL RETURN A VALUE OF ZERO IF THERE IS
008A17  2               	; NOTHING CONNECTED TO PPI PORT A.  THEN WE READ THE STATUS
008A17  2               	; REGISTER.  IF AN IDE CONTROLLER IS THERE, IT SHOULD ALWAYS
008A17  2               	; RETURN SOMETHING OTHER THAN ZERO.  IF AN IDE CONTROLLER IS
008A17  2               	; THERE, THEN THE VALUE WRITTEN TO PPI PORT A IS IGNORED
008A17  2               	; BECAUSE THE WRITE SIGNAL IS NEVER PULSED.
008A17  2               
008A17  2  A9 00        	LDA 	#$00
008A19  2  8D 60 03     	STA 	PPIDELO 		; PPI PORT A, DATALO
008A1C  2               
008A1C  2  20 FD 8D     	JSR	IDE_WAIT_NOT_BUSY	; WAIT FOR BUSY TO CLEAR
008A1F  2  B0 34        	BCS 	PPIDE_PROBE_FAIL	; IF TIMEOUT, REPORT NO IDE PRESENT
008A21  2  A9 0F        	LDA	#PPIDE_STATUS		; GET STATUS
008A23  2  20 10 90     	JSR	IDE_READ
008A26  2  8A           	TXA
008A27  2  29 40        	AND 	#%01000000
008A29  2  C9 00        	CMP 	#$00
008A2B  2  F0 28        	BEQ 	PPIDE_PROBE_FAIL	; IF NOT RDY BIT (BIT 6) THEN REPORT NO IDE PRESENT
008A2D  2               
008A2D  2               	; CHECK SIGNATURE
008A2D  2  A9 0A        	LDA	#PPIDE_SEC_CNT
008A2F  2  20 10 90     	JSR	IDE_READ
008A32  2  E0 01        	CPX 	#$01
008A34  2  D0 1F        	BNE 	PPIDE_PROBE_FAIL	; IF not '01' THEN REPORT NO IDE PRESENT
008A36  2  A9 0B        	LDA	#PPIDE_LBALOW
008A38  2  20 10 90     	JSR	IDE_READ
008A3B  2  E0 01        	CPX 	#$01
008A3D  2  D0 16        	BNE 	PPIDE_PROBE_FAIL	; IF not '01' THEN REPORT NO IDE PRESENT
008A3F  2  A9 0C        	LDA	#PPIDE_LBAMID
008A41  2  20 10 90     	JSR	IDE_READ
008A44  2  E0 00        	CPX 	#$00
008A46  2  D0 0D        	BNE 	PPIDE_PROBE_FAIL	; IF not '00' THEN REPORT NO IDE PRESENT
008A48  2  A9 0D        	LDA	#PPIDE_LBAHI
008A4A  2  20 10 90     	JSR	IDE_READ
008A4D  2  E0 00        	CPX 	#$00
008A4F  2  D0 04        	BNE 	PPIDE_PROBE_FAIL	; IF not '00' THEN REPORT NO IDE PRESENT
008A51  2  18           	CLC
008A52  2  4C 56 8A     	JMP 	PPIDE_PROBE_SUCCESS
008A55  2               PPIDE_PROBE_FAIL:
008A55  2  38           	SEC
008A56  2               PPIDE_PROBE_SUCCESS:
008A56  2  60           	RTS				; DONE, NOTE THAT A=0 AND Z IS SET
008A57  2               
008A57  2               
008A57  2               ;___IDE_IDENTIFY_TYPE____________________________________________________________________________________
008A57  2               ;
008A57  2               ; 	READ THE DISK TYPE AND DETERMINE IF IT IS USABLE BY DOS/65
008A57  2               ; 	A=IDE DEVICE (0=MST,1=SLV)
008A57  2               ;________________________________________________________________________________________________________
008A57  2               
008A57  2               IDE_IDENTIFY_TYPE:
008A57  2  48           	PHA
008A58  2  20 FD 8D     	JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
008A5B  2  B0 40        	BCS 	IDE_IDENTIFY_TYPE_ERROR	; IF TIMEOUT, REPORT ERROR
008A5D  2  A9 00        	LDA 	#$00
008A5F  2  8D 12 05     	STA	debsehd
008A62  2  8D 10 05     	STA	debcyll			; STORE IN TRACK (lsb)
008A65  2  8D 11 05     	STA	debcylm			; STORE IN TRACK (msb)
008A68  2  68           	PLA				; GET DRIVE TYPE
008A69  2  20 DE 8C     	JSR 	IDE_READ_SECTOR_DIRTY1
008A6C  2  C9 FF        	CMP 	#$FF			; IS THERE A READ ERROR?
008A6E  2  F0 2D        	BEQ 	IDE_IDENTIFY_TYPE_ERROR
008A70  2  AD BB 98     	LDA 	hstbuf+$01FE
008A73  2  C9 55        	CMP 	#$55
008A75  2  D0 23        	BNE 	IDE_IDENTIFY_TYPE_OK
008A77  2  AD BC 98     	LDA 	hstbuf+$01FF
008A7A  2  C9 AA        	CMP 	#$AA
008A7C  2  D0 1C        	BNE 	IDE_IDENTIFY_TYPE_OK
008A7E  2  AD 7F 98     	LDA 	hstbuf+$01C2
008A81  2  C9 00        	CMP 	#$00
008A83  2  D0 18        	BNE 	IDE_IDENTIFY_TYPE_ERROR
008A85  2  AD 8F 98     	LDA 	hstbuf+$01D2
008A88  2  C9 00        	CMP 	#$00
008A8A  2  D0 11        	BNE 	IDE_IDENTIFY_TYPE_ERROR
008A8C  2  AD 9F 98     	LDA 	hstbuf+$01E2
008A8F  2  C9 00        	CMP 	#$00
008A91  2  D0 0A        	BNE 	IDE_IDENTIFY_TYPE_ERROR
008A93  2  AD AF 98     	LDA 	hstbuf+$01F2
008A96  2  C9 00        	CMP 	#$00
008A98  2  D0 03        	BNE 	IDE_IDENTIFY_TYPE_ERROR
008A9A  2               IDE_IDENTIFY_TYPE_OK:
008A9A  2  A9 00        	LDA 	#$00			; EVERYTHING IS AWESOME
008A9C  2  60           	RTS
008A9D  2               IDE_IDENTIFY_TYPE_ERROR:
008A9D  2  A9 FF        	LDA 	#$FF			; SIGNIFY ERROR
008A9F  2  60           	RTS
008AA0  2               
008AA0  2               
008AA0  2               ;*__IDE_READ_INFO___________________________________________________________________________________
008AA0  2               ;*
008AA0  2               ;*  READ IDE INFORMATION
008AA0  2               ;*	CARRY SET ON ERROR
008AA0  2               ;* 	A=MST/SLV
008AA0  2               ;*____________________________________________________________________________________________________
008AA0  2               IDE_READ_INFO:
008AA0  2  48 DA 5A A2  		PRTDBG "IDE Read INFORMATION$"
008AA4  2  00 BD C3 8A  
008AA8  2  E8 C9 24 F0  
008AD8  2  48           		PHA
008AD9  2  48           		PHA
008ADA  2               		; SET DRIVE BIT
008ADA  2  29 01        		AND 	#$01			; ONLY WANT THE 1 BIT (MST/SLV)
008ADC  2  0A           		asl	a			; SHIFT 4
008ADD  2  0A           		asl	a			;
008ADE  2  0A           		asl	a			;
008ADF  2  0A           		asl	a			;
008AE0  2  09 E0        		ORA 	#$E0			; E0=MST  F0=SLV
008AE2  2  AA           		TAX
008AE3  2  A0 00        		LDY	#$00
008AE5  2  A9 0E        		LDA	#PPIDE_DEVICE
008AE7  2  20 2E 90     		JSR	IDE_WRITE
008AEA  2               
008AEA  2               
008AEA  2  20 FD 8D     		JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
008AED  2  B0 4E        		BCS	IDE_READ_INFO_ABORT
008AEF  2  A9 0F        		LDA	#PPIDE_COMMAND		;SELECT IDE REGISTER
008AF1  2  A2 EC        		LDX	#PPIDE_CMD_ID
008AF3  2  20 2E 90     		JSR	IDE_WRITE		;ASK THE DRIVE TO READ IT
008AF6  2  20 25 8E     		JSR	IDE_WAIT_DRQ		;WAIT UNTIL IT'S GOT THE DATA
008AF9  2  B0 42        		BCS	IDE_READ_INFO_ABORT
008AFB  2  20 55 8E     		JSR	IDE_READ_BUFFER		; GRAB THE 256 WORDS FROM THE BUFFER
008AFE  2  48 DA 5A A2  		PRTS    "0x$"
008B02  2  00 BD 17 8B  
008B06  2  E8 C9 24 F0  
008B1A  2  AD 38 97     		LDA 	hstbuf+123
008B1D  2  20 49 88     		JSR 	PRTHEXBYTE
008B20  2  AD 37 97     		LDA 	hstbuf+122
008B23  2  20 49 88     		JSR 	PRTHEXBYTE
008B26  2  AD 36 97     		LDA 	hstbuf+121
008B29  2  20 49 88     		JSR 	PRTHEXBYTE
008B2C  2  AD 35 97     		LDA 	hstbuf+120
008B2F  2  20 49 88     		JSR 	PRTHEXBYTE
008B32  2  68           		PLA
008B33  2  20 57 8A     		JSR 	IDE_IDENTIFY_TYPE
008B36  2  C9 00        		CMP 	#$00
008B38  2  D0 32        		BNE 	IDE_READ_INFO_BADFS
008B3A  2  4C 9E 8B     		JMP 	IDE_READ_INFO_OK
008B3D  2               IDE_READ_INFO_ABORT:
008B3D  2  68           		PLA
008B3E  2  48 DA 5A A2  		PRTS    "NOT PRESENT$"		; NOT PRESENT
008B42  2  00 BD 57 8B  
008B46  2  E8 C9 24 F0  
008B63  2  20 6B 88     		JSR	NEWLINE
008B66  2  68           		PLA
008B67  2  20 D5 8B     		JSR 	IDE_REMOVE_DRIVE_ASSIGNMENTS
008B6A  2  38           		SEC
008B6B  2  60           		RTS				;
008B6C  2               IDE_READ_INFO_BADFS:
008B6C  2  48 DA 5A A2  		PRTS    " BAD FILESYSTEM$"	; NOT PRESENT
008B70  2  00 BD 85 8B  
008B74  2  E8 C9 24 F0  
008B95  2  20 6B 88     		JSR	NEWLINE
008B98  2  68           		PLA
008B99  2  20 D5 8B     		JSR 	IDE_REMOVE_DRIVE_ASSIGNMENTS
008B9C  2  38           		SEC
008B9D  2  60           		RTS				;
008B9E  2               IDE_READ_INFO_OK:
008B9E  2  48 DA 5A A2  		PRTS    " FILE SYSTEM COMPATIBLE$" ; NOT PRESENT
008BA2  2  00 BD B7 8B  
008BA6  2  E8 C9 24 F0  
008BCF  2  20 6B 88     		JSR	NEWLINE
008BD2  2  68           		PLA
008BD3  2  18           		CLC
008BD4  2  60           		RTS
008BD5  2               
008BD5  2               IDE_REMOVE_DRIVE_ASSIGNMENTS:
008BD5  2  18           		CLC
008BD6  2  69 30        		ADC	#$30
008BD8  2  A2 00        		LDX 	#$00
008BDA  2               @1:
008BDA  2  DD 14 05     		CMP 	dskcfg,X 		; GET device
008BDD  2  F0 09        		BEQ 	@2
008BDF  2  E8           		INX
008BE0  2  E8           		INX
008BE1  2  E0 10        		CPX 	#16
008BE3  2  D0 F5        		bne 	@1
008BE5  2  4C F8 8B     		jmp 	@3
008BE8  2               @2:
008BE8  2  48           		PHA
008BE9  2  A9 00        		LDA 	#$00
008BEB  2  9D 14 05     		STA 	dskcfg,X 		; SET device
008BEE  2  E8           		INX
008BEF  2  9D 14 05     		STA 	dskcfg,X 		; SET device
008BF2  2  68           		pla
008BF3  2  E8           		INX
008BF4  2  E0 10        		CPX 	#16
008BF6  2  D0 E2        		bne 	@1
008BF8  2               @3:
008BF8  2  60           		rts
008BF9  2               
008BF9  2               ;__IDE_PPIDETECT____________________________________________________________________________________
008BF9  2               ;
008BF9  2               ;  PROBE FOR PPI HARDWARE
008BF9  2               ;____________________________________________________________________________________________________
008BF9  2               ;
008BF9  2               IDE_PPIDETECT:
008BF9  2               ;
008BF9  2               	; TEST FOR PPI EXISTENCE
008BF9  2               	; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
008BF9  2               	; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
008BF9  2               	; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
008BF9  2               	; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
008BF9  2               	; INTERFERE WITH THE VALUE BEING READ.
008BF9  2  20 52 90     	JSR	SET_PPI_WR
008BFC  2               ;
008BFC  2  A9 00        	LDA     #$00			; VALUE ZERO
008BFE  2  8D 60 03     	STA	PPIDELO			; PUSH VALUE TO PORT
008C01  2  AD 60 03     	LDA	PPIDELO			; GET PORT VALUE
008C04  2  C9 00                CMP     #$00
008C06  2  60           	RTS				; AND RETURN
008C07  2               ;
008C07  2               
008C07  2               
008C07  2               ;*__IDE_READ_SECTOR___________________________________________________________________________________
008C07  2               ;*
008C07  2               ;*  READ IDE SECTOR (IN LBA) INTO BUFFER
008C07  2               ;*
008C07  2               ;*____________________________________________________________________________________________________
008C07  2               IDE_READ_SECTOR:
008C07  2  48 DA 5A A2  		PRTDBG "IDE Read Sector$"
008C0B  2  00 BD 2A 8C  
008C0F  2  E8 C9 24 F0  
008C3A  2  20 41 8C     		JSR 	IDE_READ_RAW_SECTOR
008C3D  2  20 57 96     		JSR 	DEBSECR512
008C40  2  60           		RTS
008C41  2               
008C41  2               IDE_READ_RAW_SECTOR:
008C41  2  48 DA 5A A2  		PRTDBG "IDE Read Raw Sector$"
008C45  2  00 BD 64 8C  
008C49  2  E8 C9 24 F0  
008C78  2  20 24 8F     	  	JSR	IDE_CONVERT_SECTOR	;
008C7B  2               
008C7B  2  AD 12 05     		LDA	debsehd			; STORE CURRENT PARMS
008C7E  2  CD 60 90     		CMP	Cdebsehd		;
008C81  2  D0 13        		BNE	IDE_READ_SECTOR_DIRTY
008C83  2  AD 11 05     		LDA	debcylm			;
008C86  2  CD 5F 90     		CMP	Cdebcylm		;
008C89  2  D0 0B        		BNE	IDE_READ_SECTOR_DIRTY
008C8B  2  AD 10 05     		LDA	debcyll			;
008C8E  2  CD 5E 90     		CMP	Cdebcyll		;
008C91  2  D0 03        		BNE	IDE_READ_SECTOR_DIRTY
008C93  2  A9 00        		LDA	#$00			; ZERO = 1 ON RETURN = OPERATION OK
008C95  2  60           		RTS
008C96  2               
008C96  2               IDE_READ_SECTOR_DIRTY:
008C96  2  48 DA 5A A2  		PRTDBG "IDE Read Sector Buffer Dirty$"
008C9A  2  00 BD B9 8C  
008C9E  2  E8 C9 24 F0  
008CD6  2  20 FD 8D     		JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
008CD9  2  B0 2A        		BCS 	IDE_READ_SECTOR_DIRTY_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
008CDB  2  20 A1 96     		JSR 	GET_DRIVE_DEVICE
008CDE  2               IDE_READ_SECTOR_DIRTY1:
008CDE  2  20 C1 8E     		JSR	IDE_SETUP_LBA		;TELL IT WHICH SECTOR WE WANT
008CE1  2  A9 0F        		LDA	#PPIDE_COMMAND		;SELECT IDE REGISTER
008CE3  2  A2 20        		LDX	#PPIDE_CMD_READ
008CE5  2  20 2E 90     		JSR	IDE_WRITE		;ASK THE DRIVE TO READ IT
008CE8  2  20 25 8E     		JSR	IDE_WAIT_DRQ		;WAIT UNTIL IT'S GOT THE DATA
008CEB  2  B0 18        		BCS 	IDE_READ_SECTOR_DIRTY_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
008CED  2  20 55 8E     		JSR	IDE_READ_BUFFER		; GRAB THE 256 WORDS FROM THE BUFFER
008CF0  2  AD 12 05     		LDA	debsehd			; STORE CURRENT PARMS
008CF3  2  8D 60 90     		STA	Cdebsehd		;
008CF6  2  AD 10 05     		LDA	debcyll			;
008CF9  2  8D 5E 90     		STA	Cdebcyll		;
008CFC  2  AD 11 05     		LDA	debcylm			;
008CFF  2  8D 5F 90     		STA	Cdebcylm		;
008D02  2               
008D02  2  A9 00        		LDA	#$00			; ZERO = 1 ON RETURN = OPERATION OK
008D04  2  60           		RTS
008D05  2               IDE_READ_SECTOR_DIRTY_ERROR:
008D05  2  A9 FF        		LDA	#$FF			; ZERO = 1 ON RETURN = OPERATION OK
008D07  2  60           		RTS
008D08  2               
008D08  2               ;*__IDE_WRITE_SECTOR__________________________________________________________________________________
008D08  2               ;*
008D08  2               ;*  WRITE IDE SECTOR (IN LBA) FROM BUFFER
008D08  2               ;*
008D08  2               ;*____________________________________________________________________________________________________
008D08  2               IDE_WRITE_SECTOR:
008D08  2  48 DA 5A A2  		PRTDBG "IDE Write Sector$"
008D0C  2  00 BD 2B 8D  
008D10  2  E8 C9 24 F0  
008D3C  2  20 41 8C     	  	JSR	IDE_READ_RAW_SECTOR	; determine physical sector
008D3F  2  20 80 96     	  	JSR	BLKSECR512		; block sector for writing
008D42  2  20 FD 8D     		JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
008D45  2  B0 28        		BCS 	IDE_WRITE_SECTOR_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
008D47  2  20 A1 96     		JSR 	GET_DRIVE_DEVICE
008D4A  2  20 C1 8E     		JSR	IDE_SETUP_LBA		;TELL IT WHICH SECTOR WE WANT
008D4D  2  A9 0F        		LDA	#PPIDE_COMMAND
008D4F  2  A2 30        		LDX	#PPIDE_CMD_WRITE
008D51  2  20 2E 90     		JSR	IDE_WRITE		;TELL DRIVE TO WRITE A SECTOR
008D54  2  20 25 8E     		JSR	IDE_WAIT_DRQ		;WAIT UNIT IT WANTS THE DATA
008D57  2  B0 16        		BCS 	IDE_WRITE_SECTOR_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
008D59  2  20 8A 8E     		JSR	IDE_WRITE_BUFFER	;GIVE THE DATA TO THE DRIVE
008D5C  2  20 FD 8D     		JSR	IDE_WAIT_NOT_BUSY	;WAIT UNTIL THE WRITE IS COMPLETE
008D5F  2  B0 0E        		BCS 	IDE_WRITE_SECTOR_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
008D61  2  A9 FF        		LDA	#$FF			; STORE CURRENT PARMS
008D63  2  8D 60 90     		STA	Cdebsehd		;
008D66  2  8D 5E 90     		STA	Cdebcyll		;
008D69  2  8D 5F 90     		STA	Cdebcylm		;
008D6C  2               
008D6C  2  A9 00        		LDA	#$00			; ZERO ON RETURN = OPERATION OK
008D6E  2  60           		RTS
008D6F  2               IDE_WRITE_SECTOR_ERROR:
008D6F  2  A9 FF        		LDA	#$FF			; 1 ON RETURN = OPERATION FAIL
008D71  2  60           		RTS
008D72  2               
008D72  2               ;*__PPIDE_RESET____________________________________________________________________________________
008D72  2               ;*
008D72  2               ;*  SOFT RESET IDE CHANNEL
008D72  2               ;*
008D72  2               ;*____________________________________________________________________________________________________
008D72  2               PPIDE_RESET:
008D72  2  48 DA 5A A2    	PRTDBG "IDE Reset$"
008D76  2  00 BD 95 8D  
008D7A  2  E8 C9 24 F0  
008D9F  2  A9 00        		LDA	#$00
008DA1  2  8D 12 05     		STA	debsehd
008DA4  2  8D 10 05     		STA	debcyll
008DA7  2  8D 11 05     		STA	debcylm
008DAA  2  A9 FF        		LDA	#$FF			;
008DAC  2  8D 60 90     		STA	Cdebsehd		;
008DAF  2  8D 5E 90     		STA	Cdebcyll		;
008DB2  2  8D 5F 90     		STA	Cdebcylm		;
008DB5  2               
008DB5  2  A9 80        		LDA	#PPIDE_RST_LINE
008DB7  2  8D 62 03     		STA	PPIDECNTRL			; ASSERT RST LINE ON IDE INTERFACE
008DBA  2  A2 00        		LDX	#$00
008DBC  2  48 DA 5A A2  	PRTDBG "IDE Reset Delay$"
008DC0  2  00 BD DF 8D  
008DC4  2  E8 C9 24 F0  
008DEF  2               RST_DLY:
008DEF  2  CA           		DEX
008DF0  2  E0 00        		CPX	#$00
008DF2  2  D0 FB        		BNE	RST_DLY
008DF4  2  A9 00        		LDA	#$00
008DF6  2  8D 62 03     		STA	PPIDECNTRL			; DEASSERT RST LINE ON IDE INTERFACE
008DF9  2               
008DF9  2               ; IF A DSKYNG IS ACTIVE AND IS ON THE SAME PPI PORT AS THE PPISD BEING
008DF9  2               ; RESET, THEN THE DSKYNG WILL ALSO BE RESET.  SO, THE DSKY IS ALSO INITIALIZED.
008DF9  2               	.IF (USEDSKYNG=1)
008DF9  2  20 7E 91     	JSR 	DSKY_REINIT
008DFC  2               	.ENDIF
008DFC  2               
008DFC  2  60           		RTS
008DFD  2               
008DFD  2               
008DFD  2               ;*__IDE_WAIT_NOT_BUSY_______________________________________________________________________________
008DFD  2               ;*
008DFD  2               ;*  WAIT FOR IDE CHANNEL TO BECOME READY
008DFD  2               ;*
008DFD  2               ;*____________________________________________________________________________________________________
008DFD  2               IDE_WAIT_NOT_BUSY:
008DFD  2  DA           		PHX
008DFE  2  5A           		PHY
008DFF  2  48           		PHA
008E00  2  A9 00        		LDA #$00
008E02  2  8D FA 88     		STA PPIDETIMEOUT
008E05  2  8D FB 88     		STA PPIDETIMEOUT+1
008E08  2               IDE_WAIT_NOT_BUSY1:
008E08  2  A9 0F        		LDA	#PPIDE_STATUS		;WAIT FOR RDY BIT TO BE SET
008E0A  2  20 10 90     		JSR	IDE_READ
008E0D  2  8A           		TXA
008E0E  2  29 80        		AND	#$80
008E10  2  F0 0E        		BEQ	IDE_WAIT_NOT_BUSY2
008E12  2  EE FA 88     		INC 	PPIDETIMEOUT
008E15  2  D0 F1        		BNE 	IDE_WAIT_NOT_BUSY1
008E17  2  EE FB 88     		INC 	PPIDETIMEOUT+1
008E1A  2  D0 EC        		BNE 	IDE_WAIT_NOT_BUSY1
008E1C  2  38           		SEC
008E1D  2  4C 21 8E     		JMP	IDE_WAIT_NOT_BUSY3
008E20  2               IDE_WAIT_NOT_BUSY2:
008E20  2  18           		CLC
008E21  2               IDE_WAIT_NOT_BUSY3:
008E21  2  68           		PLA
008E22  2  7A           		PLY
008E23  2  FA           		PLX
008E24  2  60           		RTS
008E25  2               
008E25  2               ;*__IDE_WAIT_DRQ______________________________________________________________________________________
008E25  2               ;*
008E25  2               ;*	WAIT FOR THE DRIVE TO BE READY TO TRANSFER DATA.
008E25  2               ;*
008E25  2               ;*____________________________________________________________________________________________________
008E25  2               IDE_WAIT_DRQ:
008E25  2  DA           		PHX
008E26  2  5A           		PHY
008E27  2  48           		PHA
008E28  2  A9 00        		LDA #$00
008E2A  2  8D FA 88     		STA PPIDETIMEOUT
008E2D  2  8D FB 88     		STA PPIDETIMEOUT+1
008E30  2               IDE_WAIT_DRQ1:
008E30  2  A9 0F        		LDA	#PPIDE_STATUS		;WAIT FOR DRQ BIT TO BE SET
008E32  2  20 10 90     		JSR	IDE_READ
008E35  2  8A           		TXA
008E36  2  29 88        		AND	#%10001000		; MASK OFF BUSY(7) AND DRQ(3)
008E38  2  C9 08        		CMP	#%00001000		; WE WANT BUSY(7) TO BE 0 AND DRQ (3) TO BE 1
008E3A  2  F0 14        		BEQ	IDE_WAIT_DRQ2
008E3C  2  29 01        		AND	#%00000001		; IS ERROR?
008E3E  2  C9 01        		CMP	#%00000001		;
008E40  2  F0 0A        		BEQ	IDE_WAIT_DRQE
008E42  2  EE FA 88     		INC 	PPIDETIMEOUT
008E45  2  D0 E9        		BNE 	IDE_WAIT_DRQ1
008E47  2  EE FB 88     		INC 	PPIDETIMEOUT+1
008E4A  2  D0 E4        		BNE 	IDE_WAIT_DRQ1
008E4C  2               IDE_WAIT_DRQE:
008E4C  2  38           		SEC
008E4D  2  4C 51 8E     		JMP	IDE_WAIT_DRQ3
008E50  2               IDE_WAIT_DRQ2:
008E50  2  18           		CLC
008E51  2               IDE_WAIT_DRQ3:
008E51  2  68           		PLA
008E52  2  7A           		PLY
008E53  2  FA           		PLX
008E54  2  60           		RTS
008E55  2               
008E55  2               
008E55  2               
008E55  2               ;*__IDE_READ_BUFFER___________________________________________________________________________________
008E55  2               ;*
008E55  2               ;*  READ IDE BUFFER LITTLE ENDIAN
008E55  2               ;*
008E55  2               ;*____________________________________________________________________________________________________
008E55  2               IDE_READ_BUFFER:
008E55  2  A2 00        		LDX    	#$00			; INDEX
008E57  2               IDEBUFRD:
008E57  2  8E F9 88     		STX	PPIDEINDEX
008E5A  2  A9 08        		LDA	#PPIDE_DATA
008E5C  2  20 10 90     		JSR	IDE_READ
008E5F  2  8A           		TXA
008E60  2  AE F9 88     		LDX	PPIDEINDEX
008E63  2  9D BD 96     		STA	hstbuf,X		;
008E66  2  E8           		INX				;
008E67  2  98           		TYA				; THEN HIGH BYTE OF WORD
008E68  2  9D BD 96     		STA	hstbuf,X		;
008E6B  2  E8           		INX
008E6C  2  E0 00        		CPX    	#$00			;
008E6E  2  D0 E7        		BNE	IDEBUFRD		;
008E70  2               IDEBUFRD1:
008E70  2  8E F9 88     		STX	PPIDEINDEX
008E73  2  A9 08        		LDA	#PPIDE_DATA
008E75  2  20 10 90     		JSR	IDE_READ
008E78  2  8A           		TXA
008E79  2  AE F9 88     		LDX	PPIDEINDEX
008E7C  2  9D BD 97     		STA	hstbuf+256,X		;
008E7F  2  E8           		INX				;
008E80  2  98           		TYA				; THEN HIGH BYTE OF WORD
008E81  2  9D BD 97     		STA	hstbuf+256,X		;
008E84  2  E8           		INX				;
008E85  2  E0 00        		CPX    	#$00			;
008E87  2  D0 E7        		BNE	IDEBUFRD1		;
008E89  2  60           		RTS				;
008E8A  2               
008E8A  2               ;*__IDE_WRITE_BUFFER___________________________________________________________________________________
008E8A  2               ;*
008E8A  2               ;*  WRITE IDE BUFFER LITTLE ENDIAN
008E8A  2               ;*
008E8A  2               ;*____________________________________________________________________________________________________
008E8A  2               IDE_WRITE_BUFFER:
008E8A  2  A2 00        		LDX    	#$00			; INDEX
008E8C  2               IDEBUFWT:
008E8C  2  8E F9 88     		STX	PPIDEINDEX
008E8F  2  BD BE 96     		LDA     hstbuf+1,X		; SECTORS ARE BIG ENDIAN
008E92  2  A8           		TAY				;
008E93  2  BD BD 96     		LDA     hstbuf,X		; SECTORS ARE BIG ENDIAN
008E96  2  AA           		TAX
008E97  2  A9 08        		LDA	#PPIDE_DATA
008E99  2  20 2E 90     		JSR	IDE_WRITE
008E9C  2  AE F9 88     		LDX	PPIDEINDEX
008E9F  2  E8           		INX				;
008EA0  2  E8           		INX				;
008EA1  2  E0 00        		CPX    	#$00			;
008EA3  2  D0 E7        		BNE	IDEBUFWT		;
008EA5  2  A2 00        		LDX    	#$00			; INDEX
008EA7  2               IDEBUFWT1:
008EA7  2  8E F9 88     		STX	PPIDEINDEX
008EAA  2  BD BE 97     		LDA     hstbuf+257,X		; SECTORS ARE BIG ENDIAN
008EAD  2  A8           		TAY
008EAE  2  BD BD 97     		LDA     hstbuf+256,X		; SECTORS ARE BIG ENDIAN
008EB1  2  AA           		TAX
008EB2  2  A9 08        		LDA	#PPIDE_DATA
008EB4  2  20 2E 90     		JSR	IDE_WRITE
008EB7  2  AE F9 88     		LDX	PPIDEINDEX
008EBA  2  E8           		INX				;
008EBB  2  E8           		INX				;
008EBC  2  E0 00        		CPX    	#$00			;
008EBE  2  D0 E7        		BNE	IDEBUFWT1		;
008EC0  2  60           		RTS				;
008EC1  2               
008EC1  2               ;*__IDE_SETUP_LBA_____________________________________________________________________________________
008EC1  2               ;*
008EC1  2               ;*  SETUP LBA DATA
008EC1  2               ;*  A= DRIVE DEVICE
008EC1  2               ;*____________________________________________________________________________________________________
008EC1  2               IDE_SETUP_LBA:
008EC1  2  48 DA 5A A2  		PRTDBG "PPIDE SETUP LBA$"
008EC5  2  00 BD E4 8E  
008EC9  2  E8 C9 24 F0  
008EF4  2  29 01        		and 	#$01			; only want drive cfg
008EF6  2  0A           		asl	a			; SHIFT 4
008EF7  2  0A           		asl	a			;
008EF8  2  0A           		asl	a			;
008EF9  2  0A           		asl	a			;
008EFA  2  09 E0        		ORA 	#$E0			; E0=MST  F0=SLV
008EFC  2  AA           		TAX
008EFD  2  A0 00        		LDY	#$00
008EFF  2  A9 0E        		LDA	#PPIDE_DEVICE
008F01  2  20 2E 90     		JSR	IDE_WRITE
008F04  2               
008F04  2  AE 11 05     		LDX    	debcylm
008F07  2  A9 0D        		LDA	#PPIDE_LBAHI
008F09  2  20 2E 90     		JSR	IDE_WRITE
008F0C  2               
008F0C  2  AE 10 05     		LDX    	debcyll			;
008F0F  2  A9 0C        		LDA	#PPIDE_LBAMID
008F11  2  20 2E 90     		JSR	IDE_WRITE
008F14  2               
008F14  2  AE 12 05     		LDX    	debsehd			;
008F17  2  A9 0B        		LDA	#PPIDE_LBALOW
008F19  2  20 2E 90     		JSR	IDE_WRITE
008F1C  2               
008F1C  2  A2 01        		LDX	#$01
008F1E  2  A9 0A        		LDA	#PPIDE_SEC_CNT
008F20  2  20 2E 90     		JSR	IDE_WRITE
008F23  2               
008F23  2  60           		RTS
008F24  2               
008F24  2               ;___IDE_CONVERT_SECTOR___________________________________________________________________________________
008F24  2               ;
008F24  2               ; 	TRANSLATE SECTORS INTO IDE FORMAT
008F24  2               ;________________________________________________________________________________________________________
008F24  2               IDE_CONVERT_SECTOR:
008F24  2  AD 0C 05     	LDA	sektrk			; LOAD TRACK # (LOW BYTE)
008F27  2  29 0F        	AND 	#$0F			; ISOLATE HEAD IN LOW 4 BITS
008F29  2  0A           	asl	a			; MOVE TO HIGH BYTE
008F2A  2  0A           	asl	a
008F2B  2  0A           	asl	a
008F2C  2  0A           	asl	a
008F2D  2  AA           	TAX 				; PARK IN X
008F2E  2  AD 0E 05     	LDA	seksec			; LOAD SECTOR # (LOW BYTE)
008F31  2  4A           	LSR	A			;
008F32  2  4A           	LSR	A			; DIVIDE BY 4 (FOR BLOCKING)
008F33  2  29 0F        	AND 	#$0F 			; CLEAR UPPER 4 BITS (JUST 'CAUSE)
008F35  2  8D 12 05     	STA	debsehd			; STORE IN SECTOR/HEAD
008F38  2  8A           	TXA 				; GET HEAD BACK
008F39  2  0D 12 05     	ORA 	debsehd
008F3C  2  8D 12 05     	STA	debsehd			; STORE IN SECTOR/HEAD
008F3F  2               
008F3F  2  AD 0C 05     	LDA 	sektrk
008F42  2  8D 10 05     	STA	debcyll			; STORE IN TRACK (lsb)
008F45  2  AD 0D 05     	LDA 	sektrk+1
008F48  2  8D 11 05     	STA	debcylm			; STORE IN TRACK (msb)
008F4B  2               					; REMOVE HEAD FROM TRACK VALUE (DIV/4)
008F4B  2  AD 11 05     	LDA	debcylm
008F4E  2  4A           	LSR 	A
008F4F  2  8D 11 05     	STA	debcylm
008F52  2  AD 10 05     	LDA	debcyll
008F55  2  6A           	ROR 	A
008F56  2  8D 10 05     	STA	debcyll
008F59  2               
008F59  2  AD 11 05     	LDA	debcylm
008F5C  2  4A           	LSR 	A
008F5D  2  8D 11 05     	STA	debcylm
008F60  2  AD 10 05     	LDA	debcyll
008F63  2  6A           	ROR 	A
008F64  2  8D 10 05     	STA	debcyll
008F67  2               
008F67  2  AD 11 05     	LDA	debcylm
008F6A  2  4A           	LSR 	A
008F6B  2  8D 11 05     	STA	debcylm
008F6E  2  AD 10 05     	LDA	debcyll
008F71  2  6A           	ROR 	A
008F72  2  8D 10 05     	STA	debcyll
008F75  2               
008F75  2  AD 11 05     	LDA	debcylm
008F78  2  4A           	LSR 	A
008F79  2  8D 11 05     	STA	debcylm
008F7C  2  AD 10 05     	LDA	debcyll
008F7F  2  6A           	ROR 	A
008F80  2  8D 10 05     	STA	debcyll
008F83  2               
008F83  2               ;	ADD SLICE OFFSET
008F83  2  AD 13 05     	LDA	sekdsk			; GET DRIVE#
008F86  2  29 07        	AND 	#7			; ONLY FIRST 8 DEVICES SUPPORTED
008F88  2  0A           	asl	a			; DOUBLE NUMBER FOR TABLE LOOKUP
008F89  2  AA           	TAX 				; MOVE TO X REGISTER
008F8A  2  E8           	INX				; WANT SECOND BYTE OF ENTRY
008F8B  2  BD 14 05     	LDA 	dskcfg,X 		; GET SLICE#
008F8E  2  8D 63 90     	STA 	slicetmp+1 		; SLICE OFFSET MSB
008F91  2  A9 00        	LDA 	#0	 		; GET SLICE#
008F93  2  8D 62 90     	STA 	slicetmp		; SLICE OFFSET LSB
008F96  2  18           	CLC				; VOODOO MATH TO TAKE SLICE*$4000
008F97  2  6E 63 90     	ROR 	slicetmp+1
008F9A  2  6E 62 90     	ROR	slicetmp
008F9D  2  6E 63 90     	ROR 	slicetmp+1
008FA0  2  6E 62 90     	ROR	slicetmp
008FA3  2               
008FA3  2  BD 14 05     	LDA 	dskcfg,X 		; GET SLICE#
008FA6  2  18           	clc
008FA7  2  6D 62 90     	adc 	slicetmp
008FAA  2  8D 62 90     	sta 	slicetmp
008FAD  2               					; ADD SLICE OFFSET TO TRACK #
008FAD  2  18           	clc				; clear carry
008FAE  2  AD 62 90     	lda slicetmp
008FB1  2  6D 10 05     	adc debcyll
008FB4  2  8D 10 05     	sta debcyll			; store sum of LSBs
008FB7  2  AD 63 90     	lda slicetmp+1
008FBA  2  6D 11 05     	adc debcylm			; add the MSBs using carry from
008FBD  2  8D 11 05     	sta debcylm			; the previous calculation
008FC0  2               
008FC0  2               
008FC0  2               
008FC0  2               
008FC0  2                 .IF USEDSKY=1 || USEDSKYNG=1
008FC0  2  48 DA 5A A2    	PRTDBG "DSKY OUTPUT 1$"
008FC4  2  00 BD E3 8F  
008FC8  2  E8 C9 24 F0  
008FF1  2  AD 13 05       	lda	sekdsk
008FF4  2  8D 08 05       	sta	DSKY_HEXBUF
008FF7  2  AD 11 05      	lda	debcylm
008FFA  2  8D 09 05       	sta	DSKY_HEXBUF+1
008FFD  2  AD 10 05      	lda	debcyll
009000  2  8D 0A 05       	sta	DSKY_HEXBUF+2
009003  2  AD 12 05         	lda	debsehd
009006  2  8D 0B 05       	sta	DSKY_HEXBUF+3
009009  2  20 04 92       	JSR	DSKY_BIN2SEG
00900C  2  20 39 92     	JSR	DSKY_SHOW
00900F  2                 .ENDIF
00900F  2  60           	RTS
009010  2               
009010  2               
009010  2               ;-------------------------------------------------------------------------------
009010  2               
009010  2               ; LOW LEVEL I/O TO THE DRIVE.  THESE ARE THE ROUTINES THAT TALK
009010  2               ; DIRECTLY TO THE DRIVE, VIA THE 8255 CHIP.  NORMALLY A MAIN
009010  2               ; PROGRAM WOULD NOT CALL TO THESE.
009010  2               
009010  2               	;DO A READ BUS CYCLE TO THE DRIVE, USING THE 8255.
009010  2               	;INPUT A = IDE REGSITER ADDRESS
009010  2               	;OUTPUT X = LOWER BYTE READ FROM IDE DRIVE
009010  2               	;OUTPUT Y = UPPER BYTE READ FROM IDE DRIVE
009010  2               
009010  2               IDE_READ:
009010  2  20 4A 90     	JSR	SET_PPI_RD		; SETUP FOR A READ CYCLE
009013  2               
009013  2  8D 62 03     	STA	PPIDECNTRL		;DRIVE ADDRESS ONTO CONTROL LINES
009016  2  09 40        	ORA	#PPIDE_RD_LINE		; ASSERT RD PIN
009018  2  8D 62 03     	STA	PPIDECNTRL
00901B  2  48           	PHA
00901C  2               
00901C  2  AE 60 03     	LDX	PPIDELO			; READ LOWER BYTE
00901F  2  AC 61 03     	LDY	PPIDEHI			; READ UPPER BYTE
009022  2               
009022  2  68           	PLA				; RESTORE REGISTER VALUE
009023  2  49 40        	EOR	#PPIDE_RD_LINE		; DE-ASSERT RD SIGNAL
009025  2  8D 62 03     	STA	PPIDECNTRL
009028  2  A9 00        	LDA	#$00
00902A  2  8D 62 03     	STA	PPIDECNTRL		;DEASSERT ALL CONTROL PINS
00902D  2  60           	RTS
00902E  2               
00902E  2               
00902E  2               
00902E  2               
00902E  2               	;DO A WRITE BUS CYCLE TO THE DRIVE, VIA THE 8255
00902E  2               	;INPUT A = IDE REGISTER ADDRESS
00902E  2               	;INPUT REGISTER X = LSB TO WRITE
00902E  2               	;INPUT REGISTER Y = MSB TO WRITE
00902E  2               	;
00902E  2               
00902E  2               
00902E  2               IDE_WRITE:
00902E  2  20 52 90     	JSR	SET_PPI_WR		; SETUP FOR A WRITE CYCLE
009031  2               
009031  2  8E 60 03     	STX	PPIDELO			; WRITE LOWER BYTE
009034  2  8C 61 03     	STY	PPIDEHI			; WRITE UPPER BYTE
009037  2               
009037  2  8D 62 03     	STA	PPIDECNTRL		;DRIVE ADDRESS ONTO CONTROL LINES
00903A  2               
00903A  2  09 20        	ORA	#PPIDE_WR_LINE		; ASSERT WRITE PIN
00903C  2  8D 62 03     	STA	PPIDECNTRL
00903F  2               
00903F  2  49 20        	EOR	#PPIDE_WR_LINE		; DE ASSERT WR PIN
009041  2  8D 62 03     	STA	PPIDECNTRL
009044  2               
009044  2  A9 00        	LDA	#$00
009046  2  8D 62 03     	STA	PPIDECNTRL		;DEASSERT ALL CONTROL PINS
009049  2  60           	RTS
00904A  2               
00904A  2               
00904A  2               ;-----------------------------------------------------------------------------------
00904A  2               ; PPI SETUP ROUTINE TO CONFIGURE THE APPROPRIATE PPI MODE
00904A  2               ;
00904A  2               ;------------------------------------------------------------------------------------
00904A  2               
00904A  2               SET_PPI_RD:
00904A  2  48           	PHA
00904B  2  A9 92        	LDA	#PPRD_IDE_8255
00904D  2  8D 63 03     	STA	PPIDEPPIC				;CONFIG 8255 CHIP, READ MODE
009050  2  68           	PLA
009051  2  60           	RTS
009052  2               
009052  2               SET_PPI_WR:
009052  2  48           	PHA
009053  2  A9 80        	LDA	#PPWR_IDE_8255
009055  2  8D 63 03     	STA	PPIDEPPIC				;CONFIG 8255 CHIP, WRITE MODE
009058  2  68           	PLA
009059  2  60           	RTS
00905A  2               
00905A  2               
00905A  2               ;allocate the following data areas to unused ram space
00905A  2  00           LASTCHAR: 	.byte 0		;save sector for warm boot
00905B  2  00           savsec:		.byte 0		;save sector for warm boot
00905C  2  00           count:		.byte 0		;counter in warm boot
00905D  2  00           temp:		.byte 0		;save hstdsk for warm boot
00905E  2  00           Cdebcyll:	.byte 0		; DEBLOCKED CYLINDER LSB
00905F  2  00           Cdebcylm:	.byte 0		; DEBLOCKED CYLINDER MSB
009060  2  00           Cdebsehd:	.byte 0		; DEBLOCKED SECTOR AND HEAD (HS)
009061  2  00           DEBDIRTY:	.byte 0		; DIRTY FLAG
009062  2  00 00        slicetmp:	.word 0		; USED TO CALCULATE SLICE OFFSET
009064  2               
009064  1               		.INCLUDE "dosdskyn.asm"
009064  2               ;__DSKYNG DRIVERS_________________________________________________________________________________________________________________
009064  2               ;
009064  2               ; 	Nhyodyne DSKY/NG drivers
009064  2               ;
009064  2               ;	Entry points:
009064  2               ;               DSKY_INIT
009064  2               ;               DSKY_SHOW
009064  2               ;               DSKY_BIN2SEG
009064  2               ;               DSKY_RESET
009064  2               ;               DSKY_STAT
009064  2               ;               DSKY_GETKEY
009064  2               ;               DSKY_BEEP
009064  2               ;               DSKY_L1ON
009064  2               ;               DSKY_L2ON
009064  2               ;               DSKY_L1OFF
009064  2               ;               DSKY_L2OFF
009064  2               ;               DSKY_PUTLED
009064  2               ;               DSKY_BLANK
009064  2               ;________________________________________________________________________________________________________________________________
009064  2               ;
009064  2               ;
009064  2               ; A DSKYNG CAN SHARE A PPI BUS WITH EITHER A PPIDE OR PPISD.
009064  2               ;
009064  2               ; LED SEGMENTS (BIT VALUES)
009064  2               ;
009064  2               ;	+--01--+
009064  2               ;	20    02
009064  2               ;	+--40--+
009064  2               ;	10    04
009064  2               ;	+--08--+  80
009064  2               ;
009064  2               ; KEY CODE MAP (KEY CODES) CSCCCRRR
009064  2               ;                          ||||||||
009064  2               ;                          |||||+++-- ROW
009064  2               ;                          ||+++----- COL
009064  2               ;                          |+-------- SHIFT
009064  2               ;                          +--------- CONTROL
009064  2               ;
009064  2               ;	00	08	10	18	23
009064  2               ;	01	09	11	19	22
009064  2               ;	02	0A	12	1A	21
009064  2               ;	03	0B	13	1B	20
009064  2               ;	04	0C	14	1C	SHIFT
009064  2               ;	05	0D	15	1D	CTRL
009064  2               ;
009064  2               ; LED BIT MAP (BIT VALUES)
009064  2               ;
009064  2               ;	$08	$09	$0A	$0B	$0C	$0D	$0E	$0F
009064  2               ;	---	---	---	---	---	---	---	---
009064  2               ;	01	01	01	01	01
009064  2               ;	02	02	02	02	02
009064  2               ;	04      04      04      04	04
009064  2               ;	08      08      08      08	08
009064  2               ;	10      10      10      10	10
009064  2               ;	20      20      20      20	20	L1	L2 	BUZZ
009064  2               ;
009064  2               DSKY_PPI	=	$0360		; PORT
009064  2               DSKY_PPIA	= 	DSKY_PPI + 0 	; PORT A
009064  2               DSKY_PPIB	= 	DSKY_PPI + 1 	; PORT B
009064  2               DSKY_PPIC	= 	DSKY_PPI + 2    ; PORT C
009064  2               DSKY_PPIX 	= 	DSKY_PPI + 3    ; PPI CONTROL PORT
009064  2               ;
009064  2               DSKY_PPIX_RD	=	%10010010	; PPIX VALUE FOR READS
009064  2               DSKY_PPIX_WR	=	%10000010	; PPIX VALUE FOR WRITES
009064  2               ;
009064  2               ; PIO CHANNEL C:
009064  2               ;
009064  2               ;	7	6	5	4	3	2	1	0
009064  2               ;	RES	0	0	CS	CS	/RD	/WR	A0
009064  2               ;
009064  2               ; SETTING BITS 3 & 4 WILL ASSERT /CS ON 3279
009064  2               ; CLEAR BITS 1 OR 2 TO ASSERT READ/WRITE
009064  2               ;
009064  2               DSKY_PPI_IDLE	=	%00000110
009064  2               ;
009064  2               DSKY_CMD_CLR	=	%11011111	; CLEAR (ALL OFF)
009064  2               DSKY_CMD_CLRX	=	%11010011	; CLEAR (ALL ON)
009064  2               DSKY_CMD_WDSP	=	%10010000	; WRITE DISPLAY RAM
009064  2               DSKY_CMD_RDSP	=	%01110000	; READ DISPLAY RAM
009064  2               DSKY_CMD_CLK	=	%00100000	; SET CLK PRESCALE
009064  2               DSKY_CMD_FIFO	=	%01000000	; READ FIFO
009064  2               ;
009064  2               DSKY_PRESCL	=	DSKYOSC/100000	; PRESCALER
009064  2               ;
009064  2               ;__DSKY_INIT_________________________________________________________________________________________
009064  2               ;
009064  2               ;  DISPLAY DSKY INFO
009064  2               ;____________________________________________________________________________________________________
009064  2               ;
009064  2               DSKY_INIT:
009064  2  48 DA 5A A2          PRTDBG "DSKY INIT:$"
009068  2  00 BD 87 90  
00906C  2  E8 C9 24 F0  
009092  2  20 4E 91             JSR     DSKY_PREINIT
009095  2  48 DA 5A A2  	PRTS "DSKY:$"
009099  2  00 BD AE 90  
00909D  2  E8 C9 24 F0  
0090B4  2  20 6B 88            	JSR	NEWLINE
0090B7  2               
0090B7  2               ;
0090B7  2  48 DA 5A A2  	PRTS    " IO=0x$"
0090BB  2  00 BD D0 90  
0090BF  2  E8 C9 24 F0  
0090D7  2  A9 03        	LDA	#>DSKY_PPI		; GET BASE PORT
0090D9  2  20 49 88     	JSR	PRTHEXBYTE		; PRINT BASE PORT
0090DC  2  A9 60               	LDA	#<DSKY_PPI		; GET BASE PORT
0090DE  2  20 49 88     	JSR	PRTHEXBYTE		; PRINT BASE PORT
0090E1  2  48 DA 5A A2  	PRTS    " MODE=$"
0090E5  2  00 BD FA 90  
0090E9  2  E8 C9 24 F0  
009101  2  48 DA 5A A2  	PRTS    "NG$"			; PRINT DSKY TYPE
009105  2  00 BD 1A 91  
009109  2  E8 C9 24 F0  
00911D  2               ;
00911D  2  AD B7 93     	LDA	DSKY_PRESENT	        ; PRESENT?
009120  2  C9 FF        	CMP     #$FF		        ; SET FLAGS
009122  2  F0 26                BEQ     DSKY_INITA
009124  2  48 DA 5A A2  	PRTS    " NOT PRESENT$"		; NOT PRESENT
009128  2  00 BD 3D 91  
00912C  2  E8 C9 24 F0  
00914A  2               DSKY_INITA:
00914A  2  20 6B 88     	JSR	NEWLINE
00914D  2  60           	RTS				; DONE
00914E  2               ;
00914E  2               ;__DSKY_PREINIT______________________________________________________________________________________
00914E  2               ;
00914E  2               ;  CONFIGURE PARALLEL PORT AND INITIALIZE 8279
00914E  2               ;____________________________________________________________________________________________________
00914E  2               ; HARDWARE RESET 8279 BY PULSING RESET LINE
00914E  2               DSKY_PREINIT:
00914E  2               	; CHECK FOR PPI
00914E  2  20 93 91     	JSR	DSKY_PPIDETECT		; TEST FOR PPI HARDWARE
009151  2  D0 2A                BNE     DSKY_ABORT      	; BAIL OUT IF NOT THERE
009153  2               
009153  2               	; SETUP PPI TO DEFAULT MODE
009153  2  20 90 93     	JSR	DSKY_PPIRD
009156  2               	; INIT 8279 VALUES TO IDLE STATE
009156  2  A9 06        	LDA	#DSKY_PPI_IDLE
009158  2  8D 62 03     	STA	DSKY_PPIC
00915B  2               	; PULSE RESET SIGNAL ON 8279
00915B  2  09 80        	ORA 	#%10000000
00915D  2  8D 62 03     	STA	DSKY_PPIC
009160  2  29 7F        	AND 	#%01111111
009162  2  8D 62 03     	STA	DSKY_PPIC
009165  2               	; INITIALIZE 8279
009165  2  20 7E 91     	JSR	DSKY_REINIT
009168  2               	; NOW SEE IF A DSKYNG IS REALLY THERE...
009168  2  A9 A5        	LDA     #$A5
00916A  2  A0 00                LDY     #$00
00916C  2  20 CF 92     	JSR	DSKY_PUTBYTE
00916F  2  A0 00                LDY     #$00
009171  2  20 E3 92     	JSR	DSKY_GETBYTE
009174  2  C9 A5        	CMP	#$A5
009176  2  D0 05        	BNE     DSKY_ABORT			; BAIL OUT IF MISCOMPARE
009178  2  A9 FF        	LDA	#$FF
00917A  2  8D B7 93     	STA	DSKY_PRESENT
00917D  2               DSKY_ABORT:
00917D  2  60           	RTS
00917E  2               ;
00917E  2               DSKY_REINIT:
00917E  2  20 A2 93     	JSR	DSKY_PPIIDLE
009181  2               	; SET CLOCK SCALER TO 20
009181  2  A9 21        	LDA	#DSKY_CMD_CLK | DSKY_PRESCL
009183  2  20 4F 92     	JSR	DSKY_CMD
009186  2               	; FALL THRU
009186  2               ;
009186  2               DSKY_RESET:
009186  2               	; RESET DSKY -- CLEAR RAM AND FIFO
009186  2  A9 DF        	LDA	#DSKY_CMD_CLR
009188  2  20 4F 92     	JSR	DSKY_CMD
00918B  2               ;
00918B  2               	; 8259 TAKES ~160US TO CLEAR RAM DURING WHICH TIME WRITES TO
00918B  2               	; DISPLAY RAM ARE INHIBITED.  HIGH BIT OF STATUS BYTE IS SET
00918B  2               	; DURING THIS WINDOW.  TO PREVENT A DEADLOCK, A LOOP COUNTER
00918B  2               	; IS USED TO IMPLEMENT A TIMEOUT.
00918B  2  A2 00        	LDX	#0			; TIMEOUT LOOP COUNTER
00918D  2               DSKY_RESET1:
00918D  2  DA           	PHX     			; SAVE COUNTER
00918E  2               	;JSR	DSKY_ST			; GET STATUS BYTE
00918E  2  FA           	PLX				; RECOVER COUNTER
00918F  2                     ;  AND     #%10000000
00918F  2                     ;  BEQ     DSKY_RESET2		; MOVE ON IF DONE
00918F  2  CA                   DEX
009190  2  D0 FB                BNE     DSKY_RESET1		; LOOP TILL TIMEOUT
009192  2               ;
009192  2               DSKY_RESET2:
009192  2  60           	RTS
009193  2               ;
009193  2               ;
009193  2               ;
009193  2               ;__DSKY_PPIDETECT____________________________________________________________________________________
009193  2               ;
009193  2               ;  PROBE FOR PPI HARDWARE
009193  2               ;____________________________________________________________________________________________________
009193  2               ;
009193  2               DSKY_PPIDETECT:
009193  2               ;
009193  2               	; TEST FOR PPI EXISTENCE
009193  2               	; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
009193  2               	; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
009193  2               	; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
009193  2               	; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
009193  2               	; INTERFERE WITH THE VALUE BEING READ.
009193  2  20 79 93     	JSR	DSKY_PPIWR
009196  2               ;
009196  2  A9 00        	LDA     #$00			; VALUE ZERO
009198  2  8D 60 03     	STA	DSKY_PPIA		; PUSH VALUE TO PORT
00919B  2  AD 60 03     	LDA	DSKY_PPIA		; GET PORT VALUE
00919E  2  C9 00                CMP     #$00
0091A0  2  60           	RTS				; AND RETURN
0091A1  2               ;
0091A1  2                .IF DSKY_KBD=1
0091A1  2               ;
0091A1  2               KY_0	=	$00
0091A1  2               KY_1	=	$01
0091A1  2               KY_2	=	$02
0091A1  2               KY_3	=	$03
0091A1  2               KY_4	=	$04
0091A1  2               KY_5	=	$05
0091A1  2               KY_6	=	$06
0091A1  2               KY_7	=	$07
0091A1  2               KY_8	=	$08
0091A1  2               KY_9	=	$09
0091A1  2               KY_A	=	$0A
0091A1  2               KY_B	=	$0B
0091A1  2               KY_C	=	$0C
0091A1  2               KY_D	=	$0D
0091A1  2               KY_E	=	$0E
0091A1  2               KY_F	=	$0F
0091A1  2               KY_FW	=	$10	; FORWARD
0091A1  2               KY_BK	=	$11	; BACKWARD
0091A1  2               KY_CL	=	$12	; CLEAR
0091A1  2               KY_EN	=	$13	; ENTER
0091A1  2               KY_DE	=	$14	; DEPOSIT
0091A1  2               KY_EX	=	$15	; EXAMINE
0091A1  2               KY_GO	=	$16	; GO
0091A1  2               KY_BO	=	$17	; BOOT
0091A1  2               KY_F4	=	$18	; F4
0091A1  2               KY_F3	=	$19	; F3
0091A1  2               KY_F2	=	$20	; F2
0091A1  2               KY_F1	=	$21	; F1
0091A1  2               ;
0091A1  2               ;__DSKY_STAT_________________________________________________________________________________________
0091A1  2               ;
0091A1  2               ;  CHECK FOR KEY PRESS, SAVE RAW VALUE, RETURN STATUS
0091A1  2               ;____________________________________________________________________________________________________
0091A1  2               ;
0091A1  2               DSKY_STAT:
0091A1  2  AD B7 93     	LDA	DSKY_PRESENT            ; DOES IT EXIST?
0091A4  2  C9 FF        	CMP     #$FF			; SET FLAGS
0091A6  2  D0 05                BNE     DSKY_STATA		; ABORT WITH A=0 IF NOT THERE
0091A8  2  20 88 92     	JSR	DSKY_ST
0091AB  2  29 0F        	AND	#$0F			; ISOLATE THE CUR FIFO LEN
0091AD  2               DSKY_STATA:
0091AD  2  60           	RTS
0091AE  2               ;
0091AE  2               ;__DSKY_GETKEY_____________________________________________________________________________________
0091AE  2               ;
0091AE  2               ;  WAIT FOR A DSKY KEYPRESS AND RETURN
0091AE  2               ;____________________________________________________________________________________________________
0091AE  2               ;
0091AE  2               DSKY_GETKEY:
0091AE  2  AD B7 93     	LDA	DSKY_PRESENT    	; DOES IT EXIST?
0091B1  2  C9 FF               	CMP     #$FF			; SET FLAGS
0091B3  2  D0 24                BNE     DSKY_GETKEY1A		; ABORT WITH A=0 IF NOT THERE
0091B5  2  20 A1 91     	JSR	DSKY_STAT
0091B8  2  F0 F4                BEQ     DSKY_GETKEY		; LOOP IF NOTHING THERE
0091BA  2  A9 40        	LDA	#DSKY_CMD_FIFO
0091BC  2  20 4F 92     	JSR	DSKY_CMD
0091BF  2  20 8D 92     	JSR	DSKY_DIN
0091C2  2  49 C0        	EOR	#%11000000		; FLIP POLARITY OF SHIFT/CTL BITS
0091C4  2  48                   PHA
0091C5  2  29 3F        	AND	#$3F			; STRIP SHIFT/CTL BITS FOR LOOKUP
0091C7  2  8D B5 93     	STA     DSKY_TEMP_VAL
0091CA  2  A2 00        	LDX	#0			; INDEX
0091CC  2               DSKY_GETKEY1:
0091CC  2  BD E8 91             LDA     DSKY_KEYMAP,X
0091CF  2  CD B5 93     	CMP	DSKY_TEMP_VAL		; MATCH?
0091D2  2  F0 09                BEQ     DSKY_GETKEY2		; FOUND, DONE
0091D4  2  E8           	INX
0091D5  2  E0 1C                CPX     #28
0091D7  2  D0 F3                BNE	DSKY_GETKEY1		; LOOP UNTIL EOT
0091D9  2               DSKY_GETKEY1A:
0091D9  2  68                   PLA
0091DA  2  A9 FF        	LDA	#$FF			; NOT FOUND ERR, RETURN $FF
0091DC  2  60           	RTS
0091DD  2               DSKY_GETKEY2:
0091DD  2               	; RETURN THE INDEX POSITION WHERE THE SCAN CODE WAS FOUND
0091DD  2               	; THE ORIGINAL SHIFT/CTRL BITS ARE RESTORED
0091DD  2  68           	PLA				; RESTORE RAW VALUE
0091DE  2  25 C0        	AND	%11000000		; ISOLATE SHIFT/CTRL BITS
0091E0  2  8D B5 93             STA     DSKY_TEMP_VAL
0091E3  2  8A                   TXA
0091E4  2  0D B5 93     	ORA	DSKY_TEMP_VAL		; COMBINE WITH INDEX VALUE
0091E7  2  60           	RTS
0091E8  2               ;
0091E8  2               ;_KEYMAP_TABLE_____________________________________________________________________________________________________________
0091E8  2               ;
0091E8  2               DSKY_KEYMAP:
0091E8  2               	; POS	$00  $01  $02  $03  $04  $05  $06  $07
0091E8  2               	; KEY   [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]
0091E8  2  0D 04 0C 14  	.BYTE	$0D, $04, $0C, $14, $03, $0B, $13, $02
0091EC  2  03 0B 13 02  
0091F0  2               ;
0091F0  2               	; POS	$08  $09  $0A  $0B  $0C  $0D  $0E  $0F
0091F0  2               	; KEY   [8]  [9]  [A]  [B]  [C]  [D]  [E]  [F]
0091F0  2  0A 12 01 09  	.BYTE	$0A, $12, $01, $09, $11, $00, $08, $10
0091F4  2  11 00 08 10  
0091F8  2               ;
0091F8  2               	; POS	$10  $11  $12  $13  $14  $15  $16  $17
0091F8  2               	; KEY   [FW] [BK] [CL] [EN] [DE] [EX] [GO] [BO]
0091F8  2  05 15 1D 1C  	.BYTE	$05, $15, $1D, $1C, $1B, $1A, $19, $18
0091FC  2  1B 1A 19 18  
009200  2               
009200  2               	; POS	$18  $19  $20  $21
009200  2               	; KEY   [F4] [F3] [F2] [F1]
009200  2  23 22 21 20  	.BYTE	$23, $22, $21, $20
009204  2               
009204  2               ;
009204  2                       .ENDIF	; DSKY_KBD
009204  2               ;
009204  2               ;__DSKY_BIN2SEG________________________________________________________________________________________
009204  2               ;
009204  2               ; CONVERT 32 BIT BINARY TO 8 BYTE HEX SEGMENT DISPLAY
009204  2               ;
009204  2               ; DSKY_BUF: 32 BIT BINARY
009204  2               ; DSKY_HEXBUF: DEST LED SEGMENT DISPLAY BUFFER (8 BYTES)
009204  2               ;____________________________________________________________________________________________________
009204  2               ;
009204  2               DSKY_BIN2SEG:
009204  2  A2 00        	LDX	#$00
009206  2               DSKY_BIN2SEG1:
009206  2  BD 08 05     	LDA	DSKY_HEXBUF,X			; FIRST NIBBLE
009209  2  4A           	LSR	A
00920A  2  4A                   LSR	A
00920B  2  4A                   LSR	A
00920C  2  4A                   LSR	A
00920D  2  DA           	PHX                                     ; STORE READ INDEX
00920E  2  AA                   TAX					; MOVE DIGIT TO LOOKUP INDEX
00920F  2  BD A5 93     	LDA	DSKY_HEXMAP,X                   ; GET DECODED DIGIT INTO A
009212  2  FA           	PLX                                     ; GET READ INDEX
009213  2  DA           	PHX
009214  2  48           	PHA
009215  2  8A           	TXA
009216  2  0A           	asl	a
009217  2  AA           	TAX
009218  2  68           	PLA
009219  2  9D 00 05             STA     DSKY_BUF,X    		        ;STORE HIGH BYTE IN OUT BUFFER
00921C  2  FA           	PLX
00921D  2  BD 08 05     	LDA	DSKY_HEXBUF,X			; SECOND NIBBLE
009220  2               
009220  2  29 0F        	AND	#$0F
009222  2  DA                   PHX
009223  2  AA                   TAX
009224  2  BD A5 93     	LDA	DSKY_HEXMAP,X                   ; GET DECODED DIGIT INTO A
009227  2  FA           	PLX
009228  2  DA           	PHX
009229  2  48           	PHA
00922A  2  8A           	TXA		                        ; GET READ INDEX
00922B  2  0A           	asl	a
00922C  2  AA           	TAX
00922D  2  E8           	INX
00922E  2  68           	PLA
00922F  2  9D 00 05             STA     DSKY_BUF,X	                ;STORE HIGH BYTE IN OUT BUFFER
009232  2  FA           	PLX
009233  2  E8                   INX
009234  2  E0 04                CPX     #4
009236  2  D0 CE                BNE     DSKY_BIN2SEG1
009238  2  60           	RTS
009239  2               ;
009239  2               ;__DSKY_SHOW___________________________________________________________________________________________
009239  2               ; DSKY SHOW BUFFER
009239  2               ;______________________________________________________________________________________________________
009239  2               ;
009239  2               DSKY_SHOW:
009239  2  48                   PHA
00923A  2  DA                   PHX
00923B  2  5A                   PHY
00923C  2  A2 00                LDX     #0
00923E  2               DSKY_SHOW1:
00923E  2  BD 00 05     	LDA     DSKY_BUF,X
009241  2  DA                   PHX
009242  2  7A                   PLY
009243  2  20 CF 92     	JSR	DSKY_PUTBYTE
009246  2  E8           	INX
009247  2  E0 08                CPX     #8
009249  2  D0 F3                BNE     DSKY_SHOW1
00924B  2  7A                   PLY
00924C  2  FA                   PLX
00924D  2  68                   PLA
00924E  2  60           	RTS
00924F  2               
00924F  2               ;______________________________________________________________________________________________________
00924F  2               ; DSKYNG OUTPUT ROUTINES
00924F  2               ;______________________________________________________________________________________________________
00924F  2               
00924F  2               ; SEND DSKY COMMAND BYTE IN REGISTER A
00924F  2               DSKY_CMD:
00924F  2  48                   PHA
009250  2  A9 01        	LDA	#$01
009252  2  4C 58 92     	JMP	DSKY_DOUT2
009255  2               ;
009255  2               ; SEND DSKY DATA BYTE IN REGISTER A
009255  2               ; TRASHES BC
009255  2               ;
009255  2               DSKY_DOUT:
009255  2  48                   PHA
009256  2  A9 00        	LDA	#$00
009258  2               ;
009258  2               DSKY_DOUT2:
009258  2               	; SET PPI LINE CONFIG TO WRITE MODE
009258  2  20 79 93     	JSR	DSKY_PPIWR
00925B  2               ;
00925B  2               	; SET ADDRESS FIRST
00925B  2  09 06                ORA     #DSKY_PPI_IDLE
00925D  2  8D 62 03     	STA	DSKY_PPIC
009260  2               ;
009260  2               	; ASSERT 8279 /CS
009260  2  09 18        	ORA     #%00011000
009262  2  8D 62 03     	STA	DSKY_PPIC
009265  2               ;
009265  2               	; PPIC WORKING VALUE TO DSKY_TEMP_VAL
009265  2  8D B5 93     	STA     DSKY_TEMP_VAL
009268  2               ;
009268  2               	; ASSERT DATA BYTE VALUE
009268  2  68                   PLA
009269  2  8D 60 03     	STA	DSKY_PPIA
00926C  2               ;
00926C  2               	; PULSE /WR
00926C  2  AD B5 93             LDA     DSKY_TEMP_VAL
00926F  2  29 FD                AND     #%11111101
009271  2  8D 62 03     	STA	DSKY_PPIC
009274  2  EA           	NOP			; MAY NOT BE NEEDED
009275  2  09 02                ORA     #%00000010
009277  2  8D 62 03     	STA	DSKY_PPIC
00927A  2               ;
00927A  2               	; DEASSERT /CS
00927A  2  29 E7                AND     #%11100111
00927C  2  8D 62 03     	STA	DSKY_PPIC
00927F  2               ;
00927F  2               	; CLEAR ADDRESS BIT
00927F  2  29 E6                AND     #%11100110
009281  2  8D 62 03     	STA	DSKY_PPIC
009284  2               ;
009284  2               	; DONE
009284  2  20 A2 93     	JSR	DSKY_PPIIDLE
009287  2  60           	RTS
009288  2               ;
009288  2               ;==================================================================================================
009288  2               ; DSKYNG OUTPUT ROUTINES
009288  2               ;==================================================================================================
009288  2               ;
009288  2               ; RETURN DSKY STATUS VALUE IN A
009288  2               ;
009288  2               DSKY_ST:
009288  2  A9 01        	LDA	#$01
00928A  2  4C 8F 92     	JMP	DSKY_DIN2
00928D  2               ;
00928D  2               ; RETURN NEXT DATA VALUE IN A
00928D  2               ;
00928D  2               DSKY_DIN:
00928D  2  A9 00        	LDA	#$00
00928F  2               ;
00928F  2               DSKY_DIN2:
00928F  2               	; SET PPI LINE CONFIG TO READ MODE
00928F  2  20 90 93     	JSR	DSKY_PPIRD
009292  2               ;
009292  2               	; SET ADDRESS FIRST
009292  2  09 06        	ORA	#DSKY_PPI_IDLE
009294  2  8D 62 03     	STA	DSKY_PPIC
009297  2               ;
009297  2               	; ASSERT 8279 /CS
009297  2  09 18        	ORA     #%00011000
009299  2  8D 62 03     	STA	DSKY_PPIC
00929C  2               ;
00929C  2               	; ASSERT /RD
00929C  2  29 7B        	AND     #%01111011
00929E  2  8D 62 03     	STA	DSKY_PPIC
0092A1  2               ;
0092A1  2  8D B5 93     	STA 	DSKY_TEMP_VAL
0092A4  2               	; GET VALUE
0092A4  2  AD 60 03     	LDA	DSKY_PPIA
0092A7  2  48                   PHA
0092A8  2               
0092A8  2  AD B5 93     	LDA 	DSKY_TEMP_VAL
0092AB  2               	; DEASSERT /RD
0092AB  2  09 04        	ORA     #%00000100
0092AD  2  8D 62 03     	STA	DSKY_PPIC
0092B0  2               ;
0092B0  2               	; DEASSERT /CS
0092B0  2  29 E7                AND     #%11100111
0092B2  2  8D 62 03     	STA	DSKY_PPIC
0092B5  2               ;
0092B5  2               	; CLEAR ADDRESS BIT
0092B5  2  29 E6                AND     #%11100110
0092B7  2  8D 62 03     	STA	DSKY_PPIC
0092BA  2               ;
0092BA  2               	; DONE
0092BA  2  20 A2 93     	JSR	DSKY_PPIIDLE
0092BD  2  68                   PLA
0092BE  2  60           	RTS
0092BF  2               
0092BF  2               ;__DSKY_BLANK_____________________________________________________________________________________
0092BF  2               ;
0092BF  2               ; BLANK DSKYNG DISPLAY  (WITHOUT USING CLEAR)
0092BF  2               ;
0092BF  2               ;_________________________________________________________________________________________________
0092BF  2               ;
0092BF  2               DSKY_BLANK:
0092BF  2  A9 90        	LDA	#DSKY_CMD_WDSP
0092C1  2  20 4F 92     	JSR	DSKY_CMD
0092C4  2  A2 10        	LDX	#16
0092C6  2               DSKY_BLANK1:
0092C6  2  A9 FF        	LDA	#$FF
0092C8  2  20 55 92     	JSR	DSKY_DOUT
0092CB  2  CA                   DEX
0092CC  2  D0 F8        	BNE	DSKY_BLANK1
0092CE  2  60           	RTS
0092CF  2               ;
0092CF  2               ;__DSKY_PUTBYTE____________________________________________________________________________________
0092CF  2               ;
0092CF  2               ; WRITE A RAW BYTE VALUE TO DSKY DISPLAY RAM
0092CF  2               ; AT LOCATION IN REGISTER Y, VALUE IN A.
0092CF  2               ;
0092CF  2               ;__________________________________________________________________________________________________
0092CF  2               ;
0092CF  2               DSKY_PUTBYTE:
0092CF  2  5A                   PHY
0092D0  2  48                   PHA
0092D1  2  48                   PHA
0092D2  2  18           	CLC
0092D3  2  98                   TYA
0092D4  2  69 90        	ADC	#DSKY_CMD_WDSP
0092D6  2  A8                   TAY
0092D7  2  20 4F 92     	JSR	DSKY_CMD
0092DA  2  68                   PLA
0092DB  2  49 FF        	EOR	#$FF
0092DD  2  20 55 92     	JSR	DSKY_DOUT
0092E0  2  68                   PLA
0092E1  2  7A                   PLY
0092E2  2  60           	RTS
0092E3  2               ;
0092E3  2               ;__DSKY_GETBYTE___________________________________________________________________________________
0092E3  2               ; READ A RAW BYTE VALUE FROM DSKY DISPLAY RAM
0092E3  2               ; AT LOCATION IN REGISTER Y, VALUE RETURNED IN A
0092E3  2               ;
0092E3  2               ;_________________________________________________________________________________________________
0092E3  2               ;
0092E3  2               DSKY_GETBYTE:
0092E3  2  18           	CLC
0092E4  2  98                   TYA
0092E5  2  69 70        	ADC	#DSKY_CMD_RDSP
0092E7  2  A8                   TAY
0092E8  2  20 4F 92     	JSR	DSKY_CMD
0092EB  2  20 8D 92     	JSR	DSKY_DIN
0092EE  2  49 FF        	EOR	#$FF
0092F0  2  60           	RTS
0092F1  2               
0092F1  2               ;
0092F1  2               ;__DSKY_PUTLED____________________________________________________________________________________
0092F1  2               ;
0092F1  2               ;	This function is intended to update the LEDs.
0092F1  2               ;	VALUES SHOULD BE IN DSKY_BUF
0092F1  2               ;_________________________________________________________________________________________________
0092F1  2               ;
0092F1  2               DSKY_PUTLED:
0092F1  2  DA           	PHX
0092F2  2  5A           	PHY
0092F3  2  48           	PHA
0092F4  2  A0 00        	LDY 	#$00
0092F6  2  A2 00        	LDX 	#$00
0092F8  2               DSKY_PUTLED_1:
0092F8  2  BD 00 05             LDA     DSKY_BUF,X              ; GET BYTE
0092FB  2  20 CF 92     	JSR	DSKY_PUTBYTE            ; SEND IT TO DSKY
0092FE  2  C8                   INY                             ; LOOP TIL DONE
0092FF  2  E8           	INX
009300  2  C0 08                CPY     #8
009302  2  D0 F4                BNE     DSKY_PUTLED_1
009304  2  68                   PLA                             ; RESTORE REGISTERS
009305  2  7A                   PLY
009306  2  FA                   PLX
009307  2  60           	RTS
009308  2               ;
009308  2               ;__DSKY_BEEP______________________________________________________________________________________
009308  2               ;	This function is intended to beep the speaker on the DSKY
009308  2               ;_________________________________________________________________________________________________
009308  2               ;
009308  2               DSKY_BEEP:
009308  2  5A           	PHY
009309  2  DA                   PHX
00930A  2  48           	PHA
00930B  2  A0 0F        	LDY 	#$0F
00930D  2  20 E3 92     	JSR	DSKY_GETBYTE
009310  2  09 20        	ORA 	#$20
009312  2  A9 20        			LDA 	#$20
009314  2  A0 0F        	LDY	#$0F
009316  2  20 CF 92     	JSR	DSKY_PUTBYTE
009319  2               
009319  2               ;;; 	timer . . .
009319  2  A2 8F        	LDX 	#$8F
00931B  2  A0 FF                LDY     #$FF
00931D  2               DSKY_BEEP1:
00931D  2  88                   DEY
00931E  2  D0 FD                BNE     DSKY_BEEP1
009320  2  CA                   DEX
009321  2  D0 FA                BNE     DSKY_BEEP1
009323  2               
009323  2  A0 0F        	LDY 	#$0F
009325  2  20 E3 92     	JSR	DSKY_GETBYTE
009328  2  29 DF        	AND 	#$DF
00932A  2  A9 DF        			LDA 	#$DF
00932C  2  A0 0F        	LDY	#$0F
00932E  2  20 CF 92     	JSR	DSKY_PUTBYTE
009331  2               
009331  2  68                   PLA
009332  2  FA                   PLX
009333  2  7A                   PLY
009334  2  60           	RTS
009335  2               ;
009335  2               ;__DSKY_L1ON______________________________________________________________________________________
009335  2               ;	This function is intended to turn on DSKY L1
009335  2               ;_________________________________________________________________________________________________
009335  2               ;
009335  2               DSKY_L1ON:
009335  2  5A           	PHY
009336  2  48           	PHA
009337  2  A0 0D        	LDY 	#$0D
009339  2  20 E3 92     	JSR	DSKY_GETBYTE
00933C  2  09 20        	ORA 	#$20
00933E  2  A0 0D        	LDY	#$0D
009340  2  20 CF 92     	JSR	DSKY_PUTBYTE
009343  2  68           	PLA
009344  2  7A                   PLY
009345  2  60           	RTS
009346  2               ;
009346  2               ;__DSKY_L2ON______________________________________________________________________________________
009346  2               ;	This function is intended to turn on DSKY L2
009346  2               ;_________________________________________________________________________________________________
009346  2               ;
009346  2               DSKY_L2ON:
009346  2  5A           	PHY
009347  2  48           	PHA
009348  2  A0 0E        	LDY 	#$0E
00934A  2  20 E3 92     	JSR	DSKY_GETBYTE
00934D  2  09 20        	ORA 	#$20
00934F  2  A0 0E        	LDY	#$0E
009351  2  20 CF 92     	JSR	DSKY_PUTBYTE
009354  2  68           	PLA
009355  2  7A                   PLY
009356  2  60           	RTS
009357  2               ;
009357  2               ;__DSKY_L1OFF_____________________________________________________________________________________
009357  2               ;	This function is intended to turn off DSKY L1
009357  2               ;_________________________________________________________________________________________________
009357  2               ;
009357  2               DSKY_L1OFF:
009357  2  5A           	PHY
009358  2  48           	PHA
009359  2  A0 0D        	LDY 	#$0D
00935B  2  20 E3 92     	JSR	DSKY_GETBYTE
00935E  2  29 DF        	AND 	#$DF
009360  2  A0 0D        	LDY	#$0D
009362  2  20 CF 92     	JSR	DSKY_PUTBYTE
009365  2  68           	PLA
009366  2  7A                   PLY
009367  2  60           	RTS
009368  2               ;
009368  2               ;__DSKY_L2OFF_____________________________________________________________________________________
009368  2               ;	This function is intended to turn off DSKY L2
009368  2               ;_________________________________________________________________________________________________
009368  2               ;
009368  2               DSKY_L2OFF:
009368  2  5A           	PHY
009369  2  48           	PHA
00936A  2  A0 0E        	LDY 	#$0E
00936C  2  20 E3 92     	JSR	DSKY_GETBYTE
00936F  2  29 DF        	AND 	#$DF
009371  2  A0 0E        	LDY	#$0E
009373  2  20 CF 92     	JSR	DSKY_PUTBYTE
009376  2  68           	PLA
009377  2  7A                   PLY
009378  2  60           	RTS
009379  2               ;
009379  2               ;_________________________________________________________________________________________________
009379  2               ; DSKYNG LINE CONTROL ROUTINES
009379  2               ;
009379  2               ; SETUP PPI FOR WRITING: PUT PPI PORT A IN OUTPUT MODE
009379  2               ; AVOID REWRTING PPIX IF ALREADY IN OUTPUT MODE
009379  2               ;
009379  2               ;_________________________________________________________________________________________________
009379  2               ;
009379  2               DSKY_PPIWR:
009379  2  48           	PHA
00937A  2               ;
00937A  2               	; CHECK FOR WRITE MODE
00937A  2  AD B6 93     	LDA     DSKY_PPIX_VAL
00937D  2  C9 82        	CMP	#DSKY_PPIX_WR
00937F  2  F0 0D        	BEQ	DSKY_PPIWR1
009381  2               ;
009381  2               	; SET PPI TO WRITE MODE
009381  2  A9 82        	LDA	#DSKY_PPIX_WR
009383  2  8D 63 03     	STA	DSKY_PPIX
009386  2  8D B6 93     	STA	DSKY_PPIX_VAL
009389  2               ;
009389  2               	; RESTORE PORT C (MAY NOT BE NEEDED)
009389  2  A9 06        	LDA     #DSKY_PPI_IDLE
00938B  2  8D 62 03     	STA	DSKY_PPIC
00938E  2               ;
00938E  2               DSKY_PPIWR1:
00938E  2               ;
00938E  2  68           	PLA
00938F  2  60           	RTS
009390  2               ;
009390  2               ; SETUP PPI FOR READING: PUT PPI PORT A IN INPUT MODE
009390  2               ; AVOID REWRTING PPIX IF ALREADY IN INPUT MODE
009390  2               ;
009390  2               DSKY_PPIRD:
009390  2  48           	PHA
009391  2               ;
009391  2               	; CHECK FOR READ MODE
009391  2  AD B6 93     	LDA	DSKY_PPIX_VAL
009394  2  C9 92        	CMP	#DSKY_PPIX_RD
009396  2  F0 08        	BEQ	DSKY_PPIRD1
009398  2               ;
009398  2               	; SET PPI TO READ MODE
009398  2  A9 92        	LDA	#DSKY_PPIX_RD
00939A  2  8D 63 03     	STA	DSKY_PPIX
00939D  2  8D B6 93     	STA	DSKY_PPIX_VAL
0093A0  2               ;
0093A0  2               DSKY_PPIRD1:
0093A0  2  68           	PLA
0093A1  2  60           	RTS
0093A2  2               ;
0093A2  2               ; RELEASE USE OF PPI
0093A2  2               ;
0093A2  2               DSKY_PPIIDLE:
0093A2  2  4C 90 93     	JMP	DSKY_PPIRD		; SAME AS READ MODE
0093A5  2               ;
0093A5  2               ;__STORAGE_________________________________________________________________________________________
0093A5  2               ; CODES FOR NUMERICS
0093A5  2               ; HIGH BIT ALWAYS CLEAR TO SUPPRESS DECIMAL POINT
0093A5  2               ; SET HIGH BIT TO SHOW DECIMAL POINT
0093A5  2               ;_________________________________________________________________________________________________
0093A5  2               ;
0093A5  2               DSKY_HEXMAP:
0093A5  2  3F           	.BYTE	$3F	; 0
0093A6  2  06           	.BYTE	$06	; 1
0093A7  2  5B           	.BYTE	$5B	; 2
0093A8  2  4F           	.BYTE	$4F	; 3
0093A9  2  66           	.BYTE	$66	; 4
0093AA  2  6D           	.BYTE	$6D	; 5
0093AB  2  7D           	.BYTE	$7D	; 6
0093AC  2  07           	.BYTE	$07	; 7
0093AD  2  7F           	.BYTE	$7F	; 8
0093AE  2  67           	.BYTE	$67	; 9
0093AF  2  77           	.BYTE	$77	; A
0093B0  2  7C           	.BYTE	$7C	; B
0093B1  2  39           	.BYTE	$39	; C
0093B2  2  5E           	.BYTE	$5E	; D
0093B3  2  79           	.BYTE	$79	; E
0093B4  2  71           	.BYTE	$71	; F
0093B5  2               ;
0093B5  2  00           DSKY_TEMP_VAL:	.BYTE	0
0093B6  2  00           DSKY_PPIX_VAL:	.BYTE	0
0093B7  2  00           DSKY_PRESENT:	.BYTE	0
0093B8  2               
0093B8  1               		.INCLUDE "dosmd.asm"
0093B8  2               ;__MD DRIVERS____________________________________________________________________________________________________________________
0093B8  2               ;
0093B8  2               ; 	Nhyodyne Memory disk drivers
0093B8  2               ;
0093B8  2               ;	Entry points:
0093B8  2               ;		MD_SHOW         - called during OS init
0093B8  2               ;		MD_READ_SECTOR  - read a sector from drive
0093B8  2               ;		MD_WRITE_SECTOR - write a sector to drive
0093B8  2               ;________________________________________________________________________________________________________________________________
0093B8  2               ;
0093B8  2               ; RAM BANK $0C is RAM area for Drivers
0093B8  2               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
0093B8  2               ; RAM BANK $0F is fixed bank $0000-$7FFF
0093B8  2               ;
0093B8  2               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
0093B8  2               ;
0093B8  2               ; ROM MEMORY PAGE CONFIGURATION LATCH CONTROL PORT
0093B8  2               ;       A15 IS INVERTED FOR THE NYHODYNE 65C02 CPU . . .
0093B8  2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
0093B8  2               ;	^ ^ ^ ^  ^ ^ ^ ^
0093B8  2               ;	: : : :  : : : :--0 = A15 ROM ONLY ADDRESS LINE DEFAULT IS 0
0093B8  2               ;	: : : :  : : :----0 = A16 ROM ONLY ADDRESS LINE DEFAULT IS 0
0093B8  2               ;	: : : :  : :------0 = A17 ROM ONLY ADDRESS LINE DEFAULT IS 0
0093B8  2               ;	: : : :  :--------0 = A18 ROM ONLY ADDRESS LINE DEFAULT IS 0
0093B8  2               ;	: : : :-----------0 = A19 ROM ONLY ADDRESS LINE DEFAULT IS 0
0093B8  2               ;	: : :-------------0 = A20 ROM ONLY ADDRESS LINE DEFAULT IS 0
0093B8  2               ;	: :---------------0 = ROM BOOT OVERRIDE DEFAULT IS 0
0093B8  2               ;	:-----------------0 = LOWER PAGE ROM SELECT (0=ROM, 1=NOTHING) DEFAULT IS 0
0093B8  2               ;
0093B8  2               ; RAM PAGE CONFIGURATION LATCH CONTROL PORT
0093B8  2               ;
0093B8  2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
0093B8  2               ;	^ ^ ^ ^  ^ ^ ^ ^
0093B8  2               ;	: : : :  : : : :--0 = A15 RAM ONLY ADDRESS LINE DEFAULT IS 0
0093B8  2               ;	: : : :  : : :----0 = A16 RAM ONLY ADDRESS LINE DEFAULT IS 0
0093B8  2               ;	: : : :  : :------0 = A17 RAM ONLY ADDRESS LINE DEFAULT IS 0
0093B8  2               ;	: : : :  :--------0 = A18 RAM ONLY ADDRESS LINE DEFAULT IS 0
0093B8  2               ;	: : : :-----------0 = A19 RAM ONLY ADDRESS LINE DEFAULT IS 0
0093B8  2               ;	: : :-------------0 = UNDEFINED DEFAULT IS 0
0093B8  2               ;	: :---------------0 = RAM BOOT OVERRIDE DEFAULT IS 0
0093B8  2               ;	:-----------------0 = LOWER PAGE RAM SELECT (0=NOTHING, 1=RAM) DEFAULT IS 0;
0093B8  2               
0093B8  2               
0093B8  2               ;__MD_SHOW___________________________________________________________________________________________
0093B8  2               ;
0093B8  2               ;  Display info on MD devices
0093B8  2               ;____________________________________________________________________________________________________
0093B8  2               ;
0093B8  2               MD_SHOW:
0093B8  2  48 DA 5A A2          PRTDBG "MD INIT:$"
0093BC  2  00 BD DB 93  
0093C0  2  E8 C9 24 F0  
0093E4  2  48 DA 5A A2          PRTS "MD: UNITS=2 RAMDISK=256KB ROMDISK=384KB$"
0093E8  2  00 BD FD 93  
0093EC  2  E8 C9 24 F0  
009425  2  20 6B 88            	JSR	NEWLINE
009428  2  60                   rts
009429  2               
009429  2               ;*__MD_READ_SECTOR____________________________________________________________________________________
009429  2               ;*
009429  2               ;*  READ MD SECTOR INTO BUFFER
009429  2               ;*
009429  2               ;*____________________________________________________________________________________________________
009429  2               MD_READ_SECTOR:
009429  2  48 DA 5A A2  		PRTDBG "MD Read Sector$"
00942D  2  00 BD 4C 94  
009431  2  E8 C9 24 F0  
00945B  2  20 A1 96                     JSR     GET_DRIVE_DEVICE
00945E  2  29 01        		and 	#$01			; only want drive cfg
009460  2  0A           		asl	a			; SHIFT 6
009461  2  0A           		asl	a			;
009462  2  0A           		asl	a			;
009463  2  0A              		asl	a			;
009464  2  0A           		asl	a			;
009465  2  0A           		asl	a			;
009466  2  29 5F        		AND 	#%01011111              ; TOGGLE READ
009468  2  AA                           TAX                             ; STASH CONTROL WORD
009469  2  AD 0E 05                     LDA	seksec			;
00946C  2  29 01                	AND	#$01			; GET SECTOR INDEX
00946E  2  C9 00                        CMP     #$00
009470  2  F0 04                        BEQ     @1
009472  2  8A                           TXA
009473  2  09 80                        ORA 	#%10000000              ; TOGGLE TOP HALF OF PAGE
009475  2  AA                           TAX
009476  2               @1:
009476  2  20 B1 95                     JSR     MD_CONVERT_SECTOR
009479  2  8A                           txa
00947A  2  29 40                        and     #%01000000
00947C  2  C9 00                        cmp     #$00                    ; read if ram
00947E  2  F0 0C                        BEQ     :+
009480  2  EE 10 05                     inc     debcyll                 ; if rom, inc bank by 4 ()
009483  2  EE 10 05                     inc     debcyll
009486  2  EE 10 05                     inc     debcyll
009489  2  EE 10 05                     inc     debcyll
00948C  2               :
00948C  2  AD 10 05       	        LDA    	debcyll			; GET BANK
00948F  2  AC 12 05     		LDY    	debsehd			; GET PAGE
009492  2  48 DA 5A A2                  PRTDBG "DO PAGER RD$"
009496  2  00 BD B5 94  
00949A  2  E8 C9 24 F0  
0094C1  2  20 00 02                     JSR     MD_PAGERA
0094C4  2  48 DA 5A A2                  PRTDBG "PAGER RETURN$"
0094C8  2  00 BD E7 94  
0094CC  2  E8 C9 24 F0  
0094F4  2  A9 00                        LDA     #$00
0094F6  2  60           		RTS
0094F7  2               
0094F7  2               
0094F7  2               ;*__MD_WRITE_SECTOR___________________________________________________________________________________
0094F7  2               ;*
0094F7  2               ;*  WRITE MD SECTOR FROM BUFFER
0094F7  2               ;*
0094F7  2               ;*____________________________________________________________________________________________________
0094F7  2               MD_WRITE_SECTOR:
0094F7  2  48 DA 5A A2  		PRTDBG "MD Write Sector$"
0094FB  2  00 BD 1A 95  
0094FF  2  E8 C9 24 F0  
00952A  2  20 A1 96                     JSR     GET_DRIVE_DEVICE
00952D  2  29 01        		and 	#$01			; only want drive cfg
00952F  2  C9 00                        CMP     #$00                    ; NO WRITE FOR ROM
009531  2  F0 03                        BEQ     MD_WRITE_SECTOR_RAM
009533  2  A9 FF                        LDA     #$FF
009535  2  60                           RTS
009536  2               MD_WRITE_SECTOR_RAM:
009536  2  20 B1 95                     JSR     MD_CONVERT_SECTOR
009539  2  A2 20        		LDX 	#%00100000              ; TOGGLE WRITE RAM (LO)
00953B  2  AD 0E 05                     LDA	seksec			;
00953E  2  29 01                	AND	#$01			; GET SECTOR INDEX
009540  2  C9 00                        CMP     #$00
009542  2  F0 02                        BEQ     @1
009544  2  A2 A0        		LDX 	#%10100000              ; TOGGLE WRITE RAM (HI)
009546  2               @1:
009546  2  AD 10 05      	        LDA    	debcyll			; GET BANK
009549  2  AC 12 05     		LDY    	debsehd			; GET PAGE
00954C  2  48 DA 5A A2                  PRTDBG "DO PAGER WR$"
009550  2  00 BD 6F 95  
009554  2  E8 C9 24 F0  
00957B  2  20 00 02                     JSR     MD_PAGERA
00957E  2  48 DA 5A A2                  PRTDBG "PAGER RETURN$"
009582  2  00 BD A1 95  
009586  2  E8 C9 24 F0  
0095AE  2  A9 00                        LDA     #$00
0095B0  2  60           		RTS
0095B1  2               
0095B1  2               ;___MD_CONVERT_SECTOR___________________________________________________________________________________
0095B1  2               ;
0095B1  2               ; 	TRANSLATE SECTORS INTO MD FORMAT
0095B1  2               ;________________________________________________________________________________________________________
0095B1  2               MD_CONVERT_SECTOR:
0095B1  2  48 DA 5A A2          PRTDBG "CONVERT SECTOR$"
0095B5  2  00 BD D4 95  
0095B9  2  E8 C9 24 F0  
0095E3  2  DA                   phx
0095E4  2  AD 0E 05     	LDA	seksec			; LOAD SECTOR # (LOW BYTE)
0095E7  2  4A           	LSR	A			; DIVIDE BY 2 (FOR BLOCKING)
0095E8  2  29 1F        	AND 	#$1F 			; CLEAR UPPER 3 BITS (JUST 'CAUSE)
0095EA  2  8D 12 05     	STA	debsehd			; STORE IN SECTOR/HEAD
0095ED  2  AD 0C 05     	LDA	sektrk			; LOAD TRACK # (LOW BYTE)
0095F0  2  29 03        	AND 	#$03			; BOTTOM 2 BITS ARE PART OF PAGE (PAGES ARE 32k)
0095F2  2  0A           	asl	a			; MOVE TO HIGH BITS
0095F3  2  0A           	asl	a
0095F4  2  0A           	asl	a
0095F5  2  0A           	asl	a
0095F6  2  0A                  	asl	a
0095F7  2  09 80                ORA     #$80                    ; PAGES ARE ALWAYS IN UPPER BANK
0095F9  2  0D 12 05     	ORA	debsehd			; STORE IN SECTOR/HEAD
0095FC  2  8D 12 05             STA     debsehd                 ; STORE IN SECTOR/HEAD
0095FF  2                                                       ; AT THIS POINT PAGE REGISTER SHOULD BE
0095FF  2                                                       ; SET
0095FF  2  AD 0C 05     	LDA	sektrk			; LOAD TRACK #
009602  2  4A                  	LSR	a			; LOSE BOTTOM TWO BITS
009603  2  4A           	LSR	a
009604  2  8D 10 05     	STA	debcyll			; THIS SHOULD BE BANK#
009607  2               
009607  2               
009607  2                 .IF USEDSKY=1 || USEDSKYNG=1
009607  2  48 DA 5A A2    	PRTDBG "DSKY OUTPUT 1$"
00960B  2  00 BD 2A 96  
00960F  2  E8 C9 24 F0  
009638  2  AD 13 05       	lda	sekdsk
00963B  2  8D 08 05       	sta	DSKY_HEXBUF
00963E  2  A9 00         	lda	#$00
009640  2  8D 09 05       	sta	DSKY_HEXBUF+1
009643  2  AD 10 05      	lda	debcyll
009646  2  8D 0A 05       	sta	DSKY_HEXBUF+2
009649  2  AD 12 05         	lda	debsehd
00964C  2  8D 0B 05       	sta	DSKY_HEXBUF+3
00964F  2  20 04 92             jsr     DSKY_BIN2SEG
009652  2  20 39 92             jsr     DSKY_SHOW
009655  2                 .ENDIF
009655  2  FA                   plx
009656  2  60           	RTS
009657  2               
009657  1               		.INCLUDE "dosdblk.asm"
009657  2               ;__DOS DEBLOCK DRIVERS___________________________________________________________________________________________________________
009657  2               ;
009657  2               ; 	Nhyodyne DOS/65 Blocking and Deblocking code
009657  2               ;
009657  2               ;________________________________________________________________________________________________________________________________
009657  2               ;
009657  2               
009657  2               ;___DEBSECR512________________________________________________________________________________________
009657  2               ;
009657  2               ;	DEBLOCK 512 BYTE SECTOR FOR DOS/65
009657  2               ;
009657  2               ;________________________________________________________________________________________________________
009657  2               DEBSECR512:
009657  2  48           	PHA
009658  2  AD 0E 05     	LDA	seksec			;
00965B  2  29 03        	AND	#$03			; GET SECTOR INDEX
00965D  2  18           	CLC				;
00965E  2  2A           	ROL	A			;
00965F  2  AA           	TAX				;
009660  2  BD 78 96     	LDA	DEBTAB,X		;
009663  2  85 EE        	STA     SRC
009665  2  E8           	INX
009666  2  BD 78 96     	LDA	DEBTAB,X		;
009669  2  85 EF        	STA	SRC+1			;
00966B  2  A9 00        	LDA	#<MD_PAGEBU		;
00966D  2  85 EC        	STA	DEST			;
00966F  2  A9 04        	LDA	#>MD_PAGEBU           	;
009671  2  85 ED        	STA	DEST+1			;
009673  2  20 AE 96     	JSR	COPY_DOS_SECTOR		;
009676  2  68           	PLA
009677  2  60           	RTS
009678  2               
009678  2               DEBTAB:
009678  2  BD 96        	.word	hstbuf			;
00967A  2  3D 97        	.word	hstbuf+128		;
00967C  2  BD 97        	.word	hstbuf+256		;
00967E  2  3D 98        	.word	hstbuf+384		;
009680  2               
009680  2               
009680  2               ;___BLKSECR512___________________________________________________________________________________________
009680  2               ;
009680  2               ;	BLOCK 512 SECTOR FOR DOS/65
009680  2               ;
009680  2               ;________________________________________________________________________________________________________
009680  2               BLKSECR512:
009680  2  48           	PHA
009681  2  AD 0E 05     	LDA	seksec			;
009684  2  29 03        	AND	#$03			; GET SECTOR INDEX
009686  2  18           	CLC				;
009687  2  2A           	ROL	A			;
009688  2  AA           	TAX				;
009689  2  BD 78 96     	LDA	DEBTAB,X		;
00968C  2  85 EC        	STA     DEST
00968E  2  E8           	INX
00968F  2  BD 78 96     	LDA	DEBTAB,X		;
009692  2  85 ED        	STA	DEST+1			;
009694  2  A9 00        	LDA	#<MD_PAGEBU		;
009696  2  85 EE        	STA	SRC			;
009698  2  A9 04        	LDA	#>MD_PAGEBU		;
00969A  2  85 EF        	STA	SRC+1			;
00969C  2  20 AE 96     	JSR	COPY_DOS_SECTOR		;
00969F  2  68           	PLA
0096A0  2  60           	RTS
0096A1  2               
0096A1  2               ;___GET_DRIVE_DEVICE_____________________________________________________________________________________
0096A1  2               ;
0096A1  2               ;	GET SELECTED DEVICE TYPE AND UNIT, RETURN IN "A"
0096A1  2               ;
0096A1  2               ;________________________________________________________________________________________________________
0096A1  2               GET_DRIVE_DEVICE:
0096A1  2  DA           	PHX
0096A2  2  AD 13 05     	LDA	sekdsk			; GET DRIVE
0096A5  2  29 07        	AND 	#7			; ONLY FIRST 8 DEVICES SUPPORTED
0096A7  2  0A           	asl	a			; DOUBLE NUMBER FOR TABLE LOOKUP
0096A8  2  AA           	TAX 				; MOVE TO X REGISTER
0096A9  2  BD 14 05     	LDA 	dskcfg,X 		; GET device
0096AC  2  FA           	PLX
0096AD  2  60           	RTS
0096AE  2               
0096AE  2               
0096AE  2               ;___COPY_DOS_SECTOR______________________________________________________________________________________
0096AE  2               ;
0096AE  2               ;	COPY 128 BYTE SECTOR FOR DOS/65
0096AE  2               ;
0096AE  2               ;________________________________________________________________________________________________________
0096AE  2               COPY_DOS_SECTOR:
0096AE  2  5A           	PHY
0096AF  2  A0 00        	LDY	#$00			;
0096B1  2               COPY_DOS_SECTOR1:
0096B1  2  B1 EE        	LDA	(SRC),Y			;
0096B3  2  91 EC        	STA	(DEST),Y		;
0096B5  2  C8           	INY				;
0096B6  2  98           	TYA				;
0096B7  2  C9 80        	CMP	#$80			;
0096B9  2  D0 F6        	BNE	COPY_DOS_SECTOR1	;
0096BB  2  7A           	PLY
0096BC  2  60           	RTS
0096BD  2               
0096BD  2               
0096BD  2               ;deblocking buffer for dba
0096BD  2  xx xx xx xx  hstbuf:		.res	512		;256 or 512 byte sectors
0096C1  2  xx xx xx xx  
0096C5  2  xx xx xx xx  
0098BD  2               
0098BD  1               		.INCLUDE "dosflp.asm"
0098BD  2               ;__FLOPPY DRIVERS________________________________________________________________________________________________________________
0098BD  2               ;
0098BD  2               ; 	DOS/65 floppy drivers for direct attached disk-io V3 card
0098BD  2               ;
0098BD  2               ;	Entry points:
0098BD  2               ;		FL_SETUP        - called during OS init
0098BD  2               ;		FL_READ_SECTOR	- read a sector from drive
0098BD  2               ;		FL_WRITE_SECTOR	- write a sector to drive
0098BD  2               ;
0098BD  2               ;________________________________________________________________________________________________________________________________
0098BD  2               ;
0098BD  2               ;*
0098BD  2               ;* HARDWARE I/O ADDRESSES
0098BD  2               ;*
0098BD  2               FDC_MSR		=	$0330		; ADDRESS OF MAIN STATUS REGISTER
0098BD  2               FDC_DATA	=	$0331		; FLOPPY DATA REGISTER
0098BD  2               FDC_RESET	=	$0333		; FLOPPY RESET
0098BD  2               FDC_DCR		=	$0335		; LOAD CONTROL REGISTER
0098BD  2               FDC_DOR		=       $0336		; CONFIGURATION CONTROL REGISTER
0098BD  2               FDC_TC		=	$0337		; TERMINAL COUNT
0098BD  2               
0098BD  2               ;
0098BD  2               ; FDC COMMANDS
0098BD  2               ;
0098BD  2               CFD_READ	=	%00000110	; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
0098BD  2               CFD_READDEL	=	%00001100	; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
0098BD  2               CFD_WRITE	=	%00000101	; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
0098BD  2               CFD_WRITEDEL	=	%00001001	; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
0098BD  2               CFD_READTRK	=	%00000010	; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
0098BD  2               CFD_READID	=	%00001010	; CMD,HDS/DS --> ST0,ST1,ST2,C,H,R,N
0098BD  2               CFD_FMTTRK	=	%00001101	; CMD,HDS/DS,N,SC,GPL,D --> ST0,ST1,ST2,C,H,R,N
0098BD  2               CFD_SCANEQ	=	%00010001	; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
0098BD  2               CFD_SCANLOEQ	=	%00011001	; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
0098BD  2               CFD_SCANHIEQ	=	%00011101	; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
0098BD  2               CFD_RECAL	=	%00000111	; CMD,DS --> <EMPTY>
0098BD  2               CFD_SENSEINT	=	%00001000	; CMD --> ST0,PCN
0098BD  2               CFD_SPECIFY	=	%00000011	; CMD,SRT/HUT,HLT/ND --> <EMPTY>
0098BD  2               CFD_DRVSTAT	=	%00000100	; CMD,HDS/DS --> ST3
0098BD  2               CFD_SEEK	=	%00001111	; CMD,HDS/DS --> <EMPTY>
0098BD  2               CFD_VERSION	=	%00010000	; CMD --> ST0
0098BD  2               
0098BD  2               CFD_MFM	        =	%01000000	;
0098BD  2               
0098BD  2               ;
0098BD  2               ;
0098BD  2               ; Specify Command:
0098BD  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
0098BD  2               ; |Byte |  7  |	 6  |  5  |  4	|  3  |	 2  |  1  |  0	|
0098BD  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
0098BD  2               ; |  0	|  0  |	 0  |  0  |  0	|  0  |	 0  |  1  |  1	|
0098BD  2               ; |  1	| ----- STEP RATE ----- | -- HEAD UNLOAD TIME - |
0098BD  2               ; |  2	| ------------ HEAD LOAD TIME ----------- | NDM |
0098BD  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
0098BD  2               ;
0098BD  2               ;
0098BD  2               ; Step Rate (milliseconds):		 Head Unload Time (milliseconds):	Head Load Time (milliseconds):
0098BD  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
0098BD  2               ; |	 |	   BITRATE	     |	 |	|	  BITRATE	    |	|      |	 BITRATE	   |
0098BD  2               ; |  VAL | 1.0M | 500K | 300K | 250K |	 |  VAL | 1.0M | 500K | 300K | 250K |	|  VAL | 1.0M | 500K | 300K | 250K |
0098BD  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
0098BD  2               ; |    0 |  8.0 | 16.0 | 26.7 | 32.0 |	 |    0 |  128 |  256 |	 426 |	512 |	|    0 |  128 |	 256 |	426 |  512 |
0098BD  2               ; |    1 |  7.5 | 15.0 | 25.0 | 30.0 |	 |    1 |    8 |   16 | 26.7 |	 32 |	|    1 |    1 |	   2 |	3.3 |	 4 |
0098BD  2               ; |    2 |  7.0 | 14.0 | 23.3 | 28.0 |	 |    2 |   16 |   32 | 53.3 |	 64 |	|    2 |    2 |	   4 |	6.7 |	 8 |
0098BD  2               ; |  ... |  ... |  ... |  ... |	 ... |	 |  ... |  ... |  ... |	 ... |	... |	|  ... |  ... |	 ... |	... |  ... |
0098BD  2               ; |   14 |  1.0 |  2.0 |  3.3 |	 4.0 |	 |   14 |  112 |  224 |	 373 |	448 |	|  126 |  126 |	 252 |	420 |  504 |
0098BD  2               ; |   15 |  0.5 |  1.0 |  1.7 |	 2.0 |	 |   15 |  120 |  240 |	 400 |	480 |	|  127 |  127 |	 254 |	423 |  508 |
0098BD  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
0098BD  2               ;
0098BD  2               ; IBM PS/2 CALLS FOR:
0098BD  2               ;   STEP RATE: 3ms (6ms FOR ALL 41mm OR 720K DRIVES)
0098BD  2               ;   HEAD LOAD TIME: 15ms
0098BD  2               
0098BD  2               
0098BD  2               
0098BD  2               ; DOR BITS (3AH)
0098BD  2               ;
0098BD  2               ;	DISKIO			250KBPS		500KBPS
0098BD  2               ;	-------			-------		-------
0098BD  2               ;D7	/DC/RDY			1 (N/A)		1 (N/A)
0098BD  2               ;D6	/REDWC (DENSITY)	0 (DD)		1 (HD)
0098BD  2               ;D5	P0* (PRECOMP BIT 0)	1 \		0 \
0098BD  2               ;D4	P1* (PRECOMP BIT 1)	0 (125NS)	1 (125NS)
0098BD  2               ;D3	P2* (PRECOMP BIT 2)	0 /		0 /
0098BD  2               ;D2	MINI (BITRATE)		1 (250KBPS)	0 (500KBPS)
0098BD  2               ;D1	/MOTOR (ACTIVE LO)	1 (OFF)		1 (OFF)
0098BD  2               ;D0	TC (TERMINAL COUNT)	0 (OFF)		0 (OFF)
0098BD  2               ;
0098BD  2               FDREADY		=	%10000000	; BIT PATTERN IN LATCH TO FLOPPY READY (P-34):
0098BD  2               FDDENSITY	=	%01000000	; BIT PATTERN IN LATCH TO FLOPPY LOW DENSITY (HIGH IS 1)
0098BD  2               FDPRECOMP	=	%00100000	; BIT PATTERN IN LATCH TO SET WRITE PRECOMP
0098BD  2               FDPRECOMP1	=	%00010000	; BIT PATTERN IN LATCH TO SET WRITE PRECOMP
0098BD  2               FDPRECOMP2	=	%00001000	; BIT PATTERN IN LATCH TO SET WRITE PRECOMP
0098BD  2               FDMINI		=	%00000100	; BIT PATTERN IN LATCH TO SET MINI MODE FDC9229 LOW DENS=1, HIGH DENS=0
0098BD  2               FDMOTOR_ON	=	%00000010	; BIT PATTERN IN LATCH FOR MOTOR CONTROL (ON)
0098BD  2               FDTERMCN	=	%00000001	; BIT PATTERN IN LATCH TO WRITE A TC STROBE
0098BD  2               FDRESETL	=	%00000000	; BIT PATTERN IN LATCH TO RESET ALL BITS
0098BD  2               
0098BD  2               FDMOTOR_OFF	=	%11111101	; BIT PATTERN IN LATCH FOR MOTOR CONTROL (OFF)
0098BD  2               
0098BD  2               DOR_BR250	=	FDREADY | FDPRECOMP | FDMINI
0098BD  2               DOR_BR500	=	FDREADY | FDDENSITY | FDPRECOMP1
0098BD  2               DOR_INIT        =       DOR_BR250
0098BD  2               
0098BD  2               FLOPPY_RETRIES  =       6               ; HOW ABOUT SIX RETIRES?
0098BD  2               FLOPPY_RETRIES1 =       2               ; TWO ITERATIONS OF RECAL?
0098BD  2               
0098BD  2               ;__FL_SETUP______________________________________________________________________________________________________________________
0098BD  2               ;
0098BD  2               ;	SETUP FLOPPY DRIVE SETTINGS
0098BD  2               ;________________________________________________________________________________________________________________________________
0098BD  2               ;
0098BD  2               FL_SETUP:
0098BD  2  A9 00        	LDA	#$00                    ; RESET TRACK/CYL/SEC STORAGE
0098BF  2  8D 19 9E     	STA	debhead                 ;
0098C2  2  8D 1A 9E     	STA	debcyl                  ;
0098C5  2  8D 1B 9E     	STA	debsec                  ;
0098C8  2  A9 FF        	LDA	#$FF			; SET CACHE TO INVALID
0098CA  2  8D 1C 9E     	STA	Cdebhead		;
0098CD  2  8D 1D 9E     	STA	Cdebcyl			;
0098D0  2  8D 1E 9E     	STA	Cdebsec			;
0098D3  2               
0098D3  2  48 DA 5A A2  	PRTS "FD: MODE=MBC$"
0098D7  2  00 BD EC 98  
0098DB  2  E8 C9 24 F0  
0098F9  2               ;
0098F9  2  48 DA 5A A2  	PRTS " IO=0x$"
0098FD  2  00 BD 12 99  
009901  2  E8 C9 24 F0  
009919  2  A9 03        	LDA	#>FDC_MSR
00991B  2  20 49 88     	JSR	PRTHEXBYTE
00991E  2  A9 30        	LDA	#<FDC_MSR
009920  2  20 49 88     	JSR	PRTHEXBYTE
009923  2  20 B7 9D     	JSR	FD_DETECT		; CHECK FOR FDC
009926  2  C9 00                CMP     #$00
009928  2  F0 2C                BEQ     :+                      ; CONTINUE IF FOUND
00992A  2  48 DA 5A A2  	PRTS " NOT PRESENT$" 		; NOT ZERO, H/W NOT PRESENT
00992E  2  00 BD 43 99  
009932  2  E8 C9 24 F0  
009950  2  20 6B 88            	JSR	NEWLINE
009953  2  A9 FF                LDA     #$FF
009955  2  60           	RTS				; BAIL OUT
009956  2               :
009956  2  48 DA 5A A2          PRTS " PRESENT$" 		; NOT ZERO, H/W NOT PRESENT
00995A  2  00 BD 6F 99  
00995E  2  E8 C9 24 F0  
009978  2  20 6B 88             JSR	NEWLINE
00997B  2  A9 A4        	LDA	#DOR_BR250 		; RESET SETTINGS
00997D  2  8D 23 9E     	STA	FDC_DOR_STORE		; SAVE SETTINGS
009980  2  8D 36 03     	STA	FDC_DOR
009983  2               
009983  2  20 55 9D     	JSR	CHECKINT		;
009986  2  A9 03        	LDA	#CFD_SPECIFY		; SPECIFY COMMAND
009988  2  20 11 9D     	JSR	PFDATA			; OUTPUT TO FDC
00998B  2  A9 7F        	LDA	#$7F			; 6 MS STEP, 480 MS HEAD UNLOAD
00998D  2  20 11 9D     	JSR	PFDATA			; OUTPUT TO FDC
009990  2  A9 05        	LDA	#$05			; 508 MS HEAD LOAD, NON-DMA MODE
009992  2  20 11 9D     	JSR	PFDATA			; OUTPUT TO FDC
009995  2               
009995  2  20 55 9D     	JSR	CHECKINT		; SEND SEVERAL INTERRUPTS TO ENSURE PROPER STATE
009998  2  20 55 9D     	JSR	CHECKINT		;
00999B  2  20 55 9D     	JSR	CHECKINT		;
00999E  2  20 55 9D     	JSR	CHECKINT		;
0099A1  2  20 55 9D     	JSR	CHECKINT		;
0099A4  2  20 55 9D     	JSR	CHECKINT		;
0099A7  2               
0099A7  2  20 E9 9C     	JSR	RECAL			;
0099AA  2               
0099AA  2  A9 27        	LDA	#39			;
0099AC  2  8D 1A 9E     	STA	debcyl			;
0099AF  2  20 B9 9C     	JSR	SETTRACK
0099B2  2  4C E9 9C     	JMP	RECAL			;
0099B5  2               
0099B5  2               
0099B5  2               ;__FL_READ_SECTOR________________________________________________________________________________________________________________
0099B5  2               ;
0099B5  2               ; 	READ A FLOPPY SECTOR
0099B5  2               ;________________________________________________________________________________________________________________________________
0099B5  2               ;
0099B5  2               ;
0099B5  2               FL_READ_SECTOR:
0099B5  2  AD 18 9E             LDA     HARDWARE_DETCT
0099B8  2  C9 00                CMP     #$00
0099BA  2  F0 01                BEQ     :+
0099BC  2  60                   RTS
0099BD  2               :
0099BD  2  8D 24 9E             STA     FLRETRY                 ; BLANK RETRIES
0099C0  2  8D 25 9E             STA     FLRETRY1
0099C3  2               
0099C3  2  20 CC 99             JSR     FL_READ_SECTOR_RAW
0099C6  2  48                   PHA
0099C7  2  20 57 96             JSR	DEBSECR512
0099CA  2  68                   PLA
0099CB  2  60                   RTS
0099CC  2               
0099CC  2               FL_READ_SECTOR_RAW:
0099CC  2  48 A9 41 20          DBGFLAG 'A'
0099D0  2  26 9E 68     
0099D3  2  AD 23 9E     	LDA	FDC_DOR_STORE		; POINT TO FDC_DOR
0099D6  2  09 02        	ORA	#FDMOTOR_ON		; SET MOTOR ON
0099D8  2  8D 23 9E     	STA	FDC_DOR_STORE		; POINT TO FDC_DOR
0099DB  2  8D 36 03     	STA	FDC_DOR			; OUTPUT TO CONTROLLER
0099DE  2  48 A9 42 20          DBGFLAG 'B'
0099E2  2  26 9E 68     
0099E5  2  20 D2 9A             JSR     SETUP_FD_CHS
0099E8  2  48 A9 43 20          DBGFLAG 'C'
0099EC  2  26 9E 68     
0099EF  2  AD 19 9E     	LDA	debhead			;
0099F2  2  CD 1C 9E     	CMP	Cdebhead		;
0099F5  2  D0 1A        	BNE	READFL_DIRTY
0099F7  2  AD 1A 9E     	LDA	debcyl			;
0099FA  2  CD 1D 9E     	CMP	Cdebcyl			;
0099FD  2  D0 12        	BNE	READFL_DIRTY
0099FF  2  AD 1B 9E     	LDA	debsec			;
009A02  2  CD 1E 9E     	CMP	Cdebsec			;
009A05  2  D0 0A        	BNE	READFL_DIRTY
009A07  2                                                       ; SECTOR ALREADY IN CACHE, DEBLOCK
009A07  2  48 A9 44 20          DBGFLAG 'D'
009A0B  2  26 9E 68     
009A0E  2  A9 00        	LDA	#$00
009A10  2  60           	RTS
009A11  2               READFL_DIRTY:
009A11  2  48 A9 45 20          DBGFLAG 'E'
009A15  2  26 9E 68     
009A18  2  AD 19 9E     	LDA	debhead			; STORE CURRENT PARMS
009A1B  2  8D 1C 9E     	STA	Cdebhead		;
009A1E  2  AD 1A 9E     	LDA	debcyl			;
009A21  2  8D 1D 9E     	STA	Cdebcyl			;
009A24  2  AD 1B 9E     	LDA	debsec			;
009A27  2  8D 1E 9E     	STA	Cdebsec			;
009A2A  2               
009A2A  2               READFL1:
009A2A  2  48 A9 46 20          DBGFLAG 'F'
009A2E  2  26 9E 68     
009A31  2  A9 46        	LDA	#CFD_READ|CFD_MFM	; BIT 6 SETS MFM, 06H IS READ COMMAND
009A33  2  8D 21 9E     	STA	FCMD                    ; SET COMMAND
009A36  2  20 39 9B     	JSR	DSKOP                   ; DO DISK OPERATION
009A39  2               
009A39  2  C9 00        	CMP	#$00
009A3B  2  F0 32        	BEQ	READFLDONE              ; OPERATION SUCCESSFUL
009A3D  2  EE 24 9E     	INC	FLRETRY                 ; LET'S RETRY
009A40  2  AD 24 9E     	LDA	FLRETRY
009A43  2  C9 06        	CMP	#FLOPPY_RETRIES
009A45  2  D0 E3        	BNE	READFL1
009A47  2  20 E9 9C     	JSR 	RECAL                   ; AFTER X RETRIES, LET'S RECAL THE HEAD
009A4A  2  20 B9 9C     	JSR	SETTRACK                ;
009A4D  2  A9 00        	LDA	#$00                    ;
009A4F  2  8D 24 9E     	STA	FLRETRY                 ; MORE RETRIES!
009A52  2  EE 25 9E     	INC	FLRETRY1
009A55  2  AD 25 9E     	LDA	FLRETRY1
009A58  2  C9 02        	CMP	#FLOPPY_RETRIES1
009A5A  2  D0 CE        	BNE	READFL1
009A5C  2               
009A5C  2  A9 FF        	LDA	#$FF                    ; RETRIES FAILED, INVALIDATE CACHE AND REPORT ERROR
009A5E  2  8D 1C 9E     	STA	Cdebhead		;
009A61  2  8D 1D 9E     	STA	Cdebcyl			;
009A64  2  8D 1E 9E     	STA	Cdebsec			;
009A67  2  48 A9 47 20          DBGFLAG 'G'
009A6B  2  26 9E 68     
009A6E  2  60           	RTS				; A = $FF ON RETURN = OPERATION ERROR
009A6F  2               READFLDONE:
009A6F  2  48 A9 48 20          DBGFLAG 'H'
009A73  2  26 9E 68     
009A76  2  A9 00        	LDA	#$00			; A = 0 ON RETURN = OPERATION OK
009A78  2  60           	RTS
009A79  2               
009A79  2               ;__FL_WRITE_SECTOR_______________________________________________________________________________________________________________
009A79  2               ;
009A79  2               ; 	WRITE A FLOPPY SECTOR
009A79  2               ;________________________________________________________________________________________________________________________________
009A79  2               ;
009A79  2               FL_WRITE_SECTOR:
009A79  2  AD 18 9E             LDA     HARDWARE_DETCT
009A7C  2  C9 00                CMP     #$00
009A7E  2  F0 01                BEQ     :+
009A80  2  60                   RTS
009A81  2               :
009A81  2  20 CC 99             JSR     FL_READ_SECTOR_RAW
009A84  2  8D 24 9E             STA     FLRETRY                 ; BLANK RETRIES
009A87  2  8D 25 9E             STA     FLRETRY1
009A8A  2  20 80 96             JSR	BLKSECR512
009A8D  2               
009A8D  2  A9 FF        	LDA	#$FF
009A8F  2  8D 1C 9E     	STA	Cdebhead		; INVALIDATE CACHE
009A92  2  8D 1D 9E     	STA	Cdebcyl			;
009A95  2  8D 1E 9E     	STA	Cdebsec			;
009A98  2               
009A98  2               WRITEFL1:
009A98  2  A9 45        	LDA	#CFD_WRITE|CFD_MFM	; BIT 6 SETS MFM, 05H IS WRITE COMMAND
009A9A  2  8D 21 9E     	STA	FCMD
009A9D  2  20 39 9B     	JSR	DSKOP
009AA0  2               
009AA0  2  C9 00        	CMP	#$00
009AA2  2  F0 2B        	BEQ	WRITEFLDONE
009AA4  2  EE 24 9E     	INC	FLRETRY
009AA7  2  AD 24 9E     	LDA	FLRETRY
009AAA  2  C9 06        	CMP	#FLOPPY_RETRIES
009AAC  2  D0 EA        	BNE	WRITEFL1
009AAE  2  20 E9 9C     	JSR 	RECAL
009AB1  2  20 B9 9C     	JSR	SETTRACK
009AB4  2  A9 00        	LDA	#$00
009AB6  2  8D 24 9E     	STA	FLRETRY
009AB9  2  EE 25 9E     	INC	FLRETRY1
009ABC  2  AD 25 9E     	LDA	FLRETRY1
009ABF  2  C9 02        	CMP	#FLOPPY_RETRIES1
009AC1  2  D0 D5        	BNE	WRITEFL1
009AC3  2  A9 FF        	LDA	#$FF			; INVALIDATE CACHE
009AC5  2  8D 1C 9E     	STA	Cdebhead		;
009AC8  2  8D 1D 9E     	STA	Cdebcyl			;
009ACB  2  8D 1E 9E     	STA	Cdebsec			;
009ACE  2  60           	RTS				; A = $FF ON RETURN = OPERATION ERROR
009ACF  2               WRITEFLDONE:
009ACF  2  A9 00        	LDA	#$00			; A = 0 ON RETURN = OPERATION OK
009AD1  2  60           	RTS
009AD2  2               
009AD2  2               
009AD2  2               ;__SETUP_FD_CHS__________________________________________________________________________________________________________________
009AD2  2               ;
009AD2  2               ; 	TRANSFORM DOS65 CHS TO FLOPPY
009AD2  2               ;________________________________________________________________________________________________________________________________
009AD2  2               ;
009AD2  2               SETUP_FD_CHS:
009AD2  2  AD 0C 05     	LDA	sektrk			; LOAD TRACK # (LOW BYTE)
009AD5  2  29 01        	AND	#$01			; FILTER OUT HEAD
009AD7  2  8D 19 9E     	STA	debhead			; STORE HEAD
009ADA  2  AD 0C 05     	LDA	sektrk			; SAVE TRACK IN A
009ADD  2  4A           	LSR	A			; REMOVE HEAD BIT
009ADE  2  8D 1A 9E     	STA	debcyl			; STORE IN TRACK
009AE1  2  AD 0E 05     	LDA	seksec			; LOAD SECTOR # (LOW BYTE)
009AE4  2  4A           	LSR	A			;
009AE5  2  4A           	LSR	A			; DIVIDE BY 4 (FOR BLOCKING)
009AE6  2  8D 1B 9E     	STA	debsec			; STORE IN SECTOR
009AE9  2               
009AE9  2                 .IF USEDSKY=1 || USEDSKYNG=1
009AE9  2  48 DA 5A A2    	PRTDBG "DSKY OUTPUT 1$"
009AED  2  00 BD 0C 9B  
009AF1  2  E8 C9 24 F0  
009B1A  2  AD 13 05       	lda	sekdsk
009B1D  2  8D 08 05       	sta	DSKY_HEXBUF
009B20  2  AD 1A 9E      	lda	debcyl
009B23  2  8D 09 05       	sta	DSKY_HEXBUF+1
009B26  2  AD 19 9E      	lda	debhead
009B29  2  8D 0A 05       	sta	DSKY_HEXBUF+2
009B2C  2  AD 1B 9E         	lda	debsec
009B2F  2  8D 0B 05       	sta	DSKY_HEXBUF+3
009B32  2  20 04 92       	JSR	DSKY_BIN2SEG
009B35  2  20 39 92     	JSR	DSKY_SHOW
009B38  2                 .ENDIF
009B38  2               
009B38  2  60                   RTS
009B39  2               
009B39  2               ;__DSKOP__________________________________________________________________________________________________________________________
009B39  2               ;
009B39  2               ; 	PERFORM A DISK OPERATION
009B39  2               ;________________________________________________________________________________________________________________________________
009B39  2               ;
009B39  2               DSKOP:
009B39  2  48 A9 49 20          DBGFLAG 'I'
009B3D  2  26 9E 68     
009B40  2  78           	SEI
009B41  2  20 55 9D     	JSR	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
009B44  2  C9 FF        	CMP	#$FF			; DID IT RETURN WITH ERROR CODE?
009B46  2  F0 29        	BEQ	DSKEXIT			; IF YES, EXIT WITH ERROR CODE
009B48  2               					;
009B48  2  48 A9 4A 20          DBGFLAG 'J'
009B4C  2  26 9E 68     
009B4F  2  AD 23 9E     	LDA	FDC_DOR_STORE		; POINT TO FLATCH
009B52  2  09 02        	ORA	#FDMOTOR_ON		; SET MOTOR ON
009B54  2  8D 23 9E     	STA	FDC_DOR_STORE		; POINT TO FLATCH
009B57  2  8D 36 03     	STA	FDC_DOR			; OUTPUT TO CONTROLLER
009B5A  2               					;
009B5A  2  20 B9 9C     	JSR	SETTRACK		; PERFORM SEEK TO TRACK
009B5D  2  48 A9 4B 20          DBGFLAG 'K'
009B61  2  26 9E 68     
009B64  2               					;
009B64  2  AD 21 9E     	LDA	FCMD			; WHAT COMMAND IS PENDING?
009B67  2  C9 46        	CMP	#CFD_READ|CFD_MFM	; IS IT A READ COMMAND?
009B69  2  D0 03        	BNE	GWRR_POLL		;
009B6B  2  4C 0D 9C     	JMP	RDD_POLL		;
009B6E  2               GWRR_POLL:
009B6E  2  4C 8F 9C     	JMP	WRR_POLL		;
009B71  2               DSKEXIT:
009B71  2  AD 23 9E     	LDA	FDC_DOR_STORE		; POINT TO FLATCH
009B74  2  29 FD        	AND	#FDMOTOR_OFF		; SET MOTOR OFF
009B76  2  8D 23 9E     	STA	FDC_DOR_STORE		; POINT TO FLATCH
009B79  2  8D 36 03     	STA	FDC_DOR			; OUTPUT TO CONTROLLER
009B7C  2  A9 FF        	LDA	#$FF			; SET IF ERROR
009B7E  2  58           	CLI
009B7F  2  60           	RTS
009B80  2               
009B80  2               SNDFDWR:
009B80  2  48 A9 4C 20          DBGFLAG 'L'
009B84  2  26 9E 68     
009B87  2  A0 00        	LDY	#$00			; BYTES/SECTOR COUNT
009B89  2  18           	CLC
009B8A  2  AD 13 05     	LDA	sekdsk			; GET DISK UNIT NUMBER
009B8D  2  29 03        	AND	#$03			; MASK FOR FOUR DRIVES.
009B8F  2  8D 20 9E     	STA	UNIT			; PARK IT IN TEMP
009B92  2  AD 19 9E     	LDA	debhead			; GET HEAD SELECTION
009B95  2  29 01        	AND	#$01			; INSURE SINGLE BIT
009B97  2  0A           	ASL	A			;
009B98  2  0A           	ASL	A			; MOVE HEAD TO BIT 2 POSITION
009B99  2  0D 20 9E     	ORA	UNIT			; OR HEAD TO UNIT BYTE IN COMMAND BLOCK
009B9C  2  8D 20 9E     	STA	UNIT			; STORE IN UNIT
009B9F  2  AD 21 9E     	LDA	FCMD			;
009BA2  2  20 11 9D     	JSR	PFDATA			; PUSH COMMAND TO I8272
009BA5  2  48 A9 6D 20                  DBGFLAG 'm'
009BA9  2  26 9E 68     
009BAC  2  AD 20 9E     	LDA	UNIT			;
009BAF  2  20 11 9D     	JSR	PFDATA			;
009BB2  2  48 A9 6E 20                  DBGFLAG 'n'
009BB6  2  26 9E 68     
009BB9  2  AD 1A 9E     	LDA	debcyl			;
009BBC  2  20 11 9D     	JSR	PFDATA			;
009BBF  2  48 A9 6F 20                  DBGFLAG 'o'
009BC3  2  26 9E 68     
009BC6  2  AD 19 9E     	LDA	debhead			;
009BC9  2  20 11 9D     	JSR	PFDATA			;
009BCC  2  48 A9 70 20                  DBGFLAG 'p'
009BD0  2  26 9E 68     
009BD3  2  18           	CLC				;
009BD4  2  AD 1B 9E     	LDA	debsec			;
009BD7  2  69 01        	ADC	#$01			;
009BD9  2  20 11 9D     	JSR	PFDATA			;
009BDC  2  48 A9 71 20                  DBGFLAG 'q'
009BE0  2  26 9E 68     
009BE3  2  A9 02        	LDA	#$02			;
009BE5  2  20 11 9D     	JSR	PFDATA			; WHAT DENSITY
009BE8  2  48 A9 72 20                  DBGFLAG 'r'
009BEC  2  26 9E 68     
009BEF  2  A9 09        	LDA	#$09			;
009BF1  2  20 11 9D     	JSR	PFDATA			; ASSUME SC (SECTOR COUNT)  EOT
009BF4  2  48 A9 73 20                          DBGFLAG 's'
009BF8  2  26 9E 68     
009BFB  2  A9 1B        	LDA	#$1B			;
009BFD  2  20 11 9D     	JSR	PFDATA			; WHAT GAP IS NEEDED
009C00  2  48 A9 74 20                  DBGFLAG 't'
009C04  2  26 9E 68     
009C07  2  A9 FF        	LDA	#$FF			; DTL, IS THE LAST COMMAND BYTE TO I8272
009C09  2  20 3C 9D     	JSR	PFDATAS
009C0C  2  60           	RTS
009C0D  2               ; PERFORM READ
009C0D  2               ; FROM READ TO READ MUST NOT EXCEED 25US WORST CASE MIN. (AT 2MHZ IS 2,000,000 CYCLES PER SECOND == 50 CYCLE BUDGET.)
009C0D  2               ;
009C0D  2               RDD_POLL:
009C0D  2  20 80 9B     	JSR	SNDFDWR			;
009C10  2  A2 00                LDX     #$00
009C12  2  AD 30 03     RDS1:	LDA	FDC_MSR			; GET STATUS  (4 CYCLES)
009C15  2               	;BPL	RDS1                    ; FDC IS NOT READY, WAIT FOR IT (UP TO 4 CYCLES)
009C15  2               ;	AND	#%00100000		; EXECUTION MODE? (2 CYCLES)
009C15  2               ;	BEQ	DSKOPEND		; NO, ERROR
009C15  2  C9 F0                CMP     #$F0                    ; (2 CYCLES)
009C17  2  F0 06        	BEQ	RDS1A			; READY TO GO
009C19  2  E8                   INX
009C1A  2  D0 F6                BNE     RDS1                    ; NOT READY TO GO
009C1C  2  4C 40 9C            	JMP	DSKOPEND		; ERROR
009C1F  2               RDS1A:
009C1F  2  AD 31 03     	LDA	FDC_DATA		; GET DATA (4 CYCLES)
009C22  2  99 BD 96     	STA	hstbuf,Y		; WRITE IT (5 CYCLES)
009C25  2  C8           	INY                             ; (2 CYCLES)
009C26  2  D0 EA        	BNE	RDS1			; KEEP GOING (UP TO 4 CYCLES)   TOTAL =
009C28  2  A2 00                LDX     #$00
009C2A  2  AD 30 03     RDS2:	LDA	FDC_MSR			; GET STATUS
009C2D  2               ;	BPL	RDS2                    ; FDC IS NOT READY, WAIT FOR IT (UP TO 4 CYCLES)
009C2D  2               ;	AND	#%00100000		; EXECUTION MODE?
009C2D  2               ;	BEQ	DSKOPEND		; NO, ERROR
009C2D  2  C9 F0                CMP     #$F0                    ; (2 CYCLES)
009C2F  2  F0 06        	BEQ	RDS2A			; READY TO GO
009C31  2  E8                   INX
009C32  2  D0 F6                BNE     RDS2                    ; NOT READY TO GO
009C34  2  4C 40 9C            	JMP	DSKOPEND		; ERROR
009C37  2               RDS2A:
009C37  2  AD 31 03     	LDA	FDC_DATA		; GET DATA
009C3A  2  99 BD 97     	STA	hstbuf+256,Y		; WRITE IT
009C3D  2  C8           	INY
009C3E  2  D0 EA        	BNE	RDS2			; KEEP GOING
009C40  2               DSKOPEND:
009C40  2  48 A9 59 20          DBGFLAG 'Y'
009C44  2  26 9E 68     
009C47  2  AD 23 9E     	LDA	FDC_DOR_STORE		; POINT TO FLATCH
009C4A  2  09 01        	ORA	#%00000001		;
009C4C  2  8D 23 9E     	STA	FDC_DOR_STORE		; SET TC
009C4F  2  8D 36 03     	STA	FDC_DOR			; OUTPUT TO CONTROLLER
009C52  2  20 09 9E             JSR     FDDELAY
009C55  2  AD 23 9E     	LDA	FDC_DOR_STORE		; POINT TO FLATCH
009C58  2  29 FE        	AND	#%11111110		;
009C5A  2  8D 23 9E     	STA	FDC_DOR_STORE		; CLEAR TC
009C5D  2  8D 36 03     	STA	FDC_DOR			; OUTPUT TO CONTROLLER
009C60  2  20 09 9E             JSR     FDDELAY
009C63  2  AD 23 9E     	LDA	FDC_DOR_STORE		; POINT TO FLATCH
009C66  2  29 FD        	AND	#%11111101		; SET MOTOR OFF
009C68  2  8D 23 9E     	STA	FDC_DOR_STORE		; POINT TO FLATCH
009C6B  2  8D 36 03     	STA	FDC_DOR			; OUTPUT TO CONTROLLER					;
009C6E  2               					;
009C6E  2  20 9E 9D     	JSR	GFDATA			;GET ERROR TYPE
009C71  2  8D 1F 9E     	STA	FLERR
009C74  2  48 A9 28 20          DBGFLAG '('
009C78  2  26 9E 68     
009C7B  2               ;* CLEAR OUT ANY REMAINING DATA
009C7B  2               RESUL3:
009C7B  2  20 9E 9D     	JSR	GFDATA			;READ BYTE FROM FDC
009C7E  2  C9 00        	CMP	#$00
009C80  2  D0 F9        	BNE	RESUL3			;CLEAR THEM ALL
009C82  2  48 A9 29 20          DBGFLAG ')'
009C86  2  26 9E 68     
009C89  2  AD 1F 9E     	LDA	FLERR			;
009C8C  2  29 C0        	AND	#%11000000		;
009C8E  2  60           	RTS
009C8F  2               
009C8F  2               WRR_POLL:
009C8F  2  20 80 9B     	JSR	SNDFDWR			;
009C92  2               WRS1:					;
009C92  2  AD 30 03     	LDA	FDC_MSR			; GET STATUS
009C95  2  10 FB        	BPL	WRS1			; NOT READY
009C97  2  29 20        	AND	#%00100000		; EXECUTION MODE?
009C99  2  F0 1B        	BEQ	WRS3			; NO, ERROR
009C9B  2  B9 BD 96     	LDA	hstbuf,Y		; WRITE IT
009C9E  2  8D 31 03     	STA	FDC_DATA			; WRITE TO FDC
009CA1  2  C8           	INY
009CA2  2  D0 EE        	BNE	WRS1			; DO NEXT
009CA4  2               WRS2:					;
009CA4  2  AD 30 03     	LDA	FDC_MSR			; GET STATUS
009CA7  2  10 FB        	BPL	WRS2			; NOT READY
009CA9  2  29 20        	AND	#%00100000		; EXECUTION MODE?
009CAB  2  F0 09        	BEQ	WRS3			; NO, ERROR
009CAD  2  B9 BD 97     	LDA	hstbuf+256,Y		; WRITE IT
009CB0  2  8D 31 03     	STA	FDC_DATA		; WRITE TO FDC
009CB3  2  C8           	INY
009CB4  2  D0 EE        	BNE	WRS2			; DO NEXT
009CB6  2               WRS3:
009CB6  2  4C 40 9C     	JMP	DSKOPEND		;
009CB9  2               
009CB9  2               
009CB9  2               ;__SETTRACK__________________________________________________________________________________________________________________________
009CB9  2               ;
009CB9  2               ; 	SEEK TO A TRACK ON GIVEN UNIT
009CB9  2               ; 	A: TRACK #
009CB9  2               ;________________________________________________________________________________________________________________________________
009CB9  2               ;
009CB9  2               SETTRACK:
009CB9  2  AD 23 9E     	LDA	FDC_DOR_STORE		; POINT TO FLATCH
009CBC  2  09 02        	ORA	#FDMOTOR_ON		; SET MOTOR ON
009CBE  2  8D 23 9E     	STA	FDC_DOR_STORE		; POINT TO FLATCH
009CC1  2  8D 36 03     	STA	FDC_DOR			; OUTPUT TO CONTROLLER
009CC4  2               
009CC4  2               					; ANY INTERUPT PENDING
009CC4  2               					; IF YES FIND OUT WHY/CLEAR
009CC4  2  20 55 9D     	JSR	CHECKINT		; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
009CC7  2  C9 FF        	CMP	#$FF			; DID IT RTSURN WITH ERROR CODE?
009CC9  2  D0 03        	BNE	SETTRK1
009CCB  2  4C 10 9D     	JMP	SETTRKEXIT		;
009CCE  2               
009CCE  2               					;
009CCE  2               SETTRK1:
009CCE  2  AD 1A 9E     	LDA	debcyl			; GET TRACK
009CD1  2  C9 00        	CMP	#$00			;
009CD3  2  F0 14        	BEQ	RECAL			; IF 0 PERFORM RECAL INSTEAD OF SEEK
009CD5  2  A9 0F        	LDA	#CFD_SEEK		; SEEK COMMAND
009CD7  2  20 11 9D     	JSR	PFDATA			; PUSH COMMAND
009CDA  2  AD 13 05     	LDA	sekdsk			; SAY WHICH UNIT
009CDD  2  20 11 9D     	JSR	PFDATA			; SEND THAT
009CE0  2  AD 1A 9E     	LDA	debcyl			; TO WHAT TRACK
009CE3  2  20 11 9D     	JSR	PFDATA			; SEND THAT TOO
009CE6  2  4C FF 9C     	JMP	WAINT			; WAIT FOR INTERRUPT SAYING DONE
009CE9  2               RECAL:
009CE9  2  AD 23 9E     	LDA	FDC_DOR_STORE		; POINT TO DOR
009CEC  2  09 02        	ORA	#FDMOTOR_ON		; SET MOTOR ON
009CEE  2  8D 23 9E     	STA	FDC_DOR_STORE		; POINT TO DOR
009CF1  2  8D 36 03             STA	FDC_DOR			; OUTPUT TO CONTROLLER
009CF4  2  A9 07        	LDA	#CFD_RECAL		; RECAL TO TRACK 0
009CF6  2  20 11 9D     	JSR	PFDATA			; SEND IT
009CF9  2  AD 13 05     	LDA	sekdsk			; WHICH UNIT
009CFC  2  20 11 9D     	JSR	PFDATA			; SEND THAT TOO
009CFF  2               ;
009CFF  2               WAINT:
009CFF  2  DA                   PHX
009D00  2  A2 64        	LDX	#100
009D02  2  20 0E 9E             JSR     FDVDELAY
009D05  2  FA                   PLX
009D06  2               :
009D06  2  20 55 9D     	JSR	CHECKINT
009D09  2  AD 30 03     	LDA	FDC_MSR			; READ SEEK STATUS
009D0C  2  29 0F        	AND	#%00001111		; ANY DRIVES SEEKING?
009D0E  2  D0 F6        	BNE	:-			; YES, WAIT FOR THEM
009D10  2               ;
009D10  2               SETTRKEXIT:
009D10  2  60           	RTS
009D11  2               
009D11  2               ;__PFDATA__________________________________________________________________________________________________________________________
009D11  2               ;
009D11  2               ; WRITE A COMMAND OR PARAMETER SEQUENCE
009D11  2               ;
009D11  2               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
009D11  2               ;	RQM  DIO
009D11  2               ;	0	0	BUSY
009D11  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
009D11  2               ;	1	1	BYTE FOR READ BY HOST PENDING
009D11  2               ;	0	1	BUSY
009D11  2               ;
009D11  2               ;________________________________________________________________________________________________________________________________
009D11  2               ;
009D11  2               PFDATA:
009D11  2  48           	PHA				; SAVE DATA BYTE
009D12  2  A0 00                LDY     #$00
009D14  2               WRF1:
009D14  2  AD 30 03     	LDA	FDC_MSR			; READ FDC STATUS
009D17  2  AA           	TAX
009D18  2  29 80        	AND	#$80			;
009D1A  2  D0 07        	BNE     :+
009D1C  2  C8                   INY
009D1D  2  D0 F5                BNE     WRF1			; FDC IS NOT READY, WAIT FOR IT
009D1F  2  68                   PLA
009D20  2  A9 FF                LDA     #$FF
009D22  2  60                   RTS
009D23  2               :
009D23  2  8A           	TXA
009D24  2  29 40        	AND	#$40			; TEST DIO BIT
009D26  2  D0 0E        	BNE	WRF2			; FDC IS OUT OF SYNC
009D28  2  68           	PLA				; RESTORE DATA
009D29  2  8D 31 03     	STA	FDC_DATA		; WRITE TO FDC
009D2C  2  20 09 9E             JSR     FDDELAY
009D2F  2  20 09 9E             JSR     FDDELAY
009D32  2  20 09 9E             JSR     FDDELAY
009D35  2  60           	RTS
009D36  2               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
009D36  2               WRF2:
009D36  2  AD 31 03     	LDA	FDC_DATA		; READ DATA REGISTER
009D39  2  4C 14 9D     	JMP	WRF1			; AND CONTINUE
009D3C  2               
009D3C  2               ;__PFDATAS_________________________________________________________________________________________________________________________
009D3C  2               ;
009D3C  2               ; WRITE A COMMAND OR PARAMETER SEQUENCE (NO PAUSE)
009D3C  2               ;
009D3C  2               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
009D3C  2               ;	RQM  DIO
009D3C  2               ;	0	0	BUSY
009D3C  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
009D3C  2               ;	1	1	BYTE FOR READ BY HOST PENDING
009D3C  2               ;	0	1	BUSY
009D3C  2               ;
009D3C  2               ;________________________________________________________________________________________________________________________________
009D3C  2               ;
009D3C  2               PFDATAS:
009D3C  2  48           	PHA				; SAVE DATA BYTE
009D3D  2               WRF1S:
009D3D  2  AD 30 03     	LDA	FDC_MSR			; READ FDC STATUS
009D40  2  AA           	TAX
009D41  2  29 80        	AND	#$80			;
009D43  2  F0 F8        	BEQ	WRF1S			; FDC IS NOT READY, WAIT FOR IT
009D45  2  8A           	TXA
009D46  2  29 40        	AND	#$40			; TEST DIO BIT
009D48  2  D0 05        	BNE	WRF2S			; FDC IS OUT OF SYNC
009D4A  2  68           	PLA				; RESTORE DATA
009D4B  2  8D 31 03     	STA	FDC_DATA		; WRITE TO FDC
009D4E  2  60           	RTS
009D4F  2               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
009D4F  2               WRF2S:
009D4F  2  AD 31 03     	LDA	FDC_DATA		; READ DATA REGISTER
009D52  2  4C 3D 9D     	JMP	WRF1S			; AND CONTINUE
009D55  2               
009D55  2               
009D55  2               
009D55  2               ;__CHECKINT__________________________________________________________________________________________________________________________
009D55  2               ;
009D55  2               ; CHECK FOR ACTIVE FDC INTERRUPTS BEFORE GIVING I8272 COMMANDS
009D55  2               ; POLL RQM FOR WHEN NOT BUSY AND THEN SEND FDC
009D55  2               ; SENSE INTERRUPT COMMAND.  IF IT RTSURNS WITH NON ZERO
009D55  2               ; ERROR CODE, PASS BACK TO JSRING ROUTINE FOR HANDLING
009D55  2               ;________________________________________________________________________________________________________________________________
009D55  2               ;
009D55  2               CHECKINT:
009D55  2  A0 00                LDY     #$00
009D57  2               :
009D57  2  AD 30 03     	LDA	FDC_MSR			; READING OR WRITING IS KEYS TO D7 RQM
009D5A  2  29 80        	AND	#$80
009D5C  2  D0 09        	BNE	:+      		; WAIT FOR RQM TO BE TRUE. WAIT UNTIL DONE
009D5E  2  20 09 9E             JSR     FDDELAY
009D61  2  C8                   INY
009D62  2  D0 F3                BNE     :-
009D64  2  4C 6F 9D             JMP     ERRCLR
009D67  2               
009D67  2               :
009D67  2  AD 30 03     	LDA	FDC_MSR			; READING OR WRITING IS KEYS TO D7 RQM
009D6A  2  29 40        	AND	#$40			; WAITING FOR INPUT?
009D6C  2  F0 16        	BEQ	SENDINT
009D6E  2  60           	RTS
009D6F  2               
009D6F  2               ERRCLR:
009D6F  2  A0 00                LDY     #$00
009D71  2               :
009D71  2  AD 31 03     	LDA	FDC_DATA		; CLEAR THE JUNK OUT OF DATA REGISTER
009D74  2  AD 30 03     	LDA	FDC_MSR			; CHECK WITH RQM
009D77  2  29 80        	AND	#$80			; IF STILL NOT READY, READ OUT MORE JUNK
009D79  2  D0 06        	BNE	:+			;
009D7B  2  20 09 9E             JSR     FDDELAY
009D7E  2  C8                   INY
009D7F  2  D0 F0                BNE     :-
009D81  2               :
009D81  2  A9 FF        	LDA	#$FF			; RETURN ERROR CODE -1
009D83  2               					;
009D83  2  60           	RTS
009D84  2               
009D84  2               ;__SENDINT__________________________________________________________________________________________________________________________
009D84  2               ;
009D84  2               ; SENSE INTERRUPT COMMAND
009D84  2               ;________________________________________________________________________________________________________________________________
009D84  2               ;
009D84  2               SENDINT:
009D84  2  A9 08        	LDA	#CFD_SENSEINT		; SENSE INTERRUPT COMMAND
009D86  2  20 11 9D     	JSR	PFDATA			; SEND IT
009D89  2  20 9E 9D     	JSR	GFDATA			; GET RESULTS
009D8C  2  8D 22 9E     	STA	ST0			; STORE THAT
009D8F  2  29 C0        	AND	#$C0			; MASK OFF INTERRUPT STATUS BITS
009D91  2  C9 80        	CMP	#$80			; CHECK IF INVALID COMMAND
009D93  2  F0 08        	BEQ	ENDSENDINT		; YES, EXIT
009D95  2  20 9E 9D     	JSR	GFDATA			; GET ANOTHER (STATUS CODE 1)
009D98  2  AD 22 9E     	LDA	ST0			; GET FIRST ONE
009D9B  2  29 C0        	AND	#$C0			; MASK OFF ALL BUT INTERRUPT CODE 00 IS NORMAL
009D9D  2               ENDSENDINT:
009D9D  2  60           	RTS				; ANYTHING ELSE IS AN ERROR
009D9E  2               
009D9E  2               
009D9E  2               ;__GFDATA__________________________________________________________________________________________________________________________
009D9E  2               ;
009D9E  2               ; GET DATA FROM FLOPPY CONTROLLER
009D9E  2               ;
009D9E  2               ; TRANSFERS ARE SYNCHONIZED BYT MSR D7 <RQM> AND D6 <DIO>
009D9E  2               ;	RQM  DIO
009D9E  2               ;	0	0	BUSY
009D9E  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
009D9E  2               ;	1	1	BYTE FOR READ BY HOST PENDING
009D9E  2               ;	0	1	BUSY
009D9E  2               ;
009D9E  2               ;________________________________________________________________________________________________________________________________
009D9E  2               ;
009D9E  2               GFDATA:
009D9E  2  A0 00                LDY     #$00
009DA0  2               :
009DA0  2  AD 30 03     	LDA	FDC_MSR			; GET STATUS
009DA3  2  AA           	TAX				;
009DA4  2  29 80        	AND	#%10000000		; NOT READY, WAIT
009DA6  2  D0 06        	BNE	:+			;
009DA8  2  C8                   INY
009DA9  2  D0 F5                BNE     :-
009DAB  2  A9 00                LDA     #$00
009DAD  2  60                   RTS
009DAE  2               :
009DAE  2  8A           	TXA
009DAF  2  29 40        	AND	#%01000000		; ANY DATA FOR US?
009DB1  2  F0 03        	BEQ	GFDATA1			; NO, SKIP IT
009DB3  2  AD 31 03     	LDA	FDC_DATA		; GET FDC DATA
009DB6  2               GFDATA1:
009DB6  2  60           	RTS
009DB7  2               
009DB7  2               ;__FD_DETECT______________________________________________________________________________________________________________________
009DB7  2               ;
009DB7  2               ; 	DETECT FLOPPY HARDWARE
009DB7  2               ;________________________________________________________________________________________________________________________________
009DB7  2               FD_DETECT:
009DB7  2               	; BLINDLY RESET FDC (WHICH MAY OR MAY NOT EXIST)
009DB7  2  A9 A4        	LDA     #DOR_INIT	; MAKE SURE INITIAL DOR VALUE IS SETUP
009DB9  2  8D 23 9E             STA	FDC_DOR_STORE	; AND PUT IN SHADOW REGISTER
009DBC  2               
009DBC  2  20 EA 9D     	JSR	FC_RESETFDC	; RESET FDC
009DBF  2               
009DBF  2  AD 30 03     	LDA 	FDC_MSR	        ; READ MSR
009DC2  2  C9 80        	CMP	#$80
009DC4  2  F0 0A        	BEQ 	FD_DETECT1	; $80 IS OK
009DC6  2  C9 D0        	CMP	#$D0
009DC8  2  F0 06        	BEQ	FD_DETECT1	; $D0 IS OK
009DCA  2  A9 FF                LDA     #$FF            ; NOT OK
009DCC  2  8D 18 9E             STA     HARDWARE_DETCT
009DCF  2  60                   RTS
009DD0  2               ;
009DD0  2               FD_DETECT1:
009DD0  2  A2 64        	LDX     #100
009DD2  2  20 0E 9E             JSR     FDVDELAY	; WAIT A BIT FOR FDC
009DD5  2  AD 30 03     	LDA	FDC_MSR 	; READ MSR AGAIN
009DD8  2  C9 80        	CMP	#$80
009DDA  2  F0 08        	BEQ 	:+      	; $80 IS OK
009DDC  2  C9 D0        	CMP	#$D0
009DDE  2  A9 FF                LDA     #$FF            ; NOT OK
009DE0  2  8D 18 9E             STA     HARDWARE_DETCT
009DE3  2  60                   RTS
009DE4  2               :
009DE4  2  A9 00                LDA     #$00            ; OK
009DE6  2  8D 18 9E             STA     HARDWARE_DETCT
009DE9  2  60                   RTS
009DEA  2               
009DEA  2               FC_RESETFDC:
009DEA  2  AD 33 03             LDA     FDC_RESET
009DED  2  AD 33 03             LDA     FDC_RESET
009DF0  2  A2 96        	LDX     #150
009DF2  2  20 0E 9E             JSR     FDVDELAY	; WAIT A BIT FOR FDC
009DF5  2               
009DF5  2  A9 00        	LDA     #FDRESETL
009DF7  2  8D 36 03            	STA     FDC_DOR
009DFA  2  20 09 9E     	JSR	FDDELAY
009DFD  2  AD 23 9E     	LDA     FDC_DOR_STORE
009E00  2  8D 36 03            	STA     FDC_DOR
009E03  2  A2 96        	LDX	#150			;
009E05  2  20 0E 9E     	JSR	FDVDELAY
009E08  2  60           	RTS
009E09  2               
009E09  2               
009E09  2               FDDELAY:
009E09  2  48                   PHA
009E0A  2  68                   PLA
009E0B  2  48                   PHA
009E0C  2  68                   PLA
009E0D  2  60                   RTS
009E0E  2               FDVDELAY:
009E0E  2  48                   PHA
009E0F  2  68                   PLA
009E10  2  48                   PHA
009E11  2  68                   PLA
009E12  2  CA                   DEX
009E13  2  E0 00                CPX     #$00
009E15  2  D0 F7                BNE     FDVDELAY
009E17  2  60                   RTS
009E18  2               
009E18  2               
009E18  2               
009E18  2  00           HARDWARE_DETCT: .byte 0		; HARDWARE DETECTED
009E19  2  00           debhead:        .byte 0		; DEBLOCKED HEAD
009E1A  2  00           debcyl:	        .byte 0		; DEBLOCKED CYLINDER
009E1B  2  00           debsec:	        .byte 0		; DEBLOCKED SECTOR
009E1C  2  00           Cdebhead:	.byte 0		; DEBLOCKED HEAD (cache)
009E1D  2  00           Cdebcyl:	.byte 0		; DEBLOCKED CYLINDER (cache)
009E1E  2  00           Cdebsec:	.byte 0		; DEBLOCKED SECTOR (cache)
009E1F  2  00           FLERR:	        .BYTE	$00	;
009E20  2  00           UNIT:	        .BYTE	$00	;
009E21  2  00           FCMD:	        .BYTE	0	; COMMAND READ OR WRITE,
009E22  2  00           ST0:	        .BYTE	0	; COMMAND READ OR WRITE,
009E23  2  00           FDC_DOR_STORE:  .BYTE	00
009E24  2  00           FLRETRY:        .BYTE	00
009E25  2  00           FLRETRY1:       .BYTE	00
009E26  2               
009E26  1               
009E26  1               ;// TODO: this should be dependent on "active console. . ." and should be a driver call
009E26  1               CONSOLE_OUT:
009E26  1  20 BC 88     		JSR WRSER1
009E29  1  60           		RTS
009E2A  1               
009E2A  1               ;// TODO: CONSOLE_IN
009E2A  1               
009E2A  1               
009E2A  1  EA           	NOP
009E2B  1  EA           	NOP
009E2C  1  EA           	NOP
009E2D  1  EA           	NOP
009E2E  1  EA           	NOP
009E2F  1  EA           	NOP
009E30  1  EA           	NOP
009E31  1  EA           	NOP
009E32  1  EA           	NOP
009E33  1  EA           	NOP
009E34  1               
009E34  1               	.end
