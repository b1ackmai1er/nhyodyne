ca65 V2.18 - Ubuntu 2.19-1
Main file   : dos65drv.asm
Current file: dos65drv.asm

000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               ;
000000r 1               ;	Nhyodyne dos/65 banked driver code
000000r 1               ;       Intended for RAM BANK $0D
000000r 1               ;
000000r 1               ;  DWERNER 04/24/2022 	Initial
000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               		.PC02
000000r 1                               .segment "DRIVERS"
000000r 1               		.ORG $8800
008800  1               .include "dosdefn.asm" 		; base addresses and definitions
008800  2               ;________________________________________________________________________________________________________________________________
008800  2               ;
008800  2               ;	Nhyodyne dos/65 base addresses and definitions
008800  2               ;
008800  2               ;  DWERNER 04/24/2022 	Initial
008800  2               ;________________________________________________________________________________________________________________________________
008800  2               
008800  2               ;base addresses and definitions
008800  2               btejmp	        =	$0100		;warm boot jump
008800  2               pemjmp	        =	$0103		;jump to pem
008800  2               iostat	        =	$0106		;i/o status
008800  2               dflfcb	        =	$0107		;default fcb
008800  2               dflbuf	        =	$0128		;default buffer
008800  2               memmovr         =	$0200		; 0200-02ff subr to move data from ram/rom disks
008800  2               MD_PAGERA       =       $0200           ; PAGE DRIVER ADDRESS
008800  2               
008800  2               IO              =       $0300           ; 0300-03FF Memory mapped IO
008800  2               MPCL_ROM	=	$037C		; ROM MAPPER
008800  2               MPCL_RAM	=	$0378		; RAM MAPPER
008800  2               
008800  2               MD_PAGEBU       =       $0400           ; 0400-04FF PAGE BUFFER ADDRESS
008800  2               MD_PAGESE       =       pointr          ; PAGE SECTOR STORAGE
008800  2               
008800  2               ;
008800  2               ; DRIVER WORKING STORAGE
008800  2               ;
008800  2               DSKY_BUF        =       $0500	        ; Eight Bytes DSKY display buffer
008800  2               DSKY_BUFLEN	=       8               ;
008800  2               DSKY_HEXBUF     =       $0508           ; Four Bytes DSKY hex buffer
008800  2               DSKY_HEXBUFLEN	=       4               ;
008800  2               sektrk          =       $050C		; seek track number
008800  2               seksec          =       $050E		; seek sector number
008800  2               debcyll         =       $0510	        ; DEBLOCKED CYLINDER LSB
008800  2               debcylm         =	$0511           ; DEBLOCKED CYLINDER MSB
008800  2               debsehd         =	$0512           ; DEBLOCKED SECTOR AND HEAD (HS)
008800  2               sekdsk          =       $0513           ; seek disk number
008800  2               dskcfg          =       $0514           ; 16 bytes disk configuration table
008800  2               
008800  2               
008800  2               
008800  2               tea	=	$800		;tea start
008800  2               
008800  2               ;zero page for setup
008800  2               trknum	=	$02			;current track
008800  2               dcbadd	=	$04			;dcb address
008800  2               nmsstr	=	$06			;number system tracks
008800  2               nsectr	=	$08			;number sectors per track
008800  2               ttlsec	=	$0A			;total sectors to write
008800  2               trkcnt	=	ttlsec
008800  2               size	=	$0B			;ascii size
008800  2               lokim	=	$0D			;low kim limit
008800  2               hikim	=	$0F			;high kim limit
008800  2               offset	=	$11			;relocation offset
008800  2               kimcnt	=	$13			;kim counter
008800  2               pointr	=	$14			;pointer
008800  2               lengt	=	$16			;inst length
008800  2               point	=	$17			;relocate pointer
008800  2               adjust	=	$19			;relocate distance
008800  2               kimpnt	=	$1B			;kim file index
008800  2               savex	=	$1C			;save for x
008800  2               savey	=	$1D			;save for y
008800  2               number	=	$1E			;input pack buffer
008800  2               dstdrv	=	$20			;destination drive
008800  2               defalt	=	$21			;default drive
008800  2               seccnt	=	$22			;sector count
008800  2               secnum	=	$24			;sector number
008800  2               curccm	=	$26			;start of current ccm
008800  2               simlng	=	$28			;length of sim
008800  2               room	=	$2A			;memory needed for sysgen
008800  2               stksav	=	$2C			;save stack register
008800  2               frstsc	=	$2D			;first sector number of disk
008800  2               dskcfpc	=	$2E			;pointer to disk configuration table
008800  2               cmdlnp	=	$30			;pointer to command line buffer
008800  2               farfunct=       $32                     ;function to call in driver area
008800  2               farpointer=     $33                     ;WORD POINTER to call in driver area
008800  2               lastzp	=	$35
008800  2               
008800  2               ;pem constants on entry to write
008800  2               wrall	=	0		;write to allocated
008800  2               wrdir	=	1		;write to directory
008800  2               wrual	=	2		;write to unallocated
008800  2               
008800  2               ;page zero and system ram assignments
008800  2               DEST	 =	$EC		;pointer for OutMsg
008800  2               SRC	 =	$EE		;pointer for OutMsg
008800  2               OUTMSG_W =	$F0		;pointer for OutMsg
008800  2               mvepnt	=	$f2		;host buffer location
008800  2               dmaadr	=	$f4		;pointer for r/w
008800  2               
008800  2               ;fixed parameters
008800  2               lf	=	$a		;linefeeed
008800  2               cr	=	$d		;return
008800  2               eof	=	$1a		;end of file
008800  2               null	=	0		;null
008800  2               ctlc	=	3		;abort
008800  2               ctle	=	5		;physical cr lf
008800  2               ctli	=	9		;tab character
008800  2               ctlp	=	$10		;toggle printer
008800  2               ctlr	=	$12		;repeat line
008800  2               ctls	=	$13		;freeze
008800  2               ctlx	=	$18		;cancel
008800  2               semico	=	$3b		;semicolon
008800  2               delete	=	$08		;delete character
008800  2               numcmd	=	36		;number commands
008800  2               
008800  2               BANKED_DRIVER_DISPATCHER=$8800  ; LOCATION OF DRIVER DISPATCHER
008800  2               DEBUG	=	0		; assemble with debug information on
008800  2               
008800  2               
008800  2               USESERIAL 	= 	1	; SET TO ONE SERIAL CONSOLE IO
008800  2               USEFLOPPYA 	= 	0	; SET TO ONE FOR FLOPPY = "A"
008800  2               USEFLOPPYB 	= 	0	; SET TO ONE FOR FLOPPY = "B"
008800  2               USEIDEC 	= 	1	; SET TO ONE FOR IDE HDD="C"
008800  2               USEDSKY 	= 	0	; SEND INFO TO DSKY
008800  2               USEDSKYNG 	= 	1	; SEND INFO TO DSKYNG
008800  2               DSKY_KBD	=	1	; USE DSKY KEYBOARD?
008800  2               DEFDRV  	=	2	; SET TO DEFAULT DRIVE LETTER
008800  2               USEDISKIOV1     = 	0	; Floppy and IDE card is  DISK IO V1
008800  2               USEDISKIOV3     = 	0	; Floppy and IDE card is  DISK IO V3
008800  2               
008800  2               FLPA35		=	0	; set to 1 if floppy a is A 3.5" 80 track drive (0= 5.25" 40 track drive)
008800  2               FLPB35		=	0	; set to 1 if floppy a is B 3.5" 80 track drive (0= 5.25" 40 track drive)
008800  2               
008800  2               DSKYOSC         =	100000
008800  2               
008800  1               
008800  1               ; for Nhyodyne:
008800  1               ; RAM BANK $0C is RAM area for Drivers
008800  1               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
008800  1               ; RAM BANK $0F is fixed bank $0000-$7FFF
008800  1               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
008800  1               
008800  1               ;       Area from $0D:8000 to $0D:8800 reserved for work RAM for drivers
008800  1               ;
008800  1               
008800  1               ;__DISPATCHER________________________________________________________________________________________
008800  1               ;
008800  1               ;  Function dispatcher
008800  1               ;  function to call is located in "farfunct"
008800  1               ;____________________________________________________________________________________________________
008800  1               ;
008800  1  48           		PHA
008801  1  DA           		PHX
008802  1  A5 32        		LDA     farfunct
008804  1  0A           		ASL	A			; DOUBLE NUMBER FOR TABLE LOOKUP
008805  1  AA           		TAX
008806  1  BD 15 88     		LDA 	DISPATCHTABLE,X
008809  1  85 33        		STA	farpointer
00880B  1  BD 16 88     		LDA 	DISPATCHTABLE+1,X
00880E  1  85 34        		STA	farpointer+1
008810  1               
008810  1  FA           		PLX
008811  1  68           		PLA
008812  1  6C 33 00     		JMP (farpointer)
008815  1               
008815  1               
008815  1               DISPATCHTABLE:
008815  1  B6 88        		.WORD 	WRSER1			; FUNCTION 00 - WRITE SERIAL PORT
008817  1  C5 88        		.WORD 	RDSER1			; FUNCTION 01 - READ SERIAL PORT
008819  1  D5 88        		.WORD 	RDSER1W			; FUNCTION 02 - READ SERIAL PORT (BLOCKING)
00881B  1  E4 88        		.WORD 	SERIALSTATUS		; FUNCTION 03 - GET SERIAL STATUS
00881D  1               
00881D  1  F6 88        		.WORD 	PPIDE_INIT   		; FUNCTION 04 - called during OS init
00881F  1  9A 8B        		.WORD 	IDE_READ_SECTOR 	; FUNCTION 05 - read a sector from drive
008821  1  F1 8B        		.WORD 	IDE_WRITE_SECTOR	; FUNCTION 06 - write a sector to drive
008823  1               
008823  1  55 8E        		.WORD 	DSKY_INIT		; FUNCTION 07 -
008825  1  FC 8F        		.WORD 	DSKY_SHOW		; FUNCTION 08 -
008827  1  C7 8F        		.WORD 	DSKY_BIN2SEG		; FUNCTION 09 -
008829  1  49 8F        		.WORD 	DSKY_RESET		; FUNCTION 10 -
00882B  1  64 8F        		.WORD 	DSKY_STAT		; FUNCTION 11 -
00882D  1  71 8F        		.WORD 	DSKY_GETKEY		; FUNCTION 12 -
00882F  1  CB 90        		.WORD 	DSKY_BEEP		; FUNCTION 13 -
008831  1  F8 90        		.WORD 	DSKY_L1ON		; FUNCTION 14 -
008833  1  09 91        		.WORD 	DSKY_L2ON		; FUNCTION 15 -
008835  1  1A 91        		.WORD 	DSKY_L1OFF		; FUNCTION 16 -
008837  1  2B 91        		.WORD 	DSKY_L2OFF		; FUNCTION 17 -
008839  1  B4 90        		.WORD 	DSKY_PUTLED		; FUNCTION 18 -
00883B  1  82 90        		.WORD 	DSKY_BLANK		; FUNCTION 19 -
00883D  1               
00883D  1  C0 91        		.WORD 	MD_READ_SECTOR 		; FUNCTION 20 - read a sector from memory device
00883F  1  FD 91        		.WORD 	MD_WRITE_SECTOR		; FUNCTION 21 - write a sector to memory device
008841  1  7B 91        		.WORD 	MD_SHOW			; FUNCTION 22 - md show information
008843  1               
008843  1               ;		.WORD 	FL_READ_SECTOR 		; FUNCTION 23 - read a sector from floppy device
008843  1               ;		.WORD 	FL_WRITE_SECTOR		; FUNCTION 24 - write a sector to floppy device
008843  1               ;		.WORD 	FL_SETUP		; FUNCTION 25 - init floppy device
008843  1               
008843  1               
008843  1               ;__DRIVERS___________________________________________________________________________________________
008843  1               ;
008843  1               		.include "drvmacro.asm"
008843  2               ;__MACRO___________________________________________________________________________________________________________________
008843  2               ;
008843  2               ; 	Macros for the betterment of Mankind
008843  2               ;________________________________________________________________________________________________________________________________
008843  2               ;
008843  2               
008843  2               .macro          PRTDBG      message
008843  2               .LOCAL p1
008843  2               .LOCAL p2
008843  2               .LOCAL p3
008843  2               .LOCAL p4
008843  2               .LOCAL p5
008843  2                 .if     .paramcount <> 1
008843  2                       .error  "Too few parameters for macro PRTDBG"
008843  2                       .endif
008843  2                       .if DEBUG=1
008843  2                       PHA
008843  2                       PHX
008843  2                       PHY
008843  2                       LDX #$00
008843  2               p1:
008843  2                       LDA p4,x
008843  2                       INX
008843  2                       CMP #'$'
008843  2                       BEQ p2
008843  2                       JSR CONSOLE_OUT
008843  2                       JMP p1
008843  2               p2:
008843  2                       LDA #13
008843  2                       jsr CONSOLE_OUT
008843  2                       LDA #10
008843  2                       jsr CONSOLE_OUT
008843  2                       PLY
008843  2                       plx
008843  2                       pla
008843  2                       JMP p5
008843  2               p4:
008843  2                       .BYTE message
008843  2               p5:
008843  2                       .endif
008843  2               .endmacro
008843  2               
008843  2               .macro          PRTS      message
008843  2               .LOCAL p1
008843  2               .LOCAL p2
008843  2               .LOCAL p3
008843  2               .LOCAL p4
008843  2               .LOCAL p5
008843  2                 .if     .paramcount <> 1
008843  2                       .error  "Too few parameters for macro PRTS"
008843  2                       .endif
008843  2                       PHA
008843  2                       PHX
008843  2                       PHY
008843  2                       LDX #$00
008843  2               p1:
008843  2                       LDA p4,x
008843  2                       INX
008843  2                       CMP #'$'
008843  2                       BEQ p2
008843  2                       JSR CONSOLE_OUT
008843  2                       JMP p1
008843  2               p2:
008843  2                       PLY
008843  2                       plx
008843  2                       pla
008843  2                       JMP p5
008843  2               p4:
008843  2                       .BYTE message
008843  2               p5:
008843  2               .endmacro
008843  2               
008843  2               .macro          DBGFLAG      character
008843  2                 .if     .paramcount <> 1
008843  2                       .error  "Too few parameters for macro DBGFLAG"
008843  2                       .endif
008843  2                       .if DEBUG=1
008843  2                       PHA
008843  2                       LDA #character
008843  2                       JSR CONSOLE_OUT
008843  2                       pla
008843  2                       .endif
008843  2               .endmacro
008843  2               
008843  2               
008843  2               ;__PRTHEXBYTE__________________________________________________
008843  2               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
008843  2               ;______________________________________________________________
008843  2               PRTHEXBYTE:
008843  2  48                   PHA
008844  2  DA                   PHX
008845  2  5A                   PHY
008846  2  AA                   TAX				; SAVE A REGISTER
008847  2  4A                   LSR 				; SHIFT HIGH NIBBLE TO LOW NIBBLE
008848  2  4A                   LSR 				;
008849  2  4A                   LSR 				;
00884A  2  4A                   LSR 				;
00884B  2  18                   CLC               		; CLEAR CARRY
00884C  2  20 57 88             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
00884F  2  8A                   TXA				; RESTORE ACCUMULATOR
008850  2  20 57 88             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
008853  2  7A                   PLY
008854  2  FA                   plx
008855  2  68                   PLA
008856  2  60                   RTS
008857  2               
008857  2               ;__PRINT_DIGIT_________________________________________________
008857  2               ;
008857  2               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
008857  2               ;
008857  2               ;______________________________________________________________
008857  2               PRINT_DIGIT:
008857  2  29 0F                       AND #$0F				; STRIP OFF HIGH NIBBLE
008859  2  09 30                       ORA #$30				; ADD $30 TO PRODUCE ASCII
00885B  2  C9 3A                       CMP #$3A               		; IS GREATER THAN 9
00885D  2  30 03                       BMI PRINT_DIGIT_OUT		; NO, SKIP ADD
00885F  2  18                          CLC				; CLEAR CARRY
008860  2  69 07                       ADC #$07				; ADD ON FOR LETTER VALUES
008862  2               PRINT_DIGIT_OUT:					;
008862  2  4C CE 94                    JMP CONSOLE_OUT              		; PRINT OUT CHAR
008865  2               
008865  2               NEWLINE:
008865  2  48                           pha
008866  2  DA                           PHX
008867  2  5A                           phy
008868  2  A9 0D                        LDA #$0D
00886A  2  20 CE 94                     JSR CONSOLE_OUT
00886D  2  A9 0A                        LDA #$0A
00886F  2  20 CE 94                     Jsr CONSOLE_OUT
008872  2  7A                           ply
008873  2  FA                           plx
008874  2  68                           pla
008875  2  60                           rts
008876  2               
008876  2               PRTDEC:
008876  2  5A                           phy
008877  2  DA                           PHX
008878  2  48                           PHA
008879  2  A0 00                        ldy #00
00887B  2  A2 FF                        LDX #$FF
00887D  2  38                           SEC
00887E  2               PrDec100:
00887E  2  E8                           INX
00887F  2  E9 64                        SBC #100
008881  2  B0 FB                        BCS PrDec100            ;Count how many 100s
008883  2  69 64                        ADC #100
008885  2  20 9F 88                     JSR PrDecDigit          ;Print the 100s
008888  2  A2 FF                        LDX #$FF
00888A  2  38                           SEC                     ;Prepare for subtraction
00888B  2               PrDec10:
00888B  2  E8                           INX
00888C  2  E9 0A                        SBC #10
00888E  2  B0 FB                        BCS PrDec10             ;Count how many 10s
008890  2  69 0A                        ADC #10
008892  2  20 9F 88                     JSR PrDecDigit          ;Print the 10s
008895  2  AA                           TAX                     ;Pass 1s into X
008896  2  A0 01                        ldy #1
008898  2  20 9F 88                     JSR PrDecDigit          ;Print the 1s
00889B  2  68                           PLA
00889C  2  FA                           PLX
00889D  2  7A                           ply
00889E  2  60                           RTS
00889F  2               PrDecDigit:
00889F  2  48                           PHA
0088A0  2  C0 00                        cpy #$00
0088A2  2  D0 09                        bne PrDecDigit1
0088A4  2  8A                           txa
0088A5  2  A8                           tay
0088A6  2  C0 00                        cpy #$00
0088A8  2  D0 03                        bne PrDecDigit1
0088AA  2  4C B3 88                     jmp PrDecDigit2
0088AD  2               PrDecDigit1:
0088AD  2  8A                           TXA                     ;Save A, pass digit to A
0088AE  2  09 30                        ORA #'0'
0088B0  2  20 CE 94                     JSR  CONSOLE_OUT        ;Convert to character and print it
0088B3  2               PrDecDigit2:
0088B3  2  68                           PLA
0088B4  2  60                           RTS                     ;Restore A and return
0088B5  2               
0088B5  1               		.INCLUDE "dosser.asm"
0088B5  2               ;__SERIAL DRIVERS________________________________________________________________________________________________________________
0088B5  2               ;
0088B5  2               ; 	Nhyodyne serial drivers for single serial port card
0088B5  2               ;
0088B5  2               ;	Entry points:
0088B5  2               ;		SERIALINIT  - called during OS init
0088B5  2               ;		RDSER1	    - read a byte from serial port ('A' POINTS TO BYTE)
0088B5  2               ;		WRSER1	    - write a byte from serial port  ('A' POINTS TO BYTE)
0088B5  2               ;		RDSER1W	    - read a byte from serial port ('A' POINTS TO BYTE, WAIT FOR INPUT)
0088B5  2               ;		SERIALSTATUS- GET UART STATUS
0088B5  2               ;________________________________________________________________________________________________________________________________
0088B5  2               ;
0088B5  2               
0088B5  2               
0088B5  2               ;*
0088B5  2               ;* HARDWARE I/O ADDRESSES
0088B5  2               ;*
0088B5  2               
0088B5  2               ; UART 16C550 SERIAL
0088B5  2               UART0       	=    	$0368           ; DATA IN/OUT
0088B5  2               UART1       	=    	$0369           ; CHECK RX
0088B5  2               UART2       	=    	$036A           ; INTERRUPTS
0088B5  2               UART3       	=    	$036B           ; LINE CONTROL
0088B5  2               UART4       	=    	$036C           ; MODEM CONTROL
0088B5  2               UART5          	=    	$036D           ; LINE STATUS
0088B5  2               UART6          	=    	$036E           ; MODEM STATUS
0088B5  2               UART7	       	=    	$036F           ; SCRATCH REG.
0088B5  2               
0088B5  2               
0088B5  2               ;__SERIALINIT____________________________________________________________________________________________________________________
0088B5  2               ;
0088B5  2               ;	INITIALIZE SERIAL PORTS
0088B5  2               ;________________________________________________________________________________________________________________________________
0088B5  2               ;
0088B5  2               SERIALINIT:
0088B5  2               ;	LDA	#$80			;
0088B5  2               ;	STA	UART3			; SET DLAB FLAG
0088B5  2               ;	LDA	#12			; SET TO 12 = 9600 BAUD
0088B5  2               ;	STA	UART0			; save baud rate
0088B5  2               ;	LDA	#00			;
0088B5  2               ;	STA	UART1			;
0088B5  2               ;	LDA	#03			;
0088B5  2               ;	STA	UART3			; SET 8 BIT DATA, 1 STOPBIT
0088B5  2               ;	STA	UART4			;
0088B5  2               
0088B5  2  60           	RTS
0088B6  2               
0088B6  2               
0088B6  2               
0088B6  2               ;__WRSER1________________________________________________________________________________________________________________________
0088B6  2               ;
0088B6  2               ;	WRITE CHARACTER(A) TO UART
0088B6  2               ;________________________________________________________________________________________________________________________________
0088B6  2               ;
0088B6  2               WRSER1:
0088B6  2  48           	PHA
0088B7  2               WRSER1a:
0088B7  2  AD 6D 03     	LDA	UART5			; READ LINE STATUS REGISTER
0088BA  2  29 20        	AND	#$20			; TEST IF UART IS READY TO SEND (BIT 5)
0088BC  2  C9 00        	CMP     #$00
0088BE  2  F0 F7        	BEQ	WRSER1a			; NO, WAIT FOR IT
0088C0  2  68           	PLA
0088C1  2  8D 68 03     	STA	UART0			; THEN WRITE THE CHAR TO UART
0088C4  2  60           	RTS
0088C5  2               
0088C5  2               ;__RDSER1________________________________________________________________________________________________________________________
0088C5  2               ;
0088C5  2               ;	READ CHARACTER FROM UART TO (A)
0088C5  2               ;________________________________________________________________________________________________________________________________
0088C5  2               ;
0088C5  2               RDSER1:
0088C5  2  AD 6D 03     	LDA	UART5			; READ LINE STATUS REGISTER
0088C8  2  29 01        	AND	#$01			; TEST IF DATA IN RECEIVE BUFFER
0088CA  2  C9 00        	CMP 	#$00
0088CC  2  F0 04        	BEQ	RDSER1N			; LOOP UNTIL DATA IS READY
0088CE  2  AD 68 03     	LDA	UART0			; THEN READ THE CHAR FROM THE UART
0088D1  2  60           	RTS
0088D2  2               RDSER1N:
0088D2  2  A9 00        	LDA	#$00			;
0088D4  2  60           	RTS				;
0088D5  2               
0088D5  2               ;__RDSER1W_______________________________________________________________________________________________________________________
0088D5  2               ;
0088D5  2               ;	READ CHARACTER FROM UART TO (A) - WAIT FOR CHAR
0088D5  2               ;________________________________________________________________________________________________________________________________
0088D5  2               ;
0088D5  2               
0088D5  2               RDSER1W:
0088D5  2  AD 6D 03     		LDA	UART5			; READ LINE STATUS REGISTER
0088D8  2  29 01        		AND	#$01			; TEST IF DATA IN RECEIVE BUFFER
0088DA  2  C9 00        		CMP 	#$00
0088DC  2  F0 F7        		BEQ	RDSER1W			; LOOP UNTIL DATA IS READY
0088DE  2  AD 68 03     		LDA	UART0			; THEN READ THE CHAR FROM THE UART
0088E1  2  29 7F        		AND #$7F
0088E3  2  60           		RTS
0088E4  2               
0088E4  2               ;__SERIALSTATUS__________________________________________________________________________________________________________________
0088E4  2               ;
0088E4  2               ;	READ UARD STATUS
0088E4  2               ;________________________________________________________________________________________________________________________________
0088E4  2               ;
0088E4  2               SERIALSTATUS:
0088E4  2  AD 6D 03     	LDA	UART5			; READ LINE STATUS REGISTER
0088E7  2  29 01        	AND	#$01			; TEST IF DATA IN RECEIVE BUFFER
0088E9  2  C9 00        	CMP 	#$00
0088EB  2  F0 03        	BEQ	RDSTAT1			; NO, INDICATE NO CHAR
0088ED  2  A9 FF        	LDA	#$FF			; GET DATA CHAR
0088EF  2  60           	RTS
0088F0  2               RDSTAT1:
0088F0  2  A9 00        	LDA	#$00			; GET DATA CHAR
0088F2  2  60           	RTS
0088F3  2               
0088F3  2               ; end
0088F3  2               
0088F3  1               		.INCLUDE "doside.asm"
0088F3  2               ;__IDE DRIVERS___________________________________________________________________________________________________________________
0088F3  2               ;
0088F3  2               ; 	Nhyodyne IDE disk drivers for Z80PPIDE card
0088F3  2               ;
0088F3  2               ;	Entry points:
0088F3  2               ;		PPIDE_INIT   	- called during OS init
0088F3  2               ;		IDE_READ_SECTOR - read a sector from drive
0088F3  2               ;		IDE_WRITE_SECTOR- write a sector to drive
0088F3  2               ;________________________________________________________________________________________________________________________________
0088F3  2               ;
0088F3  2               PPIDE_PPI	=	$0360		; PORT A
0088F3  2               ;
0088F3  2               PPIDELO		=	PPIDE_PPI+0	; LSB
0088F3  2               PPIDEHI		=	PPIDE_PPI+1	; MSB
0088F3  2               PPIDECNTRL	=	PPIDE_PPI+2	; Control Signals
0088F3  2               PPIDEPPIC	=	PPIDE_PPI+3	; CONTROL BYTE PPI 82C55
0088F3  2               
0088F3  2               PPIDE_A0_LINE	=	$01		;DIRECT FROM 8255 TO IDE INTERFACE
0088F3  2               PPIDE_A1_LINE	=	$02		;DIRECT FROM 8255 TO IDE INTERFACE
0088F3  2               PPIDE_A2_LINE	=	$04		;DIRECT FROM 8255 TO IDE INTERFACE
0088F3  2               PPIDE_CS0_LINE	=	$08		;INVERTER BETWEEN 8255 AND IDE INTERFACE
0088F3  2               PPIDE_CS1_LINE	=	$10		;INVERTER BETWEEN 8255 AND IDE INTERFACE
0088F3  2               PPIDE_WR_LINE	=	$20		;INVERTER BETWEEN 8255 AND IDE INTERFACE
0088F3  2               PPIDE_RD_LINE	=	$40		;INVERTER BETWEEN 8255 AND IDE INTERFACE
0088F3  2               PPIDE_RST_LINE	=	$80		;INVERTER BETWEEN 8255 AND IDE INTERFACE
0088F3  2               
0088F3  2               PPIDE_DATA	=	PPIDE_CS0_LINE
0088F3  2               PPIDE_ERR	=	PPIDE_CS0_LINE + PPIDE_A0_LINE
0088F3  2               PPIDE_SEC_CNT	=	PPIDE_CS0_LINE + PPIDE_A1_LINE
0088F3  2               PPIDE_LBALOW	=	PPIDE_CS0_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
0088F3  2               PPIDE_LBAMID	=	PPIDE_CS0_LINE + PPIDE_A2_LINE
0088F3  2               PPIDE_LBAHI	=	PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A0_LINE
0088F3  2               PPIDE_DEVICE	=	PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
0088F3  2               PPIDE_COMMAND	=	PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
0088F3  2               PPIDE_STATUS	=	PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
0088F3  2               PPIDE_CONTROL	=	PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
0088F3  2               PPIDE_ASTATUS	=	PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
0088F3  2               
0088F3  2               
0088F3  2               ;IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
0088F3  2               PPIDE_CMD_RECAL	=	$10
0088F3  2               PPIDE_CMD_READ	=	$20
0088F3  2               PPIDE_CMD_WRITE	=	$30
0088F3  2               PPIDE_CMD_INIT	=	$91
0088F3  2               PPIDE_CMD_ID	=	$EC
0088F3  2               PPIDE_CMD_SPINDOWN=	$E0
0088F3  2               PPIDE_CMD_SPINUP=	$E1
0088F3  2               
0088F3  2               
0088F3  2               PPRD_IDE_8255	=	%10010010	;IDE_8255_CTL OUT, IDE_8255_LSB/MSB INPUT
0088F3  2               PPWR_IDE_8255	=	%10000000	;ALL THREE PORTS OUTPUT
0088F3  2               
0088F3  2               
0088F3  2  00           PPIDEINDEX:	.byte	$00
0088F4  2  00 00        PPIDETIMEOUT:	.byte	$00,$00
0088F6  2               
0088F6  2               ;__PPIDE_INIT_________________________________________________________________________________________
0088F6  2               ;
0088F6  2               ;  INIT AND DISPLAY IDE INFO
0088F6  2               ;____________________________________________________________________________________________________
0088F6  2               ;
0088F6  2               PPIDE_INIT:
0088F6  2                       PRTDBG "PPIDE INIT:$"
0088F6  2  48 DA 5A A2  	PRTS "PPIDE :$"
0088FA  2  00 BD 0F 89  
0088FE  2  E8 C9 24 F0  
008917  2  20 65 88            	JSR	NEWLINE
00891A  2  20 8C 8B     	JSR	IDE_PPIDETECT		; TEST FOR PPI HARDWARE
00891D  2  D0 35                BNE     IDE_ABORT      		; BAIL OUT IF NOT THERE
00891F  2               ;
00891F  2  48 DA 5A A2  	PRTS    " IO=0x$"
008923  2  00 BD 38 89  
008927  2  E8 C9 24 F0  
00893F  2  A9 03        	LDA	#>PPIDE_PPI		; GET BASE PORT
008941  2  20 43 88     	JSR	PRTHEXBYTE		; PRINT BASE PORT
008944  2  A9 60               	LDA	#<PPIDE_PPI		; GET BASE PORT
008946  2  20 43 88     	JSR	PRTHEXBYTE		; PRINT BASE PORT
008949  2               ;
008949  2  20 27 8C     	JSR	PPIDE_RESET		; RESET THE BUS
00894C  2  20 E2 89     	JSR	PPIDE_PROBE		; DETECT AN ATA DEVICE, ABORT IF NOT FOUND
00894F  2  B0 03        	BCS 	IDE_ABORT
008951  2  4C 7D 89     	JMP 	IDE_PRINT_INFO
008954  2               IDE_ABORT:
008954  2  48 DA 5A A2  	PRTS    " NOT PRESENT$"		; NOT PRESENT
008958  2  00 BD 6D 89  
00895C  2  E8 C9 24 F0  
00897A  2  4C DE 89     	JMP 	IDE_INITA
00897D  2               IDE_PRINT_INFO:
00897D  2  20 65 88     	JSR	NEWLINE
008980  2  48 DA 5A A2  	PRTS    " PPIDE0: Blocks=$"
008984  2  00 BD 99 89  
008988  2  E8 C9 24 F0  
0089AA  2  A9 00        	LDA	#$00
0089AC  2  20 6B 8A     	JSR	IDE_READ_INFO		; GET DRIVE INFO, ABORT IF ERROR
0089AF  2  48 DA 5A A2  	PRTS    " PPIDE1: Blocks=$"
0089B3  2  00 BD C8 89  
0089B7  2  E8 C9 24 F0  
0089D9  2  A9 01        	LDA	#$01
0089DB  2  20 6B 8A     	JSR	IDE_READ_INFO		; GET DRIVE INFO, ABORT IF ERROR
0089DE  2               IDE_INITA:
0089DE  2  20 65 88     	JSR	NEWLINE
0089E1  2  60           	RTS				; DONE
0089E2  2               ;
0089E2  2               ;__PPIDE_PROBE_______________________________________________________________________________________
0089E2  2               ;
0089E2  2               ;  PROBE FOR IDE HARDWARE
0089E2  2               ;____________________________________________________________________________________________________
0089E2  2               ;
0089E2  2               PPIDE_PROBE:
0089E2  2               ;
0089E2  2               	; BELOW TESTS FOR EXISTENCE OF AN IDE CONTROLLER ON THE
0089E2  2               	; PPIDE INTERFACE.  WE WRITE A VALUE OF ZERO FIRST SO THAT
0089E2  2               	; THE PPI BUS HOLD WILL RETURN A VALUE OF ZERO IF THERE IS
0089E2  2               	; NOTHING CONNECTED TO PPI PORT A.  THEN WE READ THE STATUS
0089E2  2               	; REGISTER.  IF AN IDE CONTROLLER IS THERE, IT SHOULD ALWAYS
0089E2  2               	; RETURN SOMETHING OTHER THAN ZERO.  IF AN IDE CONTROLLER IS
0089E2  2               	; THERE, THEN THE VALUE WRITTEN TO PPI PORT A IS IGNORED
0089E2  2               	; BECAUSE THE WRITE SIGNAL IS NEVER PULSED.
0089E2  2               
0089E2  2  A9 00        	LDA 	#$00
0089E4  2  8D 60 03     	STA 	PPIDELO 		; PPI PORT A, DATALO
0089E7  2               
0089E7  2  20 52 8C     	JSR	IDE_WAIT_NOT_BUSY	; WAIT FOR BUSY TO CLEAR
0089EA  2  B0 34        	BCS 	PPIDE_PROBE_FAIL	; IF TIMEOUT, REPORT NO IDE PRESENT
0089EC  2  A9 0F        	LDA	#PPIDE_STATUS		; GET STATUS
0089EE  2  20 01 8E     	JSR	IDE_READ
0089F1  2  8A           	TXA
0089F2  2  29 40        	AND 	#%01000000
0089F4  2  C9 00        	CMP 	#$00
0089F6  2  F0 28        	BEQ 	PPIDE_PROBE_FAIL	; IF NOT RDY BIT (BIT 6) THEN REPORT NO IDE PRESENT
0089F8  2               
0089F8  2               	; CHECK SIGNATURE
0089F8  2  A9 0A        	LDA	#PPIDE_SEC_CNT
0089FA  2  20 01 8E     	JSR	IDE_READ
0089FD  2  E0 01        	CPX 	#$01
0089FF  2  D0 1F        	BNE 	PPIDE_PROBE_FAIL	; IF not '01' THEN REPORT NO IDE PRESENT
008A01  2  A9 0B        	LDA	#PPIDE_LBALOW
008A03  2  20 01 8E     	JSR	IDE_READ
008A06  2  E0 01        	CPX 	#$01
008A08  2  D0 16        	BNE 	PPIDE_PROBE_FAIL	; IF not '01' THEN REPORT NO IDE PRESENT
008A0A  2  A9 0C        	LDA	#PPIDE_LBAMID
008A0C  2  20 01 8E     	JSR	IDE_READ
008A0F  2  E0 00        	CPX 	#$00
008A11  2  D0 0D        	BNE 	PPIDE_PROBE_FAIL	; IF not '00' THEN REPORT NO IDE PRESENT
008A13  2  A9 0D        	LDA	#PPIDE_LBAHI
008A15  2  20 01 8E     	JSR	IDE_READ
008A18  2  E0 00        	CPX 	#$00
008A1A  2  D0 04        	BNE 	PPIDE_PROBE_FAIL	; IF not '00' THEN REPORT NO IDE PRESENT
008A1C  2  18           	CLC
008A1D  2  4C 21 8A     	JMP 	PPIDE_PROBE_SUCCESS
008A20  2               PPIDE_PROBE_FAIL:
008A20  2  38           	SEC
008A21  2               PPIDE_PROBE_SUCCESS:
008A21  2  60           	RTS				; DONE, NOTE THAT A=0 AND Z IS SET
008A22  2               
008A22  2               
008A22  2               ;___IDE_IDENTIFY_TYPE____________________________________________________________________________________
008A22  2               ;
008A22  2               ; 	READ THE DISK TYPE AND DETERMINE IF IT IS USABLE BY DOS/65
008A22  2               ; 	A=IDE DEVICE (0=MST,1=SLV)
008A22  2               ;________________________________________________________________________________________________________
008A22  2               
008A22  2               IDE_IDENTIFY_TYPE:
008A22  2  48           	PHA
008A23  2  20 52 8C     	JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
008A26  2  B0 40        	BCS 	IDE_IDENTIFY_TYPE_ERROR	; IF TIMEOUT, REPORT ERROR
008A28  2  A9 00        	LDA 	#$00
008A2A  2  8D 12 05     	STA	debsehd
008A2D  2  8D 10 05     	STA	debcyll			; STORE IN TRACK (lsb)
008A30  2  8D 11 05     	STA	debcylm			; STORE IN TRACK (msb)
008A33  2  68           	PLA				; GET DRIVE TYPE
008A34  2  20 C7 8B     	JSR 	IDE_READ_SECTOR_DIRTY1
008A37  2  C9 FF        	CMP 	#$FF			; IS THERE A READ ERROR?
008A39  2  F0 2D        	BEQ 	IDE_IDENTIFY_TYPE_ERROR
008A3B  2  AD CC 94     	LDA 	hstbuf+$01FE
008A3E  2  C9 55        	CMP 	#$55
008A40  2  D0 23        	BNE 	IDE_IDENTIFY_TYPE_OK
008A42  2  AD CD 94     	LDA 	hstbuf+$01FF
008A45  2  C9 AA        	CMP 	#$AA
008A47  2  D0 1C        	BNE 	IDE_IDENTIFY_TYPE_OK
008A49  2  AD 90 94     	LDA 	hstbuf+$01C2
008A4C  2  C9 00        	CMP 	#$00
008A4E  2  D0 18        	BNE 	IDE_IDENTIFY_TYPE_ERROR
008A50  2  AD A0 94     	LDA 	hstbuf+$01D2
008A53  2  C9 00        	CMP 	#$00
008A55  2  D0 11        	BNE 	IDE_IDENTIFY_TYPE_ERROR
008A57  2  AD B0 94     	LDA 	hstbuf+$01E2
008A5A  2  C9 00        	CMP 	#$00
008A5C  2  D0 0A        	BNE 	IDE_IDENTIFY_TYPE_ERROR
008A5E  2  AD C0 94     	LDA 	hstbuf+$01F2
008A61  2  C9 00        	CMP 	#$00
008A63  2  D0 03        	BNE 	IDE_IDENTIFY_TYPE_ERROR
008A65  2               IDE_IDENTIFY_TYPE_OK:
008A65  2  A9 00        	LDA 	#$00			; EVERYTHING IS AWESOME
008A67  2  60           	RTS
008A68  2               IDE_IDENTIFY_TYPE_ERROR:
008A68  2  A9 FF        	LDA 	#$FF			; SIGNIFY ERROR
008A6A  2  60           	RTS
008A6B  2               
008A6B  2               
008A6B  2               ;*__IDE_READ_INFO___________________________________________________________________________________
008A6B  2               ;*
008A6B  2               ;*  READ IDE INFORMATION
008A6B  2               ;*	CARRY SET ON ERROR
008A6B  2               ;* 	A=MST/SLV
008A6B  2               ;*____________________________________________________________________________________________________
008A6B  2               IDE_READ_INFO:
008A6B  2               		PRTDBG "IDE Read INFORMATION$"
008A6B  2  48           		PHA
008A6C  2  48           		PHA
008A6D  2               		; SET DRIVE BIT
008A6D  2  29 01        		AND 	#$01			; ONLY WANT THE 1 BIT (MST/SLV)
008A6F  2  0A           		asl	a			; SHIFT 4
008A70  2  0A           		asl	a			;
008A71  2  0A           		asl	a			;
008A72  2  0A           		asl	a			;
008A73  2  09 E0        		ORA 	#$E0			; E0=MST  F0=SLV
008A75  2  AA           		TAX
008A76  2  A0 00        		LDY	#$00
008A78  2  A9 0E        		LDA	#PPIDE_DEVICE
008A7A  2  20 1F 8E     		JSR	IDE_WRITE
008A7D  2               
008A7D  2               
008A7D  2  20 52 8C     		JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
008A80  2  B0 4E        		BCS	IDE_READ_INFO_ABORT
008A82  2  A9 0F        		LDA	#PPIDE_COMMAND		;SELECT IDE REGISTER
008A84  2  A2 EC        		LDX	#PPIDE_CMD_ID
008A86  2  20 1F 8E     		JSR	IDE_WRITE		;ASK THE DRIVE TO READ IT
008A89  2  20 7A 8C     		JSR	IDE_WAIT_DRQ		;WAIT UNTIL IT'S GOT THE DATA
008A8C  2  B0 42        		BCS	IDE_READ_INFO_ABORT
008A8E  2  20 AA 8C     		JSR	IDE_READ_BUFFER		; GRAB THE 256 WORDS FROM THE BUFFER
008A91  2  48 DA 5A A2  		PRTS    "0x$"
008A95  2  00 BD AA 8A  
008A99  2  E8 C9 24 F0  
008AAD  2  AD 49 93     		LDA 	hstbuf+123
008AB0  2  20 43 88     		JSR 	PRTHEXBYTE
008AB3  2  AD 48 93     		LDA 	hstbuf+122
008AB6  2  20 43 88     		JSR 	PRTHEXBYTE
008AB9  2  AD 47 93     		LDA 	hstbuf+121
008ABC  2  20 43 88     		JSR 	PRTHEXBYTE
008ABF  2  AD 46 93     		LDA 	hstbuf+120
008AC2  2  20 43 88     		JSR 	PRTHEXBYTE
008AC5  2  68           		PLA
008AC6  2  20 22 8A     		JSR 	IDE_IDENTIFY_TYPE
008AC9  2  C9 00        		CMP 	#$00
008ACB  2  D0 32        		BNE 	IDE_READ_INFO_BADFS
008ACD  2  4C 31 8B     		JMP 	IDE_READ_INFO_OK
008AD0  2               IDE_READ_INFO_ABORT:
008AD0  2  68           		PLA
008AD1  2  48 DA 5A A2  		PRTS    "NOT PRESENT$"		; NOT PRESENT
008AD5  2  00 BD EA 8A  
008AD9  2  E8 C9 24 F0  
008AF6  2  20 65 88     		JSR	NEWLINE
008AF9  2  68           		PLA
008AFA  2  20 68 8B     		JSR 	IDE_REMOVE_DRIVE_ASSIGNMENTS
008AFD  2  38           		SEC
008AFE  2  60           		RTS				;
008AFF  2               IDE_READ_INFO_BADFS:
008AFF  2  48 DA 5A A2  		PRTS    " BAD FILESYSTEM$"	; NOT PRESENT
008B03  2  00 BD 18 8B  
008B07  2  E8 C9 24 F0  
008B28  2  20 65 88     		JSR	NEWLINE
008B2B  2  68           		PLA
008B2C  2  20 68 8B     		JSR 	IDE_REMOVE_DRIVE_ASSIGNMENTS
008B2F  2  38           		SEC
008B30  2  60           		RTS				;
008B31  2               IDE_READ_INFO_OK:
008B31  2  48 DA 5A A2  		PRTS    " FILE SYSTEM COMPATIBLE$" ; NOT PRESENT
008B35  2  00 BD 4A 8B  
008B39  2  E8 C9 24 F0  
008B62  2  20 65 88     		JSR	NEWLINE
008B65  2  68           		PLA
008B66  2  18           		CLC
008B67  2  60           		RTS
008B68  2               
008B68  2               IDE_REMOVE_DRIVE_ASSIGNMENTS:
008B68  2  18           		CLC
008B69  2  69 30        		ADC	#$30
008B6B  2  A2 00        		LDX 	#$00
008B6D  2               @1:
008B6D  2  DD 14 05     		CMP 	dskcfg,X 		; GET device
008B70  2  F0 09        		BEQ 	@2
008B72  2  E8           		INX
008B73  2  E8           		INX
008B74  2  E0 10        		CPX 	#16
008B76  2  D0 F5        		bne 	@1
008B78  2  4C 8B 8B     		jmp 	@3
008B7B  2               @2:
008B7B  2  48           		PHA
008B7C  2  A9 00        		LDA 	#$00
008B7E  2  9D 14 05     		STA 	dskcfg,X 		; SET device
008B81  2  E8           		INX
008B82  2  9D 14 05     		STA 	dskcfg,X 		; SET device
008B85  2  68           		pla
008B86  2  E8           		INX
008B87  2  E0 10        		CPX 	#16
008B89  2  D0 E2        		bne 	@1
008B8B  2               @3:
008B8B  2  60           		rts
008B8C  2               
008B8C  2               ;__IDE_PPIDETECT____________________________________________________________________________________
008B8C  2               ;
008B8C  2               ;  PROBE FOR PPI HARDWARE
008B8C  2               ;____________________________________________________________________________________________________
008B8C  2               ;
008B8C  2               IDE_PPIDETECT:
008B8C  2               ;
008B8C  2               	; TEST FOR PPI EXISTENCE
008B8C  2               	; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
008B8C  2               	; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
008B8C  2               	; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
008B8C  2               	; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
008B8C  2               	; INTERFERE WITH THE VALUE BEING READ.
008B8C  2  20 43 8E     	JSR	SET_PPI_WR
008B8F  2               ;
008B8F  2  A9 00        	LDA     #$00			; VALUE ZERO
008B91  2  8D 60 03     	STA	PPIDELO			; PUSH VALUE TO PORT
008B94  2  AD 60 03     	LDA	PPIDELO			; GET PORT VALUE
008B97  2  C9 00                CMP     #$00
008B99  2  60           	RTS				; AND RETURN
008B9A  2               ;
008B9A  2               
008B9A  2               
008B9A  2               ;*__IDE_READ_SECTOR___________________________________________________________________________________
008B9A  2               ;*
008B9A  2               ;*  READ IDE SECTOR (IN LBA) INTO BUFFER
008B9A  2               ;*
008B9A  2               ;*____________________________________________________________________________________________________
008B9A  2               IDE_READ_SECTOR:
008B9A  2               		PRTDBG "IDE Read Sector$"
008B9A  2  20 A1 8B     		JSR 	IDE_READ_RAW_SECTOR
008B9D  2  20 68 92     		JSR 	DEBSECR512
008BA0  2  60           		RTS
008BA1  2               
008BA1  2               IDE_READ_RAW_SECTOR:
008BA1  2               		PRTDBG "IDE Read Raw Sector$"
008BA1  2  20 46 8D     	  	JSR	IDE_CONVERT_SECTOR	;
008BA4  2               
008BA4  2  AD 12 05     		LDA	debsehd			; STORE CURRENT PARMS
008BA7  2  CD 51 8E     		CMP	Cdebsehd		;
008BAA  2  D0 13        		BNE	IDE_READ_SECTOR_DIRTY
008BAC  2  AD 11 05     		LDA	debcylm			;
008BAF  2  CD 50 8E     		CMP	Cdebcylm		;
008BB2  2  D0 0B        		BNE	IDE_READ_SECTOR_DIRTY
008BB4  2  AD 10 05     		LDA	debcyll			;
008BB7  2  CD 4F 8E     		CMP	Cdebcyll		;
008BBA  2  D0 03        		BNE	IDE_READ_SECTOR_DIRTY
008BBC  2  A9 00        		LDA	#$00			; ZERO = 1 ON RETURN = OPERATION OK
008BBE  2  60           		RTS
008BBF  2               
008BBF  2               IDE_READ_SECTOR_DIRTY:
008BBF  2               		PRTDBG "IDE Read Sector Buffer Dirty$"
008BBF  2  20 52 8C     		JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
008BC2  2  B0 2A        		BCS 	IDE_READ_SECTOR_DIRTY_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
008BC4  2  20 B2 92     		JSR 	GET_DRIVE_DEVICE
008BC7  2               IDE_READ_SECTOR_DIRTY1:
008BC7  2  20 16 8D     		JSR	IDE_SETUP_LBA		;TELL IT WHICH SECTOR WE WANT
008BCA  2  A9 0F        		LDA	#PPIDE_COMMAND		;SELECT IDE REGISTER
008BCC  2  A2 20        		LDX	#PPIDE_CMD_READ
008BCE  2  20 1F 8E     		JSR	IDE_WRITE		;ASK THE DRIVE TO READ IT
008BD1  2  20 7A 8C     		JSR	IDE_WAIT_DRQ		;WAIT UNTIL IT'S GOT THE DATA
008BD4  2  B0 18        		BCS 	IDE_READ_SECTOR_DIRTY_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
008BD6  2  20 AA 8C     		JSR	IDE_READ_BUFFER		; GRAB THE 256 WORDS FROM THE BUFFER
008BD9  2  AD 12 05     		LDA	debsehd			; STORE CURRENT PARMS
008BDC  2  8D 51 8E     		STA	Cdebsehd		;
008BDF  2  AD 10 05     		LDA	debcyll			;
008BE2  2  8D 4F 8E     		STA	Cdebcyll		;
008BE5  2  AD 11 05     		LDA	debcylm			;
008BE8  2  8D 50 8E     		STA	Cdebcylm		;
008BEB  2               
008BEB  2  A9 00        		LDA	#$00			; ZERO = 1 ON RETURN = OPERATION OK
008BED  2  60           		RTS
008BEE  2               IDE_READ_SECTOR_DIRTY_ERROR:
008BEE  2  A9 FF        		LDA	#$FF			; ZERO = 1 ON RETURN = OPERATION OK
008BF0  2  60           		RTS
008BF1  2               
008BF1  2               ;*__IDE_WRITE_SECTOR__________________________________________________________________________________
008BF1  2               ;*
008BF1  2               ;*  WRITE IDE SECTOR (IN LBA) FROM BUFFER
008BF1  2               ;*
008BF1  2               ;*____________________________________________________________________________________________________
008BF1  2               IDE_WRITE_SECTOR:
008BF1  2               		PRTDBG "IDE Write Sector$"
008BF1  2  20 A1 8B     	  	JSR	IDE_READ_RAW_SECTOR	; determine physical sector
008BF4  2  20 91 92     	  	JSR	BLKSECR512		; block sector for writing
008BF7  2  20 52 8C     		JSR	IDE_WAIT_NOT_BUSY	;MAKE SURE DRIVE IS READY
008BFA  2  B0 28        		BCS 	IDE_WRITE_SECTOR_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
008BFC  2  20 B2 92     		JSR 	GET_DRIVE_DEVICE
008BFF  2  20 16 8D     		JSR	IDE_SETUP_LBA		;TELL IT WHICH SECTOR WE WANT
008C02  2  A9 0F        		LDA	#PPIDE_COMMAND
008C04  2  A2 30        		LDX	#PPIDE_CMD_WRITE
008C06  2  20 1F 8E     		JSR	IDE_WRITE		;TELL DRIVE TO WRITE A SECTOR
008C09  2  20 7A 8C     		JSR	IDE_WAIT_DRQ		;WAIT UNIT IT WANTS THE DATA
008C0C  2  B0 16        		BCS 	IDE_WRITE_SECTOR_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
008C0E  2  20 DF 8C     		JSR	IDE_WRITE_BUFFER	;GIVE THE DATA TO THE DRIVE
008C11  2  20 52 8C     		JSR	IDE_WAIT_NOT_BUSY	;WAIT UNTIL THE WRITE IS COMPLETE
008C14  2  B0 0E        		BCS 	IDE_WRITE_SECTOR_ERROR	; IF TIMEOUT, REPORT NO IDE PRESENT
008C16  2  A9 FF        		LDA	#$FF			; STORE CURRENT PARMS
008C18  2  8D 51 8E     		STA	Cdebsehd		;
008C1B  2  8D 4F 8E     		STA	Cdebcyll		;
008C1E  2  8D 50 8E     		STA	Cdebcylm		;
008C21  2               
008C21  2  A9 00        		LDA	#$00			; ZERO ON RETURN = OPERATION OK
008C23  2  60           		RTS
008C24  2               IDE_WRITE_SECTOR_ERROR:
008C24  2  A9 FF        		LDA	#$FF			; 1 ON RETURN = OPERATION FAIL
008C26  2  60           		RTS
008C27  2               
008C27  2               ;*__PPIDE_RESET____________________________________________________________________________________
008C27  2               ;*
008C27  2               ;*  SOFT RESET IDE CHANNEL
008C27  2               ;*
008C27  2               ;*____________________________________________________________________________________________________
008C27  2               PPIDE_RESET:
008C27  2                 	PRTDBG "IDE Reset$"
008C27  2  A9 00        		LDA	#$00
008C29  2  8D 12 05     		STA	debsehd
008C2C  2  8D 10 05     		STA	debcyll
008C2F  2  8D 11 05     		STA	debcylm
008C32  2  A9 FF        		LDA	#$FF			;
008C34  2  8D 51 8E     		STA	Cdebsehd		;
008C37  2  8D 4F 8E     		STA	Cdebcyll		;
008C3A  2  8D 50 8E     		STA	Cdebcylm		;
008C3D  2               
008C3D  2  A9 80        		LDA	#PPIDE_RST_LINE
008C3F  2  8D 62 03     		STA	PPIDECNTRL			; ASSERT RST LINE ON IDE INTERFACE
008C42  2  A2 00        		LDX	#$00
008C44  2               	PRTDBG "IDE Reset Delay$"
008C44  2               RST_DLY:
008C44  2  CA           		DEX
008C45  2  E0 00        		CPX	#$00
008C47  2  D0 FB        		BNE	RST_DLY
008C49  2  A9 00        		LDA	#$00
008C4B  2  8D 62 03     		STA	PPIDECNTRL			; DEASSERT RST LINE ON IDE INTERFACE
008C4E  2               
008C4E  2               ; IF A DSKYNG IS ACTIVE AND IS ON THE SAME PPI PORT AS THE PPISD BEING
008C4E  2               ; RESET, THEN THE DSKYNG WILL ALSO BE RESET.  SO, THE DSKY IS ALSO INITIALIZED.
008C4E  2               	.IF (USEDSKYNG=1)
008C4E  2  20 41 8F     	JSR 	DSKY_REINIT
008C51  2               	.ENDIF
008C51  2               
008C51  2  60           		RTS
008C52  2               
008C52  2               
008C52  2               ;*__IDE_WAIT_NOT_BUSY_______________________________________________________________________________
008C52  2               ;*
008C52  2               ;*  WAIT FOR IDE CHANNEL TO BECOME READY
008C52  2               ;*
008C52  2               ;*____________________________________________________________________________________________________
008C52  2               IDE_WAIT_NOT_BUSY:
008C52  2  DA           		PHX
008C53  2  5A           		PHY
008C54  2  48           		PHA
008C55  2  A9 00        		LDA #$00
008C57  2  8D F4 88     		STA PPIDETIMEOUT
008C5A  2  8D F5 88     		STA PPIDETIMEOUT+1
008C5D  2               IDE_WAIT_NOT_BUSY1:
008C5D  2  A9 0F        		LDA	#PPIDE_STATUS		;WAIT FOR RDY BIT TO BE SET
008C5F  2  20 01 8E     		JSR	IDE_READ
008C62  2  8A           		TXA
008C63  2  29 80        		AND	#$80
008C65  2  F0 0E        		BEQ	IDE_WAIT_NOT_BUSY2
008C67  2  EE F4 88     		INC 	PPIDETIMEOUT
008C6A  2  D0 F1        		BNE 	IDE_WAIT_NOT_BUSY1
008C6C  2  EE F5 88     		INC 	PPIDETIMEOUT+1
008C6F  2  D0 EC        		BNE 	IDE_WAIT_NOT_BUSY1
008C71  2  38           		SEC
008C72  2  4C 76 8C     		JMP	IDE_WAIT_NOT_BUSY3
008C75  2               IDE_WAIT_NOT_BUSY2:
008C75  2  18           		CLC
008C76  2               IDE_WAIT_NOT_BUSY3:
008C76  2  68           		PLA
008C77  2  7A           		PLY
008C78  2  FA           		PLX
008C79  2  60           		RTS
008C7A  2               
008C7A  2               ;*__IDE_WAIT_DRQ______________________________________________________________________________________
008C7A  2               ;*
008C7A  2               ;*	WAIT FOR THE DRIVE TO BE READY TO TRANSFER DATA.
008C7A  2               ;*
008C7A  2               ;*____________________________________________________________________________________________________
008C7A  2               IDE_WAIT_DRQ:
008C7A  2  DA           		PHX
008C7B  2  5A           		PHY
008C7C  2  48           		PHA
008C7D  2  A9 00        		LDA #$00
008C7F  2  8D F4 88     		STA PPIDETIMEOUT
008C82  2  8D F5 88     		STA PPIDETIMEOUT+1
008C85  2               IDE_WAIT_DRQ1:
008C85  2  A9 0F        		LDA	#PPIDE_STATUS		;WAIT FOR DRQ BIT TO BE SET
008C87  2  20 01 8E     		JSR	IDE_READ
008C8A  2  8A           		TXA
008C8B  2  29 88        		AND	#%10001000		; MASK OFF BUSY(7) AND DRQ(3)
008C8D  2  C9 08        		CMP	#%00001000		; WE WANT BUSY(7) TO BE 0 AND DRQ (3) TO BE 1
008C8F  2  F0 14        		BEQ	IDE_WAIT_DRQ2
008C91  2  29 01        		AND	#%00000001		; IS ERROR?
008C93  2  C9 01        		CMP	#%00000001		;
008C95  2  F0 0A        		BEQ	IDE_WAIT_DRQE
008C97  2  EE F4 88     		INC 	PPIDETIMEOUT
008C9A  2  D0 E9        		BNE 	IDE_WAIT_DRQ1
008C9C  2  EE F5 88     		INC 	PPIDETIMEOUT+1
008C9F  2  D0 E4        		BNE 	IDE_WAIT_DRQ1
008CA1  2               IDE_WAIT_DRQE:
008CA1  2  38           		SEC
008CA2  2  4C A6 8C     		JMP	IDE_WAIT_DRQ3
008CA5  2               IDE_WAIT_DRQ2:
008CA5  2  18           		CLC
008CA6  2               IDE_WAIT_DRQ3:
008CA6  2  68           		PLA
008CA7  2  7A           		PLY
008CA8  2  FA           		PLX
008CA9  2  60           		RTS
008CAA  2               
008CAA  2               
008CAA  2               
008CAA  2               ;*__IDE_READ_BUFFER___________________________________________________________________________________
008CAA  2               ;*
008CAA  2               ;*  READ IDE BUFFER LITTLE ENDIAN
008CAA  2               ;*
008CAA  2               ;*____________________________________________________________________________________________________
008CAA  2               IDE_READ_BUFFER:
008CAA  2  A2 00        		LDX    	#$00			; INDEX
008CAC  2               IDEBUFRD:
008CAC  2  8E F3 88     		STX	PPIDEINDEX
008CAF  2  A9 08        		LDA	#PPIDE_DATA
008CB1  2  20 01 8E     		JSR	IDE_READ
008CB4  2  8A           		TXA
008CB5  2  AE F3 88     		LDX	PPIDEINDEX
008CB8  2  9D CE 92     		STA	hstbuf,X		;
008CBB  2  E8           		INX				;
008CBC  2  98           		TYA				; THEN HIGH BYTE OF WORD
008CBD  2  9D CE 92     		STA	hstbuf,X		;
008CC0  2  E8           		INX
008CC1  2  E0 00        		CPX    	#$00			;
008CC3  2  D0 E7        		BNE	IDEBUFRD		;
008CC5  2               IDEBUFRD1:
008CC5  2  8E F3 88     		STX	PPIDEINDEX
008CC8  2  A9 08        		LDA	#PPIDE_DATA
008CCA  2  20 01 8E     		JSR	IDE_READ
008CCD  2  8A           		TXA
008CCE  2  AE F3 88     		LDX	PPIDEINDEX
008CD1  2  9D CE 93     		STA	hstbuf+256,X		;
008CD4  2  E8           		INX				;
008CD5  2  98           		TYA				; THEN HIGH BYTE OF WORD
008CD6  2  9D CE 93     		STA	hstbuf+256,X		;
008CD9  2  E8           		INX				;
008CDA  2  E0 00        		CPX    	#$00			;
008CDC  2  D0 E7        		BNE	IDEBUFRD1		;
008CDE  2  60           		RTS				;
008CDF  2               
008CDF  2               ;*__IDE_WRITE_BUFFER___________________________________________________________________________________
008CDF  2               ;*
008CDF  2               ;*  WRITE IDE BUFFER LITTLE ENDIAN
008CDF  2               ;*
008CDF  2               ;*____________________________________________________________________________________________________
008CDF  2               IDE_WRITE_BUFFER:
008CDF  2  A2 00        		LDX    	#$00			; INDEX
008CE1  2               IDEBUFWT:
008CE1  2  8E F3 88     		STX	PPIDEINDEX
008CE4  2  BD CF 92     		LDA     hstbuf+1,X		; SECTORS ARE BIG ENDIAN
008CE7  2  A8           		TAY				;
008CE8  2  BD CE 92     		LDA     hstbuf,X		; SECTORS ARE BIG ENDIAN
008CEB  2  AA           		TAX
008CEC  2  A9 08        		LDA	#PPIDE_DATA
008CEE  2  20 1F 8E     		JSR	IDE_WRITE
008CF1  2  AE F3 88     		LDX	PPIDEINDEX
008CF4  2  E8           		INX				;
008CF5  2  E8           		INX				;
008CF6  2  E0 00        		CPX    	#$00			;
008CF8  2  D0 E7        		BNE	IDEBUFWT		;
008CFA  2  A2 00        		LDX    	#$00			; INDEX
008CFC  2               IDEBUFWT1:
008CFC  2  8E F3 88     		STX	PPIDEINDEX
008CFF  2  BD CF 93     		LDA     hstbuf+257,X		; SECTORS ARE BIG ENDIAN
008D02  2  A8           		TAY
008D03  2  BD CE 93     		LDA     hstbuf+256,X		; SECTORS ARE BIG ENDIAN
008D06  2  AA           		TAX
008D07  2  A9 08        		LDA	#PPIDE_DATA
008D09  2  20 1F 8E     		JSR	IDE_WRITE
008D0C  2  AE F3 88     		LDX	PPIDEINDEX
008D0F  2  E8           		INX				;
008D10  2  E8           		INX				;
008D11  2  E0 00        		CPX    	#$00			;
008D13  2  D0 E7        		BNE	IDEBUFWT1		;
008D15  2  60           		RTS				;
008D16  2               
008D16  2               ;*__IDE_SETUP_LBA_____________________________________________________________________________________
008D16  2               ;*
008D16  2               ;*  SETUP LBA DATA
008D16  2               ;*  A= DRIVE DEVICE
008D16  2               ;*____________________________________________________________________________________________________
008D16  2               IDE_SETUP_LBA:
008D16  2               		PRTDBG "PPIDE SETUP LBA$"
008D16  2  29 01        		and 	#$01			; only want drive cfg
008D18  2  0A           		asl	a			; SHIFT 4
008D19  2  0A           		asl	a			;
008D1A  2  0A           		asl	a			;
008D1B  2  0A           		asl	a			;
008D1C  2  09 E0        		ORA 	#$E0			; E0=MST  F0=SLV
008D1E  2  AA           		TAX
008D1F  2  A0 00        		LDY	#$00
008D21  2  A9 0E        		LDA	#PPIDE_DEVICE
008D23  2  20 1F 8E     		JSR	IDE_WRITE
008D26  2               
008D26  2  AE 11 05     		LDX    	debcylm
008D29  2  A9 0D        		LDA	#PPIDE_LBAHI
008D2B  2  20 1F 8E     		JSR	IDE_WRITE
008D2E  2               
008D2E  2  AE 10 05     		LDX    	debcyll			;
008D31  2  A9 0C        		LDA	#PPIDE_LBAMID
008D33  2  20 1F 8E     		JSR	IDE_WRITE
008D36  2               
008D36  2  AE 12 05     		LDX    	debsehd			;
008D39  2  A9 0B        		LDA	#PPIDE_LBALOW
008D3B  2  20 1F 8E     		JSR	IDE_WRITE
008D3E  2               
008D3E  2  A2 01        		LDX	#$01
008D40  2  A9 0A        		LDA	#PPIDE_SEC_CNT
008D42  2  20 1F 8E     		JSR	IDE_WRITE
008D45  2               
008D45  2  60           		RTS
008D46  2               
008D46  2               ;___IDE_CONVERT_SECTOR___________________________________________________________________________________
008D46  2               ;
008D46  2               ; 	TRANSLATE SECTORS INTO IDE FORMAT
008D46  2               ;________________________________________________________________________________________________________
008D46  2               IDE_CONVERT_SECTOR:
008D46  2  AD 0C 05     	LDA	sektrk			; LOAD TRACK # (LOW BYTE)
008D49  2  29 0F        	AND 	#$0F			; ISOLATE HEAD IN LOW 4 BITS
008D4B  2  0A           	asl	a			; MOVE TO HIGH BYTE
008D4C  2  0A           	asl	a
008D4D  2  0A           	asl	a
008D4E  2  0A           	asl	a
008D4F  2  AA           	TAX 				; PARK IN X
008D50  2  AD 0E 05     	LDA	seksec			; LOAD SECTOR # (LOW BYTE)
008D53  2  4A           	LSR	A			;
008D54  2  4A           	LSR	A			; DIVIDE BY 4 (FOR BLOCKING)
008D55  2  29 0F        	AND 	#$0F 			; CLEAR UPPER 4 BITS (JUST 'CAUSE)
008D57  2  8D 12 05     	STA	debsehd			; STORE IN SECTOR/HEAD
008D5A  2  8A           	TXA 				; GET HEAD BACK
008D5B  2  0D 12 05     	ORA 	debsehd
008D5E  2  8D 12 05     	STA	debsehd			; STORE IN SECTOR/HEAD
008D61  2               
008D61  2  AD 0C 05     	LDA 	sektrk
008D64  2  8D 10 05     	STA	debcyll			; STORE IN TRACK (lsb)
008D67  2  AD 0D 05     	LDA 	sektrk+1
008D6A  2  8D 11 05     	STA	debcylm			; STORE IN TRACK (msb)
008D6D  2               					; REMOVE HEAD FROM TRACK VALUE (DIV/4)
008D6D  2  AD 11 05     	LDA	debcylm
008D70  2  4A           	LSR 	A
008D71  2  8D 11 05     	STA	debcylm
008D74  2  AD 10 05     	LDA	debcyll
008D77  2  6A           	ROR 	A
008D78  2  8D 10 05     	STA	debcyll
008D7B  2               
008D7B  2  AD 11 05     	LDA	debcylm
008D7E  2  4A           	LSR 	A
008D7F  2  8D 11 05     	STA	debcylm
008D82  2  AD 10 05     	LDA	debcyll
008D85  2  6A           	ROR 	A
008D86  2  8D 10 05     	STA	debcyll
008D89  2               
008D89  2  AD 11 05     	LDA	debcylm
008D8C  2  4A           	LSR 	A
008D8D  2  8D 11 05     	STA	debcylm
008D90  2  AD 10 05     	LDA	debcyll
008D93  2  6A           	ROR 	A
008D94  2  8D 10 05     	STA	debcyll
008D97  2               
008D97  2  AD 11 05     	LDA	debcylm
008D9A  2  4A           	LSR 	A
008D9B  2  8D 11 05     	STA	debcylm
008D9E  2  AD 10 05     	LDA	debcyll
008DA1  2  6A           	ROR 	A
008DA2  2  8D 10 05     	STA	debcyll
008DA5  2               
008DA5  2               ;	ADD SLICE OFFSET
008DA5  2  AD 13 05     	LDA	sekdsk			; GET DRIVE#
008DA8  2  29 07        	AND 	#7			; ONLY FIRST 8 DEVICES SUPPORTED
008DAA  2  0A           	asl	a			; DOUBLE NUMBER FOR TABLE LOOKUP
008DAB  2  AA           	TAX 				; MOVE TO X REGISTER
008DAC  2  E8           	INX				; WANT SECOND BYTE OF ENTRY
008DAD  2  BD 14 05     	LDA 	dskcfg,X 		; GET SLICE#
008DB0  2  8D 54 8E     	STA 	slicetmp+1 		; SLICE OFFSET MSB
008DB3  2  A9 00        	LDA 	#0	 		; GET SLICE#
008DB5  2  8D 53 8E     	STA 	slicetmp		; SLICE OFFSET LSB
008DB8  2  18           	CLC				; VOODOO MATH TO TAKE SLICE*$4000
008DB9  2  6E 54 8E     	ROR 	slicetmp+1
008DBC  2  6E 53 8E     	ROR	slicetmp
008DBF  2  6E 54 8E     	ROR 	slicetmp+1
008DC2  2  6E 53 8E     	ROR	slicetmp
008DC5  2               
008DC5  2  BD 14 05     	LDA 	dskcfg,X 		; GET SLICE#
008DC8  2  18           	clc
008DC9  2  6D 53 8E     	adc 	slicetmp
008DCC  2  8D 53 8E     	sta 	slicetmp
008DCF  2               					; ADD SLICE OFFSET TO TRACK #
008DCF  2  18           	clc				; clear carry
008DD0  2  AD 53 8E     	lda slicetmp
008DD3  2  6D 10 05     	adc debcyll
008DD6  2  8D 10 05     	sta debcyll			; store sum of LSBs
008DD9  2  AD 54 8E     	lda slicetmp+1
008DDC  2  6D 11 05     	adc debcylm			; add the MSBs using carry from
008DDF  2  8D 11 05     	sta debcylm			; the previous calculation
008DE2  2               
008DE2  2               
008DE2  2               
008DE2  2               
008DE2  2                 .IF USEDSKY=1 || USEDSKYNG=1
008DE2  2                 	PRTDBG "DSKY OUTPUT 1$"
008DE2  2  AD 13 05       	lda	sekdsk
008DE5  2  8D 08 05       	sta	DSKY_HEXBUF
008DE8  2  AD 11 05      	lda	debcylm
008DEB  2  8D 09 05       	sta	DSKY_HEXBUF+1
008DEE  2  AD 10 05      	lda	debcyll
008DF1  2  8D 0A 05       	sta	DSKY_HEXBUF+2
008DF4  2  AD 12 05         	lda	debsehd
008DF7  2  8D 0B 05       	sta	DSKY_HEXBUF+3
008DFA  2  20 C7 8F       	JSR	DSKY_BIN2SEG
008DFD  2  20 FC 8F     	JSR	DSKY_SHOW
008E00  2                 .ENDIF
008E00  2  60           	RTS
008E01  2               
008E01  2               
008E01  2               ;-------------------------------------------------------------------------------
008E01  2               
008E01  2               ; LOW LEVEL I/O TO THE DRIVE.  THESE ARE THE ROUTINES THAT TALK
008E01  2               ; DIRECTLY TO THE DRIVE, VIA THE 8255 CHIP.  NORMALLY A MAIN
008E01  2               ; PROGRAM WOULD NOT CALL TO THESE.
008E01  2               
008E01  2               	;DO A READ BUS CYCLE TO THE DRIVE, USING THE 8255.
008E01  2               	;INPUT A = IDE REGSITER ADDRESS
008E01  2               	;OUTPUT X = LOWER BYTE READ FROM IDE DRIVE
008E01  2               	;OUTPUT Y = UPPER BYTE READ FROM IDE DRIVE
008E01  2               
008E01  2               IDE_READ:
008E01  2  20 3B 8E     	JSR	SET_PPI_RD		; SETUP FOR A READ CYCLE
008E04  2               
008E04  2  8D 62 03     	STA	PPIDECNTRL		;DRIVE ADDRESS ONTO CONTROL LINES
008E07  2  09 40        	ORA	#PPIDE_RD_LINE		; ASSERT RD PIN
008E09  2  8D 62 03     	STA	PPIDECNTRL
008E0C  2  48           	PHA
008E0D  2               
008E0D  2  AE 60 03     	LDX	PPIDELO			; READ LOWER BYTE
008E10  2  AC 61 03     	LDY	PPIDEHI			; READ UPPER BYTE
008E13  2               
008E13  2  68           	PLA				; RESTORE REGISTER VALUE
008E14  2  49 40        	EOR	#PPIDE_RD_LINE		; DE-ASSERT RD SIGNAL
008E16  2  8D 62 03     	STA	PPIDECNTRL
008E19  2  A9 00        	LDA	#$00
008E1B  2  8D 62 03     	STA	PPIDECNTRL		;DEASSERT ALL CONTROL PINS
008E1E  2  60           	RTS
008E1F  2               
008E1F  2               
008E1F  2               
008E1F  2               
008E1F  2               	;DO A WRITE BUS CYCLE TO THE DRIVE, VIA THE 8255
008E1F  2               	;INPUT A = IDE REGISTER ADDRESS
008E1F  2               	;INPUT REGISTER X = LSB TO WRITE
008E1F  2               	;INPUT REGISTER Y = MSB TO WRITE
008E1F  2               	;
008E1F  2               
008E1F  2               
008E1F  2               IDE_WRITE:
008E1F  2  20 43 8E     	JSR	SET_PPI_WR		; SETUP FOR A WRITE CYCLE
008E22  2               
008E22  2  8E 60 03     	STX	PPIDELO			; WRITE LOWER BYTE
008E25  2  8C 61 03     	STY	PPIDEHI			; WRITE UPPER BYTE
008E28  2               
008E28  2  8D 62 03     	STA	PPIDECNTRL		;DRIVE ADDRESS ONTO CONTROL LINES
008E2B  2               
008E2B  2  09 20        	ORA	#PPIDE_WR_LINE		; ASSERT WRITE PIN
008E2D  2  8D 62 03     	STA	PPIDECNTRL
008E30  2               
008E30  2  49 20        	EOR	#PPIDE_WR_LINE		; DE ASSERT WR PIN
008E32  2  8D 62 03     	STA	PPIDECNTRL
008E35  2               
008E35  2  A9 00        	LDA	#$00
008E37  2  8D 62 03     	STA	PPIDECNTRL		;DEASSERT ALL CONTROL PINS
008E3A  2  60           	RTS
008E3B  2               
008E3B  2               
008E3B  2               ;-----------------------------------------------------------------------------------
008E3B  2               ; PPI SETUP ROUTINE TO CONFIGURE THE APPROPRIATE PPI MODE
008E3B  2               ;
008E3B  2               ;------------------------------------------------------------------------------------
008E3B  2               
008E3B  2               SET_PPI_RD:
008E3B  2  48           	PHA
008E3C  2  A9 92        	LDA	#PPRD_IDE_8255
008E3E  2  8D 63 03     	STA	PPIDEPPIC				;CONFIG 8255 CHIP, READ MODE
008E41  2  68           	PLA
008E42  2  60           	RTS
008E43  2               
008E43  2               SET_PPI_WR:
008E43  2  48           	PHA
008E44  2  A9 80        	LDA	#PPWR_IDE_8255
008E46  2  8D 63 03     	STA	PPIDEPPIC				;CONFIG 8255 CHIP, WRITE MODE
008E49  2  68           	PLA
008E4A  2  60           	RTS
008E4B  2               
008E4B  2               
008E4B  2               ;allocate the following data areas to unused ram space
008E4B  2  00           LASTCHAR: 	.byte 0		;save sector for warm boot
008E4C  2  00           savsec:		.byte 0		;save sector for warm boot
008E4D  2  00           count:		.byte 0		;counter in warm boot
008E4E  2  00           temp:		.byte 0		;save hstdsk for warm boot
008E4F  2  00           Cdebcyll:	.byte 0		; DEBLOCKED CYLINDER LSB
008E50  2  00           Cdebcylm:	.byte 0		; DEBLOCKED CYLINDER MSB
008E51  2  00           Cdebsehd:	.byte 0		; DEBLOCKED SECTOR AND HEAD (HS)
008E52  2  00           DEBDIRTY:	.byte 0		; DIRTY FLAG
008E53  2  00 00        slicetmp:	.word 0		; USED TO CALCULATE SLICE OFFSET
008E55  2               
008E55  1               		.INCLUDE "dosdskyn.asm"
008E55  2               ;__DSKYNG DRIVERS_________________________________________________________________________________________________________________
008E55  2               ;
008E55  2               ; 	Nhyodyne DSKY/NG drivers
008E55  2               ;
008E55  2               ;	Entry points:
008E55  2               ;               DSKY_INIT
008E55  2               ;               DSKY_SHOW
008E55  2               ;               DSKY_BIN2SEG
008E55  2               ;               DSKY_RESET
008E55  2               ;               DSKY_STAT
008E55  2               ;               DSKY_GETKEY
008E55  2               ;               DSKY_BEEP
008E55  2               ;               DSKY_L1ON
008E55  2               ;               DSKY_L2ON
008E55  2               ;               DSKY_L1OFF
008E55  2               ;               DSKY_L2OFF
008E55  2               ;               DSKY_PUTLED
008E55  2               ;               DSKY_BLANK
008E55  2               ;________________________________________________________________________________________________________________________________
008E55  2               ;
008E55  2               ;
008E55  2               ; A DSKYNG CAN SHARE A PPI BUS WITH EITHER A PPIDE OR PPISD.
008E55  2               ;
008E55  2               ; LED SEGMENTS (BIT VALUES)
008E55  2               ;
008E55  2               ;	+--01--+
008E55  2               ;	20    02
008E55  2               ;	+--40--+
008E55  2               ;	10    04
008E55  2               ;	+--08--+  80
008E55  2               ;
008E55  2               ; KEY CODE MAP (KEY CODES) CSCCCRRR
008E55  2               ;                          ||||||||
008E55  2               ;                          |||||+++-- ROW
008E55  2               ;                          ||+++----- COL
008E55  2               ;                          |+-------- SHIFT
008E55  2               ;                          +--------- CONTROL
008E55  2               ;
008E55  2               ;	00	08	10	18	23
008E55  2               ;	01	09	11	19	22
008E55  2               ;	02	0A	12	1A	21
008E55  2               ;	03	0B	13	1B	20
008E55  2               ;	04	0C	14	1C	SHIFT
008E55  2               ;	05	0D	15	1D	CTRL
008E55  2               ;
008E55  2               ; LED BIT MAP (BIT VALUES)
008E55  2               ;
008E55  2               ;	$08	$09	$0A	$0B	$0C	$0D	$0E	$0F
008E55  2               ;	---	---	---	---	---	---	---	---
008E55  2               ;	01	01	01	01	01
008E55  2               ;	02	02	02	02	02
008E55  2               ;	04      04      04      04	04
008E55  2               ;	08      08      08      08	08
008E55  2               ;	10      10      10      10	10
008E55  2               ;	20      20      20      20	20	L1	L2 	BUZZ
008E55  2               ;
008E55  2               DSKY_PPI	=	$0360		; PORT
008E55  2               DSKY_PPIA	= 	DSKY_PPI + 0 	; PORT A
008E55  2               DSKY_PPIB	= 	DSKY_PPI + 1 	; PORT B
008E55  2               DSKY_PPIC	= 	DSKY_PPI + 2    ; PORT C
008E55  2               DSKY_PPIX 	= 	DSKY_PPI + 3    ; PPI CONTROL PORT
008E55  2               ;
008E55  2               DSKY_PPIX_RD	=	%10010010	; PPIX VALUE FOR READS
008E55  2               DSKY_PPIX_WR	=	%10000010	; PPIX VALUE FOR WRITES
008E55  2               ;
008E55  2               ; PIO CHANNEL C:
008E55  2               ;
008E55  2               ;	7	6	5	4	3	2	1	0
008E55  2               ;	RES	0	0	CS	CS	/RD	/WR	A0
008E55  2               ;
008E55  2               ; SETTING BITS 3 & 4 WILL ASSERT /CS ON 3279
008E55  2               ; CLEAR BITS 1 OR 2 TO ASSERT READ/WRITE
008E55  2               ;
008E55  2               DSKY_PPI_IDLE	=	%00000110
008E55  2               ;
008E55  2               DSKY_CMD_CLR	=	%11011111	; CLEAR (ALL OFF)
008E55  2               DSKY_CMD_CLRX	=	%11010011	; CLEAR (ALL ON)
008E55  2               DSKY_CMD_WDSP	=	%10010000	; WRITE DISPLAY RAM
008E55  2               DSKY_CMD_RDSP	=	%01110000	; READ DISPLAY RAM
008E55  2               DSKY_CMD_CLK	=	%00100000	; SET CLK PRESCALE
008E55  2               DSKY_CMD_FIFO	=	%01000000	; READ FIFO
008E55  2               ;
008E55  2               DSKY_PRESCL	=	DSKYOSC/100000	; PRESCALER
008E55  2               ;
008E55  2               ;__DSKY_INIT_________________________________________________________________________________________
008E55  2               ;
008E55  2               ;  DISPLAY DSKY INFO
008E55  2               ;____________________________________________________________________________________________________
008E55  2               ;
008E55  2               DSKY_INIT:
008E55  2                       PRTDBG "DSKY INIT:$"
008E55  2  20 11 8F             JSR     DSKY_PREINIT
008E58  2  48 DA 5A A2  	PRTS "DSKY:$"
008E5C  2  00 BD 71 8E  
008E60  2  E8 C9 24 F0  
008E77  2  20 65 88            	JSR	NEWLINE
008E7A  2               
008E7A  2               ;
008E7A  2  48 DA 5A A2  	PRTS    " IO=0x$"
008E7E  2  00 BD 93 8E  
008E82  2  E8 C9 24 F0  
008E9A  2  A9 03        	LDA	#>DSKY_PPI		; GET BASE PORT
008E9C  2  20 43 88     	JSR	PRTHEXBYTE		; PRINT BASE PORT
008E9F  2  A9 60               	LDA	#<DSKY_PPI		; GET BASE PORT
008EA1  2  20 43 88     	JSR	PRTHEXBYTE		; PRINT BASE PORT
008EA4  2  48 DA 5A A2  	PRTS    " MODE=$"
008EA8  2  00 BD BD 8E  
008EAC  2  E8 C9 24 F0  
008EC4  2  48 DA 5A A2  	PRTS    "NG$"			; PRINT DSKY TYPE
008EC8  2  00 BD DD 8E  
008ECC  2  E8 C9 24 F0  
008EE0  2               ;
008EE0  2  AD 7A 91     	LDA	DSKY_PRESENT	        ; PRESENT?
008EE3  2  C9 FF        	CMP     #$FF		        ; SET FLAGS
008EE5  2  F0 26                BEQ     DSKY_INITA
008EE7  2  48 DA 5A A2  	PRTS    " NOT PRESENT$"		; NOT PRESENT
008EEB  2  00 BD 00 8F  
008EEF  2  E8 C9 24 F0  
008F0D  2               DSKY_INITA:
008F0D  2  20 65 88     	JSR	NEWLINE
008F10  2  60           	RTS				; DONE
008F11  2               ;
008F11  2               ;__DSKY_PREINIT______________________________________________________________________________________
008F11  2               ;
008F11  2               ;  CONFIGURE PARALLEL PORT AND INITIALIZE 8279
008F11  2               ;____________________________________________________________________________________________________
008F11  2               ; HARDWARE RESET 8279 BY PULSING RESET LINE
008F11  2               DSKY_PREINIT:
008F11  2               	; CHECK FOR PPI
008F11  2  20 56 8F     	JSR	DSKY_PPIDETECT		; TEST FOR PPI HARDWARE
008F14  2  D0 2A                BNE     DSKY_ABORT      	; BAIL OUT IF NOT THERE
008F16  2               
008F16  2               	; SETUP PPI TO DEFAULT MODE
008F16  2  20 53 91     	JSR	DSKY_PPIRD
008F19  2               	; INIT 8279 VALUES TO IDLE STATE
008F19  2  A9 06        	LDA	#DSKY_PPI_IDLE
008F1B  2  8D 62 03     	STA	DSKY_PPIC
008F1E  2               	; PULSE RESET SIGNAL ON 8279
008F1E  2  09 80        	ORA 	#%10000000
008F20  2  8D 62 03     	STA	DSKY_PPIC
008F23  2  29 7F        	AND 	#%01111111
008F25  2  8D 62 03     	STA	DSKY_PPIC
008F28  2               	; INITIALIZE 8279
008F28  2  20 41 8F     	JSR	DSKY_REINIT
008F2B  2               	; NOW SEE IF A DSKYNG IS REALLY THERE...
008F2B  2  A9 A5        	LDA     #$A5
008F2D  2  A0 00                LDY     #$00
008F2F  2  20 92 90     	JSR	DSKY_PUTBYTE
008F32  2  A0 00                LDY     #$00
008F34  2  20 A6 90     	JSR	DSKY_GETBYTE
008F37  2  C9 A5        	CMP	#$A5
008F39  2  D0 05        	BNE     DSKY_ABORT			; BAIL OUT IF MISCOMPARE
008F3B  2  A9 FF        	LDA	#$FF
008F3D  2  8D 7A 91     	STA	DSKY_PRESENT
008F40  2               DSKY_ABORT:
008F40  2  60           	RTS
008F41  2               ;
008F41  2               DSKY_REINIT:
008F41  2  20 65 91     	JSR	DSKY_PPIIDLE
008F44  2               	; SET CLOCK SCALER TO 20
008F44  2  A9 21        	LDA	#DSKY_CMD_CLK | DSKY_PRESCL
008F46  2  20 12 90     	JSR	DSKY_CMD
008F49  2               	; FALL THRU
008F49  2               ;
008F49  2               DSKY_RESET:
008F49  2               	; RESET DSKY -- CLEAR RAM AND FIFO
008F49  2  A9 DF        	LDA	#DSKY_CMD_CLR
008F4B  2  20 12 90     	JSR	DSKY_CMD
008F4E  2               ;
008F4E  2               	; 8259 TAKES ~160US TO CLEAR RAM DURING WHICH TIME WRITES TO
008F4E  2               	; DISPLAY RAM ARE INHIBITED.  HIGH BIT OF STATUS BYTE IS SET
008F4E  2               	; DURING THIS WINDOW.  TO PREVENT A DEADLOCK, A LOOP COUNTER
008F4E  2               	; IS USED TO IMPLEMENT A TIMEOUT.
008F4E  2  A2 00        	LDX	#0			; TIMEOUT LOOP COUNTER
008F50  2               DSKY_RESET1:
008F50  2  DA           	PHX     			; SAVE COUNTER
008F51  2               	;JSR	DSKY_ST			; GET STATUS BYTE
008F51  2  FA           	PLX				; RECOVER COUNTER
008F52  2                     ;  AND     #%10000000
008F52  2                     ;  BEQ     DSKY_RESET2		; MOVE ON IF DONE
008F52  2  CA                   DEX
008F53  2  D0 FB                BNE     DSKY_RESET1		; LOOP TILL TIMEOUT
008F55  2               ;
008F55  2               DSKY_RESET2:
008F55  2  60           	RTS
008F56  2               ;
008F56  2               ;
008F56  2               ;
008F56  2               ;__DSKY_PPIDETECT____________________________________________________________________________________
008F56  2               ;
008F56  2               ;  PROBE FOR PPI HARDWARE
008F56  2               ;____________________________________________________________________________________________________
008F56  2               ;
008F56  2               DSKY_PPIDETECT:
008F56  2               ;
008F56  2               	; TEST FOR PPI EXISTENCE
008F56  2               	; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
008F56  2               	; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
008F56  2               	; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
008F56  2               	; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
008F56  2               	; INTERFERE WITH THE VALUE BEING READ.
008F56  2  20 3C 91     	JSR	DSKY_PPIWR
008F59  2               ;
008F59  2  A9 00        	LDA     #$00			; VALUE ZERO
008F5B  2  8D 60 03     	STA	DSKY_PPIA		; PUSH VALUE TO PORT
008F5E  2  AD 60 03     	LDA	DSKY_PPIA		; GET PORT VALUE
008F61  2  C9 00                CMP     #$00
008F63  2  60           	RTS				; AND RETURN
008F64  2               ;
008F64  2                .IF DSKY_KBD=1
008F64  2               ;
008F64  2               KY_0	=	$00
008F64  2               KY_1	=	$01
008F64  2               KY_2	=	$02
008F64  2               KY_3	=	$03
008F64  2               KY_4	=	$04
008F64  2               KY_5	=	$05
008F64  2               KY_6	=	$06
008F64  2               KY_7	=	$07
008F64  2               KY_8	=	$08
008F64  2               KY_9	=	$09
008F64  2               KY_A	=	$0A
008F64  2               KY_B	=	$0B
008F64  2               KY_C	=	$0C
008F64  2               KY_D	=	$0D
008F64  2               KY_E	=	$0E
008F64  2               KY_F	=	$0F
008F64  2               KY_FW	=	$10	; FORWARD
008F64  2               KY_BK	=	$11	; BACKWARD
008F64  2               KY_CL	=	$12	; CLEAR
008F64  2               KY_EN	=	$13	; ENTER
008F64  2               KY_DE	=	$14	; DEPOSIT
008F64  2               KY_EX	=	$15	; EXAMINE
008F64  2               KY_GO	=	$16	; GO
008F64  2               KY_BO	=	$17	; BOOT
008F64  2               KY_F4	=	$18	; F4
008F64  2               KY_F3	=	$19	; F3
008F64  2               KY_F2	=	$20	; F2
008F64  2               KY_F1	=	$21	; F1
008F64  2               ;
008F64  2               ;__DSKY_STAT_________________________________________________________________________________________
008F64  2               ;
008F64  2               ;  CHECK FOR KEY PRESS, SAVE RAW VALUE, RETURN STATUS
008F64  2               ;____________________________________________________________________________________________________
008F64  2               ;
008F64  2               DSKY_STAT:
008F64  2  AD 7A 91     	LDA	DSKY_PRESENT            ; DOES IT EXIST?
008F67  2  C9 FF        	CMP     #$FF			; SET FLAGS
008F69  2  D0 05                BNE     DSKY_STATA		; ABORT WITH A=0 IF NOT THERE
008F6B  2  20 4B 90     	JSR	DSKY_ST
008F6E  2  29 0F        	AND	#$0F			; ISOLATE THE CUR FIFO LEN
008F70  2               DSKY_STATA:
008F70  2  60           	RTS
008F71  2               ;
008F71  2               ;__DSKY_GETKEY_____________________________________________________________________________________
008F71  2               ;
008F71  2               ;  WAIT FOR A DSKY KEYPRESS AND RETURN
008F71  2               ;____________________________________________________________________________________________________
008F71  2               ;
008F71  2               DSKY_GETKEY:
008F71  2  AD 7A 91     	LDA	DSKY_PRESENT    	; DOES IT EXIST?
008F74  2  C9 FF               	CMP     #$FF			; SET FLAGS
008F76  2  D0 24                BNE     DSKY_GETKEY1A		; ABORT WITH A=0 IF NOT THERE
008F78  2  20 64 8F     	JSR	DSKY_STAT
008F7B  2  F0 F4                BEQ     DSKY_GETKEY		; LOOP IF NOTHING THERE
008F7D  2  A9 40        	LDA	#DSKY_CMD_FIFO
008F7F  2  20 12 90     	JSR	DSKY_CMD
008F82  2  20 50 90     	JSR	DSKY_DIN
008F85  2  49 C0        	EOR	#%11000000		; FLIP POLARITY OF SHIFT/CTL BITS
008F87  2  48                   PHA
008F88  2  29 3F        	AND	#$3F			; STRIP SHIFT/CTL BITS FOR LOOKUP
008F8A  2  8D 78 91     	STA     DSKY_TEMP_VAL
008F8D  2  A2 00        	LDX	#0			; INDEX
008F8F  2               DSKY_GETKEY1:
008F8F  2  BD AB 8F             LDA     DSKY_KEYMAP,X
008F92  2  CD 78 91     	CMP	DSKY_TEMP_VAL		; MATCH?
008F95  2  F0 09                BEQ     DSKY_GETKEY2		; FOUND, DONE
008F97  2  E8           	INX
008F98  2  E0 1C                CPX     #28
008F9A  2  D0 F3                BNE	DSKY_GETKEY1		; LOOP UNTIL EOT
008F9C  2               DSKY_GETKEY1A:
008F9C  2  68                   PLA
008F9D  2  A9 FF        	LDA	#$FF			; NOT FOUND ERR, RETURN $FF
008F9F  2  60           	RTS
008FA0  2               DSKY_GETKEY2:
008FA0  2               	; RETURN THE INDEX POSITION WHERE THE SCAN CODE WAS FOUND
008FA0  2               	; THE ORIGINAL SHIFT/CTRL BITS ARE RESTORED
008FA0  2  68           	PLA				; RESTORE RAW VALUE
008FA1  2  25 C0        	AND	%11000000		; ISOLATE SHIFT/CTRL BITS
008FA3  2  8D 78 91             STA     DSKY_TEMP_VAL
008FA6  2  8A                   TXA
008FA7  2  0D 78 91     	ORA	DSKY_TEMP_VAL		; COMBINE WITH INDEX VALUE
008FAA  2  60           	RTS
008FAB  2               ;
008FAB  2               ;_KEYMAP_TABLE_____________________________________________________________________________________________________________
008FAB  2               ;
008FAB  2               DSKY_KEYMAP:
008FAB  2               	; POS	$00  $01  $02  $03  $04  $05  $06  $07
008FAB  2               	; KEY   [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]
008FAB  2  0D 04 0C 14  	.BYTE	$0D, $04, $0C, $14, $03, $0B, $13, $02
008FAF  2  03 0B 13 02  
008FB3  2               ;
008FB3  2               	; POS	$08  $09  $0A  $0B  $0C  $0D  $0E  $0F
008FB3  2               	; KEY   [8]  [9]  [A]  [B]  [C]  [D]  [E]  [F]
008FB3  2  0A 12 01 09  	.BYTE	$0A, $12, $01, $09, $11, $00, $08, $10
008FB7  2  11 00 08 10  
008FBB  2               ;
008FBB  2               	; POS	$10  $11  $12  $13  $14  $15  $16  $17
008FBB  2               	; KEY   [FW] [BK] [CL] [EN] [DE] [EX] [GO] [BO]
008FBB  2  05 15 1D 1C  	.BYTE	$05, $15, $1D, $1C, $1B, $1A, $19, $18
008FBF  2  1B 1A 19 18  
008FC3  2               
008FC3  2               	; POS	$18  $19  $20  $21
008FC3  2               	; KEY   [F4] [F3] [F2] [F1]
008FC3  2  23 22 21 20  	.BYTE	$23, $22, $21, $20
008FC7  2               
008FC7  2               ;
008FC7  2                       .ENDIF	; DSKY_KBD
008FC7  2               ;
008FC7  2               ;__DSKY_BIN2SEG________________________________________________________________________________________
008FC7  2               ;
008FC7  2               ; CONVERT 32 BIT BINARY TO 8 BYTE HEX SEGMENT DISPLAY
008FC7  2               ;
008FC7  2               ; DSKY_BUF: 32 BIT BINARY
008FC7  2               ; DSKY_HEXBUF: DEST LED SEGMENT DISPLAY BUFFER (8 BYTES)
008FC7  2               ;____________________________________________________________________________________________________
008FC7  2               ;
008FC7  2               DSKY_BIN2SEG:
008FC7  2  A2 00        	LDX	#$00
008FC9  2               DSKY_BIN2SEG1:
008FC9  2  BD 08 05     	LDA	DSKY_HEXBUF,X			; FIRST NIBBLE
008FCC  2  4A           	LSR	A
008FCD  2  4A                   LSR	A
008FCE  2  4A                   LSR	A
008FCF  2  4A                   LSR	A
008FD0  2  DA           	PHX                                     ; STORE READ INDEX
008FD1  2  AA                   TAX					; MOVE DIGIT TO LOOKUP INDEX
008FD2  2  BD 68 91     	LDA	DSKY_HEXMAP,X                   ; GET DECODED DIGIT INTO A
008FD5  2  FA           	PLX                                     ; GET READ INDEX
008FD6  2  DA           	PHX
008FD7  2  48           	PHA
008FD8  2  8A           	TXA
008FD9  2  0A           	asl	a
008FDA  2  AA           	TAX
008FDB  2  68           	PLA
008FDC  2  9D 00 05             STA     DSKY_BUF,X    		        ;STORE HIGH BYTE IN OUT BUFFER
008FDF  2  FA           	PLX
008FE0  2  BD 08 05     	LDA	DSKY_HEXBUF,X			; SECOND NIBBLE
008FE3  2               
008FE3  2  29 0F        	AND	#$0F
008FE5  2  DA                   PHX
008FE6  2  AA                   TAX
008FE7  2  BD 68 91     	LDA	DSKY_HEXMAP,X                   ; GET DECODED DIGIT INTO A
008FEA  2  FA           	PLX
008FEB  2  DA           	PHX
008FEC  2  48           	PHA
008FED  2  8A           	TXA		                        ; GET READ INDEX
008FEE  2  0A           	asl	a
008FEF  2  AA           	TAX
008FF0  2  E8           	INX
008FF1  2  68           	PLA
008FF2  2  9D 00 05             STA     DSKY_BUF,X	                ;STORE HIGH BYTE IN OUT BUFFER
008FF5  2  FA           	PLX
008FF6  2  E8                   INX
008FF7  2  E0 04                CPX     #4
008FF9  2  D0 CE                BNE     DSKY_BIN2SEG1
008FFB  2  60           	RTS
008FFC  2               ;
008FFC  2               ;__DSKY_SHOW___________________________________________________________________________________________
008FFC  2               ; DSKY SHOW BUFFER
008FFC  2               ;______________________________________________________________________________________________________
008FFC  2               ;
008FFC  2               DSKY_SHOW:
008FFC  2  48                   PHA
008FFD  2  DA                   PHX
008FFE  2  5A                   PHY
008FFF  2  A2 00                LDX     #0
009001  2               DSKY_SHOW1:
009001  2  BD 00 05     	LDA     DSKY_BUF,X
009004  2  DA                   PHX
009005  2  7A                   PLY
009006  2  20 92 90     	JSR	DSKY_PUTBYTE
009009  2  E8           	INX
00900A  2  E0 08                CPX     #8
00900C  2  D0 F3                BNE     DSKY_SHOW1
00900E  2  7A                   PLY
00900F  2  FA                   PLX
009010  2  68                   PLA
009011  2  60           	RTS
009012  2               
009012  2               ;______________________________________________________________________________________________________
009012  2               ; DSKYNG OUTPUT ROUTINES
009012  2               ;______________________________________________________________________________________________________
009012  2               
009012  2               ; SEND DSKY COMMAND BYTE IN REGISTER A
009012  2               DSKY_CMD:
009012  2  48                   PHA
009013  2  A9 01        	LDA	#$01
009015  2  4C 1B 90     	JMP	DSKY_DOUT2
009018  2               ;
009018  2               ; SEND DSKY DATA BYTE IN REGISTER A
009018  2               ; TRASHES BC
009018  2               ;
009018  2               DSKY_DOUT:
009018  2  48                   PHA
009019  2  A9 00        	LDA	#$00
00901B  2               ;
00901B  2               DSKY_DOUT2:
00901B  2               	; SET PPI LINE CONFIG TO WRITE MODE
00901B  2  20 3C 91     	JSR	DSKY_PPIWR
00901E  2               ;
00901E  2               	; SET ADDRESS FIRST
00901E  2  09 06                ORA     #DSKY_PPI_IDLE
009020  2  8D 62 03     	STA	DSKY_PPIC
009023  2               ;
009023  2               	; ASSERT 8279 /CS
009023  2  09 18        	ORA     #%00011000
009025  2  8D 62 03     	STA	DSKY_PPIC
009028  2               ;
009028  2               	; PPIC WORKING VALUE TO DSKY_TEMP_VAL
009028  2  8D 78 91     	STA     DSKY_TEMP_VAL
00902B  2               ;
00902B  2               	; ASSERT DATA BYTE VALUE
00902B  2  68                   PLA
00902C  2  8D 60 03     	STA	DSKY_PPIA
00902F  2               ;
00902F  2               	; PULSE /WR
00902F  2  AD 78 91             LDA     DSKY_TEMP_VAL
009032  2  29 FD                AND     #%11111101
009034  2  8D 62 03     	STA	DSKY_PPIC
009037  2  EA           	NOP			; MAY NOT BE NEEDED
009038  2  09 02                ORA     #%00000010
00903A  2  8D 62 03     	STA	DSKY_PPIC
00903D  2               ;
00903D  2               	; DEASSERT /CS
00903D  2  29 E7                AND     #%11100111
00903F  2  8D 62 03     	STA	DSKY_PPIC
009042  2               ;
009042  2               	; CLEAR ADDRESS BIT
009042  2  29 E6                AND     #%11100110
009044  2  8D 62 03     	STA	DSKY_PPIC
009047  2               ;
009047  2               	; DONE
009047  2  20 65 91     	JSR	DSKY_PPIIDLE
00904A  2  60           	RTS
00904B  2               ;
00904B  2               ;==================================================================================================
00904B  2               ; DSKYNG OUTPUT ROUTINES
00904B  2               ;==================================================================================================
00904B  2               ;
00904B  2               ; RETURN DSKY STATUS VALUE IN A
00904B  2               ;
00904B  2               DSKY_ST:
00904B  2  A9 01        	LDA	#$01
00904D  2  4C 52 90     	JMP	DSKY_DIN2
009050  2               ;
009050  2               ; RETURN NEXT DATA VALUE IN A
009050  2               ;
009050  2               DSKY_DIN:
009050  2  A9 00        	LDA	#$00
009052  2               ;
009052  2               DSKY_DIN2:
009052  2               	; SET PPI LINE CONFIG TO READ MODE
009052  2  20 53 91     	JSR	DSKY_PPIRD
009055  2               ;
009055  2               	; SET ADDRESS FIRST
009055  2  09 06        	ORA	#DSKY_PPI_IDLE
009057  2  8D 62 03     	STA	DSKY_PPIC
00905A  2               ;
00905A  2               	; ASSERT 8279 /CS
00905A  2  09 18        	ORA     #%00011000
00905C  2  8D 62 03     	STA	DSKY_PPIC
00905F  2               ;
00905F  2               	; ASSERT /RD
00905F  2  29 7B        	AND     #%01111011
009061  2  8D 62 03     	STA	DSKY_PPIC
009064  2               ;
009064  2  8D 78 91     	STA 	DSKY_TEMP_VAL
009067  2               	; GET VALUE
009067  2  AD 60 03     	LDA	DSKY_PPIA
00906A  2  48                   PHA
00906B  2               
00906B  2  AD 78 91     	LDA 	DSKY_TEMP_VAL
00906E  2               	; DEASSERT /RD
00906E  2  09 04        	ORA     #%00000100
009070  2  8D 62 03     	STA	DSKY_PPIC
009073  2               ;
009073  2               	; DEASSERT /CS
009073  2  29 E7                AND     #%11100111
009075  2  8D 62 03     	STA	DSKY_PPIC
009078  2               ;
009078  2               	; CLEAR ADDRESS BIT
009078  2  29 E6                AND     #%11100110
00907A  2  8D 62 03     	STA	DSKY_PPIC
00907D  2               ;
00907D  2               	; DONE
00907D  2  20 65 91     	JSR	DSKY_PPIIDLE
009080  2  68                   PLA
009081  2  60           	RTS
009082  2               
009082  2               ;__DSKY_BLANK_____________________________________________________________________________________
009082  2               ;
009082  2               ; BLANK DSKYNG DISPLAY  (WITHOUT USING CLEAR)
009082  2               ;
009082  2               ;_________________________________________________________________________________________________
009082  2               ;
009082  2               DSKY_BLANK:
009082  2  A9 90        	LDA	#DSKY_CMD_WDSP
009084  2  20 12 90     	JSR	DSKY_CMD
009087  2  A2 10        	LDX	#16
009089  2               DSKY_BLANK1:
009089  2  A9 FF        	LDA	#$FF
00908B  2  20 18 90     	JSR	DSKY_DOUT
00908E  2  CA                   DEX
00908F  2  D0 F8        	BNE	DSKY_BLANK1
009091  2  60           	RTS
009092  2               ;
009092  2               ;__DSKY_PUTBYTE____________________________________________________________________________________
009092  2               ;
009092  2               ; WRITE A RAW BYTE VALUE TO DSKY DISPLAY RAM
009092  2               ; AT LOCATION IN REGISTER Y, VALUE IN A.
009092  2               ;
009092  2               ;__________________________________________________________________________________________________
009092  2               ;
009092  2               DSKY_PUTBYTE:
009092  2  5A                   PHY
009093  2  48                   PHA
009094  2  48                   PHA
009095  2  18           	CLC
009096  2  98                   TYA
009097  2  69 90        	ADC	#DSKY_CMD_WDSP
009099  2  A8                   TAY
00909A  2  20 12 90     	JSR	DSKY_CMD
00909D  2  68                   PLA
00909E  2  49 FF        	EOR	#$FF
0090A0  2  20 18 90     	JSR	DSKY_DOUT
0090A3  2  68                   PLA
0090A4  2  7A                   PLY
0090A5  2  60           	RTS
0090A6  2               ;
0090A6  2               ;__DSKY_GETBYTE___________________________________________________________________________________
0090A6  2               ; READ A RAW BYTE VALUE FROM DSKY DISPLAY RAM
0090A6  2               ; AT LOCATION IN REGISTER Y, VALUE RETURNED IN A
0090A6  2               ;
0090A6  2               ;_________________________________________________________________________________________________
0090A6  2               ;
0090A6  2               DSKY_GETBYTE:
0090A6  2  18           	CLC
0090A7  2  98                   TYA
0090A8  2  69 70        	ADC	#DSKY_CMD_RDSP
0090AA  2  A8                   TAY
0090AB  2  20 12 90     	JSR	DSKY_CMD
0090AE  2  20 50 90     	JSR	DSKY_DIN
0090B1  2  49 FF        	EOR	#$FF
0090B3  2  60           	RTS
0090B4  2               
0090B4  2               ;
0090B4  2               ;__DSKY_PUTLED____________________________________________________________________________________
0090B4  2               ;
0090B4  2               ;	This function is intended to update the LEDs.
0090B4  2               ;	VALUES SHOULD BE IN DSKY_BUF
0090B4  2               ;_________________________________________________________________________________________________
0090B4  2               ;
0090B4  2               DSKY_PUTLED:
0090B4  2  DA           	PHX
0090B5  2  5A           	PHY
0090B6  2  48           	PHA
0090B7  2  A0 00        	LDY 	#$00
0090B9  2  A2 00        	LDX 	#$00
0090BB  2               DSKY_PUTLED_1:
0090BB  2  BD 00 05             LDA     DSKY_BUF,X              ; GET BYTE
0090BE  2  20 92 90     	JSR	DSKY_PUTBYTE            ; SEND IT TO DSKY
0090C1  2  C8                   INY                             ; LOOP TIL DONE
0090C2  2  E8           	INX
0090C3  2  C0 08                CPY     #8
0090C5  2  D0 F4                BNE     DSKY_PUTLED_1
0090C7  2  68                   PLA                             ; RESTORE REGISTERS
0090C8  2  7A                   PLY
0090C9  2  FA                   PLX
0090CA  2  60           	RTS
0090CB  2               ;
0090CB  2               ;__DSKY_BEEP______________________________________________________________________________________
0090CB  2               ;	This function is intended to beep the speaker on the DSKY
0090CB  2               ;_________________________________________________________________________________________________
0090CB  2               ;
0090CB  2               DSKY_BEEP:
0090CB  2  5A           	PHY
0090CC  2  DA                   PHX
0090CD  2  48           	PHA
0090CE  2  A0 0F        	LDY 	#$0F
0090D0  2  20 A6 90     	JSR	DSKY_GETBYTE
0090D3  2  09 20        	ORA 	#$20
0090D5  2  A9 20        			LDA 	#$20
0090D7  2  A0 0F        	LDY	#$0F
0090D9  2  20 92 90     	JSR	DSKY_PUTBYTE
0090DC  2               
0090DC  2               ;;; 	timer . . .
0090DC  2  A2 8F        	LDX 	#$8F
0090DE  2  A0 FF                LDY     #$FF
0090E0  2               DSKY_BEEP1:
0090E0  2  88                   DEY
0090E1  2  D0 FD                BNE     DSKY_BEEP1
0090E3  2  CA                   DEX
0090E4  2  D0 FA                BNE     DSKY_BEEP1
0090E6  2               
0090E6  2  A0 0F        	LDY 	#$0F
0090E8  2  20 A6 90     	JSR	DSKY_GETBYTE
0090EB  2  29 DF        	AND 	#$DF
0090ED  2  A9 DF        			LDA 	#$DF
0090EF  2  A0 0F        	LDY	#$0F
0090F1  2  20 92 90     	JSR	DSKY_PUTBYTE
0090F4  2               
0090F4  2  68                   PLA
0090F5  2  FA                   PLX
0090F6  2  7A                   PLY
0090F7  2  60           	RTS
0090F8  2               ;
0090F8  2               ;__DSKY_L1ON______________________________________________________________________________________
0090F8  2               ;	This function is intended to turn on DSKY L1
0090F8  2               ;_________________________________________________________________________________________________
0090F8  2               ;
0090F8  2               DSKY_L1ON:
0090F8  2  5A           	PHY
0090F9  2  48           	PHA
0090FA  2  A0 0D        	LDY 	#$0D
0090FC  2  20 A6 90     	JSR	DSKY_GETBYTE
0090FF  2  09 20        	ORA 	#$20
009101  2  A0 0D        	LDY	#$0D
009103  2  20 92 90     	JSR	DSKY_PUTBYTE
009106  2  68           	PLA
009107  2  7A                   PLY
009108  2  60           	RTS
009109  2               ;
009109  2               ;__DSKY_L2ON______________________________________________________________________________________
009109  2               ;	This function is intended to turn on DSKY L2
009109  2               ;_________________________________________________________________________________________________
009109  2               ;
009109  2               DSKY_L2ON:
009109  2  5A           	PHY
00910A  2  48           	PHA
00910B  2  A0 0E        	LDY 	#$0E
00910D  2  20 A6 90     	JSR	DSKY_GETBYTE
009110  2  09 20        	ORA 	#$20
009112  2  A0 0E        	LDY	#$0E
009114  2  20 92 90     	JSR	DSKY_PUTBYTE
009117  2  68           	PLA
009118  2  7A                   PLY
009119  2  60           	RTS
00911A  2               ;
00911A  2               ;__DSKY_L1OFF_____________________________________________________________________________________
00911A  2               ;	This function is intended to turn off DSKY L1
00911A  2               ;_________________________________________________________________________________________________
00911A  2               ;
00911A  2               DSKY_L1OFF:
00911A  2  5A           	PHY
00911B  2  48           	PHA
00911C  2  A0 0D        	LDY 	#$0D
00911E  2  20 A6 90     	JSR	DSKY_GETBYTE
009121  2  29 DF        	AND 	#$DF
009123  2  A0 0D        	LDY	#$0D
009125  2  20 92 90     	JSR	DSKY_PUTBYTE
009128  2  68           	PLA
009129  2  7A                   PLY
00912A  2  60           	RTS
00912B  2               ;
00912B  2               ;__DSKY_L2OFF_____________________________________________________________________________________
00912B  2               ;	This function is intended to turn off DSKY L2
00912B  2               ;_________________________________________________________________________________________________
00912B  2               ;
00912B  2               DSKY_L2OFF:
00912B  2  5A           	PHY
00912C  2  48           	PHA
00912D  2  A0 0E        	LDY 	#$0E
00912F  2  20 A6 90     	JSR	DSKY_GETBYTE
009132  2  29 DF        	AND 	#$DF
009134  2  A0 0E        	LDY	#$0E
009136  2  20 92 90     	JSR	DSKY_PUTBYTE
009139  2  68           	PLA
00913A  2  7A                   PLY
00913B  2  60           	RTS
00913C  2               ;
00913C  2               ;_________________________________________________________________________________________________
00913C  2               ; DSKYNG LINE CONTROL ROUTINES
00913C  2               ;
00913C  2               ; SETUP PPI FOR WRITING: PUT PPI PORT A IN OUTPUT MODE
00913C  2               ; AVOID REWRTING PPIX IF ALREADY IN OUTPUT MODE
00913C  2               ;
00913C  2               ;_________________________________________________________________________________________________
00913C  2               ;
00913C  2               DSKY_PPIWR:
00913C  2  48           	PHA
00913D  2               ;
00913D  2               	; CHECK FOR WRITE MODE
00913D  2  AD 79 91     	LDA     DSKY_PPIX_VAL
009140  2  C9 82        	CMP	#DSKY_PPIX_WR
009142  2  F0 0D        	BEQ	DSKY_PPIWR1
009144  2               ;
009144  2               	; SET PPI TO WRITE MODE
009144  2  A9 82        	LDA	#DSKY_PPIX_WR
009146  2  8D 63 03     	STA	DSKY_PPIX
009149  2  8D 79 91     	STA	DSKY_PPIX_VAL
00914C  2               ;
00914C  2               	; RESTORE PORT C (MAY NOT BE NEEDED)
00914C  2  A9 06        	LDA     #DSKY_PPI_IDLE
00914E  2  8D 62 03     	STA	DSKY_PPIC
009151  2               ;
009151  2               DSKY_PPIWR1:
009151  2               ;
009151  2  68           	PLA
009152  2  60           	RTS
009153  2               ;
009153  2               ; SETUP PPI FOR READING: PUT PPI PORT A IN INPUT MODE
009153  2               ; AVOID REWRTING PPIX IF ALREADY IN INPUT MODE
009153  2               ;
009153  2               DSKY_PPIRD:
009153  2  48           	PHA
009154  2               ;
009154  2               	; CHECK FOR READ MODE
009154  2  AD 79 91     	LDA	DSKY_PPIX_VAL
009157  2  C9 92        	CMP	#DSKY_PPIX_RD
009159  2  F0 08        	BEQ	DSKY_PPIRD1
00915B  2               ;
00915B  2               	; SET PPI TO READ MODE
00915B  2  A9 92        	LDA	#DSKY_PPIX_RD
00915D  2  8D 63 03     	STA	DSKY_PPIX
009160  2  8D 79 91     	STA	DSKY_PPIX_VAL
009163  2               ;
009163  2               DSKY_PPIRD1:
009163  2  68           	PLA
009164  2  60           	RTS
009165  2               ;
009165  2               ; RELEASE USE OF PPI
009165  2               ;
009165  2               DSKY_PPIIDLE:
009165  2  4C 53 91     	JMP	DSKY_PPIRD		; SAME AS READ MODE
009168  2               ;
009168  2               ;__STORAGE_________________________________________________________________________________________
009168  2               ; CODES FOR NUMERICS
009168  2               ; HIGH BIT ALWAYS CLEAR TO SUPPRESS DECIMAL POINT
009168  2               ; SET HIGH BIT TO SHOW DECIMAL POINT
009168  2               ;_________________________________________________________________________________________________
009168  2               ;
009168  2               DSKY_HEXMAP:
009168  2  3F           	.BYTE	$3F	; 0
009169  2  06           	.BYTE	$06	; 1
00916A  2  5B           	.BYTE	$5B	; 2
00916B  2  4F           	.BYTE	$4F	; 3
00916C  2  66           	.BYTE	$66	; 4
00916D  2  6D           	.BYTE	$6D	; 5
00916E  2  7D           	.BYTE	$7D	; 6
00916F  2  07           	.BYTE	$07	; 7
009170  2  7F           	.BYTE	$7F	; 8
009171  2  67           	.BYTE	$67	; 9
009172  2  77           	.BYTE	$77	; A
009173  2  7C           	.BYTE	$7C	; B
009174  2  39           	.BYTE	$39	; C
009175  2  5E           	.BYTE	$5E	; D
009176  2  79           	.BYTE	$79	; E
009177  2  71           	.BYTE	$71	; F
009178  2               ;
009178  2  00           DSKY_TEMP_VAL:	.BYTE	0
009179  2  00           DSKY_PPIX_VAL:	.BYTE	0
00917A  2  00           DSKY_PRESENT:	.BYTE	0
00917B  2               
00917B  1               		.INCLUDE "dosmd.asm"
00917B  2               ;__MD DRIVERS____________________________________________________________________________________________________________________
00917B  2               ;
00917B  2               ; 	Nhyodyne Memory disk drivers
00917B  2               ;
00917B  2               ;	Entry points:
00917B  2               ;		MD_SHOW         - called during OS init
00917B  2               ;		MD_READ_SECTOR  - read a sector from drive
00917B  2               ;		MD_WRITE_SECTOR - write a sector to drive
00917B  2               ;________________________________________________________________________________________________________________________________
00917B  2               ;
00917B  2               ; RAM BANK $0C is RAM area for Drivers
00917B  2               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
00917B  2               ; RAM BANK $0F is fixed bank $0000-$7FFF
00917B  2               ;
00917B  2               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
00917B  2               ;
00917B  2               ; ROM MEMORY PAGE CONFIGURATION LATCH CONTROL PORT
00917B  2               ;       A15 IS INVERTED FOR THE NYHODYNE 65C02 CPU . . .
00917B  2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
00917B  2               ;	^ ^ ^ ^  ^ ^ ^ ^
00917B  2               ;	: : : :  : : : :--0 = A15 ROM ONLY ADDRESS LINE DEFAULT IS 0
00917B  2               ;	: : : :  : : :----0 = A16 ROM ONLY ADDRESS LINE DEFAULT IS 0
00917B  2               ;	: : : :  : :------0 = A17 ROM ONLY ADDRESS LINE DEFAULT IS 0
00917B  2               ;	: : : :  :--------0 = A18 ROM ONLY ADDRESS LINE DEFAULT IS 0
00917B  2               ;	: : : :-----------0 = A19 ROM ONLY ADDRESS LINE DEFAULT IS 0
00917B  2               ;	: : :-------------0 = A20 ROM ONLY ADDRESS LINE DEFAULT IS 0
00917B  2               ;	: :---------------0 = ROM BOOT OVERRIDE DEFAULT IS 0
00917B  2               ;	:-----------------0 = LOWER PAGE ROM SELECT (0=ROM, 1=NOTHING) DEFAULT IS 0
00917B  2               ;
00917B  2               ; RAM PAGE CONFIGURATION LATCH CONTROL PORT
00917B  2               ;
00917B  2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
00917B  2               ;	^ ^ ^ ^  ^ ^ ^ ^
00917B  2               ;	: : : :  : : : :--0 = A15 RAM ONLY ADDRESS LINE DEFAULT IS 0
00917B  2               ;	: : : :  : : :----0 = A16 RAM ONLY ADDRESS LINE DEFAULT IS 0
00917B  2               ;	: : : :  : :------0 = A17 RAM ONLY ADDRESS LINE DEFAULT IS 0
00917B  2               ;	: : : :  :--------0 = A18 RAM ONLY ADDRESS LINE DEFAULT IS 0
00917B  2               ;	: : : :-----------0 = A19 RAM ONLY ADDRESS LINE DEFAULT IS 0
00917B  2               ;	: : :-------------0 = UNDEFINED DEFAULT IS 0
00917B  2               ;	: :---------------0 = RAM BOOT OVERRIDE DEFAULT IS 0
00917B  2               ;	:-----------------0 = LOWER PAGE RAM SELECT (0=NOTHING, 1=RAM) DEFAULT IS 0;
00917B  2               
00917B  2               
00917B  2               ;__MD_SHOW___________________________________________________________________________________________
00917B  2               ;
00917B  2               ;  Display info on MD devices
00917B  2               ;____________________________________________________________________________________________________
00917B  2               ;
00917B  2               MD_SHOW:
00917B  2                       PRTDBG "MD INIT:$"
00917B  2  48 DA 5A A2          PRTS "MD: UNITS=2 RAMDISK=256KB ROMDISK=384KB$"
00917F  2  00 BD 94 91  
009183  2  E8 C9 24 F0  
0091BC  2  20 65 88            	JSR	NEWLINE
0091BF  2  60                   rts
0091C0  2               
0091C0  2               ;*__MD_READ_SECTOR____________________________________________________________________________________
0091C0  2               ;*
0091C0  2               ;*  READ MD SECTOR INTO BUFFER
0091C0  2               ;*
0091C0  2               ;*____________________________________________________________________________________________________
0091C0  2               MD_READ_SECTOR:
0091C0  2               		PRTDBG "MD Read Sector$"
0091C0  2  20 B2 92                     JSR     GET_DRIVE_DEVICE
0091C3  2  29 01        		and 	#$01			; only want drive cfg
0091C5  2  0A           		asl	a			; SHIFT 6
0091C6  2  0A           		asl	a			;
0091C7  2  0A           		asl	a			;
0091C8  2  0A              		asl	a			;
0091C9  2  0A           		asl	a			;
0091CA  2  0A           		asl	a			;
0091CB  2  29 5F        		AND 	#%01011111              ; TOGGLE READ
0091CD  2  AA                           TAX                             ; STASH CONTROL WORD
0091CE  2  AD 0E 05                     LDA	seksec			;
0091D1  2  29 01                	AND	#$01			; GET SECTOR INDEX
0091D3  2  C9 00                        CMP     #$00
0091D5  2  F0 04                        BEQ     @1
0091D7  2  8A                           TXA
0091D8  2  09 80                        ORA 	#%10000000              ; TOGGLE TOP HALF OF PAGE
0091DA  2  AA                           TAX
0091DB  2               @1:
0091DB  2  20 25 92                     JSR     MD_CONVERT_SECTOR
0091DE  2  8A                           txa
0091DF  2  29 40                        and     #%01000000
0091E1  2  C9 00                        cmp     #$00                    ; read if ram
0091E3  2  F0 0C                        BEQ     :+
0091E5  2  EE 10 05                     inc     debcyll                 ; if rom, inc bank by 4 ()
0091E8  2  EE 10 05                     inc     debcyll
0091EB  2  EE 10 05                     inc     debcyll
0091EE  2  EE 10 05                     inc     debcyll
0091F1  2               :
0091F1  2  AD 10 05       	        LDA    	debcyll			; GET BANK
0091F4  2  AC 12 05     		LDY    	debsehd			; GET PAGE
0091F7  2                               PRTDBG "DO PAGER RD$"
0091F7  2  20 00 02                     JSR     MD_PAGERA
0091FA  2                               PRTDBG "PAGER RETURN$"
0091FA  2  A9 00                        LDA     #$00
0091FC  2  60           		RTS
0091FD  2               
0091FD  2               
0091FD  2               ;*__MD_WRITE_SECTOR___________________________________________________________________________________
0091FD  2               ;*
0091FD  2               ;*  WRITE MD SECTOR FROM BUFFER
0091FD  2               ;*
0091FD  2               ;*____________________________________________________________________________________________________
0091FD  2               MD_WRITE_SECTOR:
0091FD  2               		PRTDBG "MD Write Sector$"
0091FD  2  20 B2 92                     JSR     GET_DRIVE_DEVICE
009200  2  29 01        		and 	#$01			; only want drive cfg
009202  2  C9 00                        CMP     #$00                    ; NO WRITE FOR ROM
009204  2  F0 03                        BEQ     MD_WRITE_SECTOR_RAM
009206  2  A9 FF                        LDA     #$FF
009208  2  60                           RTS
009209  2               MD_WRITE_SECTOR_RAM:
009209  2  20 25 92                     JSR     MD_CONVERT_SECTOR
00920C  2  A2 20        		LDX 	#%00100000              ; TOGGLE WRITE RAM (LO)
00920E  2  AD 0E 05                     LDA	seksec			;
009211  2  29 01                	AND	#$01			; GET SECTOR INDEX
009213  2  C9 00                        CMP     #$00
009215  2  F0 02                        BEQ     @1
009217  2  A2 A0        		LDX 	#%10100000              ; TOGGLE WRITE RAM (HI)
009219  2               @1:
009219  2  AD 10 05      	        LDA    	debcyll			; GET BANK
00921C  2  AC 12 05     		LDY    	debsehd			; GET PAGE
00921F  2                               PRTDBG "DO PAGER WR$"
00921F  2  20 00 02                     JSR     MD_PAGERA
009222  2                               PRTDBG "PAGER RETURN$"
009222  2  A9 00                        LDA     #$00
009224  2  60           		RTS
009225  2               
009225  2               ;___MD_CONVERT_SECTOR___________________________________________________________________________________
009225  2               ;
009225  2               ; 	TRANSLATE SECTORS INTO MD FORMAT
009225  2               ;________________________________________________________________________________________________________
009225  2               MD_CONVERT_SECTOR:
009225  2                       PRTDBG "CONVERT SECTOR$"
009225  2  DA                   phx
009226  2  AD 0E 05     	LDA	seksec			; LOAD SECTOR # (LOW BYTE)
009229  2  4A           	LSR	A			; DIVIDE BY 2 (FOR BLOCKING)
00922A  2  29 1F        	AND 	#$1F 			; CLEAR UPPER 3 BITS (JUST 'CAUSE)
00922C  2  8D 12 05     	STA	debsehd			; STORE IN SECTOR/HEAD
00922F  2  AD 0C 05     	LDA	sektrk			; LOAD TRACK # (LOW BYTE)
009232  2  29 03        	AND 	#$03			; BOTTOM 2 BITS ARE PART OF PAGE (PAGES ARE 32k)
009234  2  0A           	asl	a			; MOVE TO HIGH BITS
009235  2  0A           	asl	a
009236  2  0A           	asl	a
009237  2  0A           	asl	a
009238  2  0A                  	asl	a
009239  2  09 80                ORA     #$80                    ; PAGES ARE ALWAYS IN UPPER BANK
00923B  2  0D 12 05     	ORA	debsehd			; STORE IN SECTOR/HEAD
00923E  2  8D 12 05             STA     debsehd                 ; STORE IN SECTOR/HEAD
009241  2                                                       ; AT THIS POINT PAGE REGISTER SHOULD BE
009241  2                                                       ; SET
009241  2  AD 0C 05     	LDA	sektrk			; LOAD TRACK #
009244  2  4A                  	LSR	a			; LOSE BOTTOM TWO BITS
009245  2  4A           	LSR	a
009246  2  8D 10 05     	STA	debcyll			; THIS SHOULD BE BANK#
009249  2               
009249  2               
009249  2                 .IF USEDSKY=1 || USEDSKYNG=1
009249  2                 	PRTDBG "DSKY OUTPUT 1$"
009249  2  AD 13 05       	lda	sekdsk
00924C  2  8D 08 05       	sta	DSKY_HEXBUF
00924F  2  A9 00         	lda	#$00
009251  2  8D 09 05       	sta	DSKY_HEXBUF+1
009254  2  AD 10 05      	lda	debcyll
009257  2  8D 0A 05       	sta	DSKY_HEXBUF+2
00925A  2  AD 12 05         	lda	debsehd
00925D  2  8D 0B 05       	sta	DSKY_HEXBUF+3
009260  2  20 C7 8F             jsr     DSKY_BIN2SEG
009263  2  20 FC 8F             jsr     DSKY_SHOW
009266  2                 .ENDIF
009266  2  FA                   plx
009267  2  60           	RTS
009268  2               
009268  1               		.INCLUDE "dosdblk.asm"
009268  2               ;__DOS DEBLOCK DRIVERS___________________________________________________________________________________________________________
009268  2               ;
009268  2               ; 	Nhyodyne DOS/65 Blocking and Deblocking code
009268  2               ;
009268  2               ;________________________________________________________________________________________________________________________________
009268  2               ;
009268  2               
009268  2               ;___DEBSECR512________________________________________________________________________________________
009268  2               ;
009268  2               ;	DEBLOCK 512 BYTE SECTOR FOR DOS/65
009268  2               ;
009268  2               ;________________________________________________________________________________________________________
009268  2               DEBSECR512:
009268  2  48           	PHA
009269  2  AD 0E 05     	LDA	seksec			;
00926C  2  29 03        	AND	#$03			; GET SECTOR INDEX
00926E  2  18           	CLC				;
00926F  2  2A           	ROL	A			;
009270  2  AA           	TAX				;
009271  2  BD 89 92     	LDA	DEBTAB,X		;
009274  2  85 EE        	STA     SRC
009276  2  E8           	INX
009277  2  BD 89 92     	LDA	DEBTAB,X		;
00927A  2  85 EF        	STA	SRC+1			;
00927C  2  A9 00        	LDA	#<MD_PAGEBU		;
00927E  2  85 EC        	STA	DEST			;
009280  2  A9 04        	LDA	#>MD_PAGEBU           	;
009282  2  85 ED        	STA	DEST+1			;
009284  2  20 BF 92     	JSR	COPY_DOS_SECTOR		;
009287  2  68           	PLA
009288  2  60           	RTS
009289  2               
009289  2               DEBTAB:
009289  2  CE 92        	.word	hstbuf			;
00928B  2  4E 93        	.word	hstbuf+128		;
00928D  2  CE 93        	.word	hstbuf+256		;
00928F  2  4E 94        	.word	hstbuf+384		;
009291  2               
009291  2               
009291  2               ;___BLKSECR512___________________________________________________________________________________________
009291  2               ;
009291  2               ;	BLOCK 512 SECTOR FOR DOS/65
009291  2               ;
009291  2               ;________________________________________________________________________________________________________
009291  2               BLKSECR512:
009291  2  48           	PHA
009292  2  AD 0E 05     	LDA	seksec			;
009295  2  29 03        	AND	#$03			; GET SECTOR INDEX
009297  2  18           	CLC				;
009298  2  2A           	ROL	A			;
009299  2  AA           	TAX				;
00929A  2  BD 89 92     	LDA	DEBTAB,X		;
00929D  2  85 EC        	STA     DEST
00929F  2  E8           	INX
0092A0  2  BD 89 92     	LDA	DEBTAB,X		;
0092A3  2  85 ED        	STA	DEST+1			;
0092A5  2  A9 00        	LDA	#<MD_PAGEBU		;
0092A7  2  85 EE        	STA	SRC			;
0092A9  2  A9 04        	LDA	#>MD_PAGEBU		;
0092AB  2  85 EF        	STA	SRC+1			;
0092AD  2  20 BF 92     	JSR	COPY_DOS_SECTOR		;
0092B0  2  68           	PLA
0092B1  2  60           	RTS
0092B2  2               
0092B2  2               ;___GET_DRIVE_DEVICE_____________________________________________________________________________________
0092B2  2               ;
0092B2  2               ;	GET SELECTED DEVICE TYPE AND UNIT, RETURN IN "A"
0092B2  2               ;
0092B2  2               ;________________________________________________________________________________________________________
0092B2  2               GET_DRIVE_DEVICE:
0092B2  2  DA           	PHX
0092B3  2  AD 13 05     	LDA	sekdsk			; GET DRIVE
0092B6  2  29 07        	AND 	#7			; ONLY FIRST 8 DEVICES SUPPORTED
0092B8  2  0A           	asl	a			; DOUBLE NUMBER FOR TABLE LOOKUP
0092B9  2  AA           	TAX 				; MOVE TO X REGISTER
0092BA  2  BD 14 05     	LDA 	dskcfg,X 		; GET device
0092BD  2  FA           	PLX
0092BE  2  60           	RTS
0092BF  2               
0092BF  2               
0092BF  2               ;___COPY_DOS_SECTOR______________________________________________________________________________________
0092BF  2               ;
0092BF  2               ;	COPY 128 BYTE SECTOR FOR DOS/65
0092BF  2               ;
0092BF  2               ;________________________________________________________________________________________________________
0092BF  2               COPY_DOS_SECTOR:
0092BF  2  5A           	PHY
0092C0  2  A0 00        	LDY	#$00			;
0092C2  2               COPY_DOS_SECTOR1:
0092C2  2  B1 EE        	LDA	(SRC),Y			;
0092C4  2  91 EC        	STA	(DEST),Y		;
0092C6  2  C8           	INY				;
0092C7  2  98           	TYA				;
0092C8  2  C9 80        	CMP	#$80			;
0092CA  2  D0 F6        	BNE	COPY_DOS_SECTOR1	;
0092CC  2  7A           	PLY
0092CD  2  60           	RTS
0092CE  2               
0092CE  2               
0092CE  2               ;deblocking buffer for dba
0092CE  2  xx xx xx xx  hstbuf:		.res	512		;256 or 512 byte sectors
0092D2  2  xx xx xx xx  
0092D6  2  xx xx xx xx  
0094CE  2               
0094CE  1               	;	.INCLUDE "dosflp.asm"
0094CE  1               
0094CE  1               ;// TODO: this should be dependent on "active console. . ." and should be a driver call
0094CE  1               CONSOLE_OUT:
0094CE  1  20 B6 88     		JSR WRSER1
0094D1  1  60           		RTS
0094D2  1               
0094D2  1               ;// TODO: CONSOLE_IN
0094D2  1               
0094D2  1               
0094D2  1  EA           	NOP
0094D3  1  EA           	NOP
0094D4  1  EA           	NOP
0094D5  1  EA           	NOP
0094D6  1  EA           	NOP
0094D7  1  EA           	NOP
0094D8  1  EA           	NOP
0094D9  1  EA           	NOP
0094DA  1  EA           	NOP
0094DB  1  EA           	NOP
0094DC  1               
0094DC  1               	.end
