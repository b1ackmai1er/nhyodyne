ca65 V2.18 - Ubuntu 2.19-1
Main file   : dos65drv.asm
Current file: dos65drv.asm

000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               ;
000000r 1               ;	Nhyodyne dos/65 banked driver code
000000r 1               ;       Intended for RAM BANK $0C
000000r 1               ;
000000r 1               ;  DWERNER 04/24/2022 	Initial
000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               
000000r 1                       .SEGMENT "DRIVERS"
000000r 1                       .ORG    $8800
008800  1                       DRIVERS = 1
008800  1                       .INCLUDE "DOSDEFN.ASM"  ; base addresses and definitions
008800  2               ;________________________________________________________________________________________________________________________________
008800  2               ;
008800  2               ;	Nhyodyne dos/65 base addresses and definitions
008800  2               ;
008800  2               ;  DWERNER 04/24/2022 	Initial
008800  2               ;________________________________________________________________________________________________________________________________
008800  2               
008800  2               ;base addresses and definitions
008800  2               btejmp          = $0100         ; warm boot jump
008800  2               pemjmp          = $0103         ; jump to pem
008800  2               iostat          = $0106         ; i/o status
008800  2               dflfcb          = $0107         ; default fcb
008800  2               dflbuf          = $0128         ; default buffer
008800  2               memmovr         = $0200         ; 0200-02ff subr to move data from ram/rom disks
008800  2               MD_PAGERA       = $0200         ; PAGE DRIVER ADDRESS
008800  2               
008800  2               IO              = $0300         ; 0300-03FF Memory mapped IO
008800  2               MPCL_ROM        = $037C         ; ROM MAPPER
008800  2               MPCL_RAM        = $0378         ; RAM MAPPER
008800  2               
008800  2               MD_PAGEBU       = $0400         ; 0400-04FF PAGE BUFFER ADDRESS
008800  2               MD_PAGESE       = pointr        ; PAGE SECTOR STORAGE
008800  2               
008800  2               ;
008800  2               ; DRIVER WORKING STORAGE
008800  2               ;
008800  2               DSKY_BUF        = $0500         ; Eight Bytes DSKY display buffer
008800  2               DSKY_BUFLEN     = 8             ;
008800  2               DSKY_HEXBUF     = $0508         ; Four Bytes DSKY hex buffer
008800  2               DSKY_HEXBUFLEN  = 4             ;
008800  2               sektrk          = $050C         ; seek track number
008800  2               seksec          = $050E         ; seek sector number
008800  2               debcyll         = $0510         ; DEBLOCKED CYLINDER LSB
008800  2               debcylm         = $0511         ; DEBLOCKED CYLINDER MSB
008800  2               debsehd         = $0512         ; DEBLOCKED SECTOR AND HEAD (HS)
008800  2               sekdsk          = $0513         ; seek disk number
008800  2               dskcfg          = $0514         ; 16 bytes disk configuration table
008800  2               DSKUNIT         = $0525         ; seek disk number
008800  2               
008800  2               
008800  2               tea             = $800          ;tea start
008800  2               
008800  2               ;zero page for setup
008800  2               trknum          = $02           ;current track
008800  2               dcbadd          = $04           ;dcb address
008800  2               nmsstr          = $06           ;number system tracks
008800  2               nsectr          = $08           ;number sectors per track
008800  2               ttlsec          = $0A           ;total sectors to write
008800  2               trkcnt          = ttlsec
008800  2               size            = $0B           ;ascii size
008800  2               lokim           = $0D           ;low kim limit
008800  2               hikim           = $0F           ;high kim limit
008800  2               offset          = $11           ;relocation offset
008800  2               kimcnt          = $13           ;kim counter
008800  2               pointr          = $14           ;pointer
008800  2               lengt           = $16           ;inst length
008800  2               point           = $17           ;relocate pointer
008800  2               adjust          = $19           ;relocate distance
008800  2               kimpnt          = $1B           ;kim file index
008800  2               savex           = $1C           ;save for x
008800  2               savey           = $1D           ;save for y
008800  2               number          = $1E           ;input pack buffer
008800  2               dstdrv          = $20           ;destination drive
008800  2               defalt          = $21           ;default drive
008800  2               seccnt          = $22           ;sector count
008800  2               secnum          = $24           ;sector number
008800  2               curccm          = $26           ;start of current ccm
008800  2               simlng          = $28           ;length of sim
008800  2               room            = $2A           ;memory needed for sysgen
008800  2               stksav          = $2C           ;save stack register
008800  2               frstsc          = $2D           ;first sector number of disk
008800  2               dskcfpc         = $2E           ;pointer to disk configuration table
008800  2               cmdlnp          = $30           ;pointer to command line buffer
008800  2               farfunct        = $32           ;function to call in driver area
008800  2               farpointer      = $33           ;WORD POINTER to call in driver area
008800  2               IRQVECTOR       = $35           ; VECTOR FOR USER IRQ RTN
008800  2               NMIVECTOR       = $37           ; VECTOR FOR USER NMI RTN
008800  2               zptemp          = $39
008800  2               STACKA          = $3A           ; TEMP VAR FOR STACK MANIPULATION
008800  2               lastzp          = $3B
008800  2               ;pem constants on entry to write
008800  2               wrall           = 0             ;write to allocated
008800  2               wrdir           = 1             ;write to directory
008800  2               wrual           = 2             ;write to unallocated
008800  2               
008800  2               ;page zero and system ram assignments
008800  2               DEST            = $EC           ;pointer for OutMsg
008800  2               SRC             = $EE           ;pointer for OutMsg
008800  2               OUTMSG_W        = $F0           ;pointer for OutMsg
008800  2               mvepnt          = $f2           ;host buffer location
008800  2               dmaadr          = $f4           ;pointer for r/w
008800  2               
008800  2               ;fixed parameters
008800  2               lf              = $a            ;linefeeed
008800  2               cr              = $d            ;return
008800  2               eof             = $1a           ;end of file
008800  2               null            = 0             ;null
008800  2               ctlc            = 3             ;abort
008800  2               ctle            = 5             ;physical cr lf
008800  2               ctli            = 9             ;tab character
008800  2               ctlp            = $10           ;toggle printer
008800  2               ctlr            = $12           ;repeat line
008800  2               ctls            = $13           ;freeze
008800  2               ctlx            = $18           ;cancel
008800  2               semico          = $3b           ;semicolon
008800  2               delete          = $08           ;delete character
008800  2               numcmd          = 36            ;number commands
008800  2               
008800  2               BANKED_DRIVER_DISPATCHER=$8800  ; LOCATION OF DRIVER DISPATCHER
008800  2               DEBUG           = 0             ; assemble with debug information on
008800  2               
008800  2               
008800  2               USESERIAL       = 1             ; SET TO ONE SERIAL CONSOLE IO
008800  2               USEFLOPPYA      = 0             ; SET TO ONE FOR FLOPPY = "A"
008800  2               USEFLOPPYB      = 0             ; SET TO ONE FOR FLOPPY = "B"
008800  2               USEIDEC         = 1             ; SET TO ONE FOR IDE HDD="C"
008800  2               USEDSKY         = 0             ; SEND INFO TO DSKY
008800  2               USEDSKYNG       = 1             ; SEND INFO TO DSKYNG
008800  2               DSKY_KBD        = 1             ; USE DSKY KEYBOARD?
008800  2               DEFDRV          = 2             ; SET TO DEFAULT DRIVE LETTER
008800  2               USEDISKIOV1     = 0             ; Floppy and IDE card is  DISK IO V1
008800  2               USEDISKIOV3     = 0             ; Floppy and IDE card is  DISK IO V3
008800  2               
008800  2               FLPA35          = 0             ; set to 1 if floppy a is A 3.5" 80 track drive (0= 5.25" 40 track drive)
008800  2               FLPB35          = 0             ; set to 1 if floppy a is B 3.5" 80 track drive (0= 5.25" 40 track drive)
008800  2               
008800  2               DSKYOSC         = 1000000
008800  2               USEROM          = 0
008800  2               
008800  1               
008800  1               ; for Nhyodyne:
008800  1               ; RAM BANK $0C is RAM area for Drivers
008800  1               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
008800  1               ; RAM BANK $0F is fixed bank $0000-$7FFF
008800  1               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code (AS A SECONDARY CPU)
008800  1               
008800  1               ;       Area from $0C:8000 to $0C:8800 reserved for work RAM for drivers (FOR SECONDARY CPU, UNDER ROMWBW)
008800  1               ;       Area from $0C:8000 to $0C:8800 reserved for ROM for drivers (FOR PRIMARY CPU, NO ROMWBW)
008800  1               ;
008800  1               
008800  1               ;__DISPATCHER________________________________________________________________________________________
008800  1               ;
008800  1               ;  Function dispatcher
008800  1               ;  function to call is located in "farfunct"
008800  1               ;____________________________________________________________________________________________________
008800  1               ;
008800  1  48                   PHA
008801  1  8A                   TXA
008802  1  48                   PHA
008803  1  A5 32                LDA     farfunct
008805  1  0A                   ASL     A               ; DOUBLE NUMBER FOR TABLE LOOKUP
008806  1  AA                   TAX
008807  1  BD 17 88             LDA     DISPATCHTABLE,X
00880A  1  85 33                STA     farpointer
00880C  1  BD 18 88             LDA     DISPATCHTABLE+1,X
00880F  1  85 34                STA     farpointer+1
008811  1               
008811  1  68                   PLA
008812  1  AA                   TAX
008813  1  68                   PLA
008814  1  6C 33 00             JMP     (farpointer)
008817  1               
008817  1               
008817  1               DISPATCHTABLE:
008817  1  D9 88                .WORD   WRSER1          ; FUNCTION 00 - WRITE SERIAL PORT
008819  1  E8 88                .WORD   RDSER1          ; FUNCTION 01 - READ SERIAL PORT
00881B  1  F8 88                .WORD   RDSER1W         ; FUNCTION 02 - READ SERIAL PORT (BLOCKING)
00881D  1  07 89                .WORD   SERIALSTATUS    ; FUNCTION 03 - GET SERIAL STATUS
00881F  1               
00881F  1  19 89                .WORD   PPIDE_INIT      ; FUNCTION 04 - called during OS init
008821  1  E1 8B                .WORD   IDE_READ_SECTOR ; FUNCTION 05 - read a sector from drive
008823  1  38 8C                .WORD   IDE_WRITE_SECTOR; FUNCTION 06 - write a sector to drive
008825  1               
008825  1  AF 8F                .WORD   DSKY_INIT       ; FUNCTION 07 -
008827  1  6E 91                .WORD   DSKY_SHOW       ; FUNCTION 08 -
008829  1  35 91                .WORD   DSKY_BIN2SEG    ; FUNCTION 09 -
00882B  1  B7 90                .WORD   DSKY_RESET      ; FUNCTION 10 -
00882D  1  D2 90                .WORD   DSKY_STAT       ; FUNCTION 11 -
00882F  1  DF 90                .WORD   DSKY_GETKEY     ; FUNCTION 12 -
008831  1  4D 92                .WORD   DSKY_BEEP       ; FUNCTION 13 -
008833  1  7E 92                .WORD   DSKY_L1ON       ; FUNCTION 14 -
008835  1  95 92                .WORD   DSKY_L2ON       ; FUNCTION 15 -
008837  1  AC 92                .WORD   DSKY_L1OFF      ; FUNCTION 16 -
008839  1  C3 92                .WORD   DSKY_L2OFF      ; FUNCTION 17 -
00883B  1  32 92                .WORD   DSKY_PUTLED     ; FUNCTION 18 -
00883D  1  FA 91                .WORD   DSKY_BLANK      ; FUNCTION 19 -
00883F  1               
00883F  1  62 93                .WORD   MD_READ_SECTOR  ; FUNCTION 20 - read a sector from memory device
008841  1  9F 93                .WORD   MD_WRITE_SECTOR ; FUNCTION 21 - write a sector to memory device
008843  1  19 93                .WORD   MD_SHOW         ; FUNCTION 22 - md show information
008845  1               
008845  1  13 98                .WORD   FL_READ_SECTOR  ; FUNCTION 23 - read a sector from floppy device
008847  1  9E 98                .WORD   FL_WRITE_SECTOR ; FUNCTION 24 - write a sector to floppy device
008849  1  E6 96                .WORD   FL_SETUP        ; FUNCTION 25 - init floppy device
00884B  1  13 98                .WORD   FL_READ_SECTOR  ; FUNCTION 26 - read a sector from floppy device
00884D  1  9E 98                .WORD   FL_WRITE_SECTOR ; FUNCTION 27 - write a sector to floppy device
00884F  1               
00884F  1  50 8E                .WORD   IDE_STORE_BOOT_IMAGE; FUNCTION 28 - save a boot image to a ppide device
008851  1  A5 8E                .WORD   IDE_RESTORE_BOOT_IMAGE; FUNCTION 29 - restore a boot image from a ppide device
008853  1  FA 8E                .WORD   IDE_CLEAR_TRACKS; FUNCTION 30 - clear tracks on a ppide device
008855  1               
008855  1  67 9B                .WORD   FL_STORE_BOOT_IMAGE; FUNCTION 31 - save a boot image to a ppide device
008857  1  CE 9B                .WORD   FL_RESTORE_BOOT_IMAGE; FUNCTION 32 - restore a boot image from a ppide device
008859  1               
008859  1               
008859  1               ;__DRIVERS___________________________________________________________________________________________
008859  1               ;
008859  1                       .INCLUDE "drvmacro.asm"
008859  2               ;__MACRO___________________________________________________________________________________________________________________
008859  2               ;
008859  2               ; 	Macros for the betterment of Mankind
008859  2               ;________________________________________________________________________________________________________________________________
008859  2               ;
008859  2               
008859  2               .macro          PRTDBG      message
008859  2               .LOCAL p1
008859  2               .LOCAL p2
008859  2               .LOCAL p3
008859  2               .LOCAL p4
008859  2               .LOCAL p5
008859  2                 .if     .paramcount <> 1
008859  2                       .error  "Too few parameters for macro PRTDBG"
008859  2                       .endif
008859  2                       .if DEBUG=1
008859  2                       PHA
008859  2                       txa
008859  2                       PHA
008859  2                       tya
008859  2                       PHA
008859  2                       LDX #$00
008859  2               p1:
008859  2                       LDA p4,x
008859  2                       INX
008859  2                       CMP #'$'
008859  2                       BEQ p2
008859  2                       JSR CONSOLE_OUT
008859  2                       JMP p1
008859  2               p2:
008859  2                       LDA #13
008859  2                       jsr CONSOLE_OUT
008859  2                       LDA #10
008859  2                       jsr CONSOLE_OUT
008859  2                       PLA
008859  2                       tay
008859  2                       PLA
008859  2                       tax
008859  2                       pla
008859  2                       JMP p5
008859  2               p4:
008859  2                       .BYTE message
008859  2               p5:
008859  2                       .endif
008859  2               .endmacro
008859  2               
008859  2               .macro          PRTS      message
008859  2               .LOCAL p1
008859  2               .LOCAL p2
008859  2               .LOCAL p3
008859  2               .LOCAL p4
008859  2               .LOCAL p5
008859  2                 .if     .paramcount <> 1
008859  2                       .error  "Too few parameters for macro PRTS"
008859  2                       .endif
008859  2                       PHA
008859  2                       TXA
008859  2                       PHA
008859  2                       tay
008859  2                       PHa
008859  2                       LDX #$00
008859  2               p1:
008859  2                       LDA p4,x
008859  2                       INX
008859  2                       CMP #'$'
008859  2                       BEQ p2
008859  2                       JSR CONSOLE_OUT
008859  2                       JMP p1
008859  2               p2:
008859  2                       PLA
008859  2                       tay
008859  2                       PLA
008859  2                       tax
008859  2                       pla
008859  2                       JMP p5
008859  2               p4:
008859  2                       .BYTE message
008859  2               p5:
008859  2               .endmacro
008859  2               
008859  2               .macro          DBGFLAG      character
008859  2                 .if     .paramcount <> 1
008859  2                       .error  "Too few parameters for macro DBGFLAG"
008859  2                       .endif
008859  2                       .if DEBUG=1
008859  2                       PHA
008859  2                       LDA #character
008859  2                       JSR CONSOLE_OUT
008859  2                       pla
008859  2                       .endif
008859  2               .endmacro
008859  2               
008859  2               
008859  2               ;__PRTHEXBYTE__________________________________________________
008859  2               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
008859  2               ;______________________________________________________________
008859  2               PRTHEXBYTE:
008859  2  48                   PHA
00885A  2  85 3A                sta     STACKA
00885C  2  8A                   txa
00885D  2  48                   PHa
00885E  2  98                   tya
00885F  2  48                   PHA
008860  2  A5 3A                lda     STACKA
008862  2  AA                   TAX				; SAVE A REGISTER
008863  2  4A                   LSR 				; SHIFT HIGH NIBBLE TO LOW NIBBLE
008864  2  4A                   LSR 				;
008865  2  4A                   LSR 				;
008866  2  4A                   LSR 				;
008867  2  18                   CLC               		; CLEAR CARRY
008868  2  20 75 88             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
00886B  2  8A                   TXA				; RESTORE ACCUMULATOR
00886C  2  20 75 88             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
00886F  2  68                   pla
008870  2  A8                   TAY
008871  2  68                   pla
008872  2  AA                   TAX
008873  2  68                   PLA
008874  2  60                   RTS
008875  2               
008875  2               ;__PRINT_DIGIT_________________________________________________
008875  2               ;
008875  2               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
008875  2               ;
008875  2               ;______________________________________________________________
008875  2               PRINT_DIGIT:
008875  2  29 0F                       AND #$0F				; STRIP OFF HIGH NIBBLE
008877  2  09 30                       ORA #$30				; ADD $30 TO PRODUCE ASCII
008879  2  C9 3A                       CMP #$3A               		; IS GREATER THAN 9
00887B  2  30 03                       BMI PRINT_DIGIT_OUT		; NO, SKIP ADD
00887D  2  18                          CLC				; CLEAR CARRY
00887E  2  69 07                       ADC #$07				; ADD ON FOR LETTER VALUES
008880  2               PRINT_DIGIT_OUT:					;
008880  2  4C 44 9C                    JMP CONSOLE_OUT              		; PRINT OUT CHAR
008883  2               
008883  2               NEWLINE:
008883  2  48                           pha
008884  2  A9 0D                        LDA #$0D
008886  2  20 44 9C                     JSR CONSOLE_OUT
008889  2  A9 0A                        LDA #$0A
00888B  2  20 44 9C                     Jsr CONSOLE_OUT
00888E  2  68                           pla
00888F  2  60                           rts
008890  2               
008890  2               PRTDEC:
008890  2  48                           PHA
008891  2  85 3A                        STA     STACKA
008893  2  98                           TYA
008894  2  48                           phA
008895  2  8A                           TXA
008896  2  48                           PHA
008897  2  A5 3A                        LDA     STACKA
008899  2  48                           PHA
00889A  2  A0 00                        ldy #00
00889C  2  A2 FF                        LDX #$FF
00889E  2  38                           SEC
00889F  2               PrDec100:
00889F  2  E8                           INX
0088A0  2  E9 64                        SBC #100
0088A2  2  B0 FB                        BCS PrDec100            ;Count how many 100s
0088A4  2  69 64                        ADC #100
0088A6  2  20 C2 88                     JSR PrDecDigit          ;Print the 100s
0088A9  2  A2 FF                        LDX #$FF
0088AB  2  38                           SEC                     ;Prepare for subtraction
0088AC  2               PrDec10:
0088AC  2  E8                           INX
0088AD  2  E9 0A                        SBC #10
0088AF  2  B0 FB                        BCS PrDec10             ;Count how many 10s
0088B1  2  69 0A                        ADC #10
0088B3  2  20 C2 88                     JSR PrDecDigit          ;Print the 10s
0088B6  2  AA                           TAX                     ;Pass 1s into X
0088B7  2  A0 01                        ldy #1
0088B9  2  20 C2 88                     JSR PrDecDigit          ;Print the 1s
0088BC  2  68                           PLA
0088BD  2  68                           pla
0088BE  2  AA                           TAX
0088BF  2  68                           pla
0088C0  2  A8                           TAY
0088C1  2  60                           RTS
0088C2  2               PrDecDigit:
0088C2  2  48                           PHA
0088C3  2  C0 00                        cpy #$00
0088C5  2  D0 09                        bne PrDecDigit1
0088C7  2  8A                           txa
0088C8  2  A8                           tay
0088C9  2  C0 00                        cpy #$00
0088CB  2  D0 03                        bne PrDecDigit1
0088CD  2  4C D6 88                     jmp PrDecDigit2
0088D0  2               PrDecDigit1:
0088D0  2  8A                           TXA                     ;Save A, pass digit to A
0088D1  2  09 30                        ORA #'0'
0088D3  2  20 44 9C                     JSR  CONSOLE_OUT        ;Convert to character and print it
0088D6  2               PrDecDigit2:
0088D6  2  68                           PLA
0088D7  2  60                           RTS                     ;Restore A and return
0088D8  2               
0088D8  1                       .INCLUDE "dosser.asm"
0088D8  2               ;__SERIAL DRIVERS________________________________________________________________________________________________________________
0088D8  2               ;
0088D8  2               ; 	Nhyodyne serial drivers for single serial port card
0088D8  2               ;
0088D8  2               ;	Entry points:
0088D8  2               ;		SERIALINIT  - called during OS init
0088D8  2               ;		RDSER1	    - read a byte from serial port ('A' POINTS TO BYTE)
0088D8  2               ;		WRSER1	    - write a byte from serial port  ('A' POINTS TO BYTE)
0088D8  2               ;		RDSER1W	    - read a byte from serial port ('A' POINTS TO BYTE, WAIT FOR INPUT)
0088D8  2               ;		SERIALSTATUS- GET UART STATUS
0088D8  2               ;________________________________________________________________________________________________________________________________
0088D8  2               ;
0088D8  2               
0088D8  2               
0088D8  2               ;*
0088D8  2               ;* HARDWARE I/O ADDRESSES
0088D8  2               ;*
0088D8  2               
0088D8  2               ; UART 16C550 SERIAL
0088D8  2               UART0           = $0368         ; DATA IN/OUT
0088D8  2               UART1           = $0369         ; CHECK RX
0088D8  2               UART2           = $036A         ; INTERRUPTS
0088D8  2               UART3           = $036B         ; LINE CONTROL
0088D8  2               UART4           = $036C         ; MODEM CONTROL
0088D8  2               UART5           = $036D         ; LINE STATUS
0088D8  2               UART6           = $036E         ; MODEM STATUS
0088D8  2               UART7           = $036F         ; SCRATCH REG.
0088D8  2               
0088D8  2               
0088D8  2               ;__SERIALINIT____________________________________________________________________________________________________________________
0088D8  2               ;
0088D8  2               ;	INITIALIZE SERIAL PORTS
0088D8  2               ;________________________________________________________________________________________________________________________________
0088D8  2               ;
0088D8  2               SERIALINIT:
0088D8  2               ;	LDA	#$80			;
0088D8  2               ;	STA	UART3			; SET DLAB FLAG
0088D8  2               ;	LDA	#12			; SET TO 12 = 9600 BAUD
0088D8  2               ;	STA	UART0			; save baud rate
0088D8  2               ;	LDA	#00			;
0088D8  2               ;	STA	UART1			;
0088D8  2               ;	LDA	#03			;
0088D8  2               ;	STA	UART3			; SET 8 BIT DATA, 1 STOPBIT
0088D8  2               ;	STA	UART4			;
0088D8  2               
0088D8  2  60                   RTS
0088D9  2               
0088D9  2               
0088D9  2               
0088D9  2               ;__WRSER1________________________________________________________________________________________________________________________
0088D9  2               ;
0088D9  2               ;	WRITE CHARACTER(A) TO UART
0088D9  2               ;________________________________________________________________________________________________________________________________
0088D9  2               ;
0088D9  2               WRSER1:
0088D9  2  48                   PHA
0088DA  2               WRSER1a:
0088DA  2  AD 6D 03             LDA     UART5           ; READ LINE STATUS REGISTER
0088DD  2  29 20                AND     #$20            ; TEST IF UART IS READY TO SEND (BIT 5)
0088DF  2  C9 00                CMP     #$00
0088E1  2  F0 F7                BEQ     WRSER1a         ; NO, WAIT FOR IT
0088E3  2  68                   PLA
0088E4  2  8D 68 03             STA     UART0           ; THEN WRITE THE CHAR TO UART
0088E7  2  60                   RTS
0088E8  2               
0088E8  2               ;__RDSER1________________________________________________________________________________________________________________________
0088E8  2               ;
0088E8  2               ;	READ CHARACTER FROM UART TO (A)
0088E8  2               ;________________________________________________________________________________________________________________________________
0088E8  2               ;
0088E8  2               RDSER1:
0088E8  2  AD 6D 03             LDA     UART5           ; READ LINE STATUS REGISTER
0088EB  2  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
0088ED  2  C9 00                CMP     #$00
0088EF  2  F0 04                BEQ     RDSER1N         ; LOOP UNTIL DATA IS READY
0088F1  2  AD 68 03             LDA     UART0           ; THEN READ THE CHAR FROM THE UART
0088F4  2  60                   RTS
0088F5  2               RDSER1N:
0088F5  2  A9 00                LDA     #$00            ;
0088F7  2  60                   RTS                     ;
0088F8  2               
0088F8  2               ;__RDSER1W_______________________________________________________________________________________________________________________
0088F8  2               ;
0088F8  2               ;	READ CHARACTER FROM UART TO (A) - WAIT FOR CHAR
0088F8  2               ;________________________________________________________________________________________________________________________________
0088F8  2               ;
0088F8  2               
0088F8  2               RDSER1W:
0088F8  2  AD 6D 03             LDA     UART5           ; READ LINE STATUS REGISTER
0088FB  2  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
0088FD  2  C9 00                CMP     #$00
0088FF  2  F0 F7                BEQ     RDSER1W         ; LOOP UNTIL DATA IS READY
008901  2  AD 68 03             LDA     UART0           ; THEN READ THE CHAR FROM THE UART
008904  2  29 7F                AND     #$7F
008906  2  60                   RTS
008907  2               
008907  2               ;__SERIALSTATUS__________________________________________________________________________________________________________________
008907  2               ;
008907  2               ;	READ UARD STATUS
008907  2               ;________________________________________________________________________________________________________________________________
008907  2               ;
008907  2               SERIALSTATUS:
008907  2  AD 6D 03             LDA     UART5           ; READ LINE STATUS REGISTER
00890A  2  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
00890C  2  C9 00                CMP     #$00
00890E  2  F0 03                BEQ     RDSTAT1         ; NO, INDICATE NO CHAR
008910  2  A9 FF                LDA     #$FF            ; GET DATA CHAR
008912  2  60                   RTS
008913  2               RDSTAT1:
008913  2  A9 00                LDA     #$00            ; GET DATA CHAR
008915  2  60                   RTS
008916  2               
008916  2               ; end
008916  2               
008916  1                       .INCLUDE "doside.asm"
008916  2               ;__IDE DRIVERS___________________________________________________________________________________________________________________
008916  2               ;
008916  2               ; 	Nhyodyne IDE disk drivers for Z80PPIDE card
008916  2               ;
008916  2               ;	Entry points:
008916  2               ;		PPIDE_INIT   	- called during OS init
008916  2               ;		IDE_READ_SECTOR - read a sector from drive
008916  2               ;		IDE_WRITE_SECTOR- write a sector to drive
008916  2               ;________________________________________________________________________________________________________________________________
008916  2               ;
008916  2               PPIDE_PPI       = $0360         ; PORT A
008916  2               ;
008916  2               PPIDELO         = PPIDE_PPI+0   ; LSB
008916  2               PPIDEHI         = PPIDE_PPI+1   ; MSB
008916  2               PPIDECNTRL      = PPIDE_PPI+2   ; Control Signals
008916  2               PPIDEPPIC       = PPIDE_PPI+3   ; CONTROL BYTE PPI 82C55
008916  2               
008916  2               PPIDE_A0_LINE   = $01           ;DIRECT FROM 8255 TO IDE INTERFACE
008916  2               PPIDE_A1_LINE   = $02           ;DIRECT FROM 8255 TO IDE INTERFACE
008916  2               PPIDE_A2_LINE   = $04           ;DIRECT FROM 8255 TO IDE INTERFACE
008916  2               PPIDE_CS0_LINE  = $08           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
008916  2               PPIDE_CS1_LINE  = $10           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
008916  2               PPIDE_WR_LINE   = $20           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
008916  2               PPIDE_RD_LINE   = $40           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
008916  2               PPIDE_RST_LINE  = $80           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
008916  2               
008916  2               PPIDE_DATA      = PPIDE_CS0_LINE
008916  2               PPIDE_ERR       = PPIDE_CS0_LINE + PPIDE_A0_LINE
008916  2               PPIDE_SEC_CNT   = PPIDE_CS0_LINE + PPIDE_A1_LINE
008916  2               PPIDE_LBALOW    = PPIDE_CS0_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
008916  2               PPIDE_LBAMID    = PPIDE_CS0_LINE + PPIDE_A2_LINE
008916  2               PPIDE_LBAHI     = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A0_LINE
008916  2               PPIDE_DEVICE    = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
008916  2               PPIDE_COMMAND   = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
008916  2               PPIDE_STATUS    = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
008916  2               PPIDE_CONTROL   = PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
008916  2               PPIDE_ASTATUS   = PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
008916  2               
008916  2               
008916  2               ;IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
008916  2               PPIDE_CMD_RECAL = $10
008916  2               PPIDE_CMD_READ  = $20
008916  2               PPIDE_CMD_WRITE = $30
008916  2               PPIDE_CMD_INIT  = $91
008916  2               PPIDE_CMD_ID    = $EC
008916  2               PPIDE_CMD_SPINDOWN = $E0
008916  2               PPIDE_CMD_SPINUP = $E1
008916  2               
008916  2               
008916  2               PPRD_IDE_8255   = %10010010     ;IDE_8255_CTL OUT, IDE_8255_LSB/MSB INPUT
008916  2               PPWR_IDE_8255   = %10000000     ;ALL THREE PORTS OUTPUT
008916  2               
008916  2               
008916  2               PPIDEINDEX:
008916  2  00                   .BYTE   $00
008917  2               PPIDETIMEOUT:
008917  2  00 00                .BYTE   $00,$00
008919  2               
008919  2               ;__PPIDE_INIT_________________________________________________________________________________________
008919  2               ;
008919  2               ;  INIT AND DISPLAY IDE INFO
008919  2               ;____________________________________________________________________________________________________
008919  2               ;
008919  2               PPIDE_INIT:
008919  2                       PRTDBG  "PPIDE INIT:$"
008919  2  48 8A 48 A8          PRTS    "PPIDE :$"
00891D  2  48 A2 00 BD  
008921  2  36 89 E8 C9  
00893E  2  20 83 88             JSR     NEWLINE
008941  2  20 D3 8B             JSR     IDE_PPIDETECT   ; TEST FOR PPI HARDWARE
008944  2  D0 39                BNE     IDE_ABORT       ; BAIL OUT IF NOT THERE
008946  2               ;
008946  2  48 8A 48 A8          PRTS    " IO=0x$"
00894A  2  48 A2 00 BD  
00894E  2  63 89 E8 C9  
00896A  2  A9 03                LDA     #>PPIDE_PPI     ; GET BASE PORT
00896C  2  20 59 88             JSR     PRTHEXBYTE      ; PRINT BASE PORT
00896F  2  A9 60                LDA     #<PPIDE_PPI     ; GET BASE PORT
008971  2  20 59 88             JSR     PRTHEXBYTE      ; PRINT BASE PORT
008974  2               ;
008974  2  20 6E 8C             JSR     PPIDE_RESET     ; RESET THE BUS
008977  2  20 19 8A             JSR     PPIDE_PROBE     ; DETECT AN ATA DEVICE, ABORT IF NOT FOUND
00897A  2  B0 03                BCS     IDE_ABORT
00897C  2  4C AC 89             JMP     IDE_PRINT_INFO
00897F  2               IDE_ABORT:
00897F  2  48 8A 48 A8          PRTS    " NOT PRESENT$" ; NOT PRESENT
008983  2  48 A2 00 BD  
008987  2  9C 89 E8 C9  
0089A9  2  4C 15 8A             JMP     IDE_INITA
0089AC  2               IDE_PRINT_INFO:
0089AC  2  20 83 88             JSR     NEWLINE
0089AF  2  48 8A 48 A8          PRTS    " PPIDE0: Blocks=$"
0089B3  2  48 A2 00 BD  
0089B7  2  CC 89 E8 C9  
0089DD  2  A9 00                LDA     #$00
0089DF  2  20 A2 8A             JSR     IDE_READ_INFO   ; GET DRIVE INFO, ABORT IF ERROR
0089E2  2  48 8A 48 A8          PRTS    " PPIDE1: Blocks=$"
0089E6  2  48 A2 00 BD  
0089EA  2  FF 89 E8 C9  
008A10  2  A9 01                LDA     #$01
008A12  2  20 A2 8A             JSR     IDE_READ_INFO   ; GET DRIVE INFO, ABORT IF ERROR
008A15  2               IDE_INITA:
008A15  2  20 83 88             JSR     NEWLINE
008A18  2  60                   RTS                     ; DONE
008A19  2               ;
008A19  2               ;__PPIDE_PROBE_______________________________________________________________________________________
008A19  2               ;
008A19  2               ;  PROBE FOR IDE HARDWARE
008A19  2               ;____________________________________________________________________________________________________
008A19  2               ;
008A19  2               PPIDE_PROBE:
008A19  2               ;
008A19  2               ; BELOW TESTS FOR EXISTENCE OF AN IDE CONTROLLER ON THE
008A19  2               ; PPIDE INTERFACE.  WE WRITE A VALUE OF ZERO FIRST SO THAT
008A19  2               ; THE PPI BUS HOLD WILL RETURN A VALUE OF ZERO IF THERE IS
008A19  2               ; NOTHING CONNECTED TO PPI PORT A.  THEN WE READ THE STATUS
008A19  2               ; REGISTER.  IF AN IDE CONTROLLER IS THERE, IT SHOULD ALWAYS
008A19  2               ; RETURN SOMETHING OTHER THAN ZERO.  IF AN IDE CONTROLLER IS
008A19  2               ; THERE, THEN THE VALUE WRITTEN TO PPI PORT A IS IGNORED
008A19  2               ; BECAUSE THE WRITE SIGNAL IS NEVER PULSED.
008A19  2               
008A19  2  A9 00                LDA     #$00
008A1B  2  8D 60 03             STA     PPIDELO         ; PPI PORT A, DATALO
008A1E  2               
008A1E  2  20 99 8C             JSR     IDE_WAIT_NOT_BUSY; WAIT FOR BUSY TO CLEAR
008A21  2  B0 34                BCS     PPIDE_PROBE_FAIL; IF TIMEOUT, REPORT NO IDE PRESENT
008A23  2  A9 0F                LDA     #PPIDE_STATUS   ; GET STATUS
008A25  2  20 5D 8F             JSR     IDE_READ
008A28  2  8A                   TXA
008A29  2  29 40                AND     #%01000000
008A2B  2  C9 00                CMP     #$00
008A2D  2  F0 28                BEQ     PPIDE_PROBE_FAIL; IF NOT RDY BIT (BIT 6) THEN REPORT NO IDE PRESENT
008A2F  2               
008A2F  2               ; CHECK SIGNATURE
008A2F  2  A9 0A                LDA     #PPIDE_SEC_CNT
008A31  2  20 5D 8F             JSR     IDE_READ
008A34  2  E0 01                CPX     #$01
008A36  2  D0 1F                BNE     PPIDE_PROBE_FAIL; IF not '01' THEN REPORT NO IDE PRESENT
008A38  2  A9 0B                LDA     #PPIDE_LBALOW
008A3A  2  20 5D 8F             JSR     IDE_READ
008A3D  2  E0 01                CPX     #$01
008A3F  2  D0 16                BNE     PPIDE_PROBE_FAIL; IF not '01' THEN REPORT NO IDE PRESENT
008A41  2  A9 0C                LDA     #PPIDE_LBAMID
008A43  2  20 5D 8F             JSR     IDE_READ
008A46  2  E0 00                CPX     #$00
008A48  2  D0 0D                BNE     PPIDE_PROBE_FAIL; IF not '00' THEN REPORT NO IDE PRESENT
008A4A  2  A9 0D                LDA     #PPIDE_LBAHI
008A4C  2  20 5D 8F             JSR     IDE_READ
008A4F  2  E0 00                CPX     #$00
008A51  2  D0 04                BNE     PPIDE_PROBE_FAIL; IF not '00' THEN REPORT NO IDE PRESENT
008A53  2  18                   CLC
008A54  2  4C 58 8A             JMP     PPIDE_PROBE_SUCCESS
008A57  2               PPIDE_PROBE_FAIL:
008A57  2  38                   SEC
008A58  2               PPIDE_PROBE_SUCCESS:
008A58  2  60                   RTS                     ; DONE, NOTE THAT A=0 AND Z IS SET
008A59  2               
008A59  2               
008A59  2               ;___IDE_IDENTIFY_TYPE____________________________________________________________________________________
008A59  2               ;
008A59  2               ; 	READ THE DISK TYPE AND DETERMINE IF IT IS USABLE BY DOS/65
008A59  2               ; 	A=IDE DEVICE (0=MST,1=SLV)
008A59  2               ;________________________________________________________________________________________________________
008A59  2               
008A59  2               IDE_IDENTIFY_TYPE:
008A59  2  48                   PHA
008A5A  2  20 99 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008A5D  2  B0 40                BCS     IDE_IDENTIFY_TYPE_ERROR; IF TIMEOUT, REPORT ERROR
008A5F  2  A9 00                LDA     #$00
008A61  2  8D 12 05             STA     debsehd
008A64  2  8D 10 05             STA     debcyll         ; STORE IN TRACK (lsb)
008A67  2  8D 11 05             STA     debcylm         ; STORE IN TRACK (msb)
008A6A  2  68                   PLA                     ; GET DRIVE TYPE
008A6B  2  20 0E 8C             JSR     IDE_READ_SECTOR_DIRTY1
008A6E  2  C9 FF                CMP     #$FF            ; IS THERE A READ ERROR?
008A70  2  F0 2D                BEQ     IDE_IDENTIFY_TYPE_ERROR
008A72  2  AD E4 96             LDA     hstbuf+$01FE
008A75  2  C9 55                CMP     #$55
008A77  2  D0 23                BNE     IDE_IDENTIFY_TYPE_OK
008A79  2  AD E5 96             LDA     hstbuf+$01FF
008A7C  2  C9 AA                CMP     #$AA
008A7E  2  D0 1C                BNE     IDE_IDENTIFY_TYPE_OK
008A80  2  AD A8 96             LDA     hstbuf+$01C2
008A83  2  C9 00                CMP     #$00
008A85  2  D0 18                BNE     IDE_IDENTIFY_TYPE_ERROR
008A87  2  AD B8 96             LDA     hstbuf+$01D2
008A8A  2  C9 00                CMP     #$00
008A8C  2  D0 11                BNE     IDE_IDENTIFY_TYPE_ERROR
008A8E  2  AD C8 96             LDA     hstbuf+$01E2
008A91  2  C9 00                CMP     #$00
008A93  2  D0 0A                BNE     IDE_IDENTIFY_TYPE_ERROR
008A95  2  AD D8 96             LDA     hstbuf+$01F2
008A98  2  C9 00                CMP     #$00
008A9A  2  D0 03                BNE     IDE_IDENTIFY_TYPE_ERROR
008A9C  2               IDE_IDENTIFY_TYPE_OK:
008A9C  2  A9 00                LDA     #$00            ; EVERYTHING IS AWESOME
008A9E  2  60                   RTS
008A9F  2               IDE_IDENTIFY_TYPE_ERROR:
008A9F  2  A9 FF                LDA     #$FF            ; SIGNIFY ERROR
008AA1  2  60                   RTS
008AA2  2               
008AA2  2               
008AA2  2               ;*__IDE_READ_INFO___________________________________________________________________________________
008AA2  2               ;*
008AA2  2               ;*  READ IDE INFORMATION
008AA2  2               ;*	CARRY SET ON ERROR
008AA2  2               ;* 	A=MST/SLV
008AA2  2               ;*____________________________________________________________________________________________________
008AA2  2               IDE_READ_INFO:
008AA2  2                       PRTDBG  "IDE Read INFORMATION$"
008AA2  2  48                   PHA
008AA3  2  48                   PHA
008AA4  2               ; SET DRIVE BIT
008AA4  2  29 01                AND     #$01            ; ONLY WANT THE 1 BIT (MST/SLV)
008AA6  2  0A                   ASL     a               ; SHIFT 4
008AA7  2  0A                   ASL     a               ;
008AA8  2  0A                   ASL     a               ;
008AA9  2  0A                   ASL     a               ;
008AAA  2  09 E0                ORA     #$E0            ; E0=MST  F0=SLV
008AAC  2  AA                   TAX
008AAD  2  A0 00                LDY     #$00
008AAF  2  A9 0E                LDA     #PPIDE_DEVICE
008AB1  2  20 79 8F             JSR     IDE_WRITE
008AB4  2               
008AB4  2               
008AB4  2  20 99 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008AB7  2  B0 52                BCS     IDE_READ_INFO_ABORT
008AB9  2  A9 0F                LDA     #PPIDE_COMMAND  ;SELECT IDE REGISTER
008ABB  2  A2 EC                LDX     #PPIDE_CMD_ID
008ABD  2  20 79 8F             JSR     IDE_WRITE       ;ASK THE DRIVE TO READ IT
008AC0  2  20 C5 8C             JSR     IDE_WAIT_DRQ    ;WAIT UNTIL IT'S GOT THE DATA
008AC3  2  B0 46                BCS     IDE_READ_INFO_ABORT
008AC5  2  20 F9 8C             JSR     IDE_READ_BUFFER ; GRAB THE 256 WORDS FROM THE BUFFER
008AC8  2  48 8A 48 A8          PRTS    "0x$"
008ACC  2  48 A2 00 BD  
008AD0  2  E5 8A E8 C9  
008AE8  2  AD 61 95             LDA     hstbuf+123
008AEB  2  20 59 88             JSR     PRTHEXBYTE
008AEE  2  AD 60 95             LDA     hstbuf+122
008AF1  2  20 59 88             JSR     PRTHEXBYTE
008AF4  2  AD 5F 95             LDA     hstbuf+121
008AF7  2  20 59 88             JSR     PRTHEXBYTE
008AFA  2  AD 5E 95             LDA     hstbuf+120
008AFD  2  20 59 88             JSR     PRTHEXBYTE
008B00  2  68                   PLA
008B01  2  20 59 8A             JSR     IDE_IDENTIFY_TYPE
008B04  2  C9 00                CMP     #$00
008B06  2  D0 36                BNE     IDE_READ_INFO_BADFS
008B08  2  4C 74 8B             JMP     IDE_READ_INFO_OK
008B0B  2               IDE_READ_INFO_ABORT:
008B0B  2  68                   PLA
008B0C  2  48 8A 48 A8          PRTS    "NOT PRESENT$"  ; NOT PRESENT
008B10  2  48 A2 00 BD  
008B14  2  29 8B E8 C9  
008B35  2  20 83 88             JSR     NEWLINE
008B38  2  68                   PLA
008B39  2  20 AF 8B             JSR     IDE_REMOVE_DRIVE_ASSIGNMENTS
008B3C  2  38                   SEC
008B3D  2  60                   RTS                     ;
008B3E  2               IDE_READ_INFO_BADFS:
008B3E  2  48 8A 48 A8          PRTS    " BAD FILESYSTEM$"; NOT PRESENT
008B42  2  48 A2 00 BD  
008B46  2  5B 8B E8 C9  
008B6B  2  20 83 88             JSR     NEWLINE
008B6E  2  68                   PLA
008B6F  2  20 AF 8B             JSR     IDE_REMOVE_DRIVE_ASSIGNMENTS
008B72  2  38                   SEC
008B73  2  60                   RTS                     ;
008B74  2               IDE_READ_INFO_OK:
008B74  2  48 8A 48 A8          PRTS    " FILE SYSTEM COMPATIBLE$"; NOT PRESENT
008B78  2  48 A2 00 BD  
008B7C  2  91 8B E8 C9  
008BA9  2  20 83 88             JSR     NEWLINE
008BAC  2  68                   PLA
008BAD  2  18                   CLC
008BAE  2  60                   RTS
008BAF  2               
008BAF  2               IDE_REMOVE_DRIVE_ASSIGNMENTS:
008BAF  2  18                   CLC
008BB0  2  69 30                ADC     #$30
008BB2  2  A2 00                LDX     #$00
008BB4  2               @1:
008BB4  2  DD 14 05             CMP     dskcfg,X        ; GET device
008BB7  2  F0 09                BEQ     @2
008BB9  2  E8                   INX
008BBA  2  E8                   INX
008BBB  2  E0 10                CPX     #16
008BBD  2  D0 F5                BNE     @1
008BBF  2  4C D2 8B             JMP     @3
008BC2  2               @2:
008BC2  2  48                   PHA
008BC3  2  A9 00                LDA     #$00
008BC5  2  9D 14 05             STA     dskcfg,X        ; SET device
008BC8  2  E8                   INX
008BC9  2  9D 14 05             STA     dskcfg,X        ; SET device
008BCC  2  68                   PLA
008BCD  2  E8                   INX
008BCE  2  E0 10                CPX     #16
008BD0  2  D0 E2                BNE     @1
008BD2  2               @3:
008BD2  2  60                   RTS
008BD3  2               
008BD3  2               ;__IDE_PPIDETECT____________________________________________________________________________________
008BD3  2               ;
008BD3  2               ;  PROBE FOR PPI HARDWARE
008BD3  2               ;____________________________________________________________________________________________________
008BD3  2               ;
008BD3  2               IDE_PPIDETECT:
008BD3  2               ;
008BD3  2               ; TEST FOR PPI EXISTENCE
008BD3  2               ; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
008BD3  2               ; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
008BD3  2               ; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
008BD3  2               ; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
008BD3  2               ; INTERFERE WITH THE VALUE BEING READ.
008BD3  2  20 9D 8F             JSR     SET_PPI_WR
008BD6  2               ;
008BD6  2  A9 00                LDA     #$00            ; VALUE ZERO
008BD8  2  8D 60 03             STA     PPIDELO         ; PUSH VALUE TO PORT
008BDB  2  AD 60 03             LDA     PPIDELO         ; GET PORT VALUE
008BDE  2  C9 00                CMP     #$00
008BE0  2  60                   RTS                     ; AND RETURN
008BE1  2               ;
008BE1  2               
008BE1  2               
008BE1  2               ;*__IDE_READ_SECTOR___________________________________________________________________________________
008BE1  2               ;*
008BE1  2               ;*  READ IDE SECTOR (IN LBA) INTO BUFFER
008BE1  2               ;*
008BE1  2               ;*____________________________________________________________________________________________________
008BE1  2               IDE_READ_SECTOR:
008BE1  2                       PRTDBG  "IDE Read Sector$"
008BE1  2  20 E8 8B             JSR     IDE_READ_RAW_SECTOR
008BE4  2  20 0E 94             JSR     DEBSECR512
008BE7  2  60                   RTS
008BE8  2               
008BE8  2               IDE_READ_RAW_SECTOR:
008BE8  2                       PRTDBG  "IDE Read Raw Sector$"
008BE8  2  20 95 8D             JSR     IDE_CONVERT_SECTOR;
008BEB  2               
008BEB  2  AD 12 05             LDA     debsehd         ; STORE CURRENT PARMS
008BEE  2  CD AB 8F             CMP     Cdebsehd        ;
008BF1  2  D0 13                BNE     IDE_READ_SECTOR_DIRTY
008BF3  2  AD 11 05             LDA     debcylm         ;
008BF6  2  CD AA 8F             CMP     Cdebcylm        ;
008BF9  2  D0 0B                BNE     IDE_READ_SECTOR_DIRTY
008BFB  2  AD 10 05             LDA     debcyll         ;
008BFE  2  CD A9 8F             CMP     Cdebcyll        ;
008C01  2  D0 03                BNE     IDE_READ_SECTOR_DIRTY
008C03  2  A9 00                LDA     #$00            ; ZERO = 1 ON RETURN = OPERATION OK
008C05  2  60                   RTS
008C06  2               
008C06  2               IDE_READ_SECTOR_DIRTY:
008C06  2                       PRTDBG  "IDE Read Sector Buffer Dirty$"
008C06  2  20 99 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008C09  2  B0 2A                BCS     IDE_READ_SECTOR_DIRTY_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C0B  2  20 58 94             JSR     GET_DRIVE_DEVICE
008C0E  2               IDE_READ_SECTOR_DIRTY1:
008C0E  2  20 65 8D             JSR     IDE_SETUP_LBA   ;TELL IT WHICH SECTOR WE WANT
008C11  2  A9 0F                LDA     #PPIDE_COMMAND  ;SELECT IDE REGISTER
008C13  2  A2 20                LDX     #PPIDE_CMD_READ
008C15  2  20 79 8F             JSR     IDE_WRITE       ;ASK THE DRIVE TO READ IT
008C18  2  20 C5 8C             JSR     IDE_WAIT_DRQ    ;WAIT UNTIL IT'S GOT THE DATA
008C1B  2  B0 18                BCS     IDE_READ_SECTOR_DIRTY_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C1D  2  20 F9 8C             JSR     IDE_READ_BUFFER ; GRAB THE 256 WORDS FROM THE BUFFER
008C20  2  AD 12 05             LDA     debsehd         ; STORE CURRENT PARMS
008C23  2  8D AB 8F             STA     Cdebsehd        ;
008C26  2  AD 10 05             LDA     debcyll         ;
008C29  2  8D A9 8F             STA     Cdebcyll        ;
008C2C  2  AD 11 05             LDA     debcylm         ;
008C2F  2  8D AA 8F             STA     Cdebcylm        ;
008C32  2               
008C32  2  A9 00                LDA     #$00            ; ZERO = 1 ON RETURN = OPERATION OK
008C34  2  60                   RTS
008C35  2               IDE_READ_SECTOR_DIRTY_ERROR:
008C35  2  A9 FF                LDA     #$FF            ; ZERO = 1 ON RETURN = OPERATION OK
008C37  2  60                   RTS
008C38  2               
008C38  2               ;*__IDE_WRITE_SECTOR__________________________________________________________________________________
008C38  2               ;*
008C38  2               ;*  WRITE IDE SECTOR (IN LBA) FROM BUFFER
008C38  2               ;*
008C38  2               ;*____________________________________________________________________________________________________
008C38  2               IDE_WRITE_SECTOR:
008C38  2                       PRTDBG  "IDE Write Sector$"
008C38  2  20 E8 8B             JSR     IDE_READ_RAW_SECTOR; determine physical sector
008C3B  2  20 37 94             JSR     BLKSECR512      ; block sector for writing
008C3E  2  20 99 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008C41  2  B0 28                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C43  2  20 58 94             JSR     GET_DRIVE_DEVICE
008C46  2               IDE_WRITE_SECTOR_RAW:
008C46  2  20 65 8D             JSR     IDE_SETUP_LBA   ;TELL IT WHICH SECTOR WE WANT
008C49  2  A9 0F                LDA     #PPIDE_COMMAND
008C4B  2  A2 30                LDX     #PPIDE_CMD_WRITE
008C4D  2  20 79 8F             JSR     IDE_WRITE       ;TELL DRIVE TO WRITE A SECTOR
008C50  2  20 C5 8C             JSR     IDE_WAIT_DRQ    ;WAIT UNIT IT WANTS THE DATA
008C53  2  B0 16                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C55  2  20 2E 8D             JSR     IDE_WRITE_BUFFER;GIVE THE DATA TO THE DRIVE
008C58  2  20 99 8C             JSR     IDE_WAIT_NOT_BUSY;WAIT UNTIL THE WRITE IS COMPLETE
008C5B  2  B0 0E                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C5D  2  A9 FF                LDA     #$FF            ; STORE CURRENT PARMS
008C5F  2  8D AB 8F             STA     Cdebsehd        ;
008C62  2  8D A9 8F             STA     Cdebcyll        ;
008C65  2  8D AA 8F             STA     Cdebcylm        ;
008C68  2               
008C68  2  A9 00                LDA     #$00            ; ZERO ON RETURN = OPERATION OK
008C6A  2  60                   RTS
008C6B  2               IDE_WRITE_SECTOR_ERROR:
008C6B  2  A9 FF                LDA     #$FF            ; 1 ON RETURN = OPERATION FAIL
008C6D  2  60                   RTS
008C6E  2               
008C6E  2               ;*__PPIDE_RESET____________________________________________________________________________________
008C6E  2               ;*
008C6E  2               ;*  SOFT RESET IDE CHANNEL
008C6E  2               ;*
008C6E  2               ;*____________________________________________________________________________________________________
008C6E  2               PPIDE_RESET:
008C6E  2                       PRTDBG  "IDE Reset$"
008C6E  2  A9 00                LDA     #$00
008C70  2  8D 12 05             STA     debsehd
008C73  2  8D 10 05             STA     debcyll
008C76  2  8D 11 05             STA     debcylm
008C79  2  A9 FF                LDA     #$FF            ;
008C7B  2  8D AB 8F             STA     Cdebsehd        ;
008C7E  2  8D A9 8F             STA     Cdebcyll        ;
008C81  2  8D AA 8F             STA     Cdebcylm        ;
008C84  2               
008C84  2  A9 80                LDA     #PPIDE_RST_LINE
008C86  2  8D 62 03             STA     PPIDECNTRL      ; ASSERT RST LINE ON IDE INTERFACE
008C89  2  A2 00                LDX     #$00
008C8B  2                       PRTDBG  "IDE Reset Delay$"
008C8B  2               RST_DLY:
008C8B  2  CA                   DEX
008C8C  2  E0 00                CPX     #$00
008C8E  2  D0 FB                BNE     RST_DLY
008C90  2  A9 00                LDA     #$00
008C92  2  8D 62 03             STA     PPIDECNTRL      ; DEASSERT RST LINE ON IDE INTERFACE
008C95  2               
008C95  2               ; IF A DSKYNG IS ACTIVE AND IS ON THE SAME PPI PORT AS THE PPISD BEING
008C95  2               ; RESET, THEN THE DSKYNG WILL ALSO BE RESET.  SO, THE DSKY IS ALSO INITIALIZED.
008C95  2                       .IF     (USEDSKYNG=1)
008C95  2  20 AF 90                 JSR     DSKY_REINIT
008C98  2                       .ENDIF
008C98  2               
008C98  2  60                   RTS
008C99  2               
008C99  2               
008C99  2               ;*__IDE_WAIT_NOT_BUSY_______________________________________________________________________________
008C99  2               ;*
008C99  2               ;*  WAIT FOR IDE CHANNEL TO BECOME READY
008C99  2               ;*
008C99  2               ;*____________________________________________________________________________________________________
008C99  2               IDE_WAIT_NOT_BUSY:
008C99  2  48                   PHA
008C9A  2  8A                   TXA
008C9B  2  48                   PHA
008C9C  2  98                   TYA
008C9D  2  48                   PHA
008C9E  2  A9 00                LDA     #$00
008CA0  2  8D 17 89             STA     PPIDETIMEOUT
008CA3  2  8D 18 89             STA     PPIDETIMEOUT+1
008CA6  2               IDE_WAIT_NOT_BUSY1:
008CA6  2  A9 0F                LDA     #PPIDE_STATUS   ;WAIT FOR RDY BIT TO BE SET
008CA8  2  20 5D 8F             JSR     IDE_READ
008CAB  2  8A                   TXA
008CAC  2  29 80                AND     #$80
008CAE  2  F0 0E                BEQ     IDE_WAIT_NOT_BUSY2
008CB0  2  EE 17 89             INC     PPIDETIMEOUT
008CB3  2  D0 F1                BNE     IDE_WAIT_NOT_BUSY1
008CB5  2  EE 18 89             INC     PPIDETIMEOUT+1
008CB8  2  D0 EC                BNE     IDE_WAIT_NOT_BUSY1
008CBA  2  38                   SEC
008CBB  2  4C BF 8C             JMP     IDE_WAIT_NOT_BUSY3
008CBE  2               IDE_WAIT_NOT_BUSY2:
008CBE  2  18                   CLC
008CBF  2               IDE_WAIT_NOT_BUSY3:
008CBF  2  68                   PLA
008CC0  2  A8                   TAY
008CC1  2  68                   PLA
008CC2  2  AA                   TAX
008CC3  2  68                   PLA
008CC4  2  60                   RTS
008CC5  2               
008CC5  2               ;*__IDE_WAIT_DRQ______________________________________________________________________________________
008CC5  2               ;*
008CC5  2               ;*	WAIT FOR THE DRIVE TO BE READY TO TRANSFER DATA.
008CC5  2               ;*
008CC5  2               ;*____________________________________________________________________________________________________
008CC5  2               IDE_WAIT_DRQ:
008CC5  2  48                   PHA
008CC6  2  8A                   TXA
008CC7  2  48                   PHA
008CC8  2  98                   TYA
008CC9  2  48                   PHA
008CCA  2  A9 00                LDA     #$00
008CCC  2  8D 17 89             STA     PPIDETIMEOUT
008CCF  2  8D 18 89             STA     PPIDETIMEOUT+1
008CD2  2               IDE_WAIT_DRQ1:
008CD2  2  A9 0F                LDA     #PPIDE_STATUS   ;WAIT FOR DRQ BIT TO BE SET
008CD4  2  20 5D 8F             JSR     IDE_READ
008CD7  2  8A                   TXA
008CD8  2  29 88                AND     #%10001000      ; MASK OFF BUSY(7) AND DRQ(3)
008CDA  2  C9 08                CMP     #%00001000      ; WE WANT BUSY(7) TO BE 0 AND DRQ (3) TO BE 1
008CDC  2  F0 14                BEQ     IDE_WAIT_DRQ2
008CDE  2  29 01                AND     #%00000001      ; IS ERROR?
008CE0  2  C9 01                CMP     #%00000001      ;
008CE2  2  F0 0A                BEQ     IDE_WAIT_DRQE
008CE4  2  EE 17 89             INC     PPIDETIMEOUT
008CE7  2  D0 E9                BNE     IDE_WAIT_DRQ1
008CE9  2  EE 18 89             INC     PPIDETIMEOUT+1
008CEC  2  D0 E4                BNE     IDE_WAIT_DRQ1
008CEE  2               IDE_WAIT_DRQE:
008CEE  2  38                   SEC
008CEF  2  4C F3 8C             JMP     IDE_WAIT_DRQ3
008CF2  2               IDE_WAIT_DRQ2:
008CF2  2  18                   CLC
008CF3  2               IDE_WAIT_DRQ3:
008CF3  2  68                   PLA
008CF4  2  A8                   TAY
008CF5  2  68                   PLA
008CF6  2  AA                   TAX
008CF7  2  68                   PLA
008CF8  2  60                   RTS
008CF9  2               
008CF9  2               
008CF9  2               
008CF9  2               ;*__IDE_READ_BUFFER___________________________________________________________________________________
008CF9  2               ;*
008CF9  2               ;*  READ IDE BUFFER LITTLE ENDIAN
008CF9  2               ;*
008CF9  2               ;*____________________________________________________________________________________________________
008CF9  2               IDE_READ_BUFFER:
008CF9  2  A2 00                LDX     #$00            ; INDEX
008CFB  2               IDEBUFRD:
008CFB  2  8E 16 89             STX     PPIDEINDEX
008CFE  2  A9 08                LDA     #PPIDE_DATA
008D00  2  20 5D 8F             JSR     IDE_READ
008D03  2  8A                   TXA
008D04  2  AE 16 89             LDX     PPIDEINDEX
008D07  2  9D E6 94             STA     hstbuf,X        ;
008D0A  2  E8                   INX                     ;
008D0B  2  98                   TYA                     ; THEN HIGH BYTE OF WORD
008D0C  2  9D E6 94             STA     hstbuf,X        ;
008D0F  2  E8                   INX
008D10  2  E0 00                CPX     #$00            ;
008D12  2  D0 E7                BNE     IDEBUFRD        ;
008D14  2               IDEBUFRD1:
008D14  2  8E 16 89             STX     PPIDEINDEX
008D17  2  A9 08                LDA     #PPIDE_DATA
008D19  2  20 5D 8F             JSR     IDE_READ
008D1C  2  8A                   TXA
008D1D  2  AE 16 89             LDX     PPIDEINDEX
008D20  2  9D E6 95             STA     hstbuf+256,X    ;
008D23  2  E8                   INX                     ;
008D24  2  98                   TYA                     ; THEN HIGH BYTE OF WORD
008D25  2  9D E6 95             STA     hstbuf+256,X    ;
008D28  2  E8                   INX                     ;
008D29  2  E0 00                CPX     #$00            ;
008D2B  2  D0 E7                BNE     IDEBUFRD1       ;
008D2D  2  60                   RTS                     ;
008D2E  2               
008D2E  2               ;*__IDE_WRITE_BUFFER___________________________________________________________________________________
008D2E  2               ;*
008D2E  2               ;*  WRITE IDE BUFFER LITTLE ENDIAN
008D2E  2               ;*
008D2E  2               ;*____________________________________________________________________________________________________
008D2E  2               IDE_WRITE_BUFFER:
008D2E  2  A2 00                LDX     #$00            ; INDEX
008D30  2               IDEBUFWT:
008D30  2  8E 16 89             STX     PPIDEINDEX
008D33  2  BD E7 94             LDA     hstbuf+1,X      ; SECTORS ARE BIG ENDIAN
008D36  2  A8                   TAY                     ;
008D37  2  BD E6 94             LDA     hstbuf,X        ; SECTORS ARE BIG ENDIAN
008D3A  2  AA                   TAX
008D3B  2  A9 08                LDA     #PPIDE_DATA
008D3D  2  20 79 8F             JSR     IDE_WRITE
008D40  2  AE 16 89             LDX     PPIDEINDEX
008D43  2  E8                   INX                     ;
008D44  2  E8                   INX                     ;
008D45  2  E0 00                CPX     #$00            ;
008D47  2  D0 E7                BNE     IDEBUFWT        ;
008D49  2  A2 00                LDX     #$00            ; INDEX
008D4B  2               IDEBUFWT1:
008D4B  2  8E 16 89             STX     PPIDEINDEX
008D4E  2  BD E7 95             LDA     hstbuf+257,X    ; SECTORS ARE BIG ENDIAN
008D51  2  A8                   TAY
008D52  2  BD E6 95             LDA     hstbuf+256,X    ; SECTORS ARE BIG ENDIAN
008D55  2  AA                   TAX
008D56  2  A9 08                LDA     #PPIDE_DATA
008D58  2  20 79 8F             JSR     IDE_WRITE
008D5B  2  AE 16 89             LDX     PPIDEINDEX
008D5E  2  E8                   INX                     ;
008D5F  2  E8                   INX                     ;
008D60  2  E0 00                CPX     #$00            ;
008D62  2  D0 E7                BNE     IDEBUFWT1       ;
008D64  2  60                   RTS                     ;
008D65  2               
008D65  2               ;*__IDE_SETUP_LBA_____________________________________________________________________________________
008D65  2               ;*
008D65  2               ;*  SETUP LBA DATA
008D65  2               ;*  A= DRIVE DEVICE
008D65  2               ;*____________________________________________________________________________________________________
008D65  2               IDE_SETUP_LBA:
008D65  2                       PRTDBG  "PPIDE SETUP LBA$"
008D65  2  29 01                AND     #$01            ; only want drive cfg
008D67  2  0A                   ASL     a               ; SHIFT 4
008D68  2  0A                   ASL     a               ;
008D69  2  0A                   ASL     a               ;
008D6A  2  0A                   ASL     a               ;
008D6B  2  09 E0                ORA     #$E0            ; E0=MST  F0=SLV
008D6D  2  AA                   TAX
008D6E  2  A0 00                LDY     #$00
008D70  2  A9 0E                LDA     #PPIDE_DEVICE
008D72  2  20 79 8F             JSR     IDE_WRITE
008D75  2               
008D75  2  AE 11 05             LDX     debcylm
008D78  2  A9 0D                LDA     #PPIDE_LBAHI
008D7A  2  20 79 8F             JSR     IDE_WRITE
008D7D  2               
008D7D  2  AE 10 05             LDX     debcyll         ;
008D80  2  A9 0C                LDA     #PPIDE_LBAMID
008D82  2  20 79 8F             JSR     IDE_WRITE
008D85  2               
008D85  2  AE 12 05             LDX     debsehd         ;
008D88  2  A9 0B                LDA     #PPIDE_LBALOW
008D8A  2  20 79 8F             JSR     IDE_WRITE
008D8D  2               
008D8D  2  A2 01                LDX     #$01
008D8F  2  A9 0A                LDA     #PPIDE_SEC_CNT
008D91  2  20 79 8F             JSR     IDE_WRITE
008D94  2               
008D94  2  60                   RTS
008D95  2               
008D95  2               ;___IDE_CONVERT_SECTOR___________________________________________________________________________________
008D95  2               ;
008D95  2               ; 	TRANSLATE SECTORS INTO IDE FORMAT
008D95  2               ;________________________________________________________________________________________________________
008D95  2               IDE_CONVERT_SECTOR:
008D95  2  AD 0C 05             LDA     sektrk          ; LOAD TRACK # (LOW BYTE)
008D98  2  29 0F                AND     #$0F            ; ISOLATE HEAD IN LOW 4 BITS
008D9A  2  0A                   ASL     a               ; MOVE TO HIGH BYTE
008D9B  2  0A                   ASL     a
008D9C  2  0A                   ASL     a
008D9D  2  0A                   ASL     a
008D9E  2  AA                   TAX                     ; PARK IN X
008D9F  2  AD 0E 05             LDA     seksec          ; LOAD SECTOR # (LOW BYTE)
008DA2  2  4A                   LSR     A               ;
008DA3  2  4A                   LSR     A               ; DIVIDE BY 4 (FOR BLOCKING)
008DA4  2  29 0F                AND     #$0F            ; CLEAR UPPER 4 BITS (JUST 'CAUSE)
008DA6  2  8D 12 05             STA     debsehd         ; STORE IN SECTOR/HEAD
008DA9  2  8A                   TXA                     ; GET HEAD BACK
008DAA  2  0D 12 05             ORA     debsehd
008DAD  2  8D 12 05             STA     debsehd         ; STORE IN SECTOR/HEAD
008DB0  2               
008DB0  2  AD 0C 05             LDA     sektrk
008DB3  2  8D 10 05             STA     debcyll         ; STORE IN TRACK (lsb)
008DB6  2  AD 0D 05             LDA     sektrk+1
008DB9  2  8D 11 05             STA     debcylm         ; STORE IN TRACK (msb)
008DBC  2               ; REMOVE HEAD FROM TRACK VALUE (DIV/4)
008DBC  2  AD 11 05             LDA     debcylm
008DBF  2  4A                   LSR     A
008DC0  2  8D 11 05             STA     debcylm
008DC3  2  AD 10 05             LDA     debcyll
008DC6  2  6A                   ROR     A
008DC7  2  8D 10 05             STA     debcyll
008DCA  2               
008DCA  2  AD 11 05             LDA     debcylm
008DCD  2  4A                   LSR     A
008DCE  2  8D 11 05             STA     debcylm
008DD1  2  AD 10 05             LDA     debcyll
008DD4  2  6A                   ROR     A
008DD5  2  8D 10 05             STA     debcyll
008DD8  2               
008DD8  2  AD 11 05             LDA     debcylm
008DDB  2  4A                   LSR     A
008DDC  2  8D 11 05             STA     debcylm
008DDF  2  AD 10 05             LDA     debcyll
008DE2  2  6A                   ROR     A
008DE3  2  8D 10 05             STA     debcyll
008DE6  2               
008DE6  2  AD 11 05             LDA     debcylm
008DE9  2  4A                   LSR     A
008DEA  2  8D 11 05             STA     debcylm
008DED  2  AD 10 05             LDA     debcyll
008DF0  2  6A                   ROR     A
008DF1  2  8D 10 05             STA     debcyll
008DF4  2               
008DF4  2               ;	ADD SLICE OFFSET
008DF4  2  AD 13 05             LDA     sekdsk          ; GET DRIVE#
008DF7  2  29 07                AND     #7              ; ONLY FIRST 8 DEVICES SUPPORTED
008DF9  2  0A                   ASL     a               ; DOUBLE NUMBER FOR TABLE LOOKUP
008DFA  2  AA                   TAX                     ; MOVE TO X REGISTER
008DFB  2  E8                   INX                     ; WANT SECOND BYTE OF ENTRY
008DFC  2  BD 14 05             LDA     dskcfg,X        ; GET SLICE#
008DFF  2  8D AE 8F             STA     slicetmp+1      ; SLICE OFFSET MSB
008E02  2  A9 00                LDA     #0              ; GET SLICE#
008E04  2  8D AD 8F             STA     slicetmp        ; SLICE OFFSET LSB
008E07  2  18                   CLC                     ; VOODOO MATH TO TAKE SLICE*$4000
008E08  2  6E AE 8F             ROR     slicetmp+1
008E0B  2  6E AD 8F             ROR     slicetmp
008E0E  2  6E AE 8F             ROR     slicetmp+1
008E11  2  6E AD 8F             ROR     slicetmp
008E14  2               
008E14  2  BD 14 05             LDA     dskcfg,X        ; GET SLICE#
008E17  2  18                   CLC
008E18  2  6D AD 8F             ADC     slicetmp
008E1B  2  8D AD 8F             STA     slicetmp
008E1E  2               ; ADD SLICE OFFSET TO TRACK #
008E1E  2  18                   CLC                     ; clear carry
008E1F  2  AD AD 8F             LDA     slicetmp
008E22  2  6D 10 05             ADC     debcyll
008E25  2  8D 10 05             STA     debcyll         ; store sum of LSBs
008E28  2  AD AE 8F             LDA     slicetmp+1
008E2B  2  6D 11 05             ADC     debcylm         ; add the MSBs using carry from
008E2E  2  8D 11 05             STA     debcylm         ; the previous calculation
008E31  2               
008E31  2               
008E31  2               
008E31  2               
008E31  2                       .IF     USEDSKY=1 || USEDSKYNG=1
008E31  2                           PRTDBG  "DSKY OUTPUT 1$"
008E31  2  AD 13 05                 LDA     sekdsk
008E34  2  8D 08 05                 STA     DSKY_HEXBUF
008E37  2  AD 11 05                 LDA     debcylm
008E3A  2  8D 09 05                 STA     DSKY_HEXBUF+1
008E3D  2  AD 10 05                 LDA     debcyll
008E40  2  8D 0A 05                 STA     DSKY_HEXBUF+2
008E43  2  AD 12 05                 LDA     debsehd
008E46  2  8D 0B 05                 STA     DSKY_HEXBUF+3
008E49  2  20 35 91                 JSR     DSKY_BIN2SEG
008E4C  2  20 6E 91                 JSR     DSKY_SHOW
008E4F  2                       .ENDIF
008E4F  2  60                   RTS
008E50  2               
008E50  2               
008E50  2               ;*__IDE_STORE_BOOT_IMAGE______________________________________________________________________________
008E50  2               ;*
008E50  2               ;*  WRITE Boot image to block 0 of device
008E50  2               ;*
008E50  2               ;*  YA points to:
008E50  2               ;* 			DB 	Device Unit
008E50  2               ;*			DB 	RAM Page
008E50  2               ;*			DW 	Source Address
008E50  2               ;* 			DB	Image Length (Pages)
008E50  2               ;*____________________________________________________________________________________________________
008E50  2               IDE_STORE_BOOT_IMAGE:
008E50  2               
008E50  2  85 14                STA     pointr          ; SET POINTR TO INFO BLOCK
008E52  2  84 15                STY     pointr+1
008E54  2  A9 58                LDA     #<BOOTUNIT
008E56  2  85 2A                STA     room
008E58  2  A9 8F                LDA     #>BOOTUNIT
008E5A  2  85 2B                STA     room+1
008E5C  2  A0 00                LDY     #$00            ; COPY PARAMETERS TO USEFUL AREA
008E5E  2               :
008E5E  2  B1 14                LDA     (pointr),Y
008E60  2  91 2A                STA     (room),Y
008E62  2  C8                   INY
008E63  2  C0 05                CPY     #05
008E65  2  D0 F7                BNE     :-
008E67  2               
008E67  2  A9 00                LDA     #$00
008E69  2  8D 11 05             STA     debcylm
008E6C  2  8D 10 05             STA     debcyll         ;
008E6F  2  8D 12 05             STA     debsehd         ;
008E72  2               
008E72  2  20 7E 94             JSR     INIT_PAGE_COPY  ; COPY PAGE COPY CODE TO LORAM
008E75  2  AD 5A 8F             LDA     BOOTSOURCE      ; SETUP SOURCE POINTER
008E78  2  85 14                STA     pointr
008E7A  2  AD 5B 8F             LDA     BOOTSOURCE+1
008E7D  2  85 15                STA     pointr+1
008E7F  2               
008E7F  2               :
008E7F  2  AD 59 8F             LDA     BOOTRAMPAGE
008E82  2  20 00 04             JSR     COPY_PAGE_TO_HSTBUF; COPY 512 BYTES AT POINTR TO HSTBUF (AND INC POINTER)
008E85  2  20 99 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008E88  2  AD 58 8F             LDA     BOOTUNIT
008E8B  2  20 46 8C             JSR     IDE_WRITE_SECTOR_RAW
008E8E  2  C9 FF                CMP     #$FF
008E90  2  F0 10                BEQ     IDE_STORE_BOOT_IMAGE_ERROR
008E92  2  EE 12 05             INC     debsehd
008E95  2  CE 5C 8F             DEC     BOOTLENGTH
008E98  2  AD 5C 8F             LDA     BOOTLENGTH
008E9B  2  C9 00                CMP     #$00
008E9D  2  D0 E0                BNE     :-
008E9F  2  A9 00                LDA     #$00            ; ZERO ON RETURN = OPERATION OK
008EA1  2  60                   RTS
008EA2  2               IDE_STORE_BOOT_IMAGE_ERROR:
008EA2  2  A9 FF                LDA     #$FF            ; 1 ON RETURN = OPERATION FAIL
008EA4  2  60                   RTS
008EA5  2               
008EA5  2               ;*__IDE_RESTORE_BOOT_IMAGE____________________________________________________________________________
008EA5  2               ;*
008EA5  2               ;*  READ Boot image from block 0 of device
008EA5  2               ;*
008EA5  2               ;*  YA points to:
008EA5  2               ;* 			DB 	Device Unit
008EA5  2               ;*			DB 	RAM Page
008EA5  2               ;*			DW 	Source Address
008EA5  2               ;* 			DB	Image Length (Pages)
008EA5  2               ;*____________________________________________________________________________________________________
008EA5  2               IDE_RESTORE_BOOT_IMAGE:
008EA5  2               
008EA5  2  85 14                STA     pointr          ; SET POINTR TO INFO BLOCK
008EA7  2  84 15                STY     pointr+1
008EA9  2  A9 58                LDA     #<BOOTUNIT
008EAB  2  85 2A                STA     room
008EAD  2  A9 8F                LDA     #>BOOTUNIT
008EAF  2  85 2B                STA     room+1
008EB1  2  A0 00                LDY     #$00            ; COPY PARAMETERS TO USEFUL AREA
008EB3  2               :
008EB3  2  B1 14                LDA     (pointr),Y
008EB5  2  91 2A                STA     (room),Y
008EB7  2  C8                   INY
008EB8  2  C0 05                CPY     #05
008EBA  2  D0 F7                BNE     :-
008EBC  2               
008EBC  2  A9 00                LDA     #$00
008EBE  2  8D 11 05             STA     debcylm
008EC1  2  8D 10 05             STA     debcyll         ;
008EC4  2  8D 12 05             STA     debsehd         ;
008EC7  2               
008EC7  2  20 7E 94             JSR     INIT_PAGE_COPY  ; COPY PAGE COPY CODE TO LORAM
008ECA  2  AD 5A 8F             LDA     BOOTSOURCE      ; SETUP SOURCE POINTER
008ECD  2  85 14                STA     pointr
008ECF  2  AD 5B 8F             LDA     BOOTSOURCE+1
008ED2  2  85 15                STA     pointr+1
008ED4  2               
008ED4  2               :
008ED4  2  20 99 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008ED7  2  AD 58 8F             LDA     BOOTUNIT
008EDA  2  20 0E 8C             JSR     IDE_READ_SECTOR_DIRTY1
008EDD  2  C9 FF                CMP     #$FF
008EDF  2  F0 16                BEQ     IDE_RESTORE_BOOT_IMAGE_ERROR
008EE1  2  AD 59 8F             LDA     BOOTRAMPAGE
008EE4  2  20 2D 04             JSR     COPY_HSTBUF_TOPAGE; COPY 512 BYTES FROM HSTBUF TO POINTR HSTBUF (AND INC POINTER)
008EE7  2  EE 12 05             INC     debsehd
008EEA  2  CE 5C 8F             DEC     BOOTLENGTH
008EED  2  AD 5C 8F             LDA     BOOTLENGTH
008EF0  2  C9 00                CMP     #$00
008EF2  2  D0 E0                BNE     :-
008EF4  2  A9 00                LDA     #$00            ; ZERO ON RETURN = OPERATION OK
008EF6  2  60                   RTS
008EF7  2               IDE_RESTORE_BOOT_IMAGE_ERROR:
008EF7  2  A9 FF                LDA     #$FF            ; 1 ON RETURN = OPERATION FAIL
008EF9  2  60                   RTS
008EFA  2               
008EFA  2               
008EFA  2               ;*__IDE_CLEAR_TRACKS__________________________________________________________________________________
008EFA  2               ;*
008EFA  2               ;*  CLEAR IDE TRACKS
008EFA  2               ;*
008EFA  2               ;*  YA points to:
008EFA  2               ;* 			DB 	Device Unit
008EFA  2               ;*			DW 	START TRACK
008EFA  2               ;*			DB 	NUMBER of TRACKS
008EFA  2               ;*____________________________________________________________________________________________________
008EFA  2               IDE_CLEAR_TRACKS:
008EFA  2  85 14                STA     pointr          ; SET POINTR TO INFO BLOCK
008EFC  2  84 15                STY     pointr+1
008EFE  2  A0 00                LDY     #$00
008F00  2  B1 14                LDA     (pointr),Y
008F02  2  8D 58 8F             STA     BOOTUNIT
008F05  2  C8                   INY
008F06  2  B1 14                LDA     (pointr),Y
008F08  2  8D 10 05             STA     debcyll         ;
008F0B  2  C8                   INY
008F0C  2  B1 14                LDA     (pointr),Y
008F0E  2  8D 11 05             STA     debcylm         ;
008F11  2  C8                   INY
008F12  2  B1 14                LDA     (pointr),Y
008F14  2  85 06                STA     nmsstr          ;
008F16  2               
008F16  2  20 48 8F             JSR     clear_hstbuf
008F19  2               
008F19  2  A9 00                LDA     #$00
008F1B  2  8D 12 05             STA     debsehd         ;
008F1E  2  AA                   TAX
008F1F  2               :
008F1F  2  20 99 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008F22  2  AD 58 8F             LDA     BOOTUNIT
008F25  2  20 46 8C             JSR     IDE_WRITE_SECTOR_RAW
008F28  2  EE 12 05             INC     debsehd
008F2B  2  AD 12 05             LDA     debsehd
008F2E  2  C9 00                CMP     #$00
008F30  2  D0 ED                BNE     :-
008F32  2  EE 10 05             INC     debcyll
008F35  2  AD 10 05             LDA     debcyll
008F38  2  C9 00                CMP     #$00
008F3A  2  D0 03                BNE     :+
008F3C  2  EE 11 05             INC     debcylm
008F3F  2               :
008F3F  2  C6 06                DEC     nmsstr
008F41  2  A5 06                LDA     nmsstr
008F43  2  C9 00                CMP     #$00
008F45  2  D0 D8                BNE     :--
008F47  2  60                   RTS
008F48  2               
008F48  2               clear_hstbuf:
008F48  2  A2 00                LDX     #$00
008F4A  2               :
008F4A  2  A9 E5                LDA     #$e5
008F4C  2  9D E6 94             STA     hstbuf,x
008F4F  2  9D E6 95             STA     hstbuf+$100,x
008F52  2  E8                   INX
008F53  2  E0 00                CPX     #$00
008F55  2  D0 F3                BNE     :-
008F57  2  60                   RTS
008F58  2               
008F58  2               BOOTUNIT:
008F58  2  00                   .BYTE   00
008F59  2               BOOTRAMPAGE:
008F59  2  00                   .BYTE   00
008F5A  2               BOOTSOURCE:
008F5A  2  00 00                .BYTE   00,00
008F5C  2               BOOTLENGTH:
008F5C  2  00                   .BYTE   00
008F5D  2               
008F5D  2               
008F5D  2               ;-------------------------------------------------------------------------------
008F5D  2               
008F5D  2               ; LOW LEVEL I/O TO THE DRIVE.  THESE ARE THE ROUTINES THAT TALK
008F5D  2               ; DIRECTLY TO THE DRIVE, VIA THE 8255 CHIP.  NORMALLY A MAIN
008F5D  2               ; PROGRAM WOULD NOT CALL TO THESE.
008F5D  2               
008F5D  2               ;DO A READ BUS CYCLE TO THE DRIVE, USING THE 8255.
008F5D  2               ;INPUT A = IDE REGSITER ADDRESS
008F5D  2               ;OUTPUT X = LOWER BYTE READ FROM IDE DRIVE
008F5D  2               ;OUTPUT Y = UPPER BYTE READ FROM IDE DRIVE
008F5D  2               
008F5D  2               IDE_READ:
008F5D  2  20 95 8F             JSR     SET_PPI_RD      ; SETUP FOR A READ CYCLE
008F60  2  8D 62 03             STA     PPIDECNTRL      ;DRIVE ADDRESS ONTO CONTROL LINES
008F63  2  09 40                ORA     #PPIDE_RD_LINE  ; ASSERT RD PIN
008F65  2  8D 62 03             STA     PPIDECNTRL
008F68  2  AE 60 03             LDX     PPIDELO         ; READ LOWER BYTE
008F6B  2  AC 61 03             LDY     PPIDEHI         ; READ UPPER BYTE
008F6E  2  49 40                EOR     #PPIDE_RD_LINE  ; DE-ASSERT RD SIGNAL
008F70  2  8D 62 03             STA     PPIDECNTRL
008F73  2  A9 00                LDA     #$00
008F75  2  8D 62 03             STA     PPIDECNTRL      ;DEASSERT ALL CONTROL PINS
008F78  2  60                   RTS
008F79  2               
008F79  2               
008F79  2               
008F79  2               
008F79  2               ;DO A WRITE BUS CYCLE TO THE DRIVE, VIA THE 8255
008F79  2               ;INPUT A = IDE REGISTER ADDRESS
008F79  2               ;INPUT REGISTER X = LSB TO WRITE
008F79  2               ;INPUT REGISTER Y = MSB TO WRITE
008F79  2               ;
008F79  2               
008F79  2               
008F79  2               IDE_WRITE:
008F79  2  20 9D 8F             JSR     SET_PPI_WR      ; SETUP FOR A WRITE CYCLE
008F7C  2               
008F7C  2  8E 60 03             STX     PPIDELO         ; WRITE LOWER BYTE
008F7F  2  8C 61 03             STY     PPIDEHI         ; WRITE UPPER BYTE
008F82  2               
008F82  2  8D 62 03             STA     PPIDECNTRL      ;DRIVE ADDRESS ONTO CONTROL LINES
008F85  2               
008F85  2  09 20                ORA     #PPIDE_WR_LINE  ; ASSERT WRITE PIN
008F87  2  8D 62 03             STA     PPIDECNTRL
008F8A  2               
008F8A  2  49 20                EOR     #PPIDE_WR_LINE  ; DE ASSERT WR PIN
008F8C  2  8D 62 03             STA     PPIDECNTRL
008F8F  2               
008F8F  2  A9 00                LDA     #$00
008F91  2  8D 62 03             STA     PPIDECNTRL      ;DEASSERT ALL CONTROL PINS
008F94  2  60                   RTS
008F95  2               
008F95  2               
008F95  2               ;-----------------------------------------------------------------------------------
008F95  2               ; PPI SETUP ROUTINE TO CONFIGURE THE APPROPRIATE PPI MODE
008F95  2               ;
008F95  2               ;------------------------------------------------------------------------------------
008F95  2               
008F95  2               SET_PPI_RD:
008F95  2  48                   PHA
008F96  2  A9 92                LDA     #PPRD_IDE_8255
008F98  2  8D 63 03             STA     PPIDEPPIC       ;CONFIG 8255 CHIP, READ MODE
008F9B  2  68                   PLA
008F9C  2  60                   RTS
008F9D  2               
008F9D  2               SET_PPI_WR:
008F9D  2  48                   PHA
008F9E  2  A9 80                LDA     #PPWR_IDE_8255
008FA0  2  8D 63 03             STA     PPIDEPPIC       ;CONFIG 8255 CHIP, WRITE MODE
008FA3  2  68                   PLA
008FA4  2  60                   RTS
008FA5  2               
008FA5  2               
008FA5  2               ;allocate the following data areas to unused ram space
008FA5  2               LASTCHAR:
008FA5  2  00                   .BYTE   0               ;save sector for warm boot
008FA6  2               savsec:
008FA6  2  00                   .BYTE   0               ;save sector for warm boot
008FA7  2               count:
008FA7  2  00                   .BYTE   0               ;counter in warm boot
008FA8  2               temp:
008FA8  2  00                   .BYTE   0               ;save hstdsk for warm boot
008FA9  2               Cdebcyll:
008FA9  2  00                   .BYTE   0               ; DEBLOCKED CYLINDER LSB
008FAA  2               Cdebcylm:
008FAA  2  00                   .BYTE   0               ; DEBLOCKED CYLINDER MSB
008FAB  2               Cdebsehd:
008FAB  2  00                   .BYTE   0               ; DEBLOCKED SECTOR AND HEAD (HS)
008FAC  2               DEBDIRTY:
008FAC  2  00                   .BYTE   0               ; DIRTY FLAG
008FAD  2               slicetmp:
008FAD  2  00 00                .WORD   0               ; USED TO CALCULATE SLICE OFFSET
008FAF  2               
008FAF  1                       .INCLUDE "dosdskyn.asm"
008FAF  2               ;__DSKYNG DRIVERS_________________________________________________________________________________________________________________
008FAF  2               ;
008FAF  2               ; 	Nhyodyne DSKY/NG drivers
008FAF  2               ;
008FAF  2               ;	Entry points:
008FAF  2               ;               DSKY_INIT
008FAF  2               ;               DSKY_SHOW
008FAF  2               ;               DSKY_BIN2SEG
008FAF  2               ;               DSKY_RESET
008FAF  2               ;               DSKY_STAT
008FAF  2               ;               DSKY_GETKEY
008FAF  2               ;               DSKY_BEEP
008FAF  2               ;               DSKY_L1ON
008FAF  2               ;               DSKY_L2ON
008FAF  2               ;               DSKY_L1OFF
008FAF  2               ;               DSKY_L2OFF
008FAF  2               ;               DSKY_PUTLED
008FAF  2               ;               DSKY_BLANK
008FAF  2               ;________________________________________________________________________________________________________________________________
008FAF  2               ;
008FAF  2               ;
008FAF  2               ; A DSKYNG CAN SHARE A PPI BUS WITH EITHER A PPIDE OR PPISD.
008FAF  2               ;
008FAF  2               ; LED SEGMENTS (BIT VALUES)
008FAF  2               ;
008FAF  2               ;	+--01--+
008FAF  2               ;	20    02
008FAF  2               ;	+--40--+
008FAF  2               ;	10    04
008FAF  2               ;	+--08--+  80
008FAF  2               ;
008FAF  2               ; KEY CODE MAP (KEY CODES) CSCCCRRR
008FAF  2               ;                          ||||||||
008FAF  2               ;                          |||||+++-- ROW
008FAF  2               ;                          ||+++----- COL
008FAF  2               ;                          |+-------- SHIFT
008FAF  2               ;                          +--------- CONTROL
008FAF  2               ;
008FAF  2               ;	00	08	10	18	23
008FAF  2               ;	01	09	11	19	22
008FAF  2               ;	02	0A	12	1A	21
008FAF  2               ;	03	0B	13	1B	20
008FAF  2               ;	04	0C	14	1C	SHIFT
008FAF  2               ;	05	0D	15	1D	CTRL
008FAF  2               ;
008FAF  2               ; LED BIT MAP (BIT VALUES)
008FAF  2               ;
008FAF  2               ;	$08	$09	$0A	$0B	$0C	$0D	$0E	$0F
008FAF  2               ;	---	---	---	---	---	---	---	---
008FAF  2               ;	01	01	01	01	01
008FAF  2               ;	02	02	02	02	02
008FAF  2               ;	04      04      04      04	04
008FAF  2               ;	08      08      08      08	08
008FAF  2               ;	10      10      10      10	10
008FAF  2               ;	20      20      20      20	20	L1	L2 	BUZZ
008FAF  2               ;
008FAF  2               DSKY_PPI        = $0360         ; PORT
008FAF  2               DSKY_PPIA       = DSKY_PPI + 0  ; PORT A
008FAF  2               DSKY_PPIB       = DSKY_PPI + 1  ; PORT B
008FAF  2               DSKY_PPIC       = DSKY_PPI + 2  ; PORT C
008FAF  2               DSKY_PPIX       = DSKY_PPI + 3  ; PPI CONTROL PORT
008FAF  2               ;
008FAF  2               DSKY_PPIX_RD    = %10010010     ; PPIX VALUE FOR READS
008FAF  2               DSKY_PPIX_WR    = %10000010     ; PPIX VALUE FOR WRITES
008FAF  2               ;
008FAF  2               ; PIO CHANNEL C:
008FAF  2               ;
008FAF  2               ;	7	6	5	4	3	2	1	0
008FAF  2               ;	RES	0	0	CS	CS	/RD	/WR	A0
008FAF  2               ;
008FAF  2               ; SETTING BITS 3 & 4 WILL ASSERT /CS ON 3279
008FAF  2               ; CLEAR BITS 1 OR 2 TO ASSERT READ/WRITE
008FAF  2               ;
008FAF  2               DSKY_PPI_IDLE   = %00000110
008FAF  2               ;
008FAF  2               DSKY_CMD_CLR    = %11011111     ; CLEAR (ALL OFF)
008FAF  2               DSKY_CMD_CLRX   = %11010011     ; CLEAR (ALL ON)
008FAF  2               DSKY_CMD_WDSP   = %10010000     ; WRITE DISPLAY RAM
008FAF  2               DSKY_CMD_RDSP   = %01110000     ; READ DISPLAY RAM
008FAF  2               DSKY_CMD_CLK    = %00100000     ; SET CLK PRESCALE
008FAF  2               DSKY_CMD_FIFO   = %01000000     ; READ FIFO
008FAF  2               ;
008FAF  2               DSKY_PRESCL     = DSKYOSC/100000; PRESCALER
008FAF  2               ;
008FAF  2               ;__DSKY_INIT_________________________________________________________________________________________
008FAF  2               ;
008FAF  2               ;  DISPLAY DSKY INFO
008FAF  2               ;____________________________________________________________________________________________________
008FAF  2               ;
008FAF  2               DSKY_INIT:
008FAF  2                       PRTDBG  "DSKY INIT:$"
008FAF  2  20 7F 90             JSR     DSKY_PREINIT
008FB2  2  48 8A 48 A8          PRTS    "DSKY:$"
008FB6  2  48 A2 00 BD  
008FBA  2  CF 8F E8 C9  
008FD5  2  20 83 88             JSR     NEWLINE
008FD8  2               
008FD8  2               ;
008FD8  2  48 8A 48 A8          PRTS    " IO=0x$"
008FDC  2  48 A2 00 BD  
008FE0  2  F5 8F E8 C9  
008FFC  2  A9 03                LDA     #>DSKY_PPI      ; GET BASE PORT
008FFE  2  20 59 88             JSR     PRTHEXBYTE      ; PRINT BASE PORT
009001  2  A9 60                LDA     #<DSKY_PPI      ; GET BASE PORT
009003  2  20 59 88             JSR     PRTHEXBYTE      ; PRINT BASE PORT
009006  2  48 8A 48 A8          PRTS    " MODE=$"
00900A  2  48 A2 00 BD  
00900E  2  23 90 E8 C9  
00902A  2  48 8A 48 A8          PRTS    "NG$"           ; PRINT DSKY TYPE
00902E  2  48 A2 00 BD  
009032  2  47 90 E8 C9  
00904A  2               ;
00904A  2  AD 18 93             LDA     DSKY_PRESENT    ; PRESENT?
00904D  2  C9 FF                CMP     #$FF            ; SET FLAGS
00904F  2  F0 2A                BEQ     DSKY_INITA
009051  2  48 8A 48 A8          PRTS    " NOT PRESENT$" ; NOT PRESENT
009055  2  48 A2 00 BD  
009059  2  6E 90 E8 C9  
00907B  2               DSKY_INITA:
00907B  2  20 83 88             JSR     NEWLINE
00907E  2  60                   RTS                     ; DONE
00907F  2               ;
00907F  2               ;__DSKY_PREINIT______________________________________________________________________________________
00907F  2               ;
00907F  2               ;  CONFIGURE PARALLEL PORT AND INITIALIZE 8279
00907F  2               ;____________________________________________________________________________________________________
00907F  2               ; HARDWARE RESET 8279 BY PULSING RESET LINE
00907F  2               DSKY_PREINIT:
00907F  2               ; CHECK FOR PPI
00907F  2  20 C4 90             JSR     DSKY_PPIDETECT  ; TEST FOR PPI HARDWARE
009082  2  D0 2A                BNE     DSKY_ABORT      ; BAIL OUT IF NOT THERE
009084  2               
009084  2               ; SETUP PPI TO DEFAULT MODE
009084  2  20 F1 92             JSR     DSKY_PPIRD
009087  2               ; INIT 8279 VALUES TO IDLE STATE
009087  2  A9 06                LDA     #DSKY_PPI_IDLE
009089  2  8D 62 03             STA     DSKY_PPIC
00908C  2               ; PULSE RESET SIGNAL ON 8279
00908C  2  09 80                ORA     #%10000000
00908E  2  8D 62 03             STA     DSKY_PPIC
009091  2  29 7F                AND     #%01111111
009093  2  8D 62 03             STA     DSKY_PPIC
009096  2               ; INITIALIZE 8279
009096  2  20 AF 90             JSR     DSKY_REINIT
009099  2               ; NOW SEE IF A DSKYNG IS REALLY THERE...
009099  2  A9 A5                LDA     #$A5
00909B  2  A0 00                LDY     #$00
00909D  2  20 0A 92             JSR     DSKY_PUTBYTE
0090A0  2  A0 00                LDY     #$00
0090A2  2  20 24 92             JSR     DSKY_GETBYTE
0090A5  2  C9 A5                CMP     #$A5
0090A7  2  D0 05                BNE     DSKY_ABORT      ; BAIL OUT IF MISCOMPARE
0090A9  2  A9 FF                LDA     #$FF
0090AB  2  8D 18 93             STA     DSKY_PRESENT
0090AE  2               DSKY_ABORT:
0090AE  2  60                   RTS
0090AF  2               ;
0090AF  2               DSKY_REINIT:
0090AF  2  20 03 93             JSR     DSKY_PPIIDLE
0090B2  2               ; SET CLOCK SCALER TO 20
0090B2  2  A9 2A                LDA     #DSKY_CMD_CLK | DSKY_PRESCL
0090B4  2  20 8A 91             JSR     DSKY_CMD
0090B7  2               ; FALL THRU
0090B7  2               ;
0090B7  2               DSKY_RESET:
0090B7  2               ; RESET DSKY -- CLEAR RAM AND FIFO
0090B7  2  A9 DF                LDA     #DSKY_CMD_CLR
0090B9  2  20 8A 91             JSR     DSKY_CMD
0090BC  2               ;
0090BC  2               ; 8259 TAKES ~160US TO CLEAR RAM DURING WHICH TIME WRITES TO
0090BC  2               ; DISPLAY RAM ARE INHIBITED.  HIGH BIT OF STATUS BYTE IS SET
0090BC  2               ; DURING THIS WINDOW.  TO PREVENT A DEADLOCK, A LOOP COUNTER
0090BC  2               ; IS USED TO IMPLEMENT A TIMEOUT.
0090BC  2  A2 00                LDX     #0              ; TIMEOUT LOOP COUNTER
0090BE  2               DSKY_RESET1:
0090BE  2  48                   PHA                     ; SAVE COUNTER
0090BF  2  68                   PLA                     ; RECOVER COUNTER
0090C0  2  CA                   DEX
0090C1  2  D0 FB                BNE     DSKY_RESET1     ; LOOP TILL TIMEOUT
0090C3  2               ;
0090C3  2               DSKY_RESET2:
0090C3  2  60                   RTS
0090C4  2               ;
0090C4  2               ;
0090C4  2               ;
0090C4  2               ;__DSKY_PPIDETECT____________________________________________________________________________________
0090C4  2               ;
0090C4  2               ;  PROBE FOR PPI HARDWARE
0090C4  2               ;____________________________________________________________________________________________________
0090C4  2               ;
0090C4  2               DSKY_PPIDETECT:
0090C4  2               ;
0090C4  2               ; TEST FOR PPI EXISTENCE
0090C4  2               ; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
0090C4  2               ; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
0090C4  2               ; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
0090C4  2               ; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
0090C4  2               ; INTERFERE WITH THE VALUE BEING READ.
0090C4  2  20 DA 92             JSR     DSKY_PPIWR
0090C7  2               ;
0090C7  2  A9 00                LDA     #$00            ; VALUE ZERO
0090C9  2  8D 60 03             STA     DSKY_PPIA       ; PUSH VALUE TO PORT
0090CC  2  AD 60 03             LDA     DSKY_PPIA       ; GET PORT VALUE
0090CF  2  C9 00                CMP     #$00
0090D1  2  60                   RTS                     ; AND RETURN
0090D2  2               ;
0090D2  2                       .IF     DSKY_KBD=1
0090D2  2               ;
0090D2  2               KY_0                = $00
0090D2  2               KY_1                = $01
0090D2  2               KY_2                = $02
0090D2  2               KY_3                = $03
0090D2  2               KY_4                = $04
0090D2  2               KY_5                = $05
0090D2  2               KY_6                = $06
0090D2  2               KY_7                = $07
0090D2  2               KY_8                = $08
0090D2  2               KY_9                = $09
0090D2  2               KY_A                = $0A
0090D2  2               KY_B                = $0B
0090D2  2               KY_C                = $0C
0090D2  2               KY_D                = $0D
0090D2  2               KY_E                = $0E
0090D2  2               KY_F                = $0F
0090D2  2               KY_FW               = $10           ; FORWARD
0090D2  2               KY_BK               = $11           ; BACKWARD
0090D2  2               KY_CL               = $12           ; CLEAR
0090D2  2               KY_EN               = $13           ; ENTER
0090D2  2               KY_DE               = $14           ; DEPOSIT
0090D2  2               KY_EX               = $15           ; EXAMINE
0090D2  2               KY_GO               = $16           ; GO
0090D2  2               KY_BO               = $17           ; BOOT
0090D2  2               KY_F4               = $18           ; F4
0090D2  2               KY_F3               = $19           ; F3
0090D2  2               KY_F2               = $20           ; F2
0090D2  2               KY_F1               = $21           ; F1
0090D2  2               ;
0090D2  2               ;__DSKY_STAT_________________________________________________________________________________________
0090D2  2               ;
0090D2  2               ;  CHECK FOR KEY PRESS, SAVE RAW VALUE, RETURN STATUS
0090D2  2               ;____________________________________________________________________________________________________
0090D2  2               ;
0090D2  2               DSKY_STAT:
0090D2  2  AD 18 93                 LDA     DSKY_PRESENT    ; DOES IT EXIST?
0090D5  2  C9 FF                    CMP     #$FF            ; SET FLAGS
0090D7  2  D0 05                    BNE     DSKY_STATA      ; ABORT WITH A=0 IF NOT THERE
0090D9  2  20 C3 91                 JSR     DSKY_ST
0090DC  2  29 0F                    AND     #$0F            ; ISOLATE THE CUR FIFO LEN
0090DE  2               DSKY_STATA:
0090DE  2  60                       RTS
0090DF  2               ;
0090DF  2               ;__DSKY_GETKEY_____________________________________________________________________________________
0090DF  2               ;
0090DF  2               ;  WAIT FOR A DSKY KEYPRESS AND RETURN
0090DF  2               ;____________________________________________________________________________________________________
0090DF  2               ;
0090DF  2               DSKY_GETKEY:
0090DF  2  AD 18 93                 LDA     DSKY_PRESENT    ; DOES IT EXIST?
0090E2  2  C9 FF                    CMP     #$FF            ; SET FLAGS
0090E4  2  D0 24                    BNE     DSKY_GETKEY1A   ; ABORT WITH A=0 IF NOT THERE
0090E6  2  20 D2 90                 JSR     DSKY_STAT
0090E9  2  F0 F4                    BEQ     DSKY_GETKEY     ; LOOP IF NOTHING THERE
0090EB  2  A9 40                    LDA     #DSKY_CMD_FIFO
0090ED  2  20 8A 91                 JSR     DSKY_CMD
0090F0  2  20 C8 91                 JSR     DSKY_DIN
0090F3  2  49 C0                    EOR     #%11000000      ; FLIP POLARITY OF SHIFT/CTL BITS
0090F5  2  48                       PHA
0090F6  2  29 3F                    AND     #$3F            ; STRIP SHIFT/CTL BITS FOR LOOKUP
0090F8  2  8D 16 93                 STA     DSKY_TEMP_VAL
0090FB  2  A2 00                    LDX     #0              ; INDEX
0090FD  2               DSKY_GETKEY1:
0090FD  2  BD 19 91                 LDA     DSKY_KEYMAP,X
009100  2  CD 16 93                 CMP     DSKY_TEMP_VAL   ; MATCH?
009103  2  F0 09                    BEQ     DSKY_GETKEY2    ; FOUND, DONE
009105  2  E8                       INX
009106  2  E0 1C                    CPX     #28
009108  2  D0 F3                    BNE     DSKY_GETKEY1    ; LOOP UNTIL EOT
00910A  2               DSKY_GETKEY1A:
00910A  2  68                       PLA
00910B  2  A9 FF                    LDA     #$FF            ; NOT FOUND ERR, RETURN $FF
00910D  2  60                       RTS
00910E  2               DSKY_GETKEY2:
00910E  2               ; RETURN THE INDEX POSITION WHERE THE SCAN CODE WAS FOUND
00910E  2               ; THE ORIGINAL SHIFT/CTRL BITS ARE RESTORED
00910E  2  68                       PLA                     ; RESTORE RAW VALUE
00910F  2  25 C0                    AND     %11000000       ; ISOLATE SHIFT/CTRL BITS
009111  2  8D 16 93                 STA     DSKY_TEMP_VAL
009114  2  8A                       TXA
009115  2  0D 16 93                 ORA     DSKY_TEMP_VAL   ; COMBINE WITH INDEX VALUE
009118  2  60                       RTS
009119  2               ;
009119  2               ;_KEYMAP_TABLE_____________________________________________________________________________________________________________
009119  2               ;
009119  2               DSKY_KEYMAP:
009119  2               ; POS	$00  $01  $02  $03  $04  $05  $06  $07
009119  2               ; KEY   [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]
009119  2  0D 04 0C 14              .BYTE   $0D, $04, $0C, $14, $03, $0B, $13, $02
00911D  2  03 0B 13 02  
009121  2               ;
009121  2               ; POS	$08  $09  $0A  $0B  $0C  $0D  $0E  $0F
009121  2               ; KEY   [8]  [9]  [A]  [B]  [C]  [D]  [E]  [F]
009121  2  0A 12 01 09              .BYTE   $0A, $12, $01, $09, $11, $00, $08, $10
009125  2  11 00 08 10  
009129  2               ;
009129  2               ; POS	$10  $11  $12  $13  $14  $15  $16  $17
009129  2               ; KEY   [FW] [BK] [CL] [EN] [DE] [EX] [GO] [BO]
009129  2  05 15 1D 1C              .BYTE   $05, $15, $1D, $1C, $1B, $1A, $19, $18
00912D  2  1B 1A 19 18  
009131  2               
009131  2               ; POS	$18  $19  $20  $21
009131  2               ; KEY   [F4] [F3] [F2] [F1]
009131  2  23 22 21 20              .BYTE   $23, $22, $21, $20
009135  2               
009135  2               ;
009135  2                       .ENDIF                  ; DSKY_KBD
009135  2               ;
009135  2               ;__DSKY_BIN2SEG________________________________________________________________________________________
009135  2               ;
009135  2               ; CONVERT 32 BIT BINARY TO 8 BYTE HEX SEGMENT DISPLAY
009135  2               ;
009135  2               ; DSKY_BUF: 32 BIT BINARY
009135  2               ; DSKY_HEXBUF: DEST LED SEGMENT DISPLAY BUFFER (8 BYTES)
009135  2               ;____________________________________________________________________________________________________
009135  2               ;
009135  2               DSKY_BIN2SEG:
009135  2  A2 00                LDX     #$00
009137  2               DSKY_BIN2SEG1:
009137  2  BD 08 05             LDA     DSKY_HEXBUF,X   ; FIRST NIBBLE
00913A  2  4A                   LSR     A
00913B  2  4A                   LSR     A
00913C  2  4A                   LSR     A
00913D  2  4A                   LSR     A
00913E  2  86 3A                STX     STACKA          ; STORE READ INDEX
009140  2  AA                   TAX                     ; MOVE DIGIT TO LOOKUP INDEX
009141  2  BD 06 93             LDA     DSKY_HEXMAP,X   ; GET DECODED DIGIT INTO A
009144  2  A6 3A                LDX     STACKA          ; GET READ INDEX
009146  2  48                   PHA
009147  2  8A                   TXA
009148  2  0A                   ASL     a
009149  2  AA                   TAX
00914A  2  68                   PLA
00914B  2  9D 00 05             STA     DSKY_BUF,X      ;STORE HIGH BYTE IN OUT BUFFER
00914E  2  A6 3A                LDX     STACKA          ; GET READ INDEX
009150  2  BD 08 05             LDA     DSKY_HEXBUF,X   ; SECOND NIBBLE
009153  2               
009153  2  29 0F                AND     #$0F
009155  2  86 3A                STX     STACKA          ; STORE READ INDEX
009157  2  AA                   TAX
009158  2  BD 06 93             LDA     DSKY_HEXMAP,X   ; GET DECODED DIGIT INTO A
00915B  2  A6 3A                LDX     STACKA          ; GET READ INDEX
00915D  2  48                   PHA
00915E  2  8A                   TXA                     ; GET READ INDEX
00915F  2  0A                   ASL     a
009160  2  AA                   TAX
009161  2  E8                   INX
009162  2  68                   PLA
009163  2  9D 00 05             STA     DSKY_BUF,X      ;STORE HIGH BYTE IN OUT BUFFER
009166  2  A6 3A                LDX     STACKA          ; GET READ INDEX
009168  2  E8                   INX
009169  2  E0 04                CPX     #4
00916B  2  D0 CA                BNE     DSKY_BIN2SEG1
00916D  2  60                   RTS
00916E  2               ;
00916E  2               ;__DSKY_SHOW___________________________________________________________________________________________
00916E  2               ; DSKY SHOW BUFFER
00916E  2               ;______________________________________________________________________________________________________
00916E  2               ;
00916E  2               DSKY_SHOW:
00916E  2  48                   PHA
00916F  2  8A                   TXA
009170  2  48                   PHA
009171  2  98                   TYA
009172  2  48                   PHA
009173  2  A2 00                LDX     #0
009175  2               DSKY_SHOW1:
009175  2  BD 00 05             LDA     DSKY_BUF,X
009178  2  86 3A                STX     STACKA
00917A  2  A4 3A                LDY     STACKA
00917C  2  20 0A 92             JSR     DSKY_PUTBYTE
00917F  2  E8                   INX
009180  2  E0 08                CPX     #8
009182  2  D0 F1                BNE     DSKY_SHOW1
009184  2  68                   PLA
009185  2  A8                   TAY
009186  2  68                   PLA
009187  2  AA                   TAX
009188  2  68                   PLA
009189  2  60                   RTS
00918A  2               
00918A  2               ;______________________________________________________________________________________________________
00918A  2               ; DSKYNG OUTPUT ROUTINES
00918A  2               ;______________________________________________________________________________________________________
00918A  2               
00918A  2               ; SEND DSKY COMMAND BYTE IN REGISTER A
00918A  2               DSKY_CMD:
00918A  2  48                   PHA
00918B  2  A9 01                LDA     #$01
00918D  2  4C 93 91             JMP     DSKY_DOUT2
009190  2               ;
009190  2               ; SEND DSKY DATA BYTE IN REGISTER A
009190  2               ; TRASHES BC
009190  2               ;
009190  2               DSKY_DOUT:
009190  2  48                   PHA
009191  2  A9 00                LDA     #$00
009193  2               ;
009193  2               DSKY_DOUT2:
009193  2               ; SET PPI LINE CONFIG TO WRITE MODE
009193  2  20 DA 92             JSR     DSKY_PPIWR
009196  2               ;
009196  2               ; SET ADDRESS FIRST
009196  2  09 06                ORA     #DSKY_PPI_IDLE
009198  2  8D 62 03             STA     DSKY_PPIC
00919B  2               ;
00919B  2               ; ASSERT 8279 /CS
00919B  2  09 18                ORA     #%00011000
00919D  2  8D 62 03             STA     DSKY_PPIC
0091A0  2               ;
0091A0  2               ; PPIC WORKING VALUE TO DSKY_TEMP_VAL
0091A0  2  8D 16 93             STA     DSKY_TEMP_VAL
0091A3  2               ;
0091A3  2               ; ASSERT DATA BYTE VALUE
0091A3  2  68                   PLA
0091A4  2  8D 60 03             STA     DSKY_PPIA
0091A7  2               ;
0091A7  2               ; PULSE /WR
0091A7  2  AD 16 93             LDA     DSKY_TEMP_VAL
0091AA  2  29 FD                AND     #%11111101
0091AC  2  8D 62 03             STA     DSKY_PPIC
0091AF  2  EA                   NOP                     ; MAY NOT BE NEEDED
0091B0  2  09 02                ORA     #%00000010
0091B2  2  8D 62 03             STA     DSKY_PPIC
0091B5  2               ;
0091B5  2               ; DEASSERT /CS
0091B5  2  29 E7                AND     #%11100111
0091B7  2  8D 62 03             STA     DSKY_PPIC
0091BA  2               ;
0091BA  2               ; CLEAR ADDRESS BIT
0091BA  2  29 E6                AND     #%11100110
0091BC  2  8D 62 03             STA     DSKY_PPIC
0091BF  2               ;
0091BF  2               ; DONE
0091BF  2  20 03 93             JSR     DSKY_PPIIDLE
0091C2  2  60                   RTS
0091C3  2               ;
0091C3  2               ;==================================================================================================
0091C3  2               ; DSKYNG OUTPUT ROUTINES
0091C3  2               ;==================================================================================================
0091C3  2               ;
0091C3  2               ; RETURN DSKY STATUS VALUE IN A
0091C3  2               ;
0091C3  2               DSKY_ST:
0091C3  2  A9 01                LDA     #$01
0091C5  2  4C CA 91             JMP     DSKY_DIN2
0091C8  2               ;
0091C8  2               ; RETURN NEXT DATA VALUE IN A
0091C8  2               ;
0091C8  2               DSKY_DIN:
0091C8  2  A9 00                LDA     #$00
0091CA  2               ;
0091CA  2               DSKY_DIN2:
0091CA  2               ; SET PPI LINE CONFIG TO READ MODE
0091CA  2  20 F1 92             JSR     DSKY_PPIRD
0091CD  2               ;
0091CD  2               ; SET ADDRESS FIRST
0091CD  2  09 06                ORA     #DSKY_PPI_IDLE
0091CF  2  8D 62 03             STA     DSKY_PPIC
0091D2  2               ;
0091D2  2               ; ASSERT 8279 /CS
0091D2  2  09 18                ORA     #%00011000
0091D4  2  8D 62 03             STA     DSKY_PPIC
0091D7  2               ;
0091D7  2               ; ASSERT /RD
0091D7  2  29 7B                AND     #%01111011
0091D9  2  8D 62 03             STA     DSKY_PPIC
0091DC  2               ;
0091DC  2  8D 16 93             STA     DSKY_TEMP_VAL
0091DF  2               ; GET VALUE
0091DF  2  AD 60 03             LDA     DSKY_PPIA
0091E2  2  48                   PHA
0091E3  2               
0091E3  2  AD 16 93             LDA     DSKY_TEMP_VAL
0091E6  2               ; DEASSERT /RD
0091E6  2  09 04                ORA     #%00000100
0091E8  2  8D 62 03             STA     DSKY_PPIC
0091EB  2               ;
0091EB  2               ; DEASSERT /CS
0091EB  2  29 E7                AND     #%11100111
0091ED  2  8D 62 03             STA     DSKY_PPIC
0091F0  2               ;
0091F0  2               ; CLEAR ADDRESS BIT
0091F0  2  29 E6                AND     #%11100110
0091F2  2  8D 62 03             STA     DSKY_PPIC
0091F5  2               ;
0091F5  2               ; DONE
0091F5  2  20 03 93             JSR     DSKY_PPIIDLE
0091F8  2  68                   PLA
0091F9  2  60                   RTS
0091FA  2               
0091FA  2               ;__DSKY_BLANK_____________________________________________________________________________________
0091FA  2               ;
0091FA  2               ; BLANK DSKYNG DISPLAY  (WITHOUT USING CLEAR)
0091FA  2               ;
0091FA  2               ;_________________________________________________________________________________________________
0091FA  2               ;
0091FA  2               DSKY_BLANK:
0091FA  2  A9 90                LDA     #DSKY_CMD_WDSP
0091FC  2  20 8A 91             JSR     DSKY_CMD
0091FF  2  A2 10                LDX     #16
009201  2               DSKY_BLANK1:
009201  2  A9 FF                LDA     #$FF
009203  2  20 90 91             JSR     DSKY_DOUT
009206  2  CA                   DEX
009207  2  D0 F8                BNE     DSKY_BLANK1
009209  2  60                   RTS
00920A  2               ;
00920A  2               ;__DSKY_PUTBYTE____________________________________________________________________________________
00920A  2               ;
00920A  2               ; WRITE A RAW BYTE VALUE TO DSKY DISPLAY RAM
00920A  2               ; AT LOCATION IN REGISTER Y, VALUE IN A.
00920A  2               ;
00920A  2               ;__________________________________________________________________________________________________
00920A  2               ;
00920A  2               DSKY_PUTBYTE:
00920A  2  85 3A                STA     STACKA
00920C  2  48                   PHA
00920D  2  98                   TYA
00920E  2  48                   PHA
00920F  2  A5 3A                LDA     STACKA
009211  2  48                   PHA
009212  2  18                   CLC
009213  2  98                   TYA
009214  2  69 90                ADC     #DSKY_CMD_WDSP
009216  2  A8                   TAY
009217  2  20 8A 91             JSR     DSKY_CMD
00921A  2  68                   PLA
00921B  2  49 FF                EOR     #$FF
00921D  2  20 90 91             JSR     DSKY_DOUT
009220  2  68                   PLA
009221  2  A8                   TAY
009222  2  68                   PLA
009223  2  60                   RTS
009224  2               ;
009224  2               ;__DSKY_GETBYTE___________________________________________________________________________________
009224  2               ; READ A RAW BYTE VALUE FROM DSKY DISPLAY RAM
009224  2               ; AT LOCATION IN REGISTER Y, VALUE RETURNED IN A
009224  2               ;
009224  2               ;_________________________________________________________________________________________________
009224  2               ;
009224  2               DSKY_GETBYTE:
009224  2  18                   CLC
009225  2  98                   TYA
009226  2  69 70                ADC     #DSKY_CMD_RDSP
009228  2  A8                   TAY
009229  2  20 8A 91             JSR     DSKY_CMD
00922C  2  20 C8 91             JSR     DSKY_DIN
00922F  2  49 FF                EOR     #$FF
009231  2  60                   RTS
009232  2               
009232  2               ;
009232  2               ;__DSKY_PUTLED____________________________________________________________________________________
009232  2               ;
009232  2               ;	This function is intended to update the LEDs.
009232  2               ;	VALUES SHOULD BE IN DSKY_BUF
009232  2               ;_________________________________________________________________________________________________
009232  2               ;
009232  2               DSKY_PUTLED:
009232  2  48                   PHA
009233  2  8A                   TXA
009234  2  48                   PHA
009235  2  98                   TYA
009236  2  48                   PHA
009237  2  A0 00                LDY     #$00
009239  2  A2 00                LDX     #$00
00923B  2               DSKY_PUTLED_1:
00923B  2  BD 00 05             LDA     DSKY_BUF,X      ; GET BYTE
00923E  2  20 0A 92             JSR     DSKY_PUTBYTE    ; SEND IT TO DSKY
009241  2  C8                   INY                     ; LOOP TIL DONE
009242  2  E8                   INX
009243  2  C0 08                CPY     #8
009245  2  D0 F4                BNE     DSKY_PUTLED_1
009247  2  68                   PLA                     ; RESTORE REGISTERS
009248  2  A8                   TAY
009249  2  68                   PLA
00924A  2  AA                   TAX
00924B  2  68                   PLA
00924C  2  60                   RTS
00924D  2               ;
00924D  2               ;__DSKY_BEEP______________________________________________________________________________________
00924D  2               ;	This function is intended to beep the speaker on the DSKY
00924D  2               ;_________________________________________________________________________________________________
00924D  2               ;
00924D  2               DSKY_BEEP:
00924D  2  48                   PHA
00924E  2  8A                   TXA
00924F  2  48                   PHA
009250  2  98                   TYA
009251  2  48                   PHA
009252  2               
009252  2  A0 0F                LDY     #$0F
009254  2  20 24 92             JSR     DSKY_GETBYTE
009257  2  09 20                ORA     #$20
009259  2  A9 20                LDA     #$20
00925B  2  A0 0F                LDY     #$0F
00925D  2  20 0A 92             JSR     DSKY_PUTBYTE
009260  2               
009260  2               ;;; 	timer . . .
009260  2  A2 8F                LDX     #$8F
009262  2  A0 FF                LDY     #$FF
009264  2               DSKY_BEEP1:
009264  2  88                   DEY
009265  2  D0 FD                BNE     DSKY_BEEP1
009267  2  CA                   DEX
009268  2  D0 FA                BNE     DSKY_BEEP1
00926A  2               
00926A  2  A0 0F                LDY     #$0F
00926C  2  20 24 92             JSR     DSKY_GETBYTE
00926F  2  29 DF                AND     #$DF
009271  2  A9 DF                LDA     #$DF
009273  2  A0 0F                LDY     #$0F
009275  2  20 0A 92             JSR     DSKY_PUTBYTE
009278  2               
009278  2  68                   PLA                     ; RESTORE REGISTERS
009279  2  A8                   TAY
00927A  2  68                   PLA
00927B  2  AA                   TAX
00927C  2  68                   PLA
00927D  2  60                   RTS
00927E  2               ;
00927E  2               ;__DSKY_L1ON______________________________________________________________________________________
00927E  2               ;	This function is intended to turn on DSKY L1
00927E  2               ;_________________________________________________________________________________________________
00927E  2               ;
00927E  2               DSKY_L1ON:
00927E  2  48                   PHA
00927F  2  8A                   TXA
009280  2  48                   PHA
009281  2  98                   TYA
009282  2  48                   PHA
009283  2  A0 0D                LDY     #$0D
009285  2  20 24 92             JSR     DSKY_GETBYTE
009288  2  09 20                ORA     #$20
00928A  2  A0 0D                LDY     #$0D
00928C  2  20 0A 92             JSR     DSKY_PUTBYTE
00928F  2  68                   PLA                     ; RESTORE REGISTERS
009290  2  A8                   TAY
009291  2  68                   PLA
009292  2  AA                   TAX
009293  2  68                   PLA
009294  2  60                   RTS
009295  2               ;
009295  2               ;__DSKY_L2ON______________________________________________________________________________________
009295  2               ;	This function is intended to turn on DSKY L2
009295  2               ;_________________________________________________________________________________________________
009295  2               ;
009295  2               DSKY_L2ON:
009295  2  48                   PHA
009296  2  8A                   TXA
009297  2  48                   PHA
009298  2  98                   TYA
009299  2  48                   PHA
00929A  2  A0 0E                LDY     #$0E
00929C  2  20 24 92             JSR     DSKY_GETBYTE
00929F  2  09 20                ORA     #$20
0092A1  2  A0 0E                LDY     #$0E
0092A3  2  20 0A 92             JSR     DSKY_PUTBYTE
0092A6  2  68                   PLA                     ; RESTORE REGISTERS
0092A7  2  A8                   TAY
0092A8  2  68                   PLA
0092A9  2  AA                   TAX
0092AA  2  68                   PLA
0092AB  2  60                   RTS
0092AC  2               ;
0092AC  2               ;__DSKY_L1OFF_____________________________________________________________________________________
0092AC  2               ;	This function is intended to turn off DSKY L1
0092AC  2               ;_________________________________________________________________________________________________
0092AC  2               ;
0092AC  2               DSKY_L1OFF:
0092AC  2  48                   PHA
0092AD  2  8A                   TXA
0092AE  2  48                   PHA
0092AF  2  98                   TYA
0092B0  2  48                   PHA
0092B1  2  A0 0D                LDY     #$0D
0092B3  2  20 24 92             JSR     DSKY_GETBYTE
0092B6  2  29 DF                AND     #$DF
0092B8  2  A0 0D                LDY     #$0D
0092BA  2  20 0A 92             JSR     DSKY_PUTBYTE
0092BD  2  68                   PLA                     ; RESTORE REGISTERS
0092BE  2  A8                   TAY
0092BF  2  68                   PLA
0092C0  2  AA                   TAX
0092C1  2  68                   PLA
0092C2  2  60                   RTS
0092C3  2               ;
0092C3  2               ;__DSKY_L2OFF_____________________________________________________________________________________
0092C3  2               ;	This function is intended to turn off DSKY L2
0092C3  2               ;_________________________________________________________________________________________________
0092C3  2               ;
0092C3  2               DSKY_L2OFF:
0092C3  2  48                   PHA
0092C4  2  8A                   TXA
0092C5  2  48                   PHA
0092C6  2  98                   TYA
0092C7  2  48                   PHA
0092C8  2  A0 0E                LDY     #$0E
0092CA  2  20 24 92             JSR     DSKY_GETBYTE
0092CD  2  29 DF                AND     #$DF
0092CF  2  A0 0E                LDY     #$0E
0092D1  2  20 0A 92             JSR     DSKY_PUTBYTE
0092D4  2  68                   PLA                     ; RESTORE REGISTERS
0092D5  2  A8                   TAY
0092D6  2  68                   PLA
0092D7  2  AA                   TAX
0092D8  2  68                   PLA
0092D9  2  60                   RTS
0092DA  2               ;
0092DA  2               ;_________________________________________________________________________________________________
0092DA  2               ; DSKYNG LINE CONTROL ROUTINES
0092DA  2               ;
0092DA  2               ; SETUP PPI FOR WRITING: PUT PPI PORT A IN OUTPUT MODE
0092DA  2               ; AVOID REWRTING PPIX IF ALREADY IN OUTPUT MODE
0092DA  2               ;
0092DA  2               ;_________________________________________________________________________________________________
0092DA  2               ;
0092DA  2               DSKY_PPIWR:
0092DA  2  48                   PHA
0092DB  2               ;
0092DB  2               ; CHECK FOR WRITE MODE
0092DB  2  AD 17 93             LDA     DSKY_PPIX_VAL
0092DE  2  C9 82                CMP     #DSKY_PPIX_WR
0092E0  2  F0 0D                BEQ     DSKY_PPIWR1
0092E2  2               ;
0092E2  2               ; SET PPI TO WRITE MODE
0092E2  2  A9 82                LDA     #DSKY_PPIX_WR
0092E4  2  8D 63 03             STA     DSKY_PPIX
0092E7  2  8D 17 93             STA     DSKY_PPIX_VAL
0092EA  2               ;
0092EA  2               ; RESTORE PORT C (MAY NOT BE NEEDED)
0092EA  2  A9 06                LDA     #DSKY_PPI_IDLE
0092EC  2  8D 62 03             STA     DSKY_PPIC
0092EF  2               ;
0092EF  2               DSKY_PPIWR1:
0092EF  2               ;
0092EF  2  68                   PLA
0092F0  2  60                   RTS
0092F1  2               ;
0092F1  2               ; SETUP PPI FOR READING: PUT PPI PORT A IN INPUT MODE
0092F1  2               ; AVOID REWRTING PPIX IF ALREADY IN INPUT MODE
0092F1  2               ;
0092F1  2               DSKY_PPIRD:
0092F1  2  48                   PHA
0092F2  2               ;
0092F2  2               ; CHECK FOR READ MODE
0092F2  2  AD 17 93             LDA     DSKY_PPIX_VAL
0092F5  2  C9 92                CMP     #DSKY_PPIX_RD
0092F7  2  F0 08                BEQ     DSKY_PPIRD1
0092F9  2               ;
0092F9  2               ; SET PPI TO READ MODE
0092F9  2  A9 92                LDA     #DSKY_PPIX_RD
0092FB  2  8D 63 03             STA     DSKY_PPIX
0092FE  2  8D 17 93             STA     DSKY_PPIX_VAL
009301  2               ;
009301  2               DSKY_PPIRD1:
009301  2  68                   PLA
009302  2  60                   RTS
009303  2               ;
009303  2               ; RELEASE USE OF PPI
009303  2               ;
009303  2               DSKY_PPIIDLE:
009303  2  4C F1 92             JMP     DSKY_PPIRD      ; SAME AS READ MODE
009306  2               ;
009306  2               ;__STORAGE_________________________________________________________________________________________
009306  2               ; CODES FOR NUMERICS
009306  2               ; HIGH BIT ALWAYS CLEAR TO SUPPRESS DECIMAL POINT
009306  2               ; SET HIGH BIT TO SHOW DECIMAL POINT
009306  2               ;_________________________________________________________________________________________________
009306  2               ;
009306  2               DSKY_HEXMAP:
009306  2  3F                   .BYTE   $3F             ; 0
009307  2  06                   .BYTE   $06             ; 1
009308  2  5B                   .BYTE   $5B             ; 2
009309  2  4F                   .BYTE   $4F             ; 3
00930A  2  66                   .BYTE   $66             ; 4
00930B  2  6D                   .BYTE   $6D             ; 5
00930C  2  7D                   .BYTE   $7D             ; 6
00930D  2  07                   .BYTE   $07             ; 7
00930E  2  7F                   .BYTE   $7F             ; 8
00930F  2  67                   .BYTE   $67             ; 9
009310  2  77                   .BYTE   $77             ; A
009311  2  7C                   .BYTE   $7C             ; B
009312  2  39                   .BYTE   $39             ; C
009313  2  5E                   .BYTE   $5E             ; D
009314  2  79                   .BYTE   $79             ; E
009315  2  71                   .BYTE   $71             ; F
009316  2               ;
009316  2               DSKY_TEMP_VAL:
009316  2  00                   .BYTE   0
009317  2               DSKY_PPIX_VAL:
009317  2  00                   .BYTE   0
009318  2               DSKY_PRESENT:
009318  2  00                   .BYTE   0
009319  2               
009319  1                       .INCLUDE "dosmd.asm"
009319  2               ;__MD DRIVERS____________________________________________________________________________________________________________________
009319  2               ;
009319  2               ; 	Nhyodyne Memory disk drivers
009319  2               ;
009319  2               ;	Entry points:
009319  2               ;		MD_SHOW         - called during OS init
009319  2               ;		MD_READ_SECTOR  - read a sector from drive
009319  2               ;		MD_WRITE_SECTOR - write a sector to drive
009319  2               ;________________________________________________________________________________________________________________________________
009319  2               ;
009319  2               ; RAM BANK $0C is RAM area for Drivers
009319  2               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
009319  2               ; RAM BANK $0F is fixed bank $0000-$7FFF
009319  2               ;
009319  2               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
009319  2               ;
009319  2               ; ROM MEMORY PAGE CONFIGURATION LATCH CONTROL PORT
009319  2               ;       A15 IS INVERTED FOR THE NYHODYNE 65C02 CPU . . .
009319  2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
009319  2               ;	^ ^ ^ ^  ^ ^ ^ ^
009319  2               ;	: : : :  : : : :--0 = A15 ROM ONLY ADDRESS LINE DEFAULT IS 0
009319  2               ;	: : : :  : : :----0 = A16 ROM ONLY ADDRESS LINE DEFAULT IS 0
009319  2               ;	: : : :  : :------0 = A17 ROM ONLY ADDRESS LINE DEFAULT IS 0
009319  2               ;	: : : :  :--------0 = A18 ROM ONLY ADDRESS LINE DEFAULT IS 0
009319  2               ;	: : : :-----------0 = A19 ROM ONLY ADDRESS LINE DEFAULT IS 0
009319  2               ;	: : :-------------0 = A20 ROM ONLY ADDRESS LINE DEFAULT IS 0
009319  2               ;	: :---------------0 = ROM BOOT OVERRIDE DEFAULT IS 0
009319  2               ;	:-----------------0 = LOWER PAGE ROM SELECT (0=ROM, 1=NOTHING) DEFAULT IS 0
009319  2               ;
009319  2               ; RAM PAGE CONFIGURATION LATCH CONTROL PORT
009319  2               ;
009319  2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
009319  2               ;	^ ^ ^ ^  ^ ^ ^ ^
009319  2               ;	: : : :  : : : :--0 = A15 RAM ONLY ADDRESS LINE DEFAULT IS 0
009319  2               ;	: : : :  : : :----0 = A16 RAM ONLY ADDRESS LINE DEFAULT IS 0
009319  2               ;	: : : :  : :------0 = A17 RAM ONLY ADDRESS LINE DEFAULT IS 0
009319  2               ;	: : : :  :--------0 = A18 RAM ONLY ADDRESS LINE DEFAULT IS 0
009319  2               ;	: : : :-----------0 = A19 RAM ONLY ADDRESS LINE DEFAULT IS 0
009319  2               ;	: : :-------------0 = UNDEFINED DEFAULT IS 0
009319  2               ;	: :---------------0 = RAM BOOT OVERRIDE DEFAULT IS 0
009319  2               ;	:-----------------0 = LOWER PAGE RAM SELECT (0=NOTHING, 1=RAM) DEFAULT IS 0;
009319  2               
009319  2               
009319  2               ;__MD_SHOW___________________________________________________________________________________________
009319  2               ;
009319  2               ;  Display info on MD devices
009319  2               ;____________________________________________________________________________________________________
009319  2               ;
009319  2               MD_SHOW:
009319  2                       PRTDBG  "MD INIT:$"
009319  2  48 8A 48 A8          PRTS    "MD: UNITS=2 RAMDISK=256KB ROMDISK=384KB$"
00931D  2  48 A2 00 BD  
009321  2  36 93 E8 C9  
00935E  2  20 83 88             JSR     NEWLINE
009361  2  60                   RTS
009362  2               
009362  2               ;*__MD_READ_SECTOR____________________________________________________________________________________
009362  2               ;*
009362  2               ;*  READ MD SECTOR INTO BUFFER
009362  2               ;*
009362  2               ;*____________________________________________________________________________________________________
009362  2               MD_READ_SECTOR:
009362  2                       PRTDBG  "MD Read Sector$"
009362  2  20 58 94             JSR     GET_DRIVE_DEVICE
009365  2  29 01                AND     #$01            ; only want drive cfg
009367  2  0A                   ASL     a               ; SHIFT 6
009368  2  0A                   ASL     a               ;
009369  2  0A                   ASL     a               ;
00936A  2  0A                   ASL     a               ;
00936B  2  0A                   ASL     a               ;
00936C  2  0A                   ASL     a               ;
00936D  2  29 5F                AND     #%01011111      ; TOGGLE READ
00936F  2  AA                   TAX                     ; STASH CONTROL WORD
009370  2  AD 0E 05             LDA     seksec          ;
009373  2  29 01                AND     #$01            ; GET SECTOR INDEX
009375  2  C9 00                CMP     #$00
009377  2  F0 04                BEQ     @1
009379  2  8A                   TXA
00937A  2  09 80                ORA     #%10000000      ; TOGGLE TOP HALF OF PAGE
00937C  2  AA                   TAX
00937D  2               @1:
00937D  2  20 C7 93             JSR     MD_CONVERT_SECTOR
009380  2  8A                   TXA
009381  2  29 40                AND     #%01000000
009383  2  C9 00                CMP     #$00            ; read if ram
009385  2  F0 0C                BEQ     :+
009387  2  EE 10 05             INC     debcyll         ; if rom, inc bank by 4 ()
00938A  2  EE 10 05             INC     debcyll
00938D  2  EE 10 05             INC     debcyll
009390  2  EE 10 05             INC     debcyll
009393  2               :
009393  2  AD 10 05             LDA     debcyll         ; GET BANK
009396  2  AC 12 05             LDY     debsehd         ; GET PAGE
009399  2                       PRTDBG  "DO PAGER RD$"
009399  2  20 00 02             JSR     MD_PAGERA
00939C  2                       PRTDBG  "PAGER RETURN$"
00939C  2  A9 00                LDA     #$00
00939E  2  60                   RTS
00939F  2               
00939F  2               
00939F  2               ;*__MD_WRITE_SECTOR___________________________________________________________________________________
00939F  2               ;*
00939F  2               ;*  WRITE MD SECTOR FROM BUFFER
00939F  2               ;*
00939F  2               ;*____________________________________________________________________________________________________
00939F  2               MD_WRITE_SECTOR:
00939F  2                       PRTDBG  "MD Write Sector$"
00939F  2  20 58 94             JSR     GET_DRIVE_DEVICE
0093A2  2  29 01                AND     #$01            ; only want drive cfg
0093A4  2  C9 00                CMP     #$00            ; NO WRITE FOR ROM
0093A6  2  F0 03                BEQ     MD_WRITE_SECTOR_RAM
0093A8  2  A9 FF                LDA     #$FF
0093AA  2  60                   RTS
0093AB  2               MD_WRITE_SECTOR_RAM:
0093AB  2  20 C7 93             JSR     MD_CONVERT_SECTOR
0093AE  2  A2 20                LDX     #%00100000      ; TOGGLE WRITE RAM (LO)
0093B0  2  AD 0E 05             LDA     seksec          ;
0093B3  2  29 01                AND     #$01            ; GET SECTOR INDEX
0093B5  2  C9 00                CMP     #$00
0093B7  2  F0 02                BEQ     @1
0093B9  2  A2 A0                LDX     #%10100000      ; TOGGLE WRITE RAM (HI)
0093BB  2               @1:
0093BB  2  AD 10 05             LDA     debcyll         ; GET BANK
0093BE  2  AC 12 05             LDY     debsehd         ; GET PAGE
0093C1  2                       PRTDBG  "DO PAGER WR$"
0093C1  2  20 00 02             JSR     MD_PAGERA
0093C4  2                       PRTDBG  "PAGER RETURN$"
0093C4  2  A9 00                LDA     #$00
0093C6  2  60                   RTS
0093C7  2               
0093C7  2               ;___MD_CONVERT_SECTOR___________________________________________________________________________________
0093C7  2               ;
0093C7  2               ; 	TRANSLATE SECTORS INTO MD FORMAT
0093C7  2               ;________________________________________________________________________________________________________
0093C7  2               MD_CONVERT_SECTOR:
0093C7  2                       PRTDBG  "CONVERT SECTOR$"
0093C7  2  48                   PHA
0093C8  2  8A                   TXA
0093C9  2  48                   PHA
0093CA  2  AD 0E 05             LDA     seksec          ; LOAD SECTOR # (LOW BYTE)
0093CD  2  4A                   LSR     A               ; DIVIDE BY 2 (FOR BLOCKING)
0093CE  2  29 1F                AND     #$1F            ; CLEAR UPPER 3 BITS (JUST 'CAUSE)
0093D0  2  8D 12 05             STA     debsehd         ; STORE IN SECTOR/HEAD
0093D3  2  AD 0C 05             LDA     sektrk          ; LOAD TRACK # (LOW BYTE)
0093D6  2  29 03                AND     #$03            ; BOTTOM 2 BITS ARE PART OF PAGE (PAGES ARE 32k)
0093D8  2  0A                   ASL     a               ; MOVE TO HIGH BITS
0093D9  2  0A                   ASL     a
0093DA  2  0A                   ASL     a
0093DB  2  0A                   ASL     a
0093DC  2  0A                   ASL     a
0093DD  2  09 80                ORA     #$80            ; PAGES ARE ALWAYS IN UPPER BANK
0093DF  2  0D 12 05             ORA     debsehd         ; STORE IN SECTOR/HEAD
0093E2  2  8D 12 05             STA     debsehd         ; STORE IN SECTOR/HEAD
0093E5  2                                               ; AT THIS POINT PAGE REGISTER SHOULD BE
0093E5  2                                               ; SET
0093E5  2  AD 0C 05             LDA     sektrk          ; LOAD TRACK #
0093E8  2  4A                   LSR     a               ; LOSE BOTTOM TWO BITS
0093E9  2  4A                   LSR     a
0093EA  2  8D 10 05             STA     debcyll         ; THIS SHOULD BE BANK#
0093ED  2               
0093ED  2               
0093ED  2                       .IF     USEDSKY=1 || USEDSKYNG=1
0093ED  2                           PRTDBG  "DSKY OUTPUT 1$"
0093ED  2  AD 13 05                 LDA     sekdsk
0093F0  2  8D 08 05                 STA     DSKY_HEXBUF
0093F3  2  A9 00                    LDA     #$00
0093F5  2  8D 09 05                 STA     DSKY_HEXBUF+1
0093F8  2  AD 10 05                 LDA     debcyll
0093FB  2  8D 0A 05                 STA     DSKY_HEXBUF+2
0093FE  2  AD 12 05                 LDA     debsehd
009401  2  8D 0B 05                 STA     DSKY_HEXBUF+3
009404  2  20 35 91                 JSR     DSKY_BIN2SEG
009407  2  20 6E 91                 JSR     DSKY_SHOW
00940A  2                       .ENDIF
00940A  2  68                   PLA
00940B  2  AA                   TAX
00940C  2  68                   PLA
00940D  2  60                   RTS
00940E  2               
00940E  1                       .INCLUDE "dosdblk.asm"
00940E  2               ;__DOS DEBLOCK DRIVERS___________________________________________________________________________________________________________
00940E  2               ;
00940E  2               ; 	Nhyodyne DOS/65 Blocking and Deblocking code
00940E  2               ;
00940E  2               ;________________________________________________________________________________________________________________________________
00940E  2               ;
00940E  2               
00940E  2               ;___DEBSECR512________________________________________________________________________________________
00940E  2               ;
00940E  2               ;	DEBLOCK 512 BYTE SECTOR FOR DOS/65
00940E  2               ;
00940E  2               ;________________________________________________________________________________________________________
00940E  2               DEBSECR512:
00940E  2  48                   PHA
00940F  2  AD 0E 05             LDA     seksec          ;
009412  2  29 03                AND     #$03            ; GET SECTOR INDEX
009414  2  18                   CLC                     ;
009415  2  2A                   ROL     A               ;
009416  2  AA                   TAX                     ;
009417  2  BD 2F 94             LDA     DEBTAB,X        ;
00941A  2  85 EE                STA     SRC
00941C  2  E8                   INX
00941D  2  BD 2F 94             LDA     DEBTAB,X        ;
009420  2  85 EF                STA     SRC+1           ;
009422  2  A9 00                LDA     #<MD_PAGEBU     ;
009424  2  85 EC                STA     DEST            ;
009426  2  A9 04                LDA     #>MD_PAGEBU     ;
009428  2  85 ED                STA     DEST+1          ;
00942A  2  20 6B 94             JSR     COPY_DOS_SECTOR ;
00942D  2  68                   PLA
00942E  2  60                   RTS
00942F  2               
00942F  2               DEBTAB:
00942F  2  E6 94                .WORD   hstbuf          ;
009431  2  66 95                .WORD   hstbuf+128      ;
009433  2  E6 95                .WORD   hstbuf+256      ;
009435  2  66 96                .WORD   hstbuf+384      ;
009437  2               
009437  2               
009437  2               ;___BLKSECR512___________________________________________________________________________________________
009437  2               ;
009437  2               ;	BLOCK 512 SECTOR FOR DOS/65
009437  2               ;
009437  2               ;________________________________________________________________________________________________________
009437  2               BLKSECR512:
009437  2  48                   PHA
009438  2  AD 0E 05             LDA     seksec          ;
00943B  2  29 03                AND     #$03            ; GET SECTOR INDEX
00943D  2  18                   CLC                     ;
00943E  2  2A                   ROL     A               ;
00943F  2  AA                   TAX                     ;
009440  2  BD 2F 94             LDA     DEBTAB,X        ;
009443  2  85 EC                STA     DEST
009445  2  E8                   INX
009446  2  BD 2F 94             LDA     DEBTAB,X        ;
009449  2  85 ED                STA     DEST+1          ;
00944B  2  A9 00                LDA     #<MD_PAGEBU     ;
00944D  2  85 EE                STA     SRC             ;
00944F  2  A9 04                LDA     #>MD_PAGEBU     ;
009451  2  85 EF                STA     SRC+1           ;
009453  2  20 6B 94             JSR     COPY_DOS_SECTOR ;
009456  2  68                   PLA
009457  2  60                   RTS
009458  2               
009458  2               ;___GET_DRIVE_DEVICE_____________________________________________________________________________________
009458  2               ;
009458  2               ;	GET SELECTED DEVICE TYPE AND UNIT, RETURN IN "A"
009458  2               ;
009458  2               ;________________________________________________________________________________________________________
009458  2               GET_DRIVE_DEVICE:
009458  2  8A                   TXA
009459  2  48                   PHA
00945A  2  AD 13 05             LDA     sekdsk          ; GET DRIVE
00945D  2  29 07                AND     #7              ; ONLY FIRST 8 DEVICES SUPPORTED
00945F  2  0A                   ASL     a               ; DOUBLE NUMBER FOR TABLE LOOKUP
009460  2  AA                   TAX                     ; MOVE TO X REGISTER
009461  2  BD 14 05             LDA     dskcfg,X        ; GET device
009464  2  85 3A                STA     STACKA
009466  2  68                   PLA
009467  2  AA                   TAX
009468  2  A5 3A                LDA     STACKA
00946A  2  60                   RTS
00946B  2               
00946B  2               
00946B  2               ;___COPY_DOS_SECTOR______________________________________________________________________________________
00946B  2               ;
00946B  2               ;	COPY 128 BYTE SECTOR FOR DOS/65
00946B  2               ;
00946B  2               ;________________________________________________________________________________________________________
00946B  2               COPY_DOS_SECTOR:
00946B  2  48                   PHA
00946C  2  98                   TYA
00946D  2  48                   PHA
00946E  2  A0 00                LDY     #$00            ;
009470  2               COPY_DOS_SECTOR1:
009470  2  B1 EE                LDA     (SRC),Y         ;
009472  2  91 EC                STA     (DEST),Y        ;
009474  2  C8                   INY                     ;
009475  2  98                   TYA                     ;
009476  2  C9 80                CMP     #$80            ;
009478  2  D0 F6                BNE     COPY_DOS_SECTOR1;
00947A  2  68                   PLA
00947B  2  98                   TYA
00947C  2  68                   PLA
00947D  2  60                   RTS
00947E  2               
00947E  2               ;___INIT_PAGE_COPY_______________________________________________________________________________________
00947E  2               ;
00947E  2               ;	COPY PAGE COPY CODE TO LORAM AT "MD_PAGEBU"
00947E  2               ;
00947E  2               ;________________________________________________________________________________________________________
00947E  2               INIT_PAGE_COPY:
00947E  2               
00947E  2  A0 00                LDY     #$00
009480  2               :
009480  2  B9 8C 94             LDA     INIT_PAGE_COPY_1,Y
009483  2  99 00 04             STA     MD_PAGEBU,Y
009486  2  C8                   INY
009487  2  C0 00                CPY     #$00
009489  2  D0 F5                BNE     :-
00948B  2  60                   RTS
00948C  2               INIT_PAGE_COPY_1:
00948C  2               ; COPY_PAGE_TO_HSTBUF
00948C  2  85 39                STA     zptemp
00948E  2  A9 E6                LDA     #<hstbuf
009490  2  85 17                STA     point
009492  2  A9 94                LDA     #>hstbuf
009494  2  85 18                STA     point+1
009496  2  A2 02                LDX     #$02
009498  2  A0 00                LDY     #$00
00949A  2               :
00949A  2  A5 39                LDA     zptemp
00949C  2  8D 78 03             STA     MPCL_RAM        ; SET PAGE TO SOURCE
00949F  2  B1 14                LDA     (pointr),Y
0094A1  2  48                   PHA
0094A2  2  A9 8C                LDA     #$8C            ; SET PAGE TO DRIVERSPACE
0094A4  2  8D 78 03             STA     MPCL_RAM
0094A7  2  68                   PLA
0094A8  2  91 17                STA     (point),Y
0094AA  2  C8                   INY
0094AB  2  C0 00                CPY     #$00
0094AD  2  D0 EB                BNE     :-
0094AF  2  E6 15                INC     pointr+1
0094B1  2  E6 18                INC     point+1
0094B3  2  CA                   DEX
0094B4  2  E0 00                CPX     #$00
0094B6  2  D0 E2                BNE     :-
0094B8  2  60                   RTS
0094B9  2               INIT_PAGE_COPY_2:
0094B9  2               ; COPY_HSTBUF_TO_PAGE
0094B9  2  85 39                STA     zptemp
0094BB  2  A9 E6                LDA     #<hstbuf
0094BD  2  85 17                STA     point
0094BF  2  A9 94                LDA     #>hstbuf
0094C1  2  85 18                STA     point+1
0094C3  2               
0094C3  2  A2 02                LDX     #$02
0094C5  2  A0 00                LDY     #$00
0094C7  2               :
0094C7  2  B1 17                LDA     (point),Y
0094C9  2  48                   PHA
0094CA  2  A5 39                LDA     zptemp
0094CC  2  8D 78 03             STA     MPCL_RAM        ; SET PAGE TO DESTINATION
0094CF  2  68                   PLA
0094D0  2  91 14                STA     (pointr),Y
0094D2  2  A9 8C                LDA     #$8C            ; SET PAGE TO DRIVERSPACE
0094D4  2  8D 78 03             STA     MPCL_RAM
0094D7  2  C8                   INY
0094D8  2  C0 00                CPY     #$00
0094DA  2  D0 EB                BNE     :-
0094DC  2  E6 15                INC     pointr+1
0094DE  2  E6 18                INC     point+1
0094E0  2  CA                   DEX
0094E1  2  E0 00                CPX     #$00
0094E3  2  D0 E2                BNE     :-
0094E5  2  60                   RTS
0094E6  2               
0094E6  2               COPY_PAGE_TO_HSTBUF = MD_PAGEBU
0094E6  2               COPY_HSTBUF_TOPAGE = MD_PAGEBU+INIT_PAGE_COPY_2-INIT_PAGE_COPY_1
0094E6  2               ;deblocking buffer for dba
0094E6  2               hstbuf:
0094E6  2  xx xx xx xx          .RES    512             ;256 or 512 byte sectors
0094EA  2  xx xx xx xx  
0094EE  2  xx xx xx xx  
0096E6  2               
0096E6  1                       .INCLUDE "dosflp.asm"
0096E6  2               ;__FLOPPY DRIVERS________________________________________________________________________________________________________________
0096E6  2               ;
0096E6  2               ; 	DOS/65 floppy drivers for MBC FDC card
0096E6  2               ;
0096E6  2               ;	Entry points:
0096E6  2               ;		FL_SETUP        - called during OS init
0096E6  2               ;		FL_READ_SECTOR	- read a sector from drive
0096E6  2               ;		FL_WRITE_SECTOR	- write a sector to drive
0096E6  2               ;
0096E6  2               ;________________________________________________________________________________________________________________________________
0096E6  2               ;
0096E6  2               ;*
0096E6  2               ;* HARDWARE I/O ADDRESSES
0096E6  2               ;*
0096E6  2               FDC_MSR         = $0330         ; ADDRESS OF MAIN STATUS REGISTER
0096E6  2               FDC_DATA        = $0331         ; FLOPPY DATA REGISTER
0096E6  2               FDC_RESET       = $0333         ; FLOPPY RESET
0096E6  2               FDC_DCR         = $0335         ; LOAD CONTROL REGISTER
0096E6  2               FDC_DOR         = $0336         ; CONFIGURATION CONTROL REGISTER
0096E6  2               FDC_TC          = $0337         ; TERMINAL COUNT
0096E6  2               
0096E6  2               ;
0096E6  2               ; FDC COMMANDS
0096E6  2               ;
0096E6  2               CFD_READ        = %00000110     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
0096E6  2               CFD_READDEL     = %00001100     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
0096E6  2               CFD_WRITE       = %00000101     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
0096E6  2               CFD_WRITEDEL    = %00001001     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
0096E6  2               CFD_READTRK     = %00000010     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
0096E6  2               CFD_READID      = %00001010     ; CMD,HDS/DS --> ST0,ST1,ST2,C,H,R,N
0096E6  2               CFD_FMTTRK      = %00001101     ; CMD,HDS/DS,N,SC,GPL,D --> ST0,ST1,ST2,C,H,R,N
0096E6  2               CFD_SCANEQ      = %00010001     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
0096E6  2               CFD_SCANLOEQ    = %00011001     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
0096E6  2               CFD_SCANHIEQ    = %00011101     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
0096E6  2               CFD_RECAL       = %00000111     ; CMD,DS --> <EMPTY>
0096E6  2               CFD_SENSEINT    = %00001000     ; CMD --> ST0,PCN
0096E6  2               CFD_SPECIFY     = %00000011     ; CMD,SRT/HUT,HLT/ND --> <EMPTY>
0096E6  2               CFD_DRVSTAT     = %00000100     ; CMD,HDS/DS --> ST3
0096E6  2               CFD_SEEK        = %00001111     ; CMD,HDS/DS --> <EMPTY>
0096E6  2               CFD_VERSION     = %00010000     ; CMD --> ST0
0096E6  2               
0096E6  2               CFD_MFM         = %01000000     ;
0096E6  2               
0096E6  2               ;
0096E6  2               ;
0096E6  2               ; Specify Command:
0096E6  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
0096E6  2               ; |Byte |  7  |	 6  |  5  |  4	|  3  |	 2  |  1  |  0	|
0096E6  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
0096E6  2               ; |  0	|  0  |	 0  |  0  |  0	|  0  |	 0  |  1  |  1	|
0096E6  2               ; |  1	| ----- STEP RATE ----- | -- HEAD UNLOAD TIME - |
0096E6  2               ; |  2	| ------------ HEAD LOAD TIME ----------- | NDM |
0096E6  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
0096E6  2               ;
0096E6  2               ;
0096E6  2               ; Step Rate (milliseconds):		 Head Unload Time (milliseconds):	Head Load Time (milliseconds):
0096E6  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
0096E6  2               ; |	 |	   BITRATE	     |	 |	|	  BITRATE	    |	|      |	 BITRATE	   |
0096E6  2               ; |  VAL | 1.0M | 500K | 300K | 250K |	 |  VAL | 1.0M | 500K | 300K | 250K |	|  VAL | 1.0M | 500K | 300K | 250K |
0096E6  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
0096E6  2               ; |    0 |  8.0 | 16.0 | 26.7 | 32.0 |	 |    0 |  128 |  256 |	 426 |	512 |	|    0 |  128 |	 256 |	426 |  512 |
0096E6  2               ; |    1 |  7.5 | 15.0 | 25.0 | 30.0 |	 |    1 |    8 |   16 | 26.7 |	 32 |	|    1 |    1 |	   2 |	3.3 |	 4 |
0096E6  2               ; |    2 |  7.0 | 14.0 | 23.3 | 28.0 |	 |    2 |   16 |   32 | 53.3 |	 64 |	|    2 |    2 |	   4 |	6.7 |	 8 |
0096E6  2               ; |  ... |  ... |  ... |  ... |	 ... |	 |  ... |  ... |  ... |	 ... |	... |	|  ... |  ... |	 ... |	... |  ... |
0096E6  2               ; |   14 |  1.0 |  2.0 |  3.3 |	 4.0 |	 |   14 |  112 |  224 |	 373 |	448 |	|  126 |  126 |	 252 |	420 |  504 |
0096E6  2               ; |   15 |  0.5 |  1.0 |  1.7 |	 2.0 |	 |   15 |  120 |  240 |	 400 |	480 |	|  127 |  127 |	 254 |	423 |  508 |
0096E6  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
0096E6  2               ;
0096E6  2               ; IBM PS/2 CALLS FOR:
0096E6  2               ;   STEP RATE: 3ms (6ms FOR ALL 41mm OR 720K DRIVES)
0096E6  2               ;   HEAD LOAD TIME: 15ms
0096E6  2               
0096E6  2               DOR_INIT        = %00001100     ; SOFT RESET INACTIVE, DMA ENABLED
0096E6  2               DOR_BR250       = DOR_INIT
0096E6  2               DOR_BR500       = DOR_INIT
0096E6  2               
0096E6  2               
0096E6  2               
0096E6  2               FLOPPY_RETRIES  = 6             ; HOW ABOUT SIX RETIRES?
0096E6  2               FLOPPY_RETRIES1 = 2             ; TWO ITERATIONS OF RECAL?
0096E6  2               
0096E6  2               ;__FL_SETUP______________________________________________________________________________________________________________________
0096E6  2               ;
0096E6  2               ;	SETUP FLOPPY DRIVE SETTINGS
0096E6  2               ;________________________________________________________________________________________________________________________________
0096E6  2               ;
0096E6  2               FL_SETUP:
0096E6  2  A9 00                LDA     #$00            ; RESET TRACK/CYL/SEC STORAGE
0096E8  2  8D 38 9C             STA     debhead         ;
0096EB  2  8D 39 9C             STA     debcyl          ;
0096EE  2  8D 3A 9C             STA     debsec          ;
0096F1  2  A9 FF                LDA     #$FF            ; SET CACHE TO INVALID
0096F3  2  8D 3B 9C             STA     Cdebhead        ;
0096F6  2  8D 3C 9C             STA     Cdebcyl         ;
0096F9  2  8D 3D 9C             STA     Cdebsec         ;
0096FC  2               
0096FC  2  48 8A 48 A8          PRTS    "FD: MODE=MBC$"
009700  2  48 A2 00 BD  
009704  2  19 97 E8 C9  
009726  2               ;
009726  2  48 8A 48 A8          PRTS    " IO=0x$"
00972A  2  48 A2 00 BD  
00972E  2  43 97 E8 C9  
00974A  2  A9 03                LDA     #>FDC_MSR
00974C  2  20 59 88             JSR     PRTHEXBYTE
00974F  2  A9 30                LDA     #<FDC_MSR
009751  2  20 59 88             JSR     PRTHEXBYTE
009754  2  20 0C 9B             JSR     FD_DETECT       ; CHECK FOR FDC
009757  2  C9 00                CMP     #$00
009759  2  F0 30                BEQ     :+              ; CONTINUE IF FOUND
00975B  2  48 8A 48 A8          PRTS    " NOT PRESENT$" ; NOT ZERO, H/W NOT PRESENT
00975F  2  48 A2 00 BD  
009763  2  78 97 E8 C9  
009785  2  20 83 88             JSR     NEWLINE
009788  2  A9 FF                LDA     #$FF
00978A  2  60                   RTS                     ; BAIL OUT
00978B  2               :
00978B  2  48 8A 48 A8          PRTS    " PRESENT$"     ; NOT ZERO, H/W NOT PRESENT
00978F  2  48 A2 00 BD  
009793  2  A8 97 E8 C9  
0097B1  2  20 83 88             JSR     NEWLINE
0097B4  2  A9 0C                LDA     #DOR_INIT       ; RESET SETTINGS
0097B6  2  8D 36 03             STA     FDC_DOR
0097B9  2               
0097B9  2  20 AA 9A             JSR     CHECKINT        ;
0097BC  2  A9 03                LDA     #CFD_SPECIFY    ; SPECIFY COMMAND
0097BE  2  20 66 9A             JSR     PFDATA          ; OUTPUT TO FDC
0097C1  2  A9 7F                LDA     #$7F            ; 6 MS STEP, 480 MS HEAD UNLOAD
0097C3  2  20 66 9A             JSR     PFDATA          ; OUTPUT TO FDC
0097C6  2  A9 05                LDA     #$05            ; 508 MS HEAD LOAD, NON-DMA MODE
0097C8  2  20 66 9A             JSR     PFDATA          ; OUTPUT TO FDC
0097CB  2               
0097CB  2  20 AA 9A             JSR     CHECKINT        ; SEND SEVERAL INTERRUPTS TO ENSURE PROPER STATE
0097CE  2  20 AA 9A             JSR     CHECKINT        ;
0097D1  2  20 AA 9A             JSR     CHECKINT        ;
0097D4  2  20 AA 9A             JSR     CHECKINT        ;
0097D7  2  20 AA 9A             JSR     CHECKINT        ;
0097DA  2  20 AA 9A             JSR     CHECKINT        ;
0097DD  2               
0097DD  2  A9 00                LDA     #$00
0097DF  2  8D 13 05             STA     sekdsk
0097E2  2  A9 10                LDA     #%00010000
0097E4  2  8D 25 05             STA     DSKUNIT
0097E7  2  20 3B 9A             JSR     RECAL           ;
0097EA  2  A9 27                LDA     #39             ;
0097EC  2  8D 39 9C             STA     debcyl          ;
0097EF  2  20 1E 9A             JSR     SETTRK1
0097F2  2  20 3B 9A             JSR     RECAL           ;
0097F5  2               
0097F5  2  A9 01                LDA     #$01
0097F7  2  8D 13 05             STA     sekdsk
0097FA  2  A9 21                LDA     #%00100001
0097FC  2  8D 25 05             STA     DSKUNIT
0097FF  2  20 3B 9A             JSR     RECAL           ;
009802  2  A9 27                LDA     #39             ;
009804  2  8D 39 9C             STA     debcyl          ;
009807  2  20 1E 9A             JSR     SETTRK1
00980A  2  20 3B 9A             JSR     RECAL           ;
00980D  2  A9 0C                LDA     #DOR_INIT       ; RESET SETTINGS
00980F  2  8D 36 03             STA     FDC_DOR
009812  2  60                   RTS
009813  2               
009813  2               
009813  2               ;__FL_READ_SECTOR________________________________________________________________________________________________________________
009813  2               ;
009813  2               ; 	READ A FLOPPY SECTOR
009813  2               ;________________________________________________________________________________________________________________________________
009813  2               ;
009813  2               ;
009813  2               FL_READ_SECTOR:
009813  2  AD 37 9C             LDA     HARDWARE_DETCT
009816  2  C9 00                CMP     #$00
009818  2  F0 01                BEQ     :+
00981A  2  60                   RTS
00981B  2               :
00981B  2  20 24 98             JSR     FL_READ_SECTOR_RAW
00981E  2  48                   PHA
00981F  2  20 0E 94             JSR     DEBSECR512
009822  2  68                   PLA
009823  2  60                   RTS
009824  2               
009824  2               FL_READ_SECTOR_RAW:
009824  2  A9 00                LDA     #$00
009826  2  8D 42 9C             STA     FLRETRY         ; BLANK RETRIES
009829  2  8D 43 9C             STA     FLRETRY1
00982C  2  A9 0C                LDA     #DOR_INIT
00982E  2  0D 25 05             ORA     DSKUNIT         ;
009831  2  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
009834  2  20 F9 98             JSR     SETUP_FD_CHS
009837  2  AD 38 9C             LDA     debhead         ;
00983A  2  CD 3B 9C             CMP     Cdebhead        ;
00983D  2  D0 13                BNE     READFL_DIRTY
00983F  2  AD 39 9C             LDA     debcyl          ;
009842  2  CD 3C 9C             CMP     Cdebcyl         ;
009845  2  D0 0B                BNE     READFL_DIRTY
009847  2  AD 3A 9C             LDA     debsec          ;
00984A  2  CD 3D 9C             CMP     Cdebsec         ;
00984D  2  D0 03                BNE     READFL_DIRTY
00984F  2               ; SECTOR ALREADY IN CACHE, DEBLOCK
00984F  2  A9 00                LDA     #$00
009851  2  60                   RTS
009852  2               READFL_DIRTY:
009852  2  AD 38 9C             LDA     debhead         ; STORE CURRENT PARMS
009855  2  8D 3B 9C             STA     Cdebhead        ;
009858  2  AD 39 9C             LDA     debcyl          ;
00985B  2  8D 3C 9C             STA     Cdebcyl         ;
00985E  2  AD 3A 9C             LDA     debsec          ;
009861  2  8D 3D 9C             STA     Cdebsec         ;
009864  2               
009864  2               READFL1:
009864  2  A9 46                LDA     #CFD_READ|CFD_MFM; BIT 6 SETS MFM, 06H IS READ COMMAND
009866  2  8D 40 9C             STA     FCMD            ; SET COMMAND
009869  2  20 2F 99             JSR     DSKOP           ; DO DISK OPERATION
00986C  2               
00986C  2  C9 00                CMP     #$00
00986E  2  F0 2B                BEQ     READFLDONE      ; OPERATION SUCCESSFUL
009870  2  EE 42 9C             INC     FLRETRY         ; LET'S RETRY
009873  2  AD 42 9C             LDA     FLRETRY
009876  2  C9 06                CMP     #FLOPPY_RETRIES
009878  2  D0 EA                BNE     READFL1
00987A  2  20 3B 9A             JSR     RECAL           ; AFTER X RETRIES, LET'S RECAL THE HEAD
00987D  2  20 0C 9A             JSR     SETTRACK        ;
009880  2  A9 00                LDA     #$00            ;
009882  2  8D 42 9C             STA     FLRETRY         ; MORE RETRIES!
009885  2  EE 43 9C             INC     FLRETRY1
009888  2  AD 43 9C             LDA     FLRETRY1
00988B  2  C9 02                CMP     #FLOPPY_RETRIES1
00988D  2  D0 D5                BNE     READFL1
00988F  2               
00988F  2  A9 FF                LDA     #$FF            ; RETRIES FAILED, INVALIDATE CACHE AND REPORT ERROR
009891  2  8D 3B 9C             STA     Cdebhead        ;
009894  2  8D 3C 9C             STA     Cdebcyl         ;
009897  2  8D 3D 9C             STA     Cdebsec         ;
00989A  2  60                   RTS                     ; A = $FF ON RETURN = OPERATION ERROR
00989B  2               READFLDONE:
00989B  2  A9 00                LDA     #$00            ; A = 0 ON RETURN = OPERATION OK
00989D  2  60                   RTS
00989E  2               
00989E  2               ;__FL_WRITE_SECTOR_______________________________________________________________________________________________________________
00989E  2               ;
00989E  2               ; 	WRITE A FLOPPY SECTOR
00989E  2               ;________________________________________________________________________________________________________________________________
00989E  2               ;
00989E  2               FL_WRITE_SECTOR:
00989E  2  AD 37 9C             LDA     HARDWARE_DETCT
0098A1  2  C9 00                CMP     #$00
0098A3  2  F0 01                BEQ     :+
0098A5  2  60                   RTS
0098A6  2               :
0098A6  2  20 24 98             JSR     FL_READ_SECTOR_RAW
0098A9  2  20 37 94             JSR     BLKSECR512
0098AC  2               
0098AC  2               FL_WRITE_SECTOR_RAW:
0098AC  2  A9 00                LDA     #$00
0098AE  2  8D 42 9C             STA     FLRETRY         ; BLANK RETRIES
0098B1  2  8D 43 9C             STA     FLRETRY1
0098B4  2  A9 FF                LDA     #$FF
0098B6  2  8D 3B 9C             STA     Cdebhead        ; INVALIDATE CACHE
0098B9  2  8D 3C 9C             STA     Cdebcyl         ;
0098BC  2  8D 3D 9C             STA     Cdebsec         ;
0098BF  2               
0098BF  2               WRITEFL1:
0098BF  2  A9 45                LDA     #CFD_WRITE|CFD_MFM; BIT 6 SETS MFM, 05H IS WRITE COMMAND
0098C1  2  8D 40 9C             STA     FCMD
0098C4  2  20 2F 99             JSR     DSKOP
0098C7  2               
0098C7  2  C9 00                CMP     #$00
0098C9  2  F0 2B                BEQ     WRITEFLDONE
0098CB  2  EE 42 9C             INC     FLRETRY
0098CE  2  AD 42 9C             LDA     FLRETRY
0098D1  2  C9 06                CMP     #FLOPPY_RETRIES
0098D3  2  D0 EA                BNE     WRITEFL1
0098D5  2  20 3B 9A             JSR     RECAL
0098D8  2  20 0C 9A             JSR     SETTRACK
0098DB  2  A9 00                LDA     #$00
0098DD  2  8D 42 9C             STA     FLRETRY
0098E0  2  EE 43 9C             INC     FLRETRY1
0098E3  2  AD 43 9C             LDA     FLRETRY1
0098E6  2  C9 02                CMP     #FLOPPY_RETRIES1
0098E8  2  D0 D5                BNE     WRITEFL1
0098EA  2  A9 FF                LDA     #$FF            ; INVALIDATE CACHE
0098EC  2  8D 3B 9C             STA     Cdebhead        ;
0098EF  2  8D 3C 9C             STA     Cdebcyl         ;
0098F2  2  8D 3D 9C             STA     Cdebsec         ;
0098F5  2  60                   RTS                     ; A = $FF ON RETURN = OPERATION ERROR
0098F6  2               WRITEFLDONE:
0098F6  2  A9 00                LDA     #$00            ; A = 0 ON RETURN = OPERATION OK
0098F8  2  60                   RTS
0098F9  2               
0098F9  2               
0098F9  2               ;__SETUP_FD_CHS__________________________________________________________________________________________________________________
0098F9  2               ;
0098F9  2               ; 	TRANSFORM DOS65 CHS TO FLOPPY
0098F9  2               ;________________________________________________________________________________________________________________________________
0098F9  2               ;
0098F9  2               SETUP_FD_CHS:
0098F9  2  AD 0C 05             LDA     sektrk          ; LOAD TRACK # (LOW BYTE)
0098FC  2  29 01                AND     #$01            ; FILTER OUT HEAD
0098FE  2  8D 38 9C             STA     debhead         ; STORE HEAD
009901  2  AD 0C 05             LDA     sektrk          ; SAVE TRACK IN A
009904  2  4A                   LSR     A               ; REMOVE HEAD BIT
009905  2  8D 39 9C             STA     debcyl          ; STORE IN TRACK
009908  2  AD 0E 05             LDA     seksec          ; LOAD SECTOR # (LOW BYTE)
00990B  2  4A                   LSR     A               ;
00990C  2  4A                   LSR     A               ; DIVIDE BY 4 (FOR BLOCKING)
00990D  2  8D 3A 9C             STA     debsec          ; STORE IN SECTOR
009910  2               
009910  2                       .IF     USEDSKY=1 || USEDSKYNG=1
009910  2                           PRTDBG  "DSKY OUTPUT 1$"
009910  2  AD 13 05                 LDA     sekdsk
009913  2  8D 08 05                 STA     DSKY_HEXBUF
009916  2  AD 39 9C                 LDA     debcyl
009919  2  8D 09 05                 STA     DSKY_HEXBUF+1
00991C  2  AD 38 9C                 LDA     debhead
00991F  2  8D 0A 05                 STA     DSKY_HEXBUF+2
009922  2  AD 3A 9C                 LDA     debsec
009925  2  8D 0B 05                 STA     DSKY_HEXBUF+3
009928  2  20 35 91                 JSR     DSKY_BIN2SEG
00992B  2  20 6E 91                 JSR     DSKY_SHOW
00992E  2                       .ENDIF
00992E  2               
00992E  2  60                   RTS
00992F  2               
00992F  2               ;__DSKOP__________________________________________________________________________________________________________________________
00992F  2               ;
00992F  2               ; 	PERFORM A DISK OPERATION
00992F  2               ;________________________________________________________________________________________________________________________________
00992F  2               ;
00992F  2               DSKOP:
00992F  2  78                   SEI
009930  2  20 AA 9A             JSR     CHECKINT        ; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
009933  2  C9 FF                CMP     #$FF            ; DID IT RETURN WITH ERROR CODE?
009935  2  F0 10                BEQ     DSKEXIT         ; IF YES, EXIT WITH ERROR CODE
009937  2               ;
009937  2  20 0C 9A             JSR     SETTRACK        ; PERFORM SEEK TO TRACK
00993A  2               ;
00993A  2  AD 40 9C             LDA     FCMD            ; WHAT COMMAND IS PENDING?
00993D  2  C9 46                CMP     #CFD_READ|CFD_MFM; IS IT A READ COMMAND?
00993F  2  D0 03                BNE     GWRR_POLL       ;
009941  2  4C 9C 99             JMP     RDD_POLL        ;
009944  2               GWRR_POLL:
009944  2  4C E2 99             JMP     WRR_POLL        ;
009947  2               DSKEXIT:
009947  2  A9 00                LDA     #0              ; SET MOTOR OFF
009949  2  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
00994C  2  A9 FF                LDA     #$FF            ; SET IF ERROR
00994E  2  58                   CLI
00994F  2  60                   RTS
009950  2               
009950  2               SNDFDWR:
009950  2  18                   CLC
009951  2  AD 25 05             LDA     DSKUNIT         ; GET DISK UNIT NUMBER
009954  2  29 01                AND     #$01            ; MASK FOR TWO DRIVES.
009956  2  8D 3F 9C             STA     UNIT            ; PARK IT IN TEMP
009959  2  AD 38 9C             LDA     debhead         ; GET HEAD SELECTION
00995C  2  29 01                AND     #$01            ; INSURE SINGLE BIT
00995E  2  0A                   ASL     A               ;
00995F  2  0A                   ASL     A               ; MOVE HEAD TO BIT 2 POSITION
009960  2  0D 3F 9C             ORA     UNIT            ; OR HEAD TO UNIT BYTE IN COMMAND BLOCK
009963  2  8D 3F 9C             STA     UNIT            ; STORE IN UNIT
009966  2  AD 40 9C             LDA     FCMD            ;
009969  2  20 66 9A             JSR     PFDATA          ; PUSH COMMAND TO I8272
00996C  2  AD 3F 9C             LDA     UNIT            ;
00996F  2  20 66 9A             JSR     PFDATA          ;
009972  2  AD 39 9C             LDA     debcyl          ;
009975  2  20 66 9A             JSR     PFDATA          ;
009978  2  AD 38 9C             LDA     debhead         ;
00997B  2  20 66 9A             JSR     PFDATA          ;
00997E  2  18                   CLC                     ;
00997F  2  AD 3A 9C             LDA     debsec          ;
009982  2  69 01                ADC     #$01            ;
009984  2  20 66 9A             JSR     PFDATA          ;
009987  2  A9 02                LDA     #$02            ;
009989  2  20 66 9A             JSR     PFDATA          ; WHAT DENSITY
00998C  2  A9 09                LDA     #$09            ;
00998E  2  20 66 9A             JSR     PFDATA          ; ASSUME SC (SECTOR COUNT)  EOT
009991  2  A9 1B                LDA     #$1B            ;
009993  2  20 66 9A             JSR     PFDATA          ; WHAT GAP IS NEEDED
009996  2  A9 FF                LDA     #$FF            ; DTL, IS THE LAST COMMAND BYTE TO I8272
009998  2  20 91 9A             JSR     PFDATAS
00999B  2  60                   RTS
00999C  2               
00999C  2               
00999C  2               ; PERFORM READ
00999C  2               ; FROM READ TO READ MUST NOT EXCEED 25US WORST CASE MIN. (AT 2MHZ IS 2,000,000 CYCLES PER SECOND == 50 CYCLE BUDGET.)
00999C  2               ;
00999C  2               RDD_POLL:
00999C  2  A2 00                LDX     #$00
00999E  2  A0 00                LDY     #$00
0099A0  2  20 50 99             JSR     SNDFDWR         ;
0099A3  2               RDS1:
0099A3  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS  (4 CYCLES)
0099A6  2  10 FB                BPL     RDS1            ; FDC IS NOT READY, WAIT FOR IT (UP TO 4 CYCLES)
0099A8  2  29 20                AND     #%00100000      ; EXECUTION MODE? (2 CYCLES)
0099AA  2  F0 1D                BEQ     DSKOPEND        ; NO, ERROR
0099AC  2               RDS1A:
0099AC  2  AD 31 03             LDA     FDC_DATA        ; GET DATA (4 CYCLES)
0099AF  2  99 E6 94             STA     hstbuf,Y        ; WRITE IT (5 CYCLES)
0099B2  2  C8                   INY                     ; (2 CYCLES)
0099B3  2  D0 EE                BNE     RDS1            ; KEEP GOING (UP TO 4 CYCLES)   TOTAL =
0099B5  2  A2 00                LDX     #$00
0099B7  2               RDS2:
0099B7  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS
0099BA  2  10 FB                BPL     RDS2            ; FDC IS NOT READY, WAIT FOR IT (UP TO 4 CYCLES)
0099BC  2  29 20                AND     #%00100000      ; EXECUTION MODE?
0099BE  2  F0 09                BEQ     DSKOPEND        ; NO, ERROR
0099C0  2               RDS2A:
0099C0  2  AD 31 03             LDA     FDC_DATA        ; GET DATA
0099C3  2  99 E6 95             STA     hstbuf+256,Y    ; WRITE IT
0099C6  2  C8                   INY
0099C7  2  D0 EE                BNE     RDS2            ; KEEP GOING
0099C9  2               DSKOPEND:
0099C9  2  AD 37 03             LDA     FDC_TC
0099CC  2  20 58 9B             JSR     FDDELAY
0099CF  2               ;
0099CF  2  20 F3 9A             JSR     GFDATA          ;GET ERROR TYPE
0099D2  2  8D 3E 9C             STA     FLERR
0099D5  2               ;* CLEAR OUT ANY REMAINING DATA
0099D5  2               RESUL3:
0099D5  2  20 F3 9A             JSR     GFDATA          ;READ BYTE FROM FDC
0099D8  2  C9 00                CMP     #$00
0099DA  2  D0 F9                BNE     RESUL3          ;CLEAR THEM ALL
0099DC  2  AD 3E 9C             LDA     FLERR           ;
0099DF  2  29 C0                AND     #%11000000      ;
0099E1  2  60                   RTS
0099E2  2               
0099E2  2               
0099E2  2               WRR_POLL:
0099E2  2  20 50 99             JSR     SNDFDWR         ;
0099E5  2               WRS1:   ;
0099E5  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS
0099E8  2  10 FB                BPL     WRS1            ; NOT READY
0099EA  2  29 20                AND     #%00100000      ; EXECUTION MODE?
0099EC  2  F0 1B                BEQ     WRS3            ; NO, ERROR
0099EE  2  B9 E6 94             LDA     hstbuf,Y        ; WRITE IT
0099F1  2  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
0099F4  2  C8                   INY
0099F5  2  D0 EE                BNE     WRS1            ; DO NEXT
0099F7  2               WRS2:   ;
0099F7  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS
0099FA  2  10 FB                BPL     WRS2            ; NOT READY
0099FC  2  29 20                AND     #%00100000      ; EXECUTION MODE?
0099FE  2  F0 09                BEQ     WRS3            ; NO, ERROR
009A00  2  B9 E6 95             LDA     hstbuf+256,Y    ; WRITE IT
009A03  2  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
009A06  2  C8                   INY
009A07  2  D0 EE                BNE     WRS2            ; DO NEXT
009A09  2               WRS3:
009A09  2  4C C9 99             JMP     DSKOPEND        ;
009A0C  2               
009A0C  2               
009A0C  2               ;__SETTRACK__________________________________________________________________________________________________________________________
009A0C  2               ;
009A0C  2               ; 	SEEK TO A TRACK ON GIVEN UNIT
009A0C  2               ; 	A: TRACK #
009A0C  2               ;________________________________________________________________________________________________________________________________
009A0C  2               ;
009A0C  2               SETTRACK:
009A0C  2  A9 0C                LDA     #DOR_INIT
009A0E  2  0D 25 05             ORA     DSKUNIT         ; SET MOTOR ON
009A11  2  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
009A14  2               
009A14  2               ; ANY INTERUPT PENDING
009A14  2               ; IF YES FIND OUT WHY/CLEAR
009A14  2  20 AA 9A             JSR     CHECKINT        ; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
009A17  2  C9 FF                CMP     #$FF            ; DID IT RTSURN WITH ERROR CODE?
009A19  2  D0 03                BNE     SETTRK1
009A1B  2  4C 65 9A             JMP     SETTRKEXIT      ;
009A1E  2               
009A1E  2               ;
009A1E  2               SETTRK1:
009A1E  2  AD 39 9C             LDA     debcyl          ; GET TRACK
009A21  2  C9 00                CMP     #$00            ;
009A23  2  F0 16                BEQ     RECAL           ; IF 0 PERFORM RECAL INSTEAD OF SEEK
009A25  2  A9 0F                LDA     #CFD_SEEK       ; SEEK COMMAND
009A27  2  20 66 9A             JSR     PFDATA          ; PUSH COMMAND
009A2A  2  AD 25 05             LDA     DSKUNIT         ; SAY WHICH UNIT
009A2D  2  29 01                AND     #$01
009A2F  2  20 66 9A             JSR     PFDATA          ; SEND THAT
009A32  2  AD 39 9C             LDA     debcyl          ; TO WHAT TRACK
009A35  2  20 66 9A             JSR     PFDATA          ; SEND THAT TOO
009A38  2  4C 50 9A             JMP     WAINT           ; WAIT FOR INTERRUPT SAYING DONE
009A3B  2               RECAL:
009A3B  2  A9 0C                LDA     #DOR_INIT
009A3D  2  0D 25 05             ORA     DSKUNIT         ; SET MOTOR ON
009A40  2  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
009A43  2  A9 07                LDA     #CFD_RECAL      ; RECAL TO TRACK 0
009A45  2  20 66 9A             JSR     PFDATA          ; SEND IT
009A48  2  AD 25 05             LDA     DSKUNIT         ; SAY WHICH UNIT
009A4B  2  29 01                AND     #$01
009A4D  2  20 66 9A             JSR     PFDATA          ; SEND THAT TOO
009A50  2               ;
009A50  2               WAINT:
009A50  2  48                   PHA
009A51  2  8A                   TXA
009A52  2  48                   PHA
009A53  2  A2 64                LDX     #100
009A55  2  20 5D 9B             JSR     FDVDELAY
009A58  2  68                   PLA
009A59  2  AA                   TAX
009A5A  2  68                   PLA
009A5B  2               :
009A5B  2  20 AA 9A             JSR     CHECKINT
009A5E  2  AD 30 03             LDA     FDC_MSR         ; READ SEEK STATUS
009A61  2  29 0F                AND     #%00001111      ; ANY DRIVES SEEKING?
009A63  2  D0 F6                BNE     :-              ; YES, WAIT FOR THEM
009A65  2               ;
009A65  2               SETTRKEXIT:
009A65  2  60                   RTS
009A66  2               
009A66  2               ;__PFDATA__________________________________________________________________________________________________________________________
009A66  2               ;
009A66  2               ; WRITE A COMMAND OR PARAMETER SEQUENCE
009A66  2               ;
009A66  2               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
009A66  2               ;	RQM  DIO
009A66  2               ;	0	0	BUSY
009A66  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
009A66  2               ;	1	1	BYTE FOR READ BY HOST PENDING
009A66  2               ;	0	1	BUSY
009A66  2               ;
009A66  2               ;________________________________________________________________________________________________________________________________
009A66  2               ;
009A66  2               PFDATA:
009A66  2  48                   PHA                     ; SAVE DATA BYTE
009A67  2  A0 00                LDY     #$00
009A69  2               WRF1:
009A69  2  AD 30 03             LDA     FDC_MSR         ; READ FDC STATUS
009A6C  2  AA                   TAX
009A6D  2  29 80                AND     #$80            ;
009A6F  2  D0 07                BNE     :+
009A71  2  C8                   INY
009A72  2  D0 F5                BNE     WRF1            ; FDC IS NOT READY, WAIT FOR IT
009A74  2  68                   PLA
009A75  2  A9 FF                LDA     #$FF
009A77  2  60                   RTS
009A78  2               :
009A78  2  8A                   TXA
009A79  2  29 40                AND     #$40            ; TEST DIO BIT
009A7B  2  D0 0E                BNE     WRF2            ; FDC IS OUT OF SYNC
009A7D  2  68                   PLA                     ; RESTORE DATA
009A7E  2  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
009A81  2  20 58 9B             JSR     FDDELAY
009A84  2  20 58 9B             JSR     FDDELAY
009A87  2  20 58 9B             JSR     FDDELAY
009A8A  2  60                   RTS
009A8B  2               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
009A8B  2               WRF2:
009A8B  2  AD 31 03             LDA     FDC_DATA        ; READ DATA REGISTER
009A8E  2  4C 69 9A             JMP     WRF1            ; AND CONTINUE
009A91  2               
009A91  2               ;__PFDATAS_________________________________________________________________________________________________________________________
009A91  2               ;
009A91  2               ; WRITE A COMMAND OR PARAMETER SEQUENCE (NO PAUSE)
009A91  2               ;
009A91  2               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
009A91  2               ;	RQM  DIO
009A91  2               ;	0	0	BUSY
009A91  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
009A91  2               ;	1	1	BYTE FOR READ BY HOST PENDING
009A91  2               ;	0	1	BUSY
009A91  2               ;
009A91  2               ;________________________________________________________________________________________________________________________________
009A91  2               ;
009A91  2               PFDATAS:
009A91  2  48                   PHA                     ; SAVE DATA BYTE
009A92  2               WRF1S:
009A92  2  AD 30 03             LDA     FDC_MSR         ; READ FDC STATUS
009A95  2  AA                   TAX
009A96  2  29 80                AND     #$80            ;
009A98  2  F0 F8                BEQ     WRF1S           ; FDC IS NOT READY, WAIT FOR IT
009A9A  2  8A                   TXA
009A9B  2  29 40                AND     #$40            ; TEST DIO BIT
009A9D  2  D0 05                BNE     WRF2S           ; FDC IS OUT OF SYNC
009A9F  2  68                   PLA                     ; RESTORE DATA
009AA0  2  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
009AA3  2  60                   RTS
009AA4  2               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
009AA4  2               WRF2S:
009AA4  2  AD 31 03             LDA     FDC_DATA        ; READ DATA REGISTER
009AA7  2  4C 92 9A             JMP     WRF1S           ; AND CONTINUE
009AAA  2               
009AAA  2               
009AAA  2               
009AAA  2               ;__CHECKINT__________________________________________________________________________________________________________________________
009AAA  2               ;
009AAA  2               ; CHECK FOR ACTIVE FDC INTERRUPTS BEFORE GIVING I8272 COMMANDS
009AAA  2               ; POLL RQM FOR WHEN NOT BUSY AND THEN SEND FDC
009AAA  2               ; SENSE INTERRUPT COMMAND.  IF IT RTSURNS WITH NON ZERO
009AAA  2               ; ERROR CODE, PASS BACK TO JSRING ROUTINE FOR HANDLING
009AAA  2               ;________________________________________________________________________________________________________________________________
009AAA  2               ;
009AAA  2               CHECKINT:
009AAA  2  A0 00                LDY     #$00
009AAC  2               :
009AAC  2  AD 30 03             LDA     FDC_MSR         ; READING OR WRITING IS KEYS TO D7 RQM
009AAF  2  29 80                AND     #$80
009AB1  2  D0 09                BNE     :+              ; WAIT FOR RQM TO BE TRUE. WAIT UNTIL DONE
009AB3  2  20 58 9B             JSR     FDDELAY
009AB6  2  C8                   INY
009AB7  2  D0 F3                BNE     :-
009AB9  2  4C C4 9A             JMP     ERRCLR
009ABC  2               
009ABC  2               :
009ABC  2  AD 30 03             LDA     FDC_MSR         ; READING OR WRITING IS KEYS TO D7 RQM
009ABF  2  29 40                AND     #$40            ; WAITING FOR INPUT?
009AC1  2  F0 16                BEQ     SENDINT
009AC3  2  60                   RTS
009AC4  2               
009AC4  2               ERRCLR:
009AC4  2  A0 00                LDY     #$00
009AC6  2               :
009AC6  2  AD 31 03             LDA     FDC_DATA        ; CLEAR THE JUNK OUT OF DATA REGISTER
009AC9  2  AD 30 03             LDA     FDC_MSR         ; CHECK WITH RQM
009ACC  2  29 80                AND     #$80            ; IF STILL NOT READY, READ OUT MORE JUNK
009ACE  2  D0 06                BNE     :+              ;
009AD0  2  20 58 9B             JSR     FDDELAY
009AD3  2  C8                   INY
009AD4  2  D0 F0                BNE     :-
009AD6  2               :
009AD6  2  A9 FF                LDA     #$FF            ; RETURN ERROR CODE -1
009AD8  2               ;
009AD8  2  60                   RTS
009AD9  2               
009AD9  2               ;__SENDINT__________________________________________________________________________________________________________________________
009AD9  2               ;
009AD9  2               ; SENSE INTERRUPT COMMAND
009AD9  2               ;________________________________________________________________________________________________________________________________
009AD9  2               ;
009AD9  2               SENDINT:
009AD9  2  A9 08                LDA     #CFD_SENSEINT   ; SENSE INTERRUPT COMMAND
009ADB  2  20 66 9A             JSR     PFDATA          ; SEND IT
009ADE  2  20 F3 9A             JSR     GFDATA          ; GET RESULTS
009AE1  2  8D 41 9C             STA     ST0             ; STORE THAT
009AE4  2  29 C0                AND     #$C0            ; MASK OFF INTERRUPT STATUS BITS
009AE6  2  C9 80                CMP     #$80            ; CHECK IF INVALID COMMAND
009AE8  2  F0 08                BEQ     ENDSENDINT      ; YES, EXIT
009AEA  2  20 F3 9A             JSR     GFDATA          ; GET ANOTHER (STATUS CODE 1)
009AED  2  AD 41 9C             LDA     ST0             ; GET FIRST ONE
009AF0  2  29 C0                AND     #$C0            ; MASK OFF ALL BUT INTERRUPT CODE 00 IS NORMAL
009AF2  2               ENDSENDINT:
009AF2  2  60                   RTS                     ; ANYTHING ELSE IS AN ERROR
009AF3  2               
009AF3  2               
009AF3  2               ;__GFDATA__________________________________________________________________________________________________________________________
009AF3  2               ;
009AF3  2               ; GET DATA FROM FLOPPY CONTROLLER
009AF3  2               ;
009AF3  2               ; TRANSFERS ARE SYNCHONIZED BYT MSR D7 <RQM> AND D6 <DIO>
009AF3  2               ;	RQM  DIO
009AF3  2               ;	0	0	BUSY
009AF3  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
009AF3  2               ;	1	1	BYTE FOR READ BY HOST PENDING
009AF3  2               ;	0	1	BUSY
009AF3  2               ;
009AF3  2               ;________________________________________________________________________________________________________________________________
009AF3  2               ;
009AF3  2               GFDATA:
009AF3  2  A0 00                LDY     #$00
009AF5  2               :
009AF5  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS
009AF8  2  AA                   TAX                     ;
009AF9  2  29 80                AND     #%10000000      ; NOT READY, WAIT
009AFB  2  D0 06                BNE     :+              ;
009AFD  2  C8                   INY
009AFE  2  D0 F5                BNE     :-
009B00  2  A9 00                LDA     #$00
009B02  2  60                   RTS
009B03  2               :
009B03  2  8A                   TXA
009B04  2  29 40                AND     #%01000000      ; ANY DATA FOR US?
009B06  2  F0 03                BEQ     GFDATA1         ; NO, SKIP IT
009B08  2  AD 31 03             LDA     FDC_DATA        ; GET FDC DATA
009B0B  2               GFDATA1:
009B0B  2  60                   RTS
009B0C  2               
009B0C  2               ;__FD_DETECT______________________________________________________________________________________________________________________
009B0C  2               ;
009B0C  2               ; 	DETECT FLOPPY HARDWARE
009B0C  2               ;________________________________________________________________________________________________________________________________
009B0C  2               FD_DETECT:
009B0C  2               ; BLINDLY RESET FDC (WHICH MAY OR MAY NOT EXIST)
009B0C  2  20 3A 9B             JSR     FC_RESETFDC     ; RESET FDC
009B0F  2               
009B0F  2  AD 30 03             LDA     FDC_MSR         ; READ MSR
009B12  2  C9 80                CMP     #$80
009B14  2  F0 0A                BEQ     FD_DETECT1      ; $80 IS OK
009B16  2  C9 D0                CMP     #$D0
009B18  2  F0 06                BEQ     FD_DETECT1      ; $D0 IS OK
009B1A  2  A9 FF                LDA     #$FF            ; NOT OK
009B1C  2  8D 37 9C             STA     HARDWARE_DETCT
009B1F  2  60                   RTS
009B20  2               ;
009B20  2               FD_DETECT1:
009B20  2  A2 64                LDX     #100
009B22  2  20 5D 9B             JSR     FDVDELAY        ; WAIT A BIT FOR FDC
009B25  2  AD 30 03             LDA     FDC_MSR         ; READ MSR AGAIN
009B28  2  C9 80                CMP     #$80
009B2A  2  F0 08                BEQ     :+              ; $80 IS OK
009B2C  2  C9 D0                CMP     #$D0
009B2E  2  A9 FF                LDA     #$FF            ; NOT OK
009B30  2  8D 37 9C             STA     HARDWARE_DETCT
009B33  2  60                   RTS
009B34  2               :
009B34  2  A9 00                LDA     #$00            ; OK
009B36  2  8D 37 9C             STA     HARDWARE_DETCT
009B39  2  60                   RTS
009B3A  2               
009B3A  2               FC_RESETFDC:
009B3A  2  AD 33 03             LDA     FDC_RESET
009B3D  2  AD 33 03             LDA     FDC_RESET
009B40  2  A2 96                LDX     #150
009B42  2  20 5D 9B             JSR     FDVDELAY        ; WAIT A BIT FOR FDC
009B45  2               
009B45  2  A9 00                LDA     #$00
009B47  2  8D 36 03             STA     FDC_DOR
009B4A  2  20 58 9B             JSR     FDDELAY
009B4D  2  A9 0C                LDA     #DOR_INIT
009B4F  2  8D 36 03             STA     FDC_DOR
009B52  2  A2 96                LDX     #150            ;
009B54  2  20 5D 9B             JSR     FDVDELAY
009B57  2  60                   RTS
009B58  2               
009B58  2               
009B58  2               FDDELAY:
009B58  2  48                   PHA
009B59  2  68                   PLA
009B5A  2  48                   PHA
009B5B  2  68                   PLA
009B5C  2  60                   RTS
009B5D  2               FDVDELAY:
009B5D  2  48                   PHA
009B5E  2  68                   PLA
009B5F  2  48                   PHA
009B60  2  68                   PLA
009B61  2  CA                   DEX
009B62  2  E0 00                CPX     #$00
009B64  2  D0 F7                BNE     FDVDELAY
009B66  2  60                   RTS
009B67  2               
009B67  2                       .IF     DRIVERS=1
009B67  2               ;*__FL_STORE_BOOT_IMAGE_______________________________________________________________________________
009B67  2               ;*
009B67  2               ;*  WRITE Boot image to block 0 of device
009B67  2               ;*
009B67  2               ;*  YA points to:
009B67  2               ;* 			DB 	Device Unit
009B67  2               ;*			DB 	RAM Page
009B67  2               ;*			DW 	Source Address
009B67  2               ;* 			DB	Image Length (Pages)
009B67  2               ;*____________________________________________________________________________________________________
009B67  2               FL_STORE_BOOT_IMAGE:
009B67  2               
009B67  2  85 14                    STA     pointr          ; SET POINTR TO INFO BLOCK
009B69  2  84 15                    STY     pointr+1
009B6B  2  A9 58                    LDA     #<BOOTUNIT
009B6D  2  85 2A                    STA     room
009B6F  2  A9 8F                    LDA     #>BOOTUNIT
009B71  2  85 2B                    STA     room+1
009B73  2  A0 00                    LDY     #$00            ; COPY PARAMETERS TO USEFUL AREA
009B75  2               :
009B75  2  B1 14                    LDA     (pointr),Y
009B77  2  91 2A                    STA     (room),Y
009B79  2  C8                       INY
009B7A  2  C0 05                    CPY     #05
009B7C  2  D0 F7                    BNE     :-
009B7E  2               
009B7E  2  A9 00                    LDA     #$00
009B80  2  8D 0C 05                 STA     sektrk
009B83  2  8D 0D 05                 STA     sektrk+1
009B86  2  8D 0E 05                 STA     seksec          ;
009B89  2  8D 0F 05                 STA     seksec+1        ;
009B8C  2  AD 25 05                 LDA     DSKUNIT
009B8F  2  8D 58 8F                 STA     BOOTUNIT
009B92  2               
009B92  2  20 7E 94                 JSR     INIT_PAGE_COPY  ; COPY PAGE COPY CODE TO LORAM
009B95  2  AD 5A 8F                 LDA     BOOTSOURCE      ; SETUP SOURCE POINTER
009B98  2  85 14                    STA     pointr
009B9A  2  AD 5B 8F                 LDA     BOOTSOURCE+1
009B9D  2  85 15                    STA     pointr+1
009B9F  2               
009B9F  2               :
009B9F  2  AD 59 8F                 LDA     BOOTRAMPAGE
009BA2  2  20 00 04                 JSR     COPY_PAGE_TO_HSTBUF; COPY 512 BYTES AT POINTR TO HSTBUF (AND INC POINTER)
009BA5  2               
009BA5  2  20 AC 98                 JSR     FL_WRITE_SECTOR_RAW
009BA8  2  C9 FF                    CMP     #$FF
009BAA  2  F0 1F                    BEQ     FL_STORE_BOOT_IMAGE_ERROR
009BAC  2  EE 0E 05                 INC     seksec
009BAF  2  AD 0E 05                 LDA     seksec
009BB2  2  C9 24                    CMP     #36
009BB4  2  D0 08                    BNE     :+
009BB6  2  A9 00                    LDA     #00
009BB8  2  8D 0E 05                 STA     seksec
009BBB  2  EE 0C 05                 INC     sektrk
009BBE  2               :
009BBE  2  CE 5C 8F                 DEC     BOOTLENGTH
009BC1  2  AD 5C 8F                 LDA     BOOTLENGTH
009BC4  2  C9 00                    CMP     #$00
009BC6  2  D0 D7                    BNE     :--
009BC8  2  A9 00                    LDA     #$00            ; ZERO ON RETURN = OPERATION OK
009BCA  2  60                       RTS
009BCB  2               FL_STORE_BOOT_IMAGE_ERROR:
009BCB  2  A9 FF                    LDA     #$FF            ; 1 ON RETURN = OPERATION FAIL
009BCD  2  60                       RTS
009BCE  2               
009BCE  2               ;*__IDE_RESTORE_BOOT_IMAGE____________________________________________________________________________
009BCE  2               ;*
009BCE  2               ;*  READ Boot image from block 0 of device
009BCE  2               ;*
009BCE  2               ;*  YA points to:
009BCE  2               ;* 			DB 	Device Unit
009BCE  2               ;*			DB 	RAM Page
009BCE  2               ;*			DW 	Source Address
009BCE  2               ;* 			DB	Image Length (Pages)
009BCE  2               ;*____________________________________________________________________________________________________
009BCE  2               FL_RESTORE_BOOT_IMAGE:
009BCE  2               
009BCE  2  85 14                    STA     pointr          ; SET POINTR TO INFO BLOCK
009BD0  2  84 15                    STY     pointr+1
009BD2  2  A9 58                    LDA     #<BOOTUNIT
009BD4  2  85 2A                    STA     room
009BD6  2  A9 8F                    LDA     #>BOOTUNIT
009BD8  2  85 2B                    STA     room+1
009BDA  2  A0 00                    LDY     #$00            ; COPY PARAMETERS TO USEFUL AREA
009BDC  2               :
009BDC  2  B1 14                    LDA     (pointr),Y
009BDE  2  91 2A                    STA     (room),Y
009BE0  2  C8                       INY
009BE1  2  C0 05                    CPY     #05
009BE3  2  D0 F7                    BNE     :-
009BE5  2               
009BE5  2  A9 00                    LDA     #$00
009BE7  2  A9 00                    LDA     #$00
009BE9  2  8D 0C 05                 STA     sektrk
009BEC  2  8D 0D 05                 STA     sektrk+1
009BEF  2  8D 0E 05                 STA     seksec          ;
009BF2  2  8D 0F 05                 STA     seksec+1        ;
009BF5  2  AD 25 05                 LDA     DSKUNIT
009BF8  2  8D 58 8F                 STA     BOOTUNIT
009BFB  2               
009BFB  2               
009BFB  2  20 7E 94                 JSR     INIT_PAGE_COPY  ; COPY PAGE COPY CODE TO LORAM
009BFE  2  AD 5A 8F                 LDA     BOOTSOURCE      ; SETUP SOURCE POINTER
009C01  2  85 14                    STA     pointr
009C03  2  AD 5B 8F                 LDA     BOOTSOURCE+1
009C06  2  85 15                    STA     pointr+1
009C08  2               
009C08  2               :
009C08  2  20 24 98                 JSR     FL_READ_SECTOR_RAW
009C0B  2  C9 FF                    CMP     #$FF
009C0D  2  F0 25                    BEQ     FL_RESTORE_BOOT_IMAGE_ERROR
009C0F  2  AD 59 8F                 LDA     BOOTRAMPAGE
009C12  2  20 2D 04                 JSR     COPY_HSTBUF_TOPAGE; COPY 512 BYTES FROM HSTBUF TO POINTR HSTBUF (AND INC POINTER)
009C15  2  EE 0E 05                 INC     seksec
009C18  2  AD 0E 05                 LDA     seksec
009C1B  2  C9 24                    CMP     #36
009C1D  2  D0 08                    BNE     :+
009C1F  2  A9 00                    LDA     #00
009C21  2  8D 0E 05                 STA     seksec
009C24  2  EE 0C 05                 INC     sektrk
009C27  2               :
009C27  2  CE 5C 8F                 DEC     BOOTLENGTH
009C2A  2  AD 5C 8F                 LDA     BOOTLENGTH
009C2D  2  C9 00                    CMP     #$00
009C2F  2  D0 D7                    BNE     :--
009C31  2  A9 00                    LDA     #$00            ; ZERO ON RETURN = OPERATION OK
009C33  2  60                       RTS
009C34  2               FL_RESTORE_BOOT_IMAGE_ERROR:
009C34  2  A9 FF                    LDA     #$FF            ; 1 ON RETURN = OPERATION FAIL
009C36  2  60                       RTS
009C37  2                       .ENDIF
009C37  2               
009C37  2               
009C37  2               HARDWARE_DETCT:
009C37  2  00                   .BYTE   0               ; HARDWARE DETECTED
009C38  2               debhead:
009C38  2  00                   .BYTE   0               ; DEBLOCKED HEAD
009C39  2               debcyl:
009C39  2  00                   .BYTE   0               ; DEBLOCKED CYLINDER
009C3A  2               debsec:
009C3A  2  00                   .BYTE   0               ; DEBLOCKED SECTOR
009C3B  2               Cdebhead:
009C3B  2  00                   .BYTE   0               ; DEBLOCKED HEAD (cache)
009C3C  2               Cdebcyl:
009C3C  2  00                   .BYTE   0               ; DEBLOCKED CYLINDER (cache)
009C3D  2               Cdebsec:
009C3D  2  00                   .BYTE   0               ; DEBLOCKED SECTOR (cache)
009C3E  2               FLERR:
009C3E  2  00                   .BYTE   $00             ;
009C3F  2               UNIT:
009C3F  2  00                   .BYTE   $00             ;
009C40  2               FCMD:
009C40  2  00                   .BYTE   0               ; COMMAND READ OR WRITE,
009C41  2               ST0:
009C41  2  00                   .BYTE   0               ; COMMAND READ OR WRITE,
009C42  2               FLRETRY:
009C42  2  00                   .BYTE   00
009C43  2               FLRETRY1:
009C43  2  00                   .BYTE   00
009C44  2               
009C44  1               
009C44  1               ;// TODO: this should be dependent on "active console. . ." and should be a driver call
009C44  1               CONSOLE_OUT:
009C44  1  20 D9 88             JSR     WRSER1
009C47  1  60                   RTS
009C48  1               
009C48  1               ;// TODO: CONSOLE_IN
009C48  1               
009C48  1               
009C48  1  EA                   NOP
009C49  1  EA                   NOP
009C4A  1  EA                   NOP
009C4B  1  EA                   NOP
009C4C  1  EA                   NOP
009C4D  1  EA                   NOP
009C4E  1  EA                   NOP
009C4F  1  EA                   NOP
009C50  1  EA                   NOP
009C51  1  EA                   NOP
009C52  1               
009C52  1                       .END
