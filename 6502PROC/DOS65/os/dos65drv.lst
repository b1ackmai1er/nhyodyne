ca65 V2.18 - Ubuntu 2.19-1
Main file   : dos65drv.asm
Current file: dos65drv.asm

000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               ;
000000r 1               ;	Nhyodyne dos/65 banked driver code
000000r 1               ;       Intended for RAM BANK $0C
000000r 1               ;
000000r 1               ;  DWERNER 04/24/2022 	Initial
000000r 1               ;________________________________________________________________________________________________________________________________
000000r 1               
000000r 1                       .SEGMENT "DRIVERS"
000000r 1                       .ORG    $8800
008800  1                       .INCLUDE "DOSDEFN.ASM"  ; base addresses and definitions
008800  2               ;________________________________________________________________________________________________________________________________
008800  2               ;
008800  2               ;	Nhyodyne dos/65 base addresses and definitions
008800  2               ;
008800  2               ;  DWERNER 04/24/2022 	Initial
008800  2               ;________________________________________________________________________________________________________________________________
008800  2               
008800  2               ;base addresses and definitions
008800  2               btejmp          = $0100         ; warm boot jump
008800  2               pemjmp          = $0103         ; jump to pem
008800  2               iostat          = $0106         ; i/o status
008800  2               dflfcb          = $0107         ; default fcb
008800  2               dflbuf          = $0128         ; default buffer
008800  2               memmovr         = $0200         ; 0200-02ff subr to move data from ram/rom disks
008800  2               MD_PAGERA       = $0200         ; PAGE DRIVER ADDRESS
008800  2               
008800  2               IO              = $0300         ; 0300-03FF Memory mapped IO
008800  2               MPCL_ROM        = $037C         ; ROM MAPPER
008800  2               MPCL_RAM        = $0378         ; RAM MAPPER
008800  2               
008800  2               MD_PAGEBU       = $0400         ; 0400-04FF PAGE BUFFER ADDRESS
008800  2               MD_PAGESE       = pointr        ; PAGE SECTOR STORAGE
008800  2               
008800  2               ;
008800  2               ; DRIVER WORKING STORAGE
008800  2               ;
008800  2               DSKY_BUF        = $0500         ; Eight Bytes DSKY display buffer
008800  2               DSKY_BUFLEN     = 8             ;
008800  2               DSKY_HEXBUF     = $0508         ; Four Bytes DSKY hex buffer
008800  2               DSKY_HEXBUFLEN  = 4             ;
008800  2               sektrk          = $050C         ; seek track number
008800  2               seksec          = $050E         ; seek sector number
008800  2               debcyll         = $0510         ; DEBLOCKED CYLINDER LSB
008800  2               debcylm         = $0511         ; DEBLOCKED CYLINDER MSB
008800  2               debsehd         = $0512         ; DEBLOCKED SECTOR AND HEAD (HS)
008800  2               sekdsk          = $0513         ; seek disk number
008800  2               dskcfg          = $0514         ; 16 bytes disk configuration table
008800  2               DSKUNIT         = $0525         ; seek disk number
008800  2               
008800  2               
008800  2               tea             = $800          ;tea start
008800  2               
008800  2               ;zero page for setup
008800  2               trknum          = $02           ;current track
008800  2               dcbadd          = $04           ;dcb address
008800  2               nmsstr          = $06           ;number system tracks
008800  2               nsectr          = $08           ;number sectors per track
008800  2               ttlsec          = $0A           ;total sectors to write
008800  2               trkcnt          = ttlsec
008800  2               size            = $0B           ;ascii size
008800  2               lokim           = $0D           ;low kim limit
008800  2               hikim           = $0F           ;high kim limit
008800  2               offset          = $11           ;relocation offset
008800  2               kimcnt          = $13           ;kim counter
008800  2               pointr          = $14           ;pointer
008800  2               lengt           = $16           ;inst length
008800  2               point           = $17           ;relocate pointer
008800  2               adjust          = $19           ;relocate distance
008800  2               kimpnt          = $1B           ;kim file index
008800  2               savex           = $1C           ;save for x
008800  2               savey           = $1D           ;save for y
008800  2               number          = $1E           ;input pack buffer
008800  2               dstdrv          = $20           ;destination drive
008800  2               defalt          = $21           ;default drive
008800  2               seccnt          = $22           ;sector count
008800  2               secnum          = $24           ;sector number
008800  2               curccm          = $26           ;start of current ccm
008800  2               simlng          = $28           ;length of sim
008800  2               room            = $2A           ;memory needed for sysgen
008800  2               stksav          = $2C           ;save stack register
008800  2               frstsc          = $2D           ;first sector number of disk
008800  2               dskcfpc         = $2E           ;pointer to disk configuration table
008800  2               cmdlnp          = $30           ;pointer to command line buffer
008800  2               farfunct        = $32           ;function to call in driver area
008800  2               farpointer      = $33           ;WORD POINTER to call in driver area
008800  2               IRQVECTOR       = $35           ; VECTOR FOR USER IRQ RTN
008800  2               NMIVECTOR       = $37           ; VECTOR FOR USER NMI RTN
008800  2               zptemp          = $39
008800  2               STACKA          = $3A           ; TEMP VAR FOR STACK MANIPULATION
008800  2               lastzp          = $3B
008800  2               ;pem constants on entry to write
008800  2               wrall           = 0             ;write to allocated
008800  2               wrdir           = 1             ;write to directory
008800  2               wrual           = 2             ;write to unallocated
008800  2               
008800  2               ;page zero and system ram assignments
008800  2               DEST            = $EC           ;pointer for OutMsg
008800  2               SRC             = $EE           ;pointer for OutMsg
008800  2               OUTMSG_W        = $F0           ;pointer for OutMsg
008800  2               mvepnt          = $f2           ;host buffer location
008800  2               dmaadr          = $f4           ;pointer for r/w
008800  2               
008800  2               ;fixed parameters
008800  2               lf              = $a            ;linefeeed
008800  2               cr              = $d            ;return
008800  2               eof             = $1a           ;end of file
008800  2               null            = 0             ;null
008800  2               ctlc            = 3             ;abort
008800  2               ctle            = 5             ;physical cr lf
008800  2               ctli            = 9             ;tab character
008800  2               ctlp            = $10           ;toggle printer
008800  2               ctlr            = $12           ;repeat line
008800  2               ctls            = $13           ;freeze
008800  2               ctlx            = $18           ;cancel
008800  2               semico          = $3b           ;semicolon
008800  2               delete          = $08           ;delete character
008800  2               numcmd          = 36            ;number commands
008800  2               
008800  2               BANKED_DRIVER_DISPATCHER=$8800  ; LOCATION OF DRIVER DISPATCHER
008800  2               DEBUG           = 0             ; assemble with debug information on
008800  2               
008800  2               
008800  2               USESERIAL       = 1             ; SET TO ONE SERIAL CONSOLE IO
008800  2               USEFLOPPYA      = 0             ; SET TO ONE FOR FLOPPY = "A"
008800  2               USEFLOPPYB      = 0             ; SET TO ONE FOR FLOPPY = "B"
008800  2               USEIDEC         = 1             ; SET TO ONE FOR IDE HDD="C"
008800  2               USEDSKY         = 0             ; SEND INFO TO DSKY
008800  2               USEDSKYNG       = 1             ; SEND INFO TO DSKYNG
008800  2               DSKY_KBD        = 1             ; USE DSKY KEYBOARD?
008800  2               DEFDRV          = 2             ; SET TO DEFAULT DRIVE LETTER
008800  2               USEDISKIOV1     = 0             ; Floppy and IDE card is  DISK IO V1
008800  2               USEDISKIOV3     = 0             ; Floppy and IDE card is  DISK IO V3
008800  2               
008800  2               FLPA35          = 0             ; set to 1 if floppy a is A 3.5" 80 track drive (0= 5.25" 40 track drive)
008800  2               FLPB35          = 0             ; set to 1 if floppy a is B 3.5" 80 track drive (0= 5.25" 40 track drive)
008800  2               
008800  2               DSKYOSC         = 1000000
008800  2               USEROM          = 0
008800  2               
008800  1               
008800  1               ; for Nhyodyne:
008800  1               ; RAM BANK $0C is RAM area for Drivers
008800  1               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
008800  1               ; RAM BANK $0F is fixed bank $0000-$7FFF
008800  1               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code (AS A SECONDARY CPU)
008800  1               
008800  1               ;       Area from $0C:8000 to $0C:8800 reserved for work RAM for drivers (FOR SECONDARY CPU, UNDER ROMWBW)
008800  1               ;       Area from $0C:8000 to $0C:8800 reserved for ROM for drivers (FOR PRIMARY CPU, NO ROMWBW)
008800  1               ;
008800  1               
008800  1               ;__DISPATCHER________________________________________________________________________________________
008800  1               ;
008800  1               ;  Function dispatcher
008800  1               ;  function to call is located in "farfunct"
008800  1               ;____________________________________________________________________________________________________
008800  1               ;
008800  1  48                   PHA
008801  1  8A                   TXA
008802  1  48                   PHA
008803  1  A5 32                LDA     farfunct
008805  1  0A                   ASL     A               ; DOUBLE NUMBER FOR TABLE LOOKUP
008806  1  AA                   TAX
008807  1  BD 17 88             LDA     DISPATCHTABLE,X
00880A  1  85 33                STA     farpointer
00880C  1  BD 18 88             LDA     DISPATCHTABLE+1,X
00880F  1  85 34                STA     farpointer+1
008811  1               
008811  1  68                   PLA
008812  1  AA                   TAX
008813  1  68                   PLA
008814  1  6C 33 00             JMP     (farpointer)
008817  1               
008817  1               
008817  1               DISPATCHTABLE:
008817  1  D5 88                .WORD   WRSER1          ; FUNCTION 00 - WRITE SERIAL PORT
008819  1  E4 88                .WORD   RDSER1          ; FUNCTION 01 - READ SERIAL PORT
00881B  1  F4 88                .WORD   RDSER1W         ; FUNCTION 02 - READ SERIAL PORT (BLOCKING)
00881D  1  03 89                .WORD   SERIALSTATUS    ; FUNCTION 03 - GET SERIAL STATUS
00881F  1               
00881F  1  15 89                .WORD   PPIDE_INIT      ; FUNCTION 04 - called during OS init
008821  1  DD 8B                .WORD   IDE_READ_SECTOR ; FUNCTION 05 - read a sector from drive
008823  1  34 8C                .WORD   IDE_WRITE_SECTOR; FUNCTION 06 - write a sector to drive
008825  1               
008825  1  AB 8F                .WORD   DSKY_INIT       ; FUNCTION 07 -
008827  1  6A 91                .WORD   DSKY_SHOW       ; FUNCTION 08 -
008829  1  31 91                .WORD   DSKY_BIN2SEG    ; FUNCTION 09 -
00882B  1  B3 90                .WORD   DSKY_RESET      ; FUNCTION 10 -
00882D  1  CE 90                .WORD   DSKY_STAT       ; FUNCTION 11 -
00882F  1  DB 90                .WORD   DSKY_GETKEY     ; FUNCTION 12 -
008831  1  49 92                .WORD   DSKY_BEEP       ; FUNCTION 13 -
008833  1  7A 92                .WORD   DSKY_L1ON       ; FUNCTION 14 -
008835  1  91 92                .WORD   DSKY_L2ON       ; FUNCTION 15 -
008837  1  A8 92                .WORD   DSKY_L1OFF      ; FUNCTION 16 -
008839  1  BF 92                .WORD   DSKY_L2OFF      ; FUNCTION 17 -
00883B  1  2E 92                .WORD   DSKY_PUTLED     ; FUNCTION 18 -
00883D  1  F6 91                .WORD   DSKY_BLANK      ; FUNCTION 19 -
00883F  1               
00883F  1  5E 93                .WORD   MD_READ_SECTOR  ; FUNCTION 20 - read a sector from memory device
008841  1  9B 93                .WORD   MD_WRITE_SECTOR ; FUNCTION 21 - write a sector to memory device
008843  1  15 93                .WORD   MD_SHOW         ; FUNCTION 22 - md show information
008845  1               
008845  1  0F 98                .WORD   FL_READ_SECTOR  ; FUNCTION 23 - read a sector from floppy device
008847  1  98 98                .WORD   FL_WRITE_SECTOR ; FUNCTION 24 - write a sector to floppy device
008849  1  E2 96                .WORD   FL_SETUP        ; FUNCTION 25 - init floppy device
00884B  1  0F 98                .WORD   FL_READ_SECTOR  ; FUNCTION 26 - read a sector from floppy device
00884D  1  98 98                .WORD   FL_WRITE_SECTOR ; FUNCTION 27 - write a sector to floppy device
00884F  1               
00884F  1  4C 8E                .WORD   IDE_STORE_BOOT_IMAGE; FUNCTION 28 - save a boot image to a ppide device
008851  1  A1 8E                .WORD   IDE_RESTORE_BOOT_IMAGE; FUNCTION 29 - restore a boot image from a ppide device
008853  1  F6 8E                .WORD   IDE_CLEAR_TRACKS; FUNCTION 30 - clear tracks on a ppide device
008855  1               
008855  1               
008855  1               ;__DRIVERS___________________________________________________________________________________________
008855  1               ;
008855  1                       .INCLUDE "drvmacro.asm"
008855  2               ;__MACRO___________________________________________________________________________________________________________________
008855  2               ;
008855  2               ; 	Macros for the betterment of Mankind
008855  2               ;________________________________________________________________________________________________________________________________
008855  2               ;
008855  2               
008855  2               .macro          PRTDBG      message
008855  2               .LOCAL p1
008855  2               .LOCAL p2
008855  2               .LOCAL p3
008855  2               .LOCAL p4
008855  2               .LOCAL p5
008855  2                 .if     .paramcount <> 1
008855  2                       .error  "Too few parameters for macro PRTDBG"
008855  2                       .endif
008855  2                       .if DEBUG=1
008855  2                       PHA
008855  2                       txa
008855  2                       PHA
008855  2                       tya
008855  2                       PHA
008855  2                       LDX #$00
008855  2               p1:
008855  2                       LDA p4,x
008855  2                       INX
008855  2                       CMP #'$'
008855  2                       BEQ p2
008855  2                       JSR CONSOLE_OUT
008855  2                       JMP p1
008855  2               p2:
008855  2                       LDA #13
008855  2                       jsr CONSOLE_OUT
008855  2                       LDA #10
008855  2                       jsr CONSOLE_OUT
008855  2                       PLA
008855  2                       tay
008855  2                       PLA
008855  2                       tax
008855  2                       pla
008855  2                       JMP p5
008855  2               p4:
008855  2                       .BYTE message
008855  2               p5:
008855  2                       .endif
008855  2               .endmacro
008855  2               
008855  2               .macro          PRTS      message
008855  2               .LOCAL p1
008855  2               .LOCAL p2
008855  2               .LOCAL p3
008855  2               .LOCAL p4
008855  2               .LOCAL p5
008855  2                 .if     .paramcount <> 1
008855  2                       .error  "Too few parameters for macro PRTS"
008855  2                       .endif
008855  2                       PHA
008855  2                       TXA
008855  2                       PHA
008855  2                       tay
008855  2                       PHa
008855  2                       LDX #$00
008855  2               p1:
008855  2                       LDA p4,x
008855  2                       INX
008855  2                       CMP #'$'
008855  2                       BEQ p2
008855  2                       JSR CONSOLE_OUT
008855  2                       JMP p1
008855  2               p2:
008855  2                       PLA
008855  2                       tay
008855  2                       PLA
008855  2                       tax
008855  2                       pla
008855  2                       JMP p5
008855  2               p4:
008855  2                       .BYTE message
008855  2               p5:
008855  2               .endmacro
008855  2               
008855  2               .macro          DBGFLAG      character
008855  2                 .if     .paramcount <> 1
008855  2                       .error  "Too few parameters for macro DBGFLAG"
008855  2                       .endif
008855  2                       .if DEBUG=1
008855  2                       PHA
008855  2                       LDA #character
008855  2                       JSR CONSOLE_OUT
008855  2                       pla
008855  2                       .endif
008855  2               .endmacro
008855  2               
008855  2               
008855  2               ;__PRTHEXBYTE__________________________________________________
008855  2               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
008855  2               ;______________________________________________________________
008855  2               PRTHEXBYTE:
008855  2  48                   PHA
008856  2  85 3A                sta     STACKA
008858  2  8A                   txa
008859  2  48                   PHa
00885A  2  98                   tya
00885B  2  48                   PHA
00885C  2  A5 3A                lda     STACKA
00885E  2  AA                   TAX				; SAVE A REGISTER
00885F  2  4A                   LSR 				; SHIFT HIGH NIBBLE TO LOW NIBBLE
008860  2  4A                   LSR 				;
008861  2  4A                   LSR 				;
008862  2  4A                   LSR 				;
008863  2  18                   CLC               		; CLEAR CARRY
008864  2  20 71 88             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
008867  2  8A                   TXA				; RESTORE ACCUMULATOR
008868  2  20 71 88             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
00886B  2  68                   pla
00886C  2  A8                   TAY
00886D  2  68                   pla
00886E  2  AA                   TAX
00886F  2  68                   PLA
008870  2  60                   RTS
008871  2               
008871  2               ;__PRINT_DIGIT_________________________________________________
008871  2               ;
008871  2               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
008871  2               ;
008871  2               ;______________________________________________________________
008871  2               PRINT_DIGIT:
008871  2  29 0F                       AND #$0F				; STRIP OFF HIGH NIBBLE
008873  2  09 30                       ORA #$30				; ADD $30 TO PRODUCE ASCII
008875  2  C9 3A                       CMP #$3A               		; IS GREATER THAN 9
008877  2  30 03                       BMI PRINT_DIGIT_OUT		; NO, SKIP ADD
008879  2  18                          CLC				; CLEAR CARRY
00887A  2  69 07                       ADC #$07				; ADD ON FOR LETTER VALUES
00887C  2               PRINT_DIGIT_OUT:					;
00887C  2  4C 6C 9B                    JMP CONSOLE_OUT              		; PRINT OUT CHAR
00887F  2               
00887F  2               NEWLINE:
00887F  2  48                           pha
008880  2  A9 0D                        LDA #$0D
008882  2  20 6C 9B                     JSR CONSOLE_OUT
008885  2  A9 0A                        LDA #$0A
008887  2  20 6C 9B                     Jsr CONSOLE_OUT
00888A  2  68                           pla
00888B  2  60                           rts
00888C  2               
00888C  2               PRTDEC:
00888C  2  48                           PHA
00888D  2  85 3A                        STA     STACKA
00888F  2  98                           TYA
008890  2  48                           phA
008891  2  8A                           TXA
008892  2  48                           PHA
008893  2  A5 3A                        LDA     STACKA
008895  2  48                           PHA
008896  2  A0 00                        ldy #00
008898  2  A2 FF                        LDX #$FF
00889A  2  38                           SEC
00889B  2               PrDec100:
00889B  2  E8                           INX
00889C  2  E9 64                        SBC #100
00889E  2  B0 FB                        BCS PrDec100            ;Count how many 100s
0088A0  2  69 64                        ADC #100
0088A2  2  20 BE 88                     JSR PrDecDigit          ;Print the 100s
0088A5  2  A2 FF                        LDX #$FF
0088A7  2  38                           SEC                     ;Prepare for subtraction
0088A8  2               PrDec10:
0088A8  2  E8                           INX
0088A9  2  E9 0A                        SBC #10
0088AB  2  B0 FB                        BCS PrDec10             ;Count how many 10s
0088AD  2  69 0A                        ADC #10
0088AF  2  20 BE 88                     JSR PrDecDigit          ;Print the 10s
0088B2  2  AA                           TAX                     ;Pass 1s into X
0088B3  2  A0 01                        ldy #1
0088B5  2  20 BE 88                     JSR PrDecDigit          ;Print the 1s
0088B8  2  68                           PLA
0088B9  2  68                           pla
0088BA  2  AA                           TAX
0088BB  2  68                           pla
0088BC  2  A8                           TAY
0088BD  2  60                           RTS
0088BE  2               PrDecDigit:
0088BE  2  48                           PHA
0088BF  2  C0 00                        cpy #$00
0088C1  2  D0 09                        bne PrDecDigit1
0088C3  2  8A                           txa
0088C4  2  A8                           tay
0088C5  2  C0 00                        cpy #$00
0088C7  2  D0 03                        bne PrDecDigit1
0088C9  2  4C D2 88                     jmp PrDecDigit2
0088CC  2               PrDecDigit1:
0088CC  2  8A                           TXA                     ;Save A, pass digit to A
0088CD  2  09 30                        ORA #'0'
0088CF  2  20 6C 9B                     JSR  CONSOLE_OUT        ;Convert to character and print it
0088D2  2               PrDecDigit2:
0088D2  2  68                           PLA
0088D3  2  60                           RTS                     ;Restore A and return
0088D4  2               
0088D4  1                       .INCLUDE "dosser.asm"
0088D4  2               ;__SERIAL DRIVERS________________________________________________________________________________________________________________
0088D4  2               ;
0088D4  2               ; 	Nhyodyne serial drivers for single serial port card
0088D4  2               ;
0088D4  2               ;	Entry points:
0088D4  2               ;		SERIALINIT  - called during OS init
0088D4  2               ;		RDSER1	    - read a byte from serial port ('A' POINTS TO BYTE)
0088D4  2               ;		WRSER1	    - write a byte from serial port  ('A' POINTS TO BYTE)
0088D4  2               ;		RDSER1W	    - read a byte from serial port ('A' POINTS TO BYTE, WAIT FOR INPUT)
0088D4  2               ;		SERIALSTATUS- GET UART STATUS
0088D4  2               ;________________________________________________________________________________________________________________________________
0088D4  2               ;
0088D4  2               
0088D4  2               
0088D4  2               ;*
0088D4  2               ;* HARDWARE I/O ADDRESSES
0088D4  2               ;*
0088D4  2               
0088D4  2               ; UART 16C550 SERIAL
0088D4  2               UART0           = $0368         ; DATA IN/OUT
0088D4  2               UART1           = $0369         ; CHECK RX
0088D4  2               UART2           = $036A         ; INTERRUPTS
0088D4  2               UART3           = $036B         ; LINE CONTROL
0088D4  2               UART4           = $036C         ; MODEM CONTROL
0088D4  2               UART5           = $036D         ; LINE STATUS
0088D4  2               UART6           = $036E         ; MODEM STATUS
0088D4  2               UART7           = $036F         ; SCRATCH REG.
0088D4  2               
0088D4  2               
0088D4  2               ;__SERIALINIT____________________________________________________________________________________________________________________
0088D4  2               ;
0088D4  2               ;	INITIALIZE SERIAL PORTS
0088D4  2               ;________________________________________________________________________________________________________________________________
0088D4  2               ;
0088D4  2               SERIALINIT:
0088D4  2               ;	LDA	#$80			;
0088D4  2               ;	STA	UART3			; SET DLAB FLAG
0088D4  2               ;	LDA	#12			; SET TO 12 = 9600 BAUD
0088D4  2               ;	STA	UART0			; save baud rate
0088D4  2               ;	LDA	#00			;
0088D4  2               ;	STA	UART1			;
0088D4  2               ;	LDA	#03			;
0088D4  2               ;	STA	UART3			; SET 8 BIT DATA, 1 STOPBIT
0088D4  2               ;	STA	UART4			;
0088D4  2               
0088D4  2  60                   RTS
0088D5  2               
0088D5  2               
0088D5  2               
0088D5  2               ;__WRSER1________________________________________________________________________________________________________________________
0088D5  2               ;
0088D5  2               ;	WRITE CHARACTER(A) TO UART
0088D5  2               ;________________________________________________________________________________________________________________________________
0088D5  2               ;
0088D5  2               WRSER1:
0088D5  2  48                   PHA
0088D6  2               WRSER1a:
0088D6  2  AD 6D 03             LDA     UART5           ; READ LINE STATUS REGISTER
0088D9  2  29 20                AND     #$20            ; TEST IF UART IS READY TO SEND (BIT 5)
0088DB  2  C9 00                CMP     #$00
0088DD  2  F0 F7                BEQ     WRSER1a         ; NO, WAIT FOR IT
0088DF  2  68                   PLA
0088E0  2  8D 68 03             STA     UART0           ; THEN WRITE THE CHAR TO UART
0088E3  2  60                   RTS
0088E4  2               
0088E4  2               ;__RDSER1________________________________________________________________________________________________________________________
0088E4  2               ;
0088E4  2               ;	READ CHARACTER FROM UART TO (A)
0088E4  2               ;________________________________________________________________________________________________________________________________
0088E4  2               ;
0088E4  2               RDSER1:
0088E4  2  AD 6D 03             LDA     UART5           ; READ LINE STATUS REGISTER
0088E7  2  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
0088E9  2  C9 00                CMP     #$00
0088EB  2  F0 04                BEQ     RDSER1N         ; LOOP UNTIL DATA IS READY
0088ED  2  AD 68 03             LDA     UART0           ; THEN READ THE CHAR FROM THE UART
0088F0  2  60                   RTS
0088F1  2               RDSER1N:
0088F1  2  A9 00                LDA     #$00            ;
0088F3  2  60                   RTS                     ;
0088F4  2               
0088F4  2               ;__RDSER1W_______________________________________________________________________________________________________________________
0088F4  2               ;
0088F4  2               ;	READ CHARACTER FROM UART TO (A) - WAIT FOR CHAR
0088F4  2               ;________________________________________________________________________________________________________________________________
0088F4  2               ;
0088F4  2               
0088F4  2               RDSER1W:
0088F4  2  AD 6D 03             LDA     UART5           ; READ LINE STATUS REGISTER
0088F7  2  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
0088F9  2  C9 00                CMP     #$00
0088FB  2  F0 F7                BEQ     RDSER1W         ; LOOP UNTIL DATA IS READY
0088FD  2  AD 68 03             LDA     UART0           ; THEN READ THE CHAR FROM THE UART
008900  2  29 7F                AND     #$7F
008902  2  60                   RTS
008903  2               
008903  2               ;__SERIALSTATUS__________________________________________________________________________________________________________________
008903  2               ;
008903  2               ;	READ UARD STATUS
008903  2               ;________________________________________________________________________________________________________________________________
008903  2               ;
008903  2               SERIALSTATUS:
008903  2  AD 6D 03             LDA     UART5           ; READ LINE STATUS REGISTER
008906  2  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
008908  2  C9 00                CMP     #$00
00890A  2  F0 03                BEQ     RDSTAT1         ; NO, INDICATE NO CHAR
00890C  2  A9 FF                LDA     #$FF            ; GET DATA CHAR
00890E  2  60                   RTS
00890F  2               RDSTAT1:
00890F  2  A9 00                LDA     #$00            ; GET DATA CHAR
008911  2  60                   RTS
008912  2               
008912  2               ; end
008912  2               
008912  1                       .INCLUDE "doside.asm"
008912  2               ;__IDE DRIVERS___________________________________________________________________________________________________________________
008912  2               ;
008912  2               ; 	Nhyodyne IDE disk drivers for Z80PPIDE card
008912  2               ;
008912  2               ;	Entry points:
008912  2               ;		PPIDE_INIT   	- called during OS init
008912  2               ;		IDE_READ_SECTOR - read a sector from drive
008912  2               ;		IDE_WRITE_SECTOR- write a sector to drive
008912  2               ;________________________________________________________________________________________________________________________________
008912  2               ;
008912  2               PPIDE_PPI       = $0360         ; PORT A
008912  2               ;
008912  2               PPIDELO         = PPIDE_PPI+0   ; LSB
008912  2               PPIDEHI         = PPIDE_PPI+1   ; MSB
008912  2               PPIDECNTRL      = PPIDE_PPI+2   ; Control Signals
008912  2               PPIDEPPIC       = PPIDE_PPI+3   ; CONTROL BYTE PPI 82C55
008912  2               
008912  2               PPIDE_A0_LINE   = $01           ;DIRECT FROM 8255 TO IDE INTERFACE
008912  2               PPIDE_A1_LINE   = $02           ;DIRECT FROM 8255 TO IDE INTERFACE
008912  2               PPIDE_A2_LINE   = $04           ;DIRECT FROM 8255 TO IDE INTERFACE
008912  2               PPIDE_CS0_LINE  = $08           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
008912  2               PPIDE_CS1_LINE  = $10           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
008912  2               PPIDE_WR_LINE   = $20           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
008912  2               PPIDE_RD_LINE   = $40           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
008912  2               PPIDE_RST_LINE  = $80           ;INVERTER BETWEEN 8255 AND IDE INTERFACE
008912  2               
008912  2               PPIDE_DATA      = PPIDE_CS0_LINE
008912  2               PPIDE_ERR       = PPIDE_CS0_LINE + PPIDE_A0_LINE
008912  2               PPIDE_SEC_CNT   = PPIDE_CS0_LINE + PPIDE_A1_LINE
008912  2               PPIDE_LBALOW    = PPIDE_CS0_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
008912  2               PPIDE_LBAMID    = PPIDE_CS0_LINE + PPIDE_A2_LINE
008912  2               PPIDE_LBAHI     = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A0_LINE
008912  2               PPIDE_DEVICE    = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
008912  2               PPIDE_COMMAND   = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
008912  2               PPIDE_STATUS    = PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
008912  2               PPIDE_CONTROL   = PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
008912  2               PPIDE_ASTATUS   = PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
008912  2               
008912  2               
008912  2               ;IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
008912  2               PPIDE_CMD_RECAL = $10
008912  2               PPIDE_CMD_READ  = $20
008912  2               PPIDE_CMD_WRITE = $30
008912  2               PPIDE_CMD_INIT  = $91
008912  2               PPIDE_CMD_ID    = $EC
008912  2               PPIDE_CMD_SPINDOWN = $E0
008912  2               PPIDE_CMD_SPINUP = $E1
008912  2               
008912  2               
008912  2               PPRD_IDE_8255   = %10010010     ;IDE_8255_CTL OUT, IDE_8255_LSB/MSB INPUT
008912  2               PPWR_IDE_8255   = %10000000     ;ALL THREE PORTS OUTPUT
008912  2               
008912  2               
008912  2               PPIDEINDEX:
008912  2  00                   .BYTE   $00
008913  2               PPIDETIMEOUT:
008913  2  00 00                .BYTE   $00,$00
008915  2               
008915  2               ;__PPIDE_INIT_________________________________________________________________________________________
008915  2               ;
008915  2               ;  INIT AND DISPLAY IDE INFO
008915  2               ;____________________________________________________________________________________________________
008915  2               ;
008915  2               PPIDE_INIT:
008915  2                       PRTDBG  "PPIDE INIT:$"
008915  2  48 8A 48 A8          PRTS    "PPIDE :$"
008919  2  48 A2 00 BD  
00891D  2  32 89 E8 C9  
00893A  2  20 7F 88             JSR     NEWLINE
00893D  2  20 CF 8B             JSR     IDE_PPIDETECT   ; TEST FOR PPI HARDWARE
008940  2  D0 39                BNE     IDE_ABORT       ; BAIL OUT IF NOT THERE
008942  2               ;
008942  2  48 8A 48 A8          PRTS    " IO=0x$"
008946  2  48 A2 00 BD  
00894A  2  5F 89 E8 C9  
008966  2  A9 03                LDA     #>PPIDE_PPI     ; GET BASE PORT
008968  2  20 55 88             JSR     PRTHEXBYTE      ; PRINT BASE PORT
00896B  2  A9 60                LDA     #<PPIDE_PPI     ; GET BASE PORT
00896D  2  20 55 88             JSR     PRTHEXBYTE      ; PRINT BASE PORT
008970  2               ;
008970  2  20 6A 8C             JSR     PPIDE_RESET     ; RESET THE BUS
008973  2  20 15 8A             JSR     PPIDE_PROBE     ; DETECT AN ATA DEVICE, ABORT IF NOT FOUND
008976  2  B0 03                BCS     IDE_ABORT
008978  2  4C A8 89             JMP     IDE_PRINT_INFO
00897B  2               IDE_ABORT:
00897B  2  48 8A 48 A8          PRTS    " NOT PRESENT$" ; NOT PRESENT
00897F  2  48 A2 00 BD  
008983  2  98 89 E8 C9  
0089A5  2  4C 11 8A             JMP     IDE_INITA
0089A8  2               IDE_PRINT_INFO:
0089A8  2  20 7F 88             JSR     NEWLINE
0089AB  2  48 8A 48 A8          PRTS    " PPIDE0: Blocks=$"
0089AF  2  48 A2 00 BD  
0089B3  2  C8 89 E8 C9  
0089D9  2  A9 00                LDA     #$00
0089DB  2  20 9E 8A             JSR     IDE_READ_INFO   ; GET DRIVE INFO, ABORT IF ERROR
0089DE  2  48 8A 48 A8          PRTS    " PPIDE1: Blocks=$"
0089E2  2  48 A2 00 BD  
0089E6  2  FB 89 E8 C9  
008A0C  2  A9 01                LDA     #$01
008A0E  2  20 9E 8A             JSR     IDE_READ_INFO   ; GET DRIVE INFO, ABORT IF ERROR
008A11  2               IDE_INITA:
008A11  2  20 7F 88             JSR     NEWLINE
008A14  2  60                   RTS                     ; DONE
008A15  2               ;
008A15  2               ;__PPIDE_PROBE_______________________________________________________________________________________
008A15  2               ;
008A15  2               ;  PROBE FOR IDE HARDWARE
008A15  2               ;____________________________________________________________________________________________________
008A15  2               ;
008A15  2               PPIDE_PROBE:
008A15  2               ;
008A15  2               ; BELOW TESTS FOR EXISTENCE OF AN IDE CONTROLLER ON THE
008A15  2               ; PPIDE INTERFACE.  WE WRITE A VALUE OF ZERO FIRST SO THAT
008A15  2               ; THE PPI BUS HOLD WILL RETURN A VALUE OF ZERO IF THERE IS
008A15  2               ; NOTHING CONNECTED TO PPI PORT A.  THEN WE READ THE STATUS
008A15  2               ; REGISTER.  IF AN IDE CONTROLLER IS THERE, IT SHOULD ALWAYS
008A15  2               ; RETURN SOMETHING OTHER THAN ZERO.  IF AN IDE CONTROLLER IS
008A15  2               ; THERE, THEN THE VALUE WRITTEN TO PPI PORT A IS IGNORED
008A15  2               ; BECAUSE THE WRITE SIGNAL IS NEVER PULSED.
008A15  2               
008A15  2  A9 00                LDA     #$00
008A17  2  8D 60 03             STA     PPIDELO         ; PPI PORT A, DATALO
008A1A  2               
008A1A  2  20 95 8C             JSR     IDE_WAIT_NOT_BUSY; WAIT FOR BUSY TO CLEAR
008A1D  2  B0 34                BCS     PPIDE_PROBE_FAIL; IF TIMEOUT, REPORT NO IDE PRESENT
008A1F  2  A9 0F                LDA     #PPIDE_STATUS   ; GET STATUS
008A21  2  20 59 8F             JSR     IDE_READ
008A24  2  8A                   TXA
008A25  2  29 40                AND     #%01000000
008A27  2  C9 00                CMP     #$00
008A29  2  F0 28                BEQ     PPIDE_PROBE_FAIL; IF NOT RDY BIT (BIT 6) THEN REPORT NO IDE PRESENT
008A2B  2               
008A2B  2               ; CHECK SIGNATURE
008A2B  2  A9 0A                LDA     #PPIDE_SEC_CNT
008A2D  2  20 59 8F             JSR     IDE_READ
008A30  2  E0 01                CPX     #$01
008A32  2  D0 1F                BNE     PPIDE_PROBE_FAIL; IF not '01' THEN REPORT NO IDE PRESENT
008A34  2  A9 0B                LDA     #PPIDE_LBALOW
008A36  2  20 59 8F             JSR     IDE_READ
008A39  2  E0 01                CPX     #$01
008A3B  2  D0 16                BNE     PPIDE_PROBE_FAIL; IF not '01' THEN REPORT NO IDE PRESENT
008A3D  2  A9 0C                LDA     #PPIDE_LBAMID
008A3F  2  20 59 8F             JSR     IDE_READ
008A42  2  E0 00                CPX     #$00
008A44  2  D0 0D                BNE     PPIDE_PROBE_FAIL; IF not '00' THEN REPORT NO IDE PRESENT
008A46  2  A9 0D                LDA     #PPIDE_LBAHI
008A48  2  20 59 8F             JSR     IDE_READ
008A4B  2  E0 00                CPX     #$00
008A4D  2  D0 04                BNE     PPIDE_PROBE_FAIL; IF not '00' THEN REPORT NO IDE PRESENT
008A4F  2  18                   CLC
008A50  2  4C 54 8A             JMP     PPIDE_PROBE_SUCCESS
008A53  2               PPIDE_PROBE_FAIL:
008A53  2  38                   SEC
008A54  2               PPIDE_PROBE_SUCCESS:
008A54  2  60                   RTS                     ; DONE, NOTE THAT A=0 AND Z IS SET
008A55  2               
008A55  2               
008A55  2               ;___IDE_IDENTIFY_TYPE____________________________________________________________________________________
008A55  2               ;
008A55  2               ; 	READ THE DISK TYPE AND DETERMINE IF IT IS USABLE BY DOS/65
008A55  2               ; 	A=IDE DEVICE (0=MST,1=SLV)
008A55  2               ;________________________________________________________________________________________________________
008A55  2               
008A55  2               IDE_IDENTIFY_TYPE:
008A55  2  48                   PHA
008A56  2  20 95 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008A59  2  B0 40                BCS     IDE_IDENTIFY_TYPE_ERROR; IF TIMEOUT, REPORT ERROR
008A5B  2  A9 00                LDA     #$00
008A5D  2  8D 12 05             STA     debsehd
008A60  2  8D 10 05             STA     debcyll         ; STORE IN TRACK (lsb)
008A63  2  8D 11 05             STA     debcylm         ; STORE IN TRACK (msb)
008A66  2  68                   PLA                     ; GET DRIVE TYPE
008A67  2  20 0A 8C             JSR     IDE_READ_SECTOR_DIRTY1
008A6A  2  C9 FF                CMP     #$FF            ; IS THERE A READ ERROR?
008A6C  2  F0 2D                BEQ     IDE_IDENTIFY_TYPE_ERROR
008A6E  2  AD E0 96             LDA     hstbuf+$01FE
008A71  2  C9 55                CMP     #$55
008A73  2  D0 23                BNE     IDE_IDENTIFY_TYPE_OK
008A75  2  AD E1 96             LDA     hstbuf+$01FF
008A78  2  C9 AA                CMP     #$AA
008A7A  2  D0 1C                BNE     IDE_IDENTIFY_TYPE_OK
008A7C  2  AD A4 96             LDA     hstbuf+$01C2
008A7F  2  C9 00                CMP     #$00
008A81  2  D0 18                BNE     IDE_IDENTIFY_TYPE_ERROR
008A83  2  AD B4 96             LDA     hstbuf+$01D2
008A86  2  C9 00                CMP     #$00
008A88  2  D0 11                BNE     IDE_IDENTIFY_TYPE_ERROR
008A8A  2  AD C4 96             LDA     hstbuf+$01E2
008A8D  2  C9 00                CMP     #$00
008A8F  2  D0 0A                BNE     IDE_IDENTIFY_TYPE_ERROR
008A91  2  AD D4 96             LDA     hstbuf+$01F2
008A94  2  C9 00                CMP     #$00
008A96  2  D0 03                BNE     IDE_IDENTIFY_TYPE_ERROR
008A98  2               IDE_IDENTIFY_TYPE_OK:
008A98  2  A9 00                LDA     #$00            ; EVERYTHING IS AWESOME
008A9A  2  60                   RTS
008A9B  2               IDE_IDENTIFY_TYPE_ERROR:
008A9B  2  A9 FF                LDA     #$FF            ; SIGNIFY ERROR
008A9D  2  60                   RTS
008A9E  2               
008A9E  2               
008A9E  2               ;*__IDE_READ_INFO___________________________________________________________________________________
008A9E  2               ;*
008A9E  2               ;*  READ IDE INFORMATION
008A9E  2               ;*	CARRY SET ON ERROR
008A9E  2               ;* 	A=MST/SLV
008A9E  2               ;*____________________________________________________________________________________________________
008A9E  2               IDE_READ_INFO:
008A9E  2                       PRTDBG  "IDE Read INFORMATION$"
008A9E  2  48                   PHA
008A9F  2  48                   PHA
008AA0  2               ; SET DRIVE BIT
008AA0  2  29 01                AND     #$01            ; ONLY WANT THE 1 BIT (MST/SLV)
008AA2  2  0A                   ASL     a               ; SHIFT 4
008AA3  2  0A                   ASL     a               ;
008AA4  2  0A                   ASL     a               ;
008AA5  2  0A                   ASL     a               ;
008AA6  2  09 E0                ORA     #$E0            ; E0=MST  F0=SLV
008AA8  2  AA                   TAX
008AA9  2  A0 00                LDY     #$00
008AAB  2  A9 0E                LDA     #PPIDE_DEVICE
008AAD  2  20 75 8F             JSR     IDE_WRITE
008AB0  2               
008AB0  2               
008AB0  2  20 95 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008AB3  2  B0 52                BCS     IDE_READ_INFO_ABORT
008AB5  2  A9 0F                LDA     #PPIDE_COMMAND  ;SELECT IDE REGISTER
008AB7  2  A2 EC                LDX     #PPIDE_CMD_ID
008AB9  2  20 75 8F             JSR     IDE_WRITE       ;ASK THE DRIVE TO READ IT
008ABC  2  20 C1 8C             JSR     IDE_WAIT_DRQ    ;WAIT UNTIL IT'S GOT THE DATA
008ABF  2  B0 46                BCS     IDE_READ_INFO_ABORT
008AC1  2  20 F5 8C             JSR     IDE_READ_BUFFER ; GRAB THE 256 WORDS FROM THE BUFFER
008AC4  2  48 8A 48 A8          PRTS    "0x$"
008AC8  2  48 A2 00 BD  
008ACC  2  E1 8A E8 C9  
008AE4  2  AD 5D 95             LDA     hstbuf+123
008AE7  2  20 55 88             JSR     PRTHEXBYTE
008AEA  2  AD 5C 95             LDA     hstbuf+122
008AED  2  20 55 88             JSR     PRTHEXBYTE
008AF0  2  AD 5B 95             LDA     hstbuf+121
008AF3  2  20 55 88             JSR     PRTHEXBYTE
008AF6  2  AD 5A 95             LDA     hstbuf+120
008AF9  2  20 55 88             JSR     PRTHEXBYTE
008AFC  2  68                   PLA
008AFD  2  20 55 8A             JSR     IDE_IDENTIFY_TYPE
008B00  2  C9 00                CMP     #$00
008B02  2  D0 36                BNE     IDE_READ_INFO_BADFS
008B04  2  4C 70 8B             JMP     IDE_READ_INFO_OK
008B07  2               IDE_READ_INFO_ABORT:
008B07  2  68                   PLA
008B08  2  48 8A 48 A8          PRTS    "NOT PRESENT$"  ; NOT PRESENT
008B0C  2  48 A2 00 BD  
008B10  2  25 8B E8 C9  
008B31  2  20 7F 88             JSR     NEWLINE
008B34  2  68                   PLA
008B35  2  20 AB 8B             JSR     IDE_REMOVE_DRIVE_ASSIGNMENTS
008B38  2  38                   SEC
008B39  2  60                   RTS                     ;
008B3A  2               IDE_READ_INFO_BADFS:
008B3A  2  48 8A 48 A8          PRTS    " BAD FILESYSTEM$"; NOT PRESENT
008B3E  2  48 A2 00 BD  
008B42  2  57 8B E8 C9  
008B67  2  20 7F 88             JSR     NEWLINE
008B6A  2  68                   PLA
008B6B  2  20 AB 8B             JSR     IDE_REMOVE_DRIVE_ASSIGNMENTS
008B6E  2  38                   SEC
008B6F  2  60                   RTS                     ;
008B70  2               IDE_READ_INFO_OK:
008B70  2  48 8A 48 A8          PRTS    " FILE SYSTEM COMPATIBLE$"; NOT PRESENT
008B74  2  48 A2 00 BD  
008B78  2  8D 8B E8 C9  
008BA5  2  20 7F 88             JSR     NEWLINE
008BA8  2  68                   PLA
008BA9  2  18                   CLC
008BAA  2  60                   RTS
008BAB  2               
008BAB  2               IDE_REMOVE_DRIVE_ASSIGNMENTS:
008BAB  2  18                   CLC
008BAC  2  69 30                ADC     #$30
008BAE  2  A2 00                LDX     #$00
008BB0  2               @1:
008BB0  2  DD 14 05             CMP     dskcfg,X        ; GET device
008BB3  2  F0 09                BEQ     @2
008BB5  2  E8                   INX
008BB6  2  E8                   INX
008BB7  2  E0 10                CPX     #16
008BB9  2  D0 F5                BNE     @1
008BBB  2  4C CE 8B             JMP     @3
008BBE  2               @2:
008BBE  2  48                   PHA
008BBF  2  A9 00                LDA     #$00
008BC1  2  9D 14 05             STA     dskcfg,X        ; SET device
008BC4  2  E8                   INX
008BC5  2  9D 14 05             STA     dskcfg,X        ; SET device
008BC8  2  68                   PLA
008BC9  2  E8                   INX
008BCA  2  E0 10                CPX     #16
008BCC  2  D0 E2                BNE     @1
008BCE  2               @3:
008BCE  2  60                   RTS
008BCF  2               
008BCF  2               ;__IDE_PPIDETECT____________________________________________________________________________________
008BCF  2               ;
008BCF  2               ;  PROBE FOR PPI HARDWARE
008BCF  2               ;____________________________________________________________________________________________________
008BCF  2               ;
008BCF  2               IDE_PPIDETECT:
008BCF  2               ;
008BCF  2               ; TEST FOR PPI EXISTENCE
008BCF  2               ; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
008BCF  2               ; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
008BCF  2               ; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
008BCF  2               ; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
008BCF  2               ; INTERFERE WITH THE VALUE BEING READ.
008BCF  2  20 99 8F             JSR     SET_PPI_WR
008BD2  2               ;
008BD2  2  A9 00                LDA     #$00            ; VALUE ZERO
008BD4  2  8D 60 03             STA     PPIDELO         ; PUSH VALUE TO PORT
008BD7  2  AD 60 03             LDA     PPIDELO         ; GET PORT VALUE
008BDA  2  C9 00                CMP     #$00
008BDC  2  60                   RTS                     ; AND RETURN
008BDD  2               ;
008BDD  2               
008BDD  2               
008BDD  2               ;*__IDE_READ_SECTOR___________________________________________________________________________________
008BDD  2               ;*
008BDD  2               ;*  READ IDE SECTOR (IN LBA) INTO BUFFER
008BDD  2               ;*
008BDD  2               ;*____________________________________________________________________________________________________
008BDD  2               IDE_READ_SECTOR:
008BDD  2                       PRTDBG  "IDE Read Sector$"
008BDD  2  20 E4 8B             JSR     IDE_READ_RAW_SECTOR
008BE0  2  20 0A 94             JSR     DEBSECR512
008BE3  2  60                   RTS
008BE4  2               
008BE4  2               IDE_READ_RAW_SECTOR:
008BE4  2                       PRTDBG  "IDE Read Raw Sector$"
008BE4  2  20 91 8D             JSR     IDE_CONVERT_SECTOR;
008BE7  2               
008BE7  2  AD 12 05             LDA     debsehd         ; STORE CURRENT PARMS
008BEA  2  CD A7 8F             CMP     Cdebsehd        ;
008BED  2  D0 13                BNE     IDE_READ_SECTOR_DIRTY
008BEF  2  AD 11 05             LDA     debcylm         ;
008BF2  2  CD A6 8F             CMP     Cdebcylm        ;
008BF5  2  D0 0B                BNE     IDE_READ_SECTOR_DIRTY
008BF7  2  AD 10 05             LDA     debcyll         ;
008BFA  2  CD A5 8F             CMP     Cdebcyll        ;
008BFD  2  D0 03                BNE     IDE_READ_SECTOR_DIRTY
008BFF  2  A9 00                LDA     #$00            ; ZERO = 1 ON RETURN = OPERATION OK
008C01  2  60                   RTS
008C02  2               
008C02  2               IDE_READ_SECTOR_DIRTY:
008C02  2                       PRTDBG  "IDE Read Sector Buffer Dirty$"
008C02  2  20 95 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008C05  2  B0 2A                BCS     IDE_READ_SECTOR_DIRTY_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C07  2  20 54 94             JSR     GET_DRIVE_DEVICE
008C0A  2               IDE_READ_SECTOR_DIRTY1:
008C0A  2  20 61 8D             JSR     IDE_SETUP_LBA   ;TELL IT WHICH SECTOR WE WANT
008C0D  2  A9 0F                LDA     #PPIDE_COMMAND  ;SELECT IDE REGISTER
008C0F  2  A2 20                LDX     #PPIDE_CMD_READ
008C11  2  20 75 8F             JSR     IDE_WRITE       ;ASK THE DRIVE TO READ IT
008C14  2  20 C1 8C             JSR     IDE_WAIT_DRQ    ;WAIT UNTIL IT'S GOT THE DATA
008C17  2  B0 18                BCS     IDE_READ_SECTOR_DIRTY_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C19  2  20 F5 8C             JSR     IDE_READ_BUFFER ; GRAB THE 256 WORDS FROM THE BUFFER
008C1C  2  AD 12 05             LDA     debsehd         ; STORE CURRENT PARMS
008C1F  2  8D A7 8F             STA     Cdebsehd        ;
008C22  2  AD 10 05             LDA     debcyll         ;
008C25  2  8D A5 8F             STA     Cdebcyll        ;
008C28  2  AD 11 05             LDA     debcylm         ;
008C2B  2  8D A6 8F             STA     Cdebcylm        ;
008C2E  2               
008C2E  2  A9 00                LDA     #$00            ; ZERO = 1 ON RETURN = OPERATION OK
008C30  2  60                   RTS
008C31  2               IDE_READ_SECTOR_DIRTY_ERROR:
008C31  2  A9 FF                LDA     #$FF            ; ZERO = 1 ON RETURN = OPERATION OK
008C33  2  60                   RTS
008C34  2               
008C34  2               ;*__IDE_WRITE_SECTOR__________________________________________________________________________________
008C34  2               ;*
008C34  2               ;*  WRITE IDE SECTOR (IN LBA) FROM BUFFER
008C34  2               ;*
008C34  2               ;*____________________________________________________________________________________________________
008C34  2               IDE_WRITE_SECTOR:
008C34  2                       PRTDBG  "IDE Write Sector$"
008C34  2  20 E4 8B             JSR     IDE_READ_RAW_SECTOR; determine physical sector
008C37  2  20 33 94             JSR     BLKSECR512      ; block sector for writing
008C3A  2  20 95 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008C3D  2  B0 28                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C3F  2  20 54 94             JSR     GET_DRIVE_DEVICE
008C42  2               IDE_WRITE_SECTOR_RAW:
008C42  2  20 61 8D             JSR     IDE_SETUP_LBA   ;TELL IT WHICH SECTOR WE WANT
008C45  2  A9 0F                LDA     #PPIDE_COMMAND
008C47  2  A2 30                LDX     #PPIDE_CMD_WRITE
008C49  2  20 75 8F             JSR     IDE_WRITE       ;TELL DRIVE TO WRITE A SECTOR
008C4C  2  20 C1 8C             JSR     IDE_WAIT_DRQ    ;WAIT UNIT IT WANTS THE DATA
008C4F  2  B0 16                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C51  2  20 2A 8D             JSR     IDE_WRITE_BUFFER;GIVE THE DATA TO THE DRIVE
008C54  2  20 95 8C             JSR     IDE_WAIT_NOT_BUSY;WAIT UNTIL THE WRITE IS COMPLETE
008C57  2  B0 0E                BCS     IDE_WRITE_SECTOR_ERROR; IF TIMEOUT, REPORT NO IDE PRESENT
008C59  2  A9 FF                LDA     #$FF            ; STORE CURRENT PARMS
008C5B  2  8D A7 8F             STA     Cdebsehd        ;
008C5E  2  8D A5 8F             STA     Cdebcyll        ;
008C61  2  8D A6 8F             STA     Cdebcylm        ;
008C64  2               
008C64  2  A9 00                LDA     #$00            ; ZERO ON RETURN = OPERATION OK
008C66  2  60                   RTS
008C67  2               IDE_WRITE_SECTOR_ERROR:
008C67  2  A9 FF                LDA     #$FF            ; 1 ON RETURN = OPERATION FAIL
008C69  2  60                   RTS
008C6A  2               
008C6A  2               ;*__PPIDE_RESET____________________________________________________________________________________
008C6A  2               ;*
008C6A  2               ;*  SOFT RESET IDE CHANNEL
008C6A  2               ;*
008C6A  2               ;*____________________________________________________________________________________________________
008C6A  2               PPIDE_RESET:
008C6A  2                       PRTDBG  "IDE Reset$"
008C6A  2  A9 00                LDA     #$00
008C6C  2  8D 12 05             STA     debsehd
008C6F  2  8D 10 05             STA     debcyll
008C72  2  8D 11 05             STA     debcylm
008C75  2  A9 FF                LDA     #$FF            ;
008C77  2  8D A7 8F             STA     Cdebsehd        ;
008C7A  2  8D A5 8F             STA     Cdebcyll        ;
008C7D  2  8D A6 8F             STA     Cdebcylm        ;
008C80  2               
008C80  2  A9 80                LDA     #PPIDE_RST_LINE
008C82  2  8D 62 03             STA     PPIDECNTRL      ; ASSERT RST LINE ON IDE INTERFACE
008C85  2  A2 00                LDX     #$00
008C87  2                       PRTDBG  "IDE Reset Delay$"
008C87  2               RST_DLY:
008C87  2  CA                   DEX
008C88  2  E0 00                CPX     #$00
008C8A  2  D0 FB                BNE     RST_DLY
008C8C  2  A9 00                LDA     #$00
008C8E  2  8D 62 03             STA     PPIDECNTRL      ; DEASSERT RST LINE ON IDE INTERFACE
008C91  2               
008C91  2               ; IF A DSKYNG IS ACTIVE AND IS ON THE SAME PPI PORT AS THE PPISD BEING
008C91  2               ; RESET, THEN THE DSKYNG WILL ALSO BE RESET.  SO, THE DSKY IS ALSO INITIALIZED.
008C91  2                       .IF     (USEDSKYNG=1)
008C91  2  20 AB 90                 JSR     DSKY_REINIT
008C94  2                       .ENDIF
008C94  2               
008C94  2  60                   RTS
008C95  2               
008C95  2               
008C95  2               ;*__IDE_WAIT_NOT_BUSY_______________________________________________________________________________
008C95  2               ;*
008C95  2               ;*  WAIT FOR IDE CHANNEL TO BECOME READY
008C95  2               ;*
008C95  2               ;*____________________________________________________________________________________________________
008C95  2               IDE_WAIT_NOT_BUSY:
008C95  2  48                   PHA
008C96  2  8A                   TXA
008C97  2  48                   PHA
008C98  2  98                   TYA
008C99  2  48                   PHA
008C9A  2  A9 00                LDA     #$00
008C9C  2  8D 13 89             STA     PPIDETIMEOUT
008C9F  2  8D 14 89             STA     PPIDETIMEOUT+1
008CA2  2               IDE_WAIT_NOT_BUSY1:
008CA2  2  A9 0F                LDA     #PPIDE_STATUS   ;WAIT FOR RDY BIT TO BE SET
008CA4  2  20 59 8F             JSR     IDE_READ
008CA7  2  8A                   TXA
008CA8  2  29 80                AND     #$80
008CAA  2  F0 0E                BEQ     IDE_WAIT_NOT_BUSY2
008CAC  2  EE 13 89             INC     PPIDETIMEOUT
008CAF  2  D0 F1                BNE     IDE_WAIT_NOT_BUSY1
008CB1  2  EE 14 89             INC     PPIDETIMEOUT+1
008CB4  2  D0 EC                BNE     IDE_WAIT_NOT_BUSY1
008CB6  2  38                   SEC
008CB7  2  4C BB 8C             JMP     IDE_WAIT_NOT_BUSY3
008CBA  2               IDE_WAIT_NOT_BUSY2:
008CBA  2  18                   CLC
008CBB  2               IDE_WAIT_NOT_BUSY3:
008CBB  2  68                   PLA
008CBC  2  A8                   TAY
008CBD  2  68                   PLA
008CBE  2  AA                   TAX
008CBF  2  68                   PLA
008CC0  2  60                   RTS
008CC1  2               
008CC1  2               ;*__IDE_WAIT_DRQ______________________________________________________________________________________
008CC1  2               ;*
008CC1  2               ;*	WAIT FOR THE DRIVE TO BE READY TO TRANSFER DATA.
008CC1  2               ;*
008CC1  2               ;*____________________________________________________________________________________________________
008CC1  2               IDE_WAIT_DRQ:
008CC1  2  48                   PHA
008CC2  2  8A                   TXA
008CC3  2  48                   PHA
008CC4  2  98                   TYA
008CC5  2  48                   PHA
008CC6  2  A9 00                LDA     #$00
008CC8  2  8D 13 89             STA     PPIDETIMEOUT
008CCB  2  8D 14 89             STA     PPIDETIMEOUT+1
008CCE  2               IDE_WAIT_DRQ1:
008CCE  2  A9 0F                LDA     #PPIDE_STATUS   ;WAIT FOR DRQ BIT TO BE SET
008CD0  2  20 59 8F             JSR     IDE_READ
008CD3  2  8A                   TXA
008CD4  2  29 88                AND     #%10001000      ; MASK OFF BUSY(7) AND DRQ(3)
008CD6  2  C9 08                CMP     #%00001000      ; WE WANT BUSY(7) TO BE 0 AND DRQ (3) TO BE 1
008CD8  2  F0 14                BEQ     IDE_WAIT_DRQ2
008CDA  2  29 01                AND     #%00000001      ; IS ERROR?
008CDC  2  C9 01                CMP     #%00000001      ;
008CDE  2  F0 0A                BEQ     IDE_WAIT_DRQE
008CE0  2  EE 13 89             INC     PPIDETIMEOUT
008CE3  2  D0 E9                BNE     IDE_WAIT_DRQ1
008CE5  2  EE 14 89             INC     PPIDETIMEOUT+1
008CE8  2  D0 E4                BNE     IDE_WAIT_DRQ1
008CEA  2               IDE_WAIT_DRQE:
008CEA  2  38                   SEC
008CEB  2  4C EF 8C             JMP     IDE_WAIT_DRQ3
008CEE  2               IDE_WAIT_DRQ2:
008CEE  2  18                   CLC
008CEF  2               IDE_WAIT_DRQ3:
008CEF  2  68                   PLA
008CF0  2  A8                   TAY
008CF1  2  68                   PLA
008CF2  2  AA                   TAX
008CF3  2  68                   PLA
008CF4  2  60                   RTS
008CF5  2               
008CF5  2               
008CF5  2               
008CF5  2               ;*__IDE_READ_BUFFER___________________________________________________________________________________
008CF5  2               ;*
008CF5  2               ;*  READ IDE BUFFER LITTLE ENDIAN
008CF5  2               ;*
008CF5  2               ;*____________________________________________________________________________________________________
008CF5  2               IDE_READ_BUFFER:
008CF5  2  A2 00                LDX     #$00            ; INDEX
008CF7  2               IDEBUFRD:
008CF7  2  8E 12 89             STX     PPIDEINDEX
008CFA  2  A9 08                LDA     #PPIDE_DATA
008CFC  2  20 59 8F             JSR     IDE_READ
008CFF  2  8A                   TXA
008D00  2  AE 12 89             LDX     PPIDEINDEX
008D03  2  9D E2 94             STA     hstbuf,X        ;
008D06  2  E8                   INX                     ;
008D07  2  98                   TYA                     ; THEN HIGH BYTE OF WORD
008D08  2  9D E2 94             STA     hstbuf,X        ;
008D0B  2  E8                   INX
008D0C  2  E0 00                CPX     #$00            ;
008D0E  2  D0 E7                BNE     IDEBUFRD        ;
008D10  2               IDEBUFRD1:
008D10  2  8E 12 89             STX     PPIDEINDEX
008D13  2  A9 08                LDA     #PPIDE_DATA
008D15  2  20 59 8F             JSR     IDE_READ
008D18  2  8A                   TXA
008D19  2  AE 12 89             LDX     PPIDEINDEX
008D1C  2  9D E2 95             STA     hstbuf+256,X    ;
008D1F  2  E8                   INX                     ;
008D20  2  98                   TYA                     ; THEN HIGH BYTE OF WORD
008D21  2  9D E2 95             STA     hstbuf+256,X    ;
008D24  2  E8                   INX                     ;
008D25  2  E0 00                CPX     #$00            ;
008D27  2  D0 E7                BNE     IDEBUFRD1       ;
008D29  2  60                   RTS                     ;
008D2A  2               
008D2A  2               ;*__IDE_WRITE_BUFFER___________________________________________________________________________________
008D2A  2               ;*
008D2A  2               ;*  WRITE IDE BUFFER LITTLE ENDIAN
008D2A  2               ;*
008D2A  2               ;*____________________________________________________________________________________________________
008D2A  2               IDE_WRITE_BUFFER:
008D2A  2  A2 00                LDX     #$00            ; INDEX
008D2C  2               IDEBUFWT:
008D2C  2  8E 12 89             STX     PPIDEINDEX
008D2F  2  BD E3 94             LDA     hstbuf+1,X      ; SECTORS ARE BIG ENDIAN
008D32  2  A8                   TAY                     ;
008D33  2  BD E2 94             LDA     hstbuf,X        ; SECTORS ARE BIG ENDIAN
008D36  2  AA                   TAX
008D37  2  A9 08                LDA     #PPIDE_DATA
008D39  2  20 75 8F             JSR     IDE_WRITE
008D3C  2  AE 12 89             LDX     PPIDEINDEX
008D3F  2  E8                   INX                     ;
008D40  2  E8                   INX                     ;
008D41  2  E0 00                CPX     #$00            ;
008D43  2  D0 E7                BNE     IDEBUFWT        ;
008D45  2  A2 00                LDX     #$00            ; INDEX
008D47  2               IDEBUFWT1:
008D47  2  8E 12 89             STX     PPIDEINDEX
008D4A  2  BD E3 95             LDA     hstbuf+257,X    ; SECTORS ARE BIG ENDIAN
008D4D  2  A8                   TAY
008D4E  2  BD E2 95             LDA     hstbuf+256,X    ; SECTORS ARE BIG ENDIAN
008D51  2  AA                   TAX
008D52  2  A9 08                LDA     #PPIDE_DATA
008D54  2  20 75 8F             JSR     IDE_WRITE
008D57  2  AE 12 89             LDX     PPIDEINDEX
008D5A  2  E8                   INX                     ;
008D5B  2  E8                   INX                     ;
008D5C  2  E0 00                CPX     #$00            ;
008D5E  2  D0 E7                BNE     IDEBUFWT1       ;
008D60  2  60                   RTS                     ;
008D61  2               
008D61  2               ;*__IDE_SETUP_LBA_____________________________________________________________________________________
008D61  2               ;*
008D61  2               ;*  SETUP LBA DATA
008D61  2               ;*  A= DRIVE DEVICE
008D61  2               ;*____________________________________________________________________________________________________
008D61  2               IDE_SETUP_LBA:
008D61  2                       PRTDBG  "PPIDE SETUP LBA$"
008D61  2  29 01                AND     #$01            ; only want drive cfg
008D63  2  0A                   ASL     a               ; SHIFT 4
008D64  2  0A                   ASL     a               ;
008D65  2  0A                   ASL     a               ;
008D66  2  0A                   ASL     a               ;
008D67  2  09 E0                ORA     #$E0            ; E0=MST  F0=SLV
008D69  2  AA                   TAX
008D6A  2  A0 00                LDY     #$00
008D6C  2  A9 0E                LDA     #PPIDE_DEVICE
008D6E  2  20 75 8F             JSR     IDE_WRITE
008D71  2               
008D71  2  AE 11 05             LDX     debcylm
008D74  2  A9 0D                LDA     #PPIDE_LBAHI
008D76  2  20 75 8F             JSR     IDE_WRITE
008D79  2               
008D79  2  AE 10 05             LDX     debcyll         ;
008D7C  2  A9 0C                LDA     #PPIDE_LBAMID
008D7E  2  20 75 8F             JSR     IDE_WRITE
008D81  2               
008D81  2  AE 12 05             LDX     debsehd         ;
008D84  2  A9 0B                LDA     #PPIDE_LBALOW
008D86  2  20 75 8F             JSR     IDE_WRITE
008D89  2               
008D89  2  A2 01                LDX     #$01
008D8B  2  A9 0A                LDA     #PPIDE_SEC_CNT
008D8D  2  20 75 8F             JSR     IDE_WRITE
008D90  2               
008D90  2  60                   RTS
008D91  2               
008D91  2               ;___IDE_CONVERT_SECTOR___________________________________________________________________________________
008D91  2               ;
008D91  2               ; 	TRANSLATE SECTORS INTO IDE FORMAT
008D91  2               ;________________________________________________________________________________________________________
008D91  2               IDE_CONVERT_SECTOR:
008D91  2  AD 0C 05             LDA     sektrk          ; LOAD TRACK # (LOW BYTE)
008D94  2  29 0F                AND     #$0F            ; ISOLATE HEAD IN LOW 4 BITS
008D96  2  0A                   ASL     a               ; MOVE TO HIGH BYTE
008D97  2  0A                   ASL     a
008D98  2  0A                   ASL     a
008D99  2  0A                   ASL     a
008D9A  2  AA                   TAX                     ; PARK IN X
008D9B  2  AD 0E 05             LDA     seksec          ; LOAD SECTOR # (LOW BYTE)
008D9E  2  4A                   LSR     A               ;
008D9F  2  4A                   LSR     A               ; DIVIDE BY 4 (FOR BLOCKING)
008DA0  2  29 0F                AND     #$0F            ; CLEAR UPPER 4 BITS (JUST 'CAUSE)
008DA2  2  8D 12 05             STA     debsehd         ; STORE IN SECTOR/HEAD
008DA5  2  8A                   TXA                     ; GET HEAD BACK
008DA6  2  0D 12 05             ORA     debsehd
008DA9  2  8D 12 05             STA     debsehd         ; STORE IN SECTOR/HEAD
008DAC  2               
008DAC  2  AD 0C 05             LDA     sektrk
008DAF  2  8D 10 05             STA     debcyll         ; STORE IN TRACK (lsb)
008DB2  2  AD 0D 05             LDA     sektrk+1
008DB5  2  8D 11 05             STA     debcylm         ; STORE IN TRACK (msb)
008DB8  2               ; REMOVE HEAD FROM TRACK VALUE (DIV/4)
008DB8  2  AD 11 05             LDA     debcylm
008DBB  2  4A                   LSR     A
008DBC  2  8D 11 05             STA     debcylm
008DBF  2  AD 10 05             LDA     debcyll
008DC2  2  6A                   ROR     A
008DC3  2  8D 10 05             STA     debcyll
008DC6  2               
008DC6  2  AD 11 05             LDA     debcylm
008DC9  2  4A                   LSR     A
008DCA  2  8D 11 05             STA     debcylm
008DCD  2  AD 10 05             LDA     debcyll
008DD0  2  6A                   ROR     A
008DD1  2  8D 10 05             STA     debcyll
008DD4  2               
008DD4  2  AD 11 05             LDA     debcylm
008DD7  2  4A                   LSR     A
008DD8  2  8D 11 05             STA     debcylm
008DDB  2  AD 10 05             LDA     debcyll
008DDE  2  6A                   ROR     A
008DDF  2  8D 10 05             STA     debcyll
008DE2  2               
008DE2  2  AD 11 05             LDA     debcylm
008DE5  2  4A                   LSR     A
008DE6  2  8D 11 05             STA     debcylm
008DE9  2  AD 10 05             LDA     debcyll
008DEC  2  6A                   ROR     A
008DED  2  8D 10 05             STA     debcyll
008DF0  2               
008DF0  2               ;	ADD SLICE OFFSET
008DF0  2  AD 13 05             LDA     sekdsk          ; GET DRIVE#
008DF3  2  29 07                AND     #7              ; ONLY FIRST 8 DEVICES SUPPORTED
008DF5  2  0A                   ASL     a               ; DOUBLE NUMBER FOR TABLE LOOKUP
008DF6  2  AA                   TAX                     ; MOVE TO X REGISTER
008DF7  2  E8                   INX                     ; WANT SECOND BYTE OF ENTRY
008DF8  2  BD 14 05             LDA     dskcfg,X        ; GET SLICE#
008DFB  2  8D AA 8F             STA     slicetmp+1      ; SLICE OFFSET MSB
008DFE  2  A9 00                LDA     #0              ; GET SLICE#
008E00  2  8D A9 8F             STA     slicetmp        ; SLICE OFFSET LSB
008E03  2  18                   CLC                     ; VOODOO MATH TO TAKE SLICE*$4000
008E04  2  6E AA 8F             ROR     slicetmp+1
008E07  2  6E A9 8F             ROR     slicetmp
008E0A  2  6E AA 8F             ROR     slicetmp+1
008E0D  2  6E A9 8F             ROR     slicetmp
008E10  2               
008E10  2  BD 14 05             LDA     dskcfg,X        ; GET SLICE#
008E13  2  18                   CLC
008E14  2  6D A9 8F             ADC     slicetmp
008E17  2  8D A9 8F             STA     slicetmp
008E1A  2               ; ADD SLICE OFFSET TO TRACK #
008E1A  2  18                   CLC                     ; clear carry
008E1B  2  AD A9 8F             LDA     slicetmp
008E1E  2  6D 10 05             ADC     debcyll
008E21  2  8D 10 05             STA     debcyll         ; store sum of LSBs
008E24  2  AD AA 8F             LDA     slicetmp+1
008E27  2  6D 11 05             ADC     debcylm         ; add the MSBs using carry from
008E2A  2  8D 11 05             STA     debcylm         ; the previous calculation
008E2D  2               
008E2D  2               
008E2D  2               
008E2D  2               
008E2D  2                       .IF     USEDSKY=1 || USEDSKYNG=1
008E2D  2                           PRTDBG  "DSKY OUTPUT 1$"
008E2D  2  AD 13 05                 LDA     sekdsk
008E30  2  8D 08 05                 STA     DSKY_HEXBUF
008E33  2  AD 11 05                 LDA     debcylm
008E36  2  8D 09 05                 STA     DSKY_HEXBUF+1
008E39  2  AD 10 05                 LDA     debcyll
008E3C  2  8D 0A 05                 STA     DSKY_HEXBUF+2
008E3F  2  AD 12 05                 LDA     debsehd
008E42  2  8D 0B 05                 STA     DSKY_HEXBUF+3
008E45  2  20 31 91                 JSR     DSKY_BIN2SEG
008E48  2  20 6A 91                 JSR     DSKY_SHOW
008E4B  2                       .ENDIF
008E4B  2  60                   RTS
008E4C  2               
008E4C  2               
008E4C  2               ;*__IDE_STORE_BOOT_IMAGE______________________________________________________________________________
008E4C  2               ;*
008E4C  2               ;*  WRITE Boot image to block 0 of device
008E4C  2               ;*
008E4C  2               ;*  YA points to:
008E4C  2               ;* 			DB 	Device Unit
008E4C  2               ;*			DB 	RAM Page
008E4C  2               ;*			DW 	Source Address
008E4C  2               ;* 			DB	Image Length (Pages)
008E4C  2               ;*____________________________________________________________________________________________________
008E4C  2               IDE_STORE_BOOT_IMAGE:
008E4C  2               
008E4C  2  85 14                STA     pointr          ; SET POINTR TO INFO BLOCK
008E4E  2  84 15                STY     pointr+1
008E50  2  A9 54                LDA     #<BOOTUNIT
008E52  2  85 2A                STA     room
008E54  2  A9 8F                LDA     #>BOOTUNIT
008E56  2  85 2B                STA     room+1
008E58  2  A0 00                LDY     #$00            ; COPY PARAMETERS TO USEFUL AREA
008E5A  2               :
008E5A  2  B1 14                LDA     (pointr),Y
008E5C  2  91 2A                STA     (room),Y
008E5E  2  C8                   INY
008E5F  2  C0 05                CPY     #05
008E61  2  D0 F7                BNE     :-
008E63  2               
008E63  2  A9 00                LDA     #$00
008E65  2  8D 11 05             STA     debcylm
008E68  2  8D 10 05             STA     debcyll         ;
008E6B  2  8D 12 05             STA     debsehd         ;
008E6E  2               
008E6E  2  20 7A 94             JSR     INIT_PAGE_COPY  ; COPY PAGE COPY CODE TO LORAM
008E71  2  AD 56 8F             LDA     BOOTSOURCE      ; SETUP SOURCE POINTER
008E74  2  85 14                STA     pointr
008E76  2  AD 57 8F             LDA     BOOTSOURCE+1
008E79  2  85 15                STA     pointr+1
008E7B  2               
008E7B  2               :
008E7B  2  AD 55 8F             LDA     BOOTRAMPAGE
008E7E  2  20 00 04             JSR     COPY_PAGE_TO_HSTBUF; COPY 512 BYTES AT POINTR TO HSTBUF (AND INC POINTER)
008E81  2  20 95 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008E84  2  AD 54 8F             LDA     BOOTUNIT
008E87  2  20 42 8C             JSR     IDE_WRITE_SECTOR_RAW
008E8A  2  C9 FF                CMP     #$FF
008E8C  2  F0 10                BEQ     IDE_STORE_BOOT_IMAGE_ERROR
008E8E  2  EE 12 05             INC     debsehd
008E91  2  CE 58 8F             DEC     BOOTLENGTH
008E94  2  AD 58 8F             LDA     BOOTLENGTH
008E97  2  C9 00                CMP     #$00
008E99  2  D0 E0                BNE     :-
008E9B  2  A9 00                LDA     #$00            ; ZERO ON RETURN = OPERATION OK
008E9D  2  60                   RTS
008E9E  2               IDE_STORE_BOOT_IMAGE_ERROR:
008E9E  2  A9 FF                LDA     #$FF            ; 1 ON RETURN = OPERATION FAIL
008EA0  2  60                   RTS
008EA1  2               
008EA1  2               ;*__IDE_RESTORE_BOOT_IMAGE____________________________________________________________________________
008EA1  2               ;*
008EA1  2               ;*  READ Boot image from block 0 of device
008EA1  2               ;*
008EA1  2               ;*  YA points to:
008EA1  2               ;* 			DB 	Device Unit
008EA1  2               ;*			DB 	RAM Page
008EA1  2               ;*			DW 	Source Address
008EA1  2               ;* 			DB	Image Length (Pages)
008EA1  2               ;*____________________________________________________________________________________________________
008EA1  2               IDE_RESTORE_BOOT_IMAGE:
008EA1  2               
008EA1  2  85 14                STA     pointr          ; SET POINTR TO INFO BLOCK
008EA3  2  84 15                STY     pointr+1
008EA5  2  A9 54                LDA     #<BOOTUNIT
008EA7  2  85 2A                STA     room
008EA9  2  A9 8F                LDA     #>BOOTUNIT
008EAB  2  85 2B                STA     room+1
008EAD  2  A0 00                LDY     #$00            ; COPY PARAMETERS TO USEFUL AREA
008EAF  2               :
008EAF  2  B1 14                LDA     (pointr),Y
008EB1  2  91 2A                STA     (room),Y
008EB3  2  C8                   INY
008EB4  2  C0 05                CPY     #05
008EB6  2  D0 F7                BNE     :-
008EB8  2               
008EB8  2  A9 00                LDA     #$00
008EBA  2  8D 11 05             STA     debcylm
008EBD  2  8D 10 05             STA     debcyll         ;
008EC0  2  8D 12 05             STA     debsehd         ;
008EC3  2               
008EC3  2  20 7A 94             JSR     INIT_PAGE_COPY  ; COPY PAGE COPY CODE TO LORAM
008EC6  2  AD 56 8F             LDA     BOOTSOURCE      ; SETUP SOURCE POINTER
008EC9  2  85 14                STA     pointr
008ECB  2  AD 57 8F             LDA     BOOTSOURCE+1
008ECE  2  85 15                STA     pointr+1
008ED0  2               
008ED0  2               :
008ED0  2  20 95 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008ED3  2  AD 54 8F             LDA     BOOTUNIT
008ED6  2  20 0A 8C             JSR     IDE_READ_SECTOR_DIRTY1
008ED9  2  C9 FF                CMP     #$FF
008EDB  2  F0 16                BEQ     IDE_RESTORE_BOOT_IMAGE_ERROR
008EDD  2  AD 55 8F             LDA     BOOTRAMPAGE
008EE0  2  20 2D 04             JSR     COPY_HSTBUF_TOPAGE; COPY 512 BYTES FROM HSTBUF TO POINTR HSTBUF (AND INC POINTER)
008EE3  2  EE 12 05             INC     debsehd
008EE6  2  CE 58 8F             DEC     BOOTLENGTH
008EE9  2  AD 58 8F             LDA     BOOTLENGTH
008EEC  2  C9 00                CMP     #$00
008EEE  2  D0 E0                BNE     :-
008EF0  2  A9 00                LDA     #$00            ; ZERO ON RETURN = OPERATION OK
008EF2  2  60                   RTS
008EF3  2               IDE_RESTORE_BOOT_IMAGE_ERROR:
008EF3  2  A9 FF                LDA     #$FF            ; 1 ON RETURN = OPERATION FAIL
008EF5  2  60                   RTS
008EF6  2               
008EF6  2               
008EF6  2               ;*__IDE_CLEAR_TRACKS__________________________________________________________________________________
008EF6  2               ;*
008EF6  2               ;*  CLEAR IDE TRACKS
008EF6  2               ;*
008EF6  2               ;*  YA points to:
008EF6  2               ;* 			DB 	Device Unit
008EF6  2               ;*			DW 	START TRACK
008EF6  2               ;*			DB 	NUMBER of TRACKS
008EF6  2               ;*____________________________________________________________________________________________________
008EF6  2               IDE_CLEAR_TRACKS:
008EF6  2  85 14                STA     pointr          ; SET POINTR TO INFO BLOCK
008EF8  2  84 15                STY     pointr+1
008EFA  2  A0 00                LDY     #$00
008EFC  2  B1 14                LDA     (pointr),Y
008EFE  2  8D 54 8F             STA     BOOTUNIT
008F01  2  C8                   INY
008F02  2  B1 14                LDA     (pointr),Y
008F04  2  8D 10 05             STA     debcyll         ;
008F07  2  C8                   INY
008F08  2  B1 14                LDA     (pointr),Y
008F0A  2  8D 11 05             STA     debcylm         ;
008F0D  2  C8                   INY
008F0E  2  B1 14                LDA     (pointr),Y
008F10  2  85 06                STA     nmsstr          ;
008F12  2               
008F12  2  20 44 8F             JSR     clear_hstbuf
008F15  2               
008F15  2  A9 00                LDA     #$00
008F17  2  8D 12 05             STA     debsehd         ;
008F1A  2  AA                   TAX
008F1B  2               :
008F1B  2  20 95 8C             JSR     IDE_WAIT_NOT_BUSY;MAKE SURE DRIVE IS READY
008F1E  2  AD 54 8F             LDA     BOOTUNIT
008F21  2  20 42 8C             JSR     IDE_WRITE_SECTOR_RAW
008F24  2  EE 12 05             INC     debsehd
008F27  2  AD 12 05             LDA     debsehd
008F2A  2  C9 00                CMP     #$00
008F2C  2  D0 ED                BNE     :-
008F2E  2  EE 10 05             INC     debcyll
008F31  2  AD 10 05             LDA     debcyll
008F34  2  C9 00                CMP     #$00
008F36  2  D0 03                BNE     :+
008F38  2  EE 11 05             INC     debcylm
008F3B  2               :
008F3B  2  C6 06                DEC     nmsstr
008F3D  2  A5 06                LDA     nmsstr
008F3F  2  C9 00                CMP     #$00
008F41  2  D0 D8                BNE     :--
008F43  2  60                   RTS
008F44  2               
008F44  2               clear_hstbuf:
008F44  2  A2 00                LDX     #$00
008F46  2               :
008F46  2  A9 E5                LDA     #$e5
008F48  2  9D E2 94             STA     hstbuf,x
008F4B  2  9D 46 95             STA     hstbuf+100,x
008F4E  2  E8                   INX
008F4F  2  E0 00                CPX     #$00
008F51  2  D0 F3                BNE     :-
008F53  2  60                   RTS
008F54  2               
008F54  2               BOOTUNIT:
008F54  2  00                   .BYTE   00
008F55  2               BOOTRAMPAGE:
008F55  2  00                   .BYTE   00
008F56  2               BOOTSOURCE:
008F56  2  00 00                .BYTE   00,00
008F58  2               BOOTLENGTH:
008F58  2  00                   .BYTE   00
008F59  2               
008F59  2               
008F59  2               ;-------------------------------------------------------------------------------
008F59  2               
008F59  2               ; LOW LEVEL I/O TO THE DRIVE.  THESE ARE THE ROUTINES THAT TALK
008F59  2               ; DIRECTLY TO THE DRIVE, VIA THE 8255 CHIP.  NORMALLY A MAIN
008F59  2               ; PROGRAM WOULD NOT CALL TO THESE.
008F59  2               
008F59  2               ;DO A READ BUS CYCLE TO THE DRIVE, USING THE 8255.
008F59  2               ;INPUT A = IDE REGSITER ADDRESS
008F59  2               ;OUTPUT X = LOWER BYTE READ FROM IDE DRIVE
008F59  2               ;OUTPUT Y = UPPER BYTE READ FROM IDE DRIVE
008F59  2               
008F59  2               IDE_READ:
008F59  2  20 91 8F             JSR     SET_PPI_RD      ; SETUP FOR A READ CYCLE
008F5C  2  8D 62 03             STA     PPIDECNTRL      ;DRIVE ADDRESS ONTO CONTROL LINES
008F5F  2  09 40                ORA     #PPIDE_RD_LINE  ; ASSERT RD PIN
008F61  2  8D 62 03             STA     PPIDECNTRL
008F64  2  AE 60 03             LDX     PPIDELO         ; READ LOWER BYTE
008F67  2  AC 61 03             LDY     PPIDEHI         ; READ UPPER BYTE
008F6A  2  49 40                EOR     #PPIDE_RD_LINE  ; DE-ASSERT RD SIGNAL
008F6C  2  8D 62 03             STA     PPIDECNTRL
008F6F  2  A9 00                LDA     #$00
008F71  2  8D 62 03             STA     PPIDECNTRL      ;DEASSERT ALL CONTROL PINS
008F74  2  60                   RTS
008F75  2               
008F75  2               
008F75  2               
008F75  2               
008F75  2               ;DO A WRITE BUS CYCLE TO THE DRIVE, VIA THE 8255
008F75  2               ;INPUT A = IDE REGISTER ADDRESS
008F75  2               ;INPUT REGISTER X = LSB TO WRITE
008F75  2               ;INPUT REGISTER Y = MSB TO WRITE
008F75  2               ;
008F75  2               
008F75  2               
008F75  2               IDE_WRITE:
008F75  2  20 99 8F             JSR     SET_PPI_WR      ; SETUP FOR A WRITE CYCLE
008F78  2               
008F78  2  8E 60 03             STX     PPIDELO         ; WRITE LOWER BYTE
008F7B  2  8C 61 03             STY     PPIDEHI         ; WRITE UPPER BYTE
008F7E  2               
008F7E  2  8D 62 03             STA     PPIDECNTRL      ;DRIVE ADDRESS ONTO CONTROL LINES
008F81  2               
008F81  2  09 20                ORA     #PPIDE_WR_LINE  ; ASSERT WRITE PIN
008F83  2  8D 62 03             STA     PPIDECNTRL
008F86  2               
008F86  2  49 20                EOR     #PPIDE_WR_LINE  ; DE ASSERT WR PIN
008F88  2  8D 62 03             STA     PPIDECNTRL
008F8B  2               
008F8B  2  A9 00                LDA     #$00
008F8D  2  8D 62 03             STA     PPIDECNTRL      ;DEASSERT ALL CONTROL PINS
008F90  2  60                   RTS
008F91  2               
008F91  2               
008F91  2               ;-----------------------------------------------------------------------------------
008F91  2               ; PPI SETUP ROUTINE TO CONFIGURE THE APPROPRIATE PPI MODE
008F91  2               ;
008F91  2               ;------------------------------------------------------------------------------------
008F91  2               
008F91  2               SET_PPI_RD:
008F91  2  48                   PHA
008F92  2  A9 92                LDA     #PPRD_IDE_8255
008F94  2  8D 63 03             STA     PPIDEPPIC       ;CONFIG 8255 CHIP, READ MODE
008F97  2  68                   PLA
008F98  2  60                   RTS
008F99  2               
008F99  2               SET_PPI_WR:
008F99  2  48                   PHA
008F9A  2  A9 80                LDA     #PPWR_IDE_8255
008F9C  2  8D 63 03             STA     PPIDEPPIC       ;CONFIG 8255 CHIP, WRITE MODE
008F9F  2  68                   PLA
008FA0  2  60                   RTS
008FA1  2               
008FA1  2               
008FA1  2               ;allocate the following data areas to unused ram space
008FA1  2               LASTCHAR:
008FA1  2  00                   .BYTE   0               ;save sector for warm boot
008FA2  2               savsec:
008FA2  2  00                   .BYTE   0               ;save sector for warm boot
008FA3  2               count:
008FA3  2  00                   .BYTE   0               ;counter in warm boot
008FA4  2               temp:
008FA4  2  00                   .BYTE   0               ;save hstdsk for warm boot
008FA5  2               Cdebcyll:
008FA5  2  00                   .BYTE   0               ; DEBLOCKED CYLINDER LSB
008FA6  2               Cdebcylm:
008FA6  2  00                   .BYTE   0               ; DEBLOCKED CYLINDER MSB
008FA7  2               Cdebsehd:
008FA7  2  00                   .BYTE   0               ; DEBLOCKED SECTOR AND HEAD (HS)
008FA8  2               DEBDIRTY:
008FA8  2  00                   .BYTE   0               ; DIRTY FLAG
008FA9  2               slicetmp:
008FA9  2  00 00                .WORD   0               ; USED TO CALCULATE SLICE OFFSET
008FAB  2               
008FAB  1                       .INCLUDE "dosdskyn.asm"
008FAB  2               ;__DSKYNG DRIVERS_________________________________________________________________________________________________________________
008FAB  2               ;
008FAB  2               ; 	Nhyodyne DSKY/NG drivers
008FAB  2               ;
008FAB  2               ;	Entry points:
008FAB  2               ;               DSKY_INIT
008FAB  2               ;               DSKY_SHOW
008FAB  2               ;               DSKY_BIN2SEG
008FAB  2               ;               DSKY_RESET
008FAB  2               ;               DSKY_STAT
008FAB  2               ;               DSKY_GETKEY
008FAB  2               ;               DSKY_BEEP
008FAB  2               ;               DSKY_L1ON
008FAB  2               ;               DSKY_L2ON
008FAB  2               ;               DSKY_L1OFF
008FAB  2               ;               DSKY_L2OFF
008FAB  2               ;               DSKY_PUTLED
008FAB  2               ;               DSKY_BLANK
008FAB  2               ;________________________________________________________________________________________________________________________________
008FAB  2               ;
008FAB  2               ;
008FAB  2               ; A DSKYNG CAN SHARE A PPI BUS WITH EITHER A PPIDE OR PPISD.
008FAB  2               ;
008FAB  2               ; LED SEGMENTS (BIT VALUES)
008FAB  2               ;
008FAB  2               ;	+--01--+
008FAB  2               ;	20    02
008FAB  2               ;	+--40--+
008FAB  2               ;	10    04
008FAB  2               ;	+--08--+  80
008FAB  2               ;
008FAB  2               ; KEY CODE MAP (KEY CODES) CSCCCRRR
008FAB  2               ;                          ||||||||
008FAB  2               ;                          |||||+++-- ROW
008FAB  2               ;                          ||+++----- COL
008FAB  2               ;                          |+-------- SHIFT
008FAB  2               ;                          +--------- CONTROL
008FAB  2               ;
008FAB  2               ;	00	08	10	18	23
008FAB  2               ;	01	09	11	19	22
008FAB  2               ;	02	0A	12	1A	21
008FAB  2               ;	03	0B	13	1B	20
008FAB  2               ;	04	0C	14	1C	SHIFT
008FAB  2               ;	05	0D	15	1D	CTRL
008FAB  2               ;
008FAB  2               ; LED BIT MAP (BIT VALUES)
008FAB  2               ;
008FAB  2               ;	$08	$09	$0A	$0B	$0C	$0D	$0E	$0F
008FAB  2               ;	---	---	---	---	---	---	---	---
008FAB  2               ;	01	01	01	01	01
008FAB  2               ;	02	02	02	02	02
008FAB  2               ;	04      04      04      04	04
008FAB  2               ;	08      08      08      08	08
008FAB  2               ;	10      10      10      10	10
008FAB  2               ;	20      20      20      20	20	L1	L2 	BUZZ
008FAB  2               ;
008FAB  2               DSKY_PPI        = $0360         ; PORT
008FAB  2               DSKY_PPIA       = DSKY_PPI + 0  ; PORT A
008FAB  2               DSKY_PPIB       = DSKY_PPI + 1  ; PORT B
008FAB  2               DSKY_PPIC       = DSKY_PPI + 2  ; PORT C
008FAB  2               DSKY_PPIX       = DSKY_PPI + 3  ; PPI CONTROL PORT
008FAB  2               ;
008FAB  2               DSKY_PPIX_RD    = %10010010     ; PPIX VALUE FOR READS
008FAB  2               DSKY_PPIX_WR    = %10000010     ; PPIX VALUE FOR WRITES
008FAB  2               ;
008FAB  2               ; PIO CHANNEL C:
008FAB  2               ;
008FAB  2               ;	7	6	5	4	3	2	1	0
008FAB  2               ;	RES	0	0	CS	CS	/RD	/WR	A0
008FAB  2               ;
008FAB  2               ; SETTING BITS 3 & 4 WILL ASSERT /CS ON 3279
008FAB  2               ; CLEAR BITS 1 OR 2 TO ASSERT READ/WRITE
008FAB  2               ;
008FAB  2               DSKY_PPI_IDLE   = %00000110
008FAB  2               ;
008FAB  2               DSKY_CMD_CLR    = %11011111     ; CLEAR (ALL OFF)
008FAB  2               DSKY_CMD_CLRX   = %11010011     ; CLEAR (ALL ON)
008FAB  2               DSKY_CMD_WDSP   = %10010000     ; WRITE DISPLAY RAM
008FAB  2               DSKY_CMD_RDSP   = %01110000     ; READ DISPLAY RAM
008FAB  2               DSKY_CMD_CLK    = %00100000     ; SET CLK PRESCALE
008FAB  2               DSKY_CMD_FIFO   = %01000000     ; READ FIFO
008FAB  2               ;
008FAB  2               DSKY_PRESCL     = DSKYOSC/100000; PRESCALER
008FAB  2               ;
008FAB  2               ;__DSKY_INIT_________________________________________________________________________________________
008FAB  2               ;
008FAB  2               ;  DISPLAY DSKY INFO
008FAB  2               ;____________________________________________________________________________________________________
008FAB  2               ;
008FAB  2               DSKY_INIT:
008FAB  2                       PRTDBG  "DSKY INIT:$"
008FAB  2  20 7B 90             JSR     DSKY_PREINIT
008FAE  2  48 8A 48 A8          PRTS    "DSKY:$"
008FB2  2  48 A2 00 BD  
008FB6  2  CB 8F E8 C9  
008FD1  2  20 7F 88             JSR     NEWLINE
008FD4  2               
008FD4  2               ;
008FD4  2  48 8A 48 A8          PRTS    " IO=0x$"
008FD8  2  48 A2 00 BD  
008FDC  2  F1 8F E8 C9  
008FF8  2  A9 03                LDA     #>DSKY_PPI      ; GET BASE PORT
008FFA  2  20 55 88             JSR     PRTHEXBYTE      ; PRINT BASE PORT
008FFD  2  A9 60                LDA     #<DSKY_PPI      ; GET BASE PORT
008FFF  2  20 55 88             JSR     PRTHEXBYTE      ; PRINT BASE PORT
009002  2  48 8A 48 A8          PRTS    " MODE=$"
009006  2  48 A2 00 BD  
00900A  2  1F 90 E8 C9  
009026  2  48 8A 48 A8          PRTS    "NG$"           ; PRINT DSKY TYPE
00902A  2  48 A2 00 BD  
00902E  2  43 90 E8 C9  
009046  2               ;
009046  2  AD 14 93             LDA     DSKY_PRESENT    ; PRESENT?
009049  2  C9 FF                CMP     #$FF            ; SET FLAGS
00904B  2  F0 2A                BEQ     DSKY_INITA
00904D  2  48 8A 48 A8          PRTS    " NOT PRESENT$" ; NOT PRESENT
009051  2  48 A2 00 BD  
009055  2  6A 90 E8 C9  
009077  2               DSKY_INITA:
009077  2  20 7F 88             JSR     NEWLINE
00907A  2  60                   RTS                     ; DONE
00907B  2               ;
00907B  2               ;__DSKY_PREINIT______________________________________________________________________________________
00907B  2               ;
00907B  2               ;  CONFIGURE PARALLEL PORT AND INITIALIZE 8279
00907B  2               ;____________________________________________________________________________________________________
00907B  2               ; HARDWARE RESET 8279 BY PULSING RESET LINE
00907B  2               DSKY_PREINIT:
00907B  2               ; CHECK FOR PPI
00907B  2  20 C0 90             JSR     DSKY_PPIDETECT  ; TEST FOR PPI HARDWARE
00907E  2  D0 2A                BNE     DSKY_ABORT      ; BAIL OUT IF NOT THERE
009080  2               
009080  2               ; SETUP PPI TO DEFAULT MODE
009080  2  20 ED 92             JSR     DSKY_PPIRD
009083  2               ; INIT 8279 VALUES TO IDLE STATE
009083  2  A9 06                LDA     #DSKY_PPI_IDLE
009085  2  8D 62 03             STA     DSKY_PPIC
009088  2               ; PULSE RESET SIGNAL ON 8279
009088  2  09 80                ORA     #%10000000
00908A  2  8D 62 03             STA     DSKY_PPIC
00908D  2  29 7F                AND     #%01111111
00908F  2  8D 62 03             STA     DSKY_PPIC
009092  2               ; INITIALIZE 8279
009092  2  20 AB 90             JSR     DSKY_REINIT
009095  2               ; NOW SEE IF A DSKYNG IS REALLY THERE...
009095  2  A9 A5                LDA     #$A5
009097  2  A0 00                LDY     #$00
009099  2  20 06 92             JSR     DSKY_PUTBYTE
00909C  2  A0 00                LDY     #$00
00909E  2  20 20 92             JSR     DSKY_GETBYTE
0090A1  2  C9 A5                CMP     #$A5
0090A3  2  D0 05                BNE     DSKY_ABORT      ; BAIL OUT IF MISCOMPARE
0090A5  2  A9 FF                LDA     #$FF
0090A7  2  8D 14 93             STA     DSKY_PRESENT
0090AA  2               DSKY_ABORT:
0090AA  2  60                   RTS
0090AB  2               ;
0090AB  2               DSKY_REINIT:
0090AB  2  20 FF 92             JSR     DSKY_PPIIDLE
0090AE  2               ; SET CLOCK SCALER TO 20
0090AE  2  A9 2A                LDA     #DSKY_CMD_CLK | DSKY_PRESCL
0090B0  2  20 86 91             JSR     DSKY_CMD
0090B3  2               ; FALL THRU
0090B3  2               ;
0090B3  2               DSKY_RESET:
0090B3  2               ; RESET DSKY -- CLEAR RAM AND FIFO
0090B3  2  A9 DF                LDA     #DSKY_CMD_CLR
0090B5  2  20 86 91             JSR     DSKY_CMD
0090B8  2               ;
0090B8  2               ; 8259 TAKES ~160US TO CLEAR RAM DURING WHICH TIME WRITES TO
0090B8  2               ; DISPLAY RAM ARE INHIBITED.  HIGH BIT OF STATUS BYTE IS SET
0090B8  2               ; DURING THIS WINDOW.  TO PREVENT A DEADLOCK, A LOOP COUNTER
0090B8  2               ; IS USED TO IMPLEMENT A TIMEOUT.
0090B8  2  A2 00                LDX     #0              ; TIMEOUT LOOP COUNTER
0090BA  2               DSKY_RESET1:
0090BA  2  48                   PHA                     ; SAVE COUNTER
0090BB  2  68                   PLA                     ; RECOVER COUNTER
0090BC  2  CA                   DEX
0090BD  2  D0 FB                BNE     DSKY_RESET1     ; LOOP TILL TIMEOUT
0090BF  2               ;
0090BF  2               DSKY_RESET2:
0090BF  2  60                   RTS
0090C0  2               ;
0090C0  2               ;
0090C0  2               ;
0090C0  2               ;__DSKY_PPIDETECT____________________________________________________________________________________
0090C0  2               ;
0090C0  2               ;  PROBE FOR PPI HARDWARE
0090C0  2               ;____________________________________________________________________________________________________
0090C0  2               ;
0090C0  2               DSKY_PPIDETECT:
0090C0  2               ;
0090C0  2               ; TEST FOR PPI EXISTENCE
0090C0  2               ; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
0090C0  2               ; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
0090C0  2               ; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
0090C0  2               ; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
0090C0  2               ; INTERFERE WITH THE VALUE BEING READ.
0090C0  2  20 D6 92             JSR     DSKY_PPIWR
0090C3  2               ;
0090C3  2  A9 00                LDA     #$00            ; VALUE ZERO
0090C5  2  8D 60 03             STA     DSKY_PPIA       ; PUSH VALUE TO PORT
0090C8  2  AD 60 03             LDA     DSKY_PPIA       ; GET PORT VALUE
0090CB  2  C9 00                CMP     #$00
0090CD  2  60                   RTS                     ; AND RETURN
0090CE  2               ;
0090CE  2                       .IF     DSKY_KBD=1
0090CE  2               ;
0090CE  2               KY_0                = $00
0090CE  2               KY_1                = $01
0090CE  2               KY_2                = $02
0090CE  2               KY_3                = $03
0090CE  2               KY_4                = $04
0090CE  2               KY_5                = $05
0090CE  2               KY_6                = $06
0090CE  2               KY_7                = $07
0090CE  2               KY_8                = $08
0090CE  2               KY_9                = $09
0090CE  2               KY_A                = $0A
0090CE  2               KY_B                = $0B
0090CE  2               KY_C                = $0C
0090CE  2               KY_D                = $0D
0090CE  2               KY_E                = $0E
0090CE  2               KY_F                = $0F
0090CE  2               KY_FW               = $10           ; FORWARD
0090CE  2               KY_BK               = $11           ; BACKWARD
0090CE  2               KY_CL               = $12           ; CLEAR
0090CE  2               KY_EN               = $13           ; ENTER
0090CE  2               KY_DE               = $14           ; DEPOSIT
0090CE  2               KY_EX               = $15           ; EXAMINE
0090CE  2               KY_GO               = $16           ; GO
0090CE  2               KY_BO               = $17           ; BOOT
0090CE  2               KY_F4               = $18           ; F4
0090CE  2               KY_F3               = $19           ; F3
0090CE  2               KY_F2               = $20           ; F2
0090CE  2               KY_F1               = $21           ; F1
0090CE  2               ;
0090CE  2               ;__DSKY_STAT_________________________________________________________________________________________
0090CE  2               ;
0090CE  2               ;  CHECK FOR KEY PRESS, SAVE RAW VALUE, RETURN STATUS
0090CE  2               ;____________________________________________________________________________________________________
0090CE  2               ;
0090CE  2               DSKY_STAT:
0090CE  2  AD 14 93                 LDA     DSKY_PRESENT    ; DOES IT EXIST?
0090D1  2  C9 FF                    CMP     #$FF            ; SET FLAGS
0090D3  2  D0 05                    BNE     DSKY_STATA      ; ABORT WITH A=0 IF NOT THERE
0090D5  2  20 BF 91                 JSR     DSKY_ST
0090D8  2  29 0F                    AND     #$0F            ; ISOLATE THE CUR FIFO LEN
0090DA  2               DSKY_STATA:
0090DA  2  60                       RTS
0090DB  2               ;
0090DB  2               ;__DSKY_GETKEY_____________________________________________________________________________________
0090DB  2               ;
0090DB  2               ;  WAIT FOR A DSKY KEYPRESS AND RETURN
0090DB  2               ;____________________________________________________________________________________________________
0090DB  2               ;
0090DB  2               DSKY_GETKEY:
0090DB  2  AD 14 93                 LDA     DSKY_PRESENT    ; DOES IT EXIST?
0090DE  2  C9 FF                    CMP     #$FF            ; SET FLAGS
0090E0  2  D0 24                    BNE     DSKY_GETKEY1A   ; ABORT WITH A=0 IF NOT THERE
0090E2  2  20 CE 90                 JSR     DSKY_STAT
0090E5  2  F0 F4                    BEQ     DSKY_GETKEY     ; LOOP IF NOTHING THERE
0090E7  2  A9 40                    LDA     #DSKY_CMD_FIFO
0090E9  2  20 86 91                 JSR     DSKY_CMD
0090EC  2  20 C4 91                 JSR     DSKY_DIN
0090EF  2  49 C0                    EOR     #%11000000      ; FLIP POLARITY OF SHIFT/CTL BITS
0090F1  2  48                       PHA
0090F2  2  29 3F                    AND     #$3F            ; STRIP SHIFT/CTL BITS FOR LOOKUP
0090F4  2  8D 12 93                 STA     DSKY_TEMP_VAL
0090F7  2  A2 00                    LDX     #0              ; INDEX
0090F9  2               DSKY_GETKEY1:
0090F9  2  BD 15 91                 LDA     DSKY_KEYMAP,X
0090FC  2  CD 12 93                 CMP     DSKY_TEMP_VAL   ; MATCH?
0090FF  2  F0 09                    BEQ     DSKY_GETKEY2    ; FOUND, DONE
009101  2  E8                       INX
009102  2  E0 1C                    CPX     #28
009104  2  D0 F3                    BNE     DSKY_GETKEY1    ; LOOP UNTIL EOT
009106  2               DSKY_GETKEY1A:
009106  2  68                       PLA
009107  2  A9 FF                    LDA     #$FF            ; NOT FOUND ERR, RETURN $FF
009109  2  60                       RTS
00910A  2               DSKY_GETKEY2:
00910A  2               ; RETURN THE INDEX POSITION WHERE THE SCAN CODE WAS FOUND
00910A  2               ; THE ORIGINAL SHIFT/CTRL BITS ARE RESTORED
00910A  2  68                       PLA                     ; RESTORE RAW VALUE
00910B  2  25 C0                    AND     %11000000       ; ISOLATE SHIFT/CTRL BITS
00910D  2  8D 12 93                 STA     DSKY_TEMP_VAL
009110  2  8A                       TXA
009111  2  0D 12 93                 ORA     DSKY_TEMP_VAL   ; COMBINE WITH INDEX VALUE
009114  2  60                       RTS
009115  2               ;
009115  2               ;_KEYMAP_TABLE_____________________________________________________________________________________________________________
009115  2               ;
009115  2               DSKY_KEYMAP:
009115  2               ; POS	$00  $01  $02  $03  $04  $05  $06  $07
009115  2               ; KEY   [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]
009115  2  0D 04 0C 14              .BYTE   $0D, $04, $0C, $14, $03, $0B, $13, $02
009119  2  03 0B 13 02  
00911D  2               ;
00911D  2               ; POS	$08  $09  $0A  $0B  $0C  $0D  $0E  $0F
00911D  2               ; KEY   [8]  [9]  [A]  [B]  [C]  [D]  [E]  [F]
00911D  2  0A 12 01 09              .BYTE   $0A, $12, $01, $09, $11, $00, $08, $10
009121  2  11 00 08 10  
009125  2               ;
009125  2               ; POS	$10  $11  $12  $13  $14  $15  $16  $17
009125  2               ; KEY   [FW] [BK] [CL] [EN] [DE] [EX] [GO] [BO]
009125  2  05 15 1D 1C              .BYTE   $05, $15, $1D, $1C, $1B, $1A, $19, $18
009129  2  1B 1A 19 18  
00912D  2               
00912D  2               ; POS	$18  $19  $20  $21
00912D  2               ; KEY   [F4] [F3] [F2] [F1]
00912D  2  23 22 21 20              .BYTE   $23, $22, $21, $20
009131  2               
009131  2               ;
009131  2                       .ENDIF                  ; DSKY_KBD
009131  2               ;
009131  2               ;__DSKY_BIN2SEG________________________________________________________________________________________
009131  2               ;
009131  2               ; CONVERT 32 BIT BINARY TO 8 BYTE HEX SEGMENT DISPLAY
009131  2               ;
009131  2               ; DSKY_BUF: 32 BIT BINARY
009131  2               ; DSKY_HEXBUF: DEST LED SEGMENT DISPLAY BUFFER (8 BYTES)
009131  2               ;____________________________________________________________________________________________________
009131  2               ;
009131  2               DSKY_BIN2SEG:
009131  2  A2 00                LDX     #$00
009133  2               DSKY_BIN2SEG1:
009133  2  BD 08 05             LDA     DSKY_HEXBUF,X   ; FIRST NIBBLE
009136  2  4A                   LSR     A
009137  2  4A                   LSR     A
009138  2  4A                   LSR     A
009139  2  4A                   LSR     A
00913A  2  86 3A                STX     STACKA          ; STORE READ INDEX
00913C  2  AA                   TAX                     ; MOVE DIGIT TO LOOKUP INDEX
00913D  2  BD 02 93             LDA     DSKY_HEXMAP,X   ; GET DECODED DIGIT INTO A
009140  2  A6 3A                LDX     STACKA          ; GET READ INDEX
009142  2  48                   PHA
009143  2  8A                   TXA
009144  2  0A                   ASL     a
009145  2  AA                   TAX
009146  2  68                   PLA
009147  2  9D 00 05             STA     DSKY_BUF,X      ;STORE HIGH BYTE IN OUT BUFFER
00914A  2  A6 3A                LDX     STACKA          ; GET READ INDEX
00914C  2  BD 08 05             LDA     DSKY_HEXBUF,X   ; SECOND NIBBLE
00914F  2               
00914F  2  29 0F                AND     #$0F
009151  2  86 3A                STX     STACKA          ; STORE READ INDEX
009153  2  AA                   TAX
009154  2  BD 02 93             LDA     DSKY_HEXMAP,X   ; GET DECODED DIGIT INTO A
009157  2  A6 3A                LDX     STACKA          ; GET READ INDEX
009159  2  48                   PHA
00915A  2  8A                   TXA                     ; GET READ INDEX
00915B  2  0A                   ASL     a
00915C  2  AA                   TAX
00915D  2  E8                   INX
00915E  2  68                   PLA
00915F  2  9D 00 05             STA     DSKY_BUF,X      ;STORE HIGH BYTE IN OUT BUFFER
009162  2  A6 3A                LDX     STACKA          ; GET READ INDEX
009164  2  E8                   INX
009165  2  E0 04                CPX     #4
009167  2  D0 CA                BNE     DSKY_BIN2SEG1
009169  2  60                   RTS
00916A  2               ;
00916A  2               ;__DSKY_SHOW___________________________________________________________________________________________
00916A  2               ; DSKY SHOW BUFFER
00916A  2               ;______________________________________________________________________________________________________
00916A  2               ;
00916A  2               DSKY_SHOW:
00916A  2  48                   PHA
00916B  2  8A                   TXA
00916C  2  48                   PHA
00916D  2  98                   TYA
00916E  2  48                   PHA
00916F  2  A2 00                LDX     #0
009171  2               DSKY_SHOW1:
009171  2  BD 00 05             LDA     DSKY_BUF,X
009174  2  86 3A                STX     STACKA
009176  2  A4 3A                LDY     STACKA
009178  2  20 06 92             JSR     DSKY_PUTBYTE
00917B  2  E8                   INX
00917C  2  E0 08                CPX     #8
00917E  2  D0 F1                BNE     DSKY_SHOW1
009180  2  68                   PLA
009181  2  A8                   TAY
009182  2  68                   PLA
009183  2  AA                   TAX
009184  2  68                   PLA
009185  2  60                   RTS
009186  2               
009186  2               ;______________________________________________________________________________________________________
009186  2               ; DSKYNG OUTPUT ROUTINES
009186  2               ;______________________________________________________________________________________________________
009186  2               
009186  2               ; SEND DSKY COMMAND BYTE IN REGISTER A
009186  2               DSKY_CMD:
009186  2  48                   PHA
009187  2  A9 01                LDA     #$01
009189  2  4C 8F 91             JMP     DSKY_DOUT2
00918C  2               ;
00918C  2               ; SEND DSKY DATA BYTE IN REGISTER A
00918C  2               ; TRASHES BC
00918C  2               ;
00918C  2               DSKY_DOUT:
00918C  2  48                   PHA
00918D  2  A9 00                LDA     #$00
00918F  2               ;
00918F  2               DSKY_DOUT2:
00918F  2               ; SET PPI LINE CONFIG TO WRITE MODE
00918F  2  20 D6 92             JSR     DSKY_PPIWR
009192  2               ;
009192  2               ; SET ADDRESS FIRST
009192  2  09 06                ORA     #DSKY_PPI_IDLE
009194  2  8D 62 03             STA     DSKY_PPIC
009197  2               ;
009197  2               ; ASSERT 8279 /CS
009197  2  09 18                ORA     #%00011000
009199  2  8D 62 03             STA     DSKY_PPIC
00919C  2               ;
00919C  2               ; PPIC WORKING VALUE TO DSKY_TEMP_VAL
00919C  2  8D 12 93             STA     DSKY_TEMP_VAL
00919F  2               ;
00919F  2               ; ASSERT DATA BYTE VALUE
00919F  2  68                   PLA
0091A0  2  8D 60 03             STA     DSKY_PPIA
0091A3  2               ;
0091A3  2               ; PULSE /WR
0091A3  2  AD 12 93             LDA     DSKY_TEMP_VAL
0091A6  2  29 FD                AND     #%11111101
0091A8  2  8D 62 03             STA     DSKY_PPIC
0091AB  2  EA                   NOP                     ; MAY NOT BE NEEDED
0091AC  2  09 02                ORA     #%00000010
0091AE  2  8D 62 03             STA     DSKY_PPIC
0091B1  2               ;
0091B1  2               ; DEASSERT /CS
0091B1  2  29 E7                AND     #%11100111
0091B3  2  8D 62 03             STA     DSKY_PPIC
0091B6  2               ;
0091B6  2               ; CLEAR ADDRESS BIT
0091B6  2  29 E6                AND     #%11100110
0091B8  2  8D 62 03             STA     DSKY_PPIC
0091BB  2               ;
0091BB  2               ; DONE
0091BB  2  20 FF 92             JSR     DSKY_PPIIDLE
0091BE  2  60                   RTS
0091BF  2               ;
0091BF  2               ;==================================================================================================
0091BF  2               ; DSKYNG OUTPUT ROUTINES
0091BF  2               ;==================================================================================================
0091BF  2               ;
0091BF  2               ; RETURN DSKY STATUS VALUE IN A
0091BF  2               ;
0091BF  2               DSKY_ST:
0091BF  2  A9 01                LDA     #$01
0091C1  2  4C C6 91             JMP     DSKY_DIN2
0091C4  2               ;
0091C4  2               ; RETURN NEXT DATA VALUE IN A
0091C4  2               ;
0091C4  2               DSKY_DIN:
0091C4  2  A9 00                LDA     #$00
0091C6  2               ;
0091C6  2               DSKY_DIN2:
0091C6  2               ; SET PPI LINE CONFIG TO READ MODE
0091C6  2  20 ED 92             JSR     DSKY_PPIRD
0091C9  2               ;
0091C9  2               ; SET ADDRESS FIRST
0091C9  2  09 06                ORA     #DSKY_PPI_IDLE
0091CB  2  8D 62 03             STA     DSKY_PPIC
0091CE  2               ;
0091CE  2               ; ASSERT 8279 /CS
0091CE  2  09 18                ORA     #%00011000
0091D0  2  8D 62 03             STA     DSKY_PPIC
0091D3  2               ;
0091D3  2               ; ASSERT /RD
0091D3  2  29 7B                AND     #%01111011
0091D5  2  8D 62 03             STA     DSKY_PPIC
0091D8  2               ;
0091D8  2  8D 12 93             STA     DSKY_TEMP_VAL
0091DB  2               ; GET VALUE
0091DB  2  AD 60 03             LDA     DSKY_PPIA
0091DE  2  48                   PHA
0091DF  2               
0091DF  2  AD 12 93             LDA     DSKY_TEMP_VAL
0091E2  2               ; DEASSERT /RD
0091E2  2  09 04                ORA     #%00000100
0091E4  2  8D 62 03             STA     DSKY_PPIC
0091E7  2               ;
0091E7  2               ; DEASSERT /CS
0091E7  2  29 E7                AND     #%11100111
0091E9  2  8D 62 03             STA     DSKY_PPIC
0091EC  2               ;
0091EC  2               ; CLEAR ADDRESS BIT
0091EC  2  29 E6                AND     #%11100110
0091EE  2  8D 62 03             STA     DSKY_PPIC
0091F1  2               ;
0091F1  2               ; DONE
0091F1  2  20 FF 92             JSR     DSKY_PPIIDLE
0091F4  2  68                   PLA
0091F5  2  60                   RTS
0091F6  2               
0091F6  2               ;__DSKY_BLANK_____________________________________________________________________________________
0091F6  2               ;
0091F6  2               ; BLANK DSKYNG DISPLAY  (WITHOUT USING CLEAR)
0091F6  2               ;
0091F6  2               ;_________________________________________________________________________________________________
0091F6  2               ;
0091F6  2               DSKY_BLANK:
0091F6  2  A9 90                LDA     #DSKY_CMD_WDSP
0091F8  2  20 86 91             JSR     DSKY_CMD
0091FB  2  A2 10                LDX     #16
0091FD  2               DSKY_BLANK1:
0091FD  2  A9 FF                LDA     #$FF
0091FF  2  20 8C 91             JSR     DSKY_DOUT
009202  2  CA                   DEX
009203  2  D0 F8                BNE     DSKY_BLANK1
009205  2  60                   RTS
009206  2               ;
009206  2               ;__DSKY_PUTBYTE____________________________________________________________________________________
009206  2               ;
009206  2               ; WRITE A RAW BYTE VALUE TO DSKY DISPLAY RAM
009206  2               ; AT LOCATION IN REGISTER Y, VALUE IN A.
009206  2               ;
009206  2               ;__________________________________________________________________________________________________
009206  2               ;
009206  2               DSKY_PUTBYTE:
009206  2  85 3A                STA     STACKA
009208  2  48                   PHA
009209  2  98                   TYA
00920A  2  48                   PHA
00920B  2  A5 3A                LDA     STACKA
00920D  2  48                   PHA
00920E  2  18                   CLC
00920F  2  98                   TYA
009210  2  69 90                ADC     #DSKY_CMD_WDSP
009212  2  A8                   TAY
009213  2  20 86 91             JSR     DSKY_CMD
009216  2  68                   PLA
009217  2  49 FF                EOR     #$FF
009219  2  20 8C 91             JSR     DSKY_DOUT
00921C  2  68                   PLA
00921D  2  A8                   TAY
00921E  2  68                   PLA
00921F  2  60                   RTS
009220  2               ;
009220  2               ;__DSKY_GETBYTE___________________________________________________________________________________
009220  2               ; READ A RAW BYTE VALUE FROM DSKY DISPLAY RAM
009220  2               ; AT LOCATION IN REGISTER Y, VALUE RETURNED IN A
009220  2               ;
009220  2               ;_________________________________________________________________________________________________
009220  2               ;
009220  2               DSKY_GETBYTE:
009220  2  18                   CLC
009221  2  98                   TYA
009222  2  69 70                ADC     #DSKY_CMD_RDSP
009224  2  A8                   TAY
009225  2  20 86 91             JSR     DSKY_CMD
009228  2  20 C4 91             JSR     DSKY_DIN
00922B  2  49 FF                EOR     #$FF
00922D  2  60                   RTS
00922E  2               
00922E  2               ;
00922E  2               ;__DSKY_PUTLED____________________________________________________________________________________
00922E  2               ;
00922E  2               ;	This function is intended to update the LEDs.
00922E  2               ;	VALUES SHOULD BE IN DSKY_BUF
00922E  2               ;_________________________________________________________________________________________________
00922E  2               ;
00922E  2               DSKY_PUTLED:
00922E  2  48                   PHA
00922F  2  8A                   TXA
009230  2  48                   PHA
009231  2  98                   TYA
009232  2  48                   PHA
009233  2  A0 00                LDY     #$00
009235  2  A2 00                LDX     #$00
009237  2               DSKY_PUTLED_1:
009237  2  BD 00 05             LDA     DSKY_BUF,X      ; GET BYTE
00923A  2  20 06 92             JSR     DSKY_PUTBYTE    ; SEND IT TO DSKY
00923D  2  C8                   INY                     ; LOOP TIL DONE
00923E  2  E8                   INX
00923F  2  C0 08                CPY     #8
009241  2  D0 F4                BNE     DSKY_PUTLED_1
009243  2  68                   PLA                     ; RESTORE REGISTERS
009244  2  A8                   TAY
009245  2  68                   PLA
009246  2  AA                   TAX
009247  2  68                   PLA
009248  2  60                   RTS
009249  2               ;
009249  2               ;__DSKY_BEEP______________________________________________________________________________________
009249  2               ;	This function is intended to beep the speaker on the DSKY
009249  2               ;_________________________________________________________________________________________________
009249  2               ;
009249  2               DSKY_BEEP:
009249  2  48                   PHA
00924A  2  8A                   TXA
00924B  2  48                   PHA
00924C  2  98                   TYA
00924D  2  48                   PHA
00924E  2               
00924E  2  A0 0F                LDY     #$0F
009250  2  20 20 92             JSR     DSKY_GETBYTE
009253  2  09 20                ORA     #$20
009255  2  A9 20                LDA     #$20
009257  2  A0 0F                LDY     #$0F
009259  2  20 06 92             JSR     DSKY_PUTBYTE
00925C  2               
00925C  2               ;;; 	timer . . .
00925C  2  A2 8F                LDX     #$8F
00925E  2  A0 FF                LDY     #$FF
009260  2               DSKY_BEEP1:
009260  2  88                   DEY
009261  2  D0 FD                BNE     DSKY_BEEP1
009263  2  CA                   DEX
009264  2  D0 FA                BNE     DSKY_BEEP1
009266  2               
009266  2  A0 0F                LDY     #$0F
009268  2  20 20 92             JSR     DSKY_GETBYTE
00926B  2  29 DF                AND     #$DF
00926D  2  A9 DF                LDA     #$DF
00926F  2  A0 0F                LDY     #$0F
009271  2  20 06 92             JSR     DSKY_PUTBYTE
009274  2               
009274  2  68                   PLA                     ; RESTORE REGISTERS
009275  2  A8                   TAY
009276  2  68                   PLA
009277  2  AA                   TAX
009278  2  68                   PLA
009279  2  60                   RTS
00927A  2               ;
00927A  2               ;__DSKY_L1ON______________________________________________________________________________________
00927A  2               ;	This function is intended to turn on DSKY L1
00927A  2               ;_________________________________________________________________________________________________
00927A  2               ;
00927A  2               DSKY_L1ON:
00927A  2  48                   PHA
00927B  2  8A                   TXA
00927C  2  48                   PHA
00927D  2  98                   TYA
00927E  2  48                   PHA
00927F  2  A0 0D                LDY     #$0D
009281  2  20 20 92             JSR     DSKY_GETBYTE
009284  2  09 20                ORA     #$20
009286  2  A0 0D                LDY     #$0D
009288  2  20 06 92             JSR     DSKY_PUTBYTE
00928B  2  68                   PLA                     ; RESTORE REGISTERS
00928C  2  A8                   TAY
00928D  2  68                   PLA
00928E  2  AA                   TAX
00928F  2  68                   PLA
009290  2  60                   RTS
009291  2               ;
009291  2               ;__DSKY_L2ON______________________________________________________________________________________
009291  2               ;	This function is intended to turn on DSKY L2
009291  2               ;_________________________________________________________________________________________________
009291  2               ;
009291  2               DSKY_L2ON:
009291  2  48                   PHA
009292  2  8A                   TXA
009293  2  48                   PHA
009294  2  98                   TYA
009295  2  48                   PHA
009296  2  A0 0E                LDY     #$0E
009298  2  20 20 92             JSR     DSKY_GETBYTE
00929B  2  09 20                ORA     #$20
00929D  2  A0 0E                LDY     #$0E
00929F  2  20 06 92             JSR     DSKY_PUTBYTE
0092A2  2  68                   PLA                     ; RESTORE REGISTERS
0092A3  2  A8                   TAY
0092A4  2  68                   PLA
0092A5  2  AA                   TAX
0092A6  2  68                   PLA
0092A7  2  60                   RTS
0092A8  2               ;
0092A8  2               ;__DSKY_L1OFF_____________________________________________________________________________________
0092A8  2               ;	This function is intended to turn off DSKY L1
0092A8  2               ;_________________________________________________________________________________________________
0092A8  2               ;
0092A8  2               DSKY_L1OFF:
0092A8  2  48                   PHA
0092A9  2  8A                   TXA
0092AA  2  48                   PHA
0092AB  2  98                   TYA
0092AC  2  48                   PHA
0092AD  2  A0 0D                LDY     #$0D
0092AF  2  20 20 92             JSR     DSKY_GETBYTE
0092B2  2  29 DF                AND     #$DF
0092B4  2  A0 0D                LDY     #$0D
0092B6  2  20 06 92             JSR     DSKY_PUTBYTE
0092B9  2  68                   PLA                     ; RESTORE REGISTERS
0092BA  2  A8                   TAY
0092BB  2  68                   PLA
0092BC  2  AA                   TAX
0092BD  2  68                   PLA
0092BE  2  60                   RTS
0092BF  2               ;
0092BF  2               ;__DSKY_L2OFF_____________________________________________________________________________________
0092BF  2               ;	This function is intended to turn off DSKY L2
0092BF  2               ;_________________________________________________________________________________________________
0092BF  2               ;
0092BF  2               DSKY_L2OFF:
0092BF  2  48                   PHA
0092C0  2  8A                   TXA
0092C1  2  48                   PHA
0092C2  2  98                   TYA
0092C3  2  48                   PHA
0092C4  2  A0 0E                LDY     #$0E
0092C6  2  20 20 92             JSR     DSKY_GETBYTE
0092C9  2  29 DF                AND     #$DF
0092CB  2  A0 0E                LDY     #$0E
0092CD  2  20 06 92             JSR     DSKY_PUTBYTE
0092D0  2  68                   PLA                     ; RESTORE REGISTERS
0092D1  2  A8                   TAY
0092D2  2  68                   PLA
0092D3  2  AA                   TAX
0092D4  2  68                   PLA
0092D5  2  60                   RTS
0092D6  2               ;
0092D6  2               ;_________________________________________________________________________________________________
0092D6  2               ; DSKYNG LINE CONTROL ROUTINES
0092D6  2               ;
0092D6  2               ; SETUP PPI FOR WRITING: PUT PPI PORT A IN OUTPUT MODE
0092D6  2               ; AVOID REWRTING PPIX IF ALREADY IN OUTPUT MODE
0092D6  2               ;
0092D6  2               ;_________________________________________________________________________________________________
0092D6  2               ;
0092D6  2               DSKY_PPIWR:
0092D6  2  48                   PHA
0092D7  2               ;
0092D7  2               ; CHECK FOR WRITE MODE
0092D7  2  AD 13 93             LDA     DSKY_PPIX_VAL
0092DA  2  C9 82                CMP     #DSKY_PPIX_WR
0092DC  2  F0 0D                BEQ     DSKY_PPIWR1
0092DE  2               ;
0092DE  2               ; SET PPI TO WRITE MODE
0092DE  2  A9 82                LDA     #DSKY_PPIX_WR
0092E0  2  8D 63 03             STA     DSKY_PPIX
0092E3  2  8D 13 93             STA     DSKY_PPIX_VAL
0092E6  2               ;
0092E6  2               ; RESTORE PORT C (MAY NOT BE NEEDED)
0092E6  2  A9 06                LDA     #DSKY_PPI_IDLE
0092E8  2  8D 62 03             STA     DSKY_PPIC
0092EB  2               ;
0092EB  2               DSKY_PPIWR1:
0092EB  2               ;
0092EB  2  68                   PLA
0092EC  2  60                   RTS
0092ED  2               ;
0092ED  2               ; SETUP PPI FOR READING: PUT PPI PORT A IN INPUT MODE
0092ED  2               ; AVOID REWRTING PPIX IF ALREADY IN INPUT MODE
0092ED  2               ;
0092ED  2               DSKY_PPIRD:
0092ED  2  48                   PHA
0092EE  2               ;
0092EE  2               ; CHECK FOR READ MODE
0092EE  2  AD 13 93             LDA     DSKY_PPIX_VAL
0092F1  2  C9 92                CMP     #DSKY_PPIX_RD
0092F3  2  F0 08                BEQ     DSKY_PPIRD1
0092F5  2               ;
0092F5  2               ; SET PPI TO READ MODE
0092F5  2  A9 92                LDA     #DSKY_PPIX_RD
0092F7  2  8D 63 03             STA     DSKY_PPIX
0092FA  2  8D 13 93             STA     DSKY_PPIX_VAL
0092FD  2               ;
0092FD  2               DSKY_PPIRD1:
0092FD  2  68                   PLA
0092FE  2  60                   RTS
0092FF  2               ;
0092FF  2               ; RELEASE USE OF PPI
0092FF  2               ;
0092FF  2               DSKY_PPIIDLE:
0092FF  2  4C ED 92             JMP     DSKY_PPIRD      ; SAME AS READ MODE
009302  2               ;
009302  2               ;__STORAGE_________________________________________________________________________________________
009302  2               ; CODES FOR NUMERICS
009302  2               ; HIGH BIT ALWAYS CLEAR TO SUPPRESS DECIMAL POINT
009302  2               ; SET HIGH BIT TO SHOW DECIMAL POINT
009302  2               ;_________________________________________________________________________________________________
009302  2               ;
009302  2               DSKY_HEXMAP:
009302  2  3F                   .BYTE   $3F             ; 0
009303  2  06                   .BYTE   $06             ; 1
009304  2  5B                   .BYTE   $5B             ; 2
009305  2  4F                   .BYTE   $4F             ; 3
009306  2  66                   .BYTE   $66             ; 4
009307  2  6D                   .BYTE   $6D             ; 5
009308  2  7D                   .BYTE   $7D             ; 6
009309  2  07                   .BYTE   $07             ; 7
00930A  2  7F                   .BYTE   $7F             ; 8
00930B  2  67                   .BYTE   $67             ; 9
00930C  2  77                   .BYTE   $77             ; A
00930D  2  7C                   .BYTE   $7C             ; B
00930E  2  39                   .BYTE   $39             ; C
00930F  2  5E                   .BYTE   $5E             ; D
009310  2  79                   .BYTE   $79             ; E
009311  2  71                   .BYTE   $71             ; F
009312  2               ;
009312  2               DSKY_TEMP_VAL:
009312  2  00                   .BYTE   0
009313  2               DSKY_PPIX_VAL:
009313  2  00                   .BYTE   0
009314  2               DSKY_PRESENT:
009314  2  00                   .BYTE   0
009315  2               
009315  1                       .INCLUDE "dosmd.asm"
009315  2               ;__MD DRIVERS____________________________________________________________________________________________________________________
009315  2               ;
009315  2               ; 	Nhyodyne Memory disk drivers
009315  2               ;
009315  2               ;	Entry points:
009315  2               ;		MD_SHOW         - called during OS init
009315  2               ;		MD_READ_SECTOR  - read a sector from drive
009315  2               ;		MD_WRITE_SECTOR - write a sector to drive
009315  2               ;________________________________________________________________________________________________________________________________
009315  2               ;
009315  2               ; RAM BANK $0C is RAM area for Drivers
009315  2               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
009315  2               ; RAM BANK $0F is fixed bank $0000-$7FFF
009315  2               ;
009315  2               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
009315  2               ;
009315  2               ; ROM MEMORY PAGE CONFIGURATION LATCH CONTROL PORT
009315  2               ;       A15 IS INVERTED FOR THE NYHODYNE 65C02 CPU . . .
009315  2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
009315  2               ;	^ ^ ^ ^  ^ ^ ^ ^
009315  2               ;	: : : :  : : : :--0 = A15 ROM ONLY ADDRESS LINE DEFAULT IS 0
009315  2               ;	: : : :  : : :----0 = A16 ROM ONLY ADDRESS LINE DEFAULT IS 0
009315  2               ;	: : : :  : :------0 = A17 ROM ONLY ADDRESS LINE DEFAULT IS 0
009315  2               ;	: : : :  :--------0 = A18 ROM ONLY ADDRESS LINE DEFAULT IS 0
009315  2               ;	: : : :-----------0 = A19 ROM ONLY ADDRESS LINE DEFAULT IS 0
009315  2               ;	: : :-------------0 = A20 ROM ONLY ADDRESS LINE DEFAULT IS 0
009315  2               ;	: :---------------0 = ROM BOOT OVERRIDE DEFAULT IS 0
009315  2               ;	:-----------------0 = LOWER PAGE ROM SELECT (0=ROM, 1=NOTHING) DEFAULT IS 0
009315  2               ;
009315  2               ; RAM PAGE CONFIGURATION LATCH CONTROL PORT
009315  2               ;
009315  2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
009315  2               ;	^ ^ ^ ^  ^ ^ ^ ^
009315  2               ;	: : : :  : : : :--0 = A15 RAM ONLY ADDRESS LINE DEFAULT IS 0
009315  2               ;	: : : :  : : :----0 = A16 RAM ONLY ADDRESS LINE DEFAULT IS 0
009315  2               ;	: : : :  : :------0 = A17 RAM ONLY ADDRESS LINE DEFAULT IS 0
009315  2               ;	: : : :  :--------0 = A18 RAM ONLY ADDRESS LINE DEFAULT IS 0
009315  2               ;	: : : :-----------0 = A19 RAM ONLY ADDRESS LINE DEFAULT IS 0
009315  2               ;	: : :-------------0 = UNDEFINED DEFAULT IS 0
009315  2               ;	: :---------------0 = RAM BOOT OVERRIDE DEFAULT IS 0
009315  2               ;	:-----------------0 = LOWER PAGE RAM SELECT (0=NOTHING, 1=RAM) DEFAULT IS 0;
009315  2               
009315  2               
009315  2               ;__MD_SHOW___________________________________________________________________________________________
009315  2               ;
009315  2               ;  Display info on MD devices
009315  2               ;____________________________________________________________________________________________________
009315  2               ;
009315  2               MD_SHOW:
009315  2                       PRTDBG  "MD INIT:$"
009315  2  48 8A 48 A8          PRTS    "MD: UNITS=2 RAMDISK=256KB ROMDISK=384KB$"
009319  2  48 A2 00 BD  
00931D  2  32 93 E8 C9  
00935A  2  20 7F 88             JSR     NEWLINE
00935D  2  60                   RTS
00935E  2               
00935E  2               ;*__MD_READ_SECTOR____________________________________________________________________________________
00935E  2               ;*
00935E  2               ;*  READ MD SECTOR INTO BUFFER
00935E  2               ;*
00935E  2               ;*____________________________________________________________________________________________________
00935E  2               MD_READ_SECTOR:
00935E  2                       PRTDBG  "MD Read Sector$"
00935E  2  20 54 94             JSR     GET_DRIVE_DEVICE
009361  2  29 01                AND     #$01            ; only want drive cfg
009363  2  0A                   ASL     a               ; SHIFT 6
009364  2  0A                   ASL     a               ;
009365  2  0A                   ASL     a               ;
009366  2  0A                   ASL     a               ;
009367  2  0A                   ASL     a               ;
009368  2  0A                   ASL     a               ;
009369  2  29 5F                AND     #%01011111      ; TOGGLE READ
00936B  2  AA                   TAX                     ; STASH CONTROL WORD
00936C  2  AD 0E 05             LDA     seksec          ;
00936F  2  29 01                AND     #$01            ; GET SECTOR INDEX
009371  2  C9 00                CMP     #$00
009373  2  F0 04                BEQ     @1
009375  2  8A                   TXA
009376  2  09 80                ORA     #%10000000      ; TOGGLE TOP HALF OF PAGE
009378  2  AA                   TAX
009379  2               @1:
009379  2  20 C3 93             JSR     MD_CONVERT_SECTOR
00937C  2  8A                   TXA
00937D  2  29 40                AND     #%01000000
00937F  2  C9 00                CMP     #$00            ; read if ram
009381  2  F0 0C                BEQ     :+
009383  2  EE 10 05             INC     debcyll         ; if rom, inc bank by 4 ()
009386  2  EE 10 05             INC     debcyll
009389  2  EE 10 05             INC     debcyll
00938C  2  EE 10 05             INC     debcyll
00938F  2               :
00938F  2  AD 10 05             LDA     debcyll         ; GET BANK
009392  2  AC 12 05             LDY     debsehd         ; GET PAGE
009395  2                       PRTDBG  "DO PAGER RD$"
009395  2  20 00 02             JSR     MD_PAGERA
009398  2                       PRTDBG  "PAGER RETURN$"
009398  2  A9 00                LDA     #$00
00939A  2  60                   RTS
00939B  2               
00939B  2               
00939B  2               ;*__MD_WRITE_SECTOR___________________________________________________________________________________
00939B  2               ;*
00939B  2               ;*  WRITE MD SECTOR FROM BUFFER
00939B  2               ;*
00939B  2               ;*____________________________________________________________________________________________________
00939B  2               MD_WRITE_SECTOR:
00939B  2                       PRTDBG  "MD Write Sector$"
00939B  2  20 54 94             JSR     GET_DRIVE_DEVICE
00939E  2  29 01                AND     #$01            ; only want drive cfg
0093A0  2  C9 00                CMP     #$00            ; NO WRITE FOR ROM
0093A2  2  F0 03                BEQ     MD_WRITE_SECTOR_RAM
0093A4  2  A9 FF                LDA     #$FF
0093A6  2  60                   RTS
0093A7  2               MD_WRITE_SECTOR_RAM:
0093A7  2  20 C3 93             JSR     MD_CONVERT_SECTOR
0093AA  2  A2 20                LDX     #%00100000      ; TOGGLE WRITE RAM (LO)
0093AC  2  AD 0E 05             LDA     seksec          ;
0093AF  2  29 01                AND     #$01            ; GET SECTOR INDEX
0093B1  2  C9 00                CMP     #$00
0093B3  2  F0 02                BEQ     @1
0093B5  2  A2 A0                LDX     #%10100000      ; TOGGLE WRITE RAM (HI)
0093B7  2               @1:
0093B7  2  AD 10 05             LDA     debcyll         ; GET BANK
0093BA  2  AC 12 05             LDY     debsehd         ; GET PAGE
0093BD  2                       PRTDBG  "DO PAGER WR$"
0093BD  2  20 00 02             JSR     MD_PAGERA
0093C0  2                       PRTDBG  "PAGER RETURN$"
0093C0  2  A9 00                LDA     #$00
0093C2  2  60                   RTS
0093C3  2               
0093C3  2               ;___MD_CONVERT_SECTOR___________________________________________________________________________________
0093C3  2               ;
0093C3  2               ; 	TRANSLATE SECTORS INTO MD FORMAT
0093C3  2               ;________________________________________________________________________________________________________
0093C3  2               MD_CONVERT_SECTOR:
0093C3  2                       PRTDBG  "CONVERT SECTOR$"
0093C3  2  48                   PHA
0093C4  2  8A                   TXA
0093C5  2  48                   PHA
0093C6  2  AD 0E 05             LDA     seksec          ; LOAD SECTOR # (LOW BYTE)
0093C9  2  4A                   LSR     A               ; DIVIDE BY 2 (FOR BLOCKING)
0093CA  2  29 1F                AND     #$1F            ; CLEAR UPPER 3 BITS (JUST 'CAUSE)
0093CC  2  8D 12 05             STA     debsehd         ; STORE IN SECTOR/HEAD
0093CF  2  AD 0C 05             LDA     sektrk          ; LOAD TRACK # (LOW BYTE)
0093D2  2  29 03                AND     #$03            ; BOTTOM 2 BITS ARE PART OF PAGE (PAGES ARE 32k)
0093D4  2  0A                   ASL     a               ; MOVE TO HIGH BITS
0093D5  2  0A                   ASL     a
0093D6  2  0A                   ASL     a
0093D7  2  0A                   ASL     a
0093D8  2  0A                   ASL     a
0093D9  2  09 80                ORA     #$80            ; PAGES ARE ALWAYS IN UPPER BANK
0093DB  2  0D 12 05             ORA     debsehd         ; STORE IN SECTOR/HEAD
0093DE  2  8D 12 05             STA     debsehd         ; STORE IN SECTOR/HEAD
0093E1  2                                               ; AT THIS POINT PAGE REGISTER SHOULD BE
0093E1  2                                               ; SET
0093E1  2  AD 0C 05             LDA     sektrk          ; LOAD TRACK #
0093E4  2  4A                   LSR     a               ; LOSE BOTTOM TWO BITS
0093E5  2  4A                   LSR     a
0093E6  2  8D 10 05             STA     debcyll         ; THIS SHOULD BE BANK#
0093E9  2               
0093E9  2               
0093E9  2                       .IF     USEDSKY=1 || USEDSKYNG=1
0093E9  2                           PRTDBG  "DSKY OUTPUT 1$"
0093E9  2  AD 13 05                 LDA     sekdsk
0093EC  2  8D 08 05                 STA     DSKY_HEXBUF
0093EF  2  A9 00                    LDA     #$00
0093F1  2  8D 09 05                 STA     DSKY_HEXBUF+1
0093F4  2  AD 10 05                 LDA     debcyll
0093F7  2  8D 0A 05                 STA     DSKY_HEXBUF+2
0093FA  2  AD 12 05                 LDA     debsehd
0093FD  2  8D 0B 05                 STA     DSKY_HEXBUF+3
009400  2  20 31 91                 JSR     DSKY_BIN2SEG
009403  2  20 6A 91                 JSR     DSKY_SHOW
009406  2                       .ENDIF
009406  2  68                   PLA
009407  2  AA                   TAX
009408  2  68                   PLA
009409  2  60                   RTS
00940A  2               
00940A  1                       .INCLUDE "dosdblk.asm"
00940A  2               ;__DOS DEBLOCK DRIVERS___________________________________________________________________________________________________________
00940A  2               ;
00940A  2               ; 	Nhyodyne DOS/65 Blocking and Deblocking code
00940A  2               ;
00940A  2               ;________________________________________________________________________________________________________________________________
00940A  2               ;
00940A  2               
00940A  2               ;___DEBSECR512________________________________________________________________________________________
00940A  2               ;
00940A  2               ;	DEBLOCK 512 BYTE SECTOR FOR DOS/65
00940A  2               ;
00940A  2               ;________________________________________________________________________________________________________
00940A  2               DEBSECR512:
00940A  2  48                   PHA
00940B  2  AD 0E 05             LDA     seksec          ;
00940E  2  29 03                AND     #$03            ; GET SECTOR INDEX
009410  2  18                   CLC                     ;
009411  2  2A                   ROL     A               ;
009412  2  AA                   TAX                     ;
009413  2  BD 2B 94             LDA     DEBTAB,X        ;
009416  2  85 EE                STA     SRC
009418  2  E8                   INX
009419  2  BD 2B 94             LDA     DEBTAB,X        ;
00941C  2  85 EF                STA     SRC+1           ;
00941E  2  A9 00                LDA     #<MD_PAGEBU     ;
009420  2  85 EC                STA     DEST            ;
009422  2  A9 04                LDA     #>MD_PAGEBU     ;
009424  2  85 ED                STA     DEST+1          ;
009426  2  20 67 94             JSR     COPY_DOS_SECTOR ;
009429  2  68                   PLA
00942A  2  60                   RTS
00942B  2               
00942B  2               DEBTAB:
00942B  2  E2 94                .WORD   hstbuf          ;
00942D  2  62 95                .WORD   hstbuf+128      ;
00942F  2  E2 95                .WORD   hstbuf+256      ;
009431  2  62 96                .WORD   hstbuf+384      ;
009433  2               
009433  2               
009433  2               ;___BLKSECR512___________________________________________________________________________________________
009433  2               ;
009433  2               ;	BLOCK 512 SECTOR FOR DOS/65
009433  2               ;
009433  2               ;________________________________________________________________________________________________________
009433  2               BLKSECR512:
009433  2  48                   PHA
009434  2  AD 0E 05             LDA     seksec          ;
009437  2  29 03                AND     #$03            ; GET SECTOR INDEX
009439  2  18                   CLC                     ;
00943A  2  2A                   ROL     A               ;
00943B  2  AA                   TAX                     ;
00943C  2  BD 2B 94             LDA     DEBTAB,X        ;
00943F  2  85 EC                STA     DEST
009441  2  E8                   INX
009442  2  BD 2B 94             LDA     DEBTAB,X        ;
009445  2  85 ED                STA     DEST+1          ;
009447  2  A9 00                LDA     #<MD_PAGEBU     ;
009449  2  85 EE                STA     SRC             ;
00944B  2  A9 04                LDA     #>MD_PAGEBU     ;
00944D  2  85 EF                STA     SRC+1           ;
00944F  2  20 67 94             JSR     COPY_DOS_SECTOR ;
009452  2  68                   PLA
009453  2  60                   RTS
009454  2               
009454  2               ;___GET_DRIVE_DEVICE_____________________________________________________________________________________
009454  2               ;
009454  2               ;	GET SELECTED DEVICE TYPE AND UNIT, RETURN IN "A"
009454  2               ;
009454  2               ;________________________________________________________________________________________________________
009454  2               GET_DRIVE_DEVICE:
009454  2  8A                   TXA
009455  2  48                   PHA
009456  2  AD 13 05             LDA     sekdsk          ; GET DRIVE
009459  2  29 07                AND     #7              ; ONLY FIRST 8 DEVICES SUPPORTED
00945B  2  0A                   ASL     a               ; DOUBLE NUMBER FOR TABLE LOOKUP
00945C  2  AA                   TAX                     ; MOVE TO X REGISTER
00945D  2  BD 14 05             LDA     dskcfg,X        ; GET device
009460  2  85 3A                STA     STACKA
009462  2  68                   PLA
009463  2  AA                   TAX
009464  2  A5 3A                LDA     STACKA
009466  2  60                   RTS
009467  2               
009467  2               
009467  2               ;___COPY_DOS_SECTOR______________________________________________________________________________________
009467  2               ;
009467  2               ;	COPY 128 BYTE SECTOR FOR DOS/65
009467  2               ;
009467  2               ;________________________________________________________________________________________________________
009467  2               COPY_DOS_SECTOR:
009467  2  48                   PHA
009468  2  98                   TYA
009469  2  48                   PHA
00946A  2  A0 00                LDY     #$00            ;
00946C  2               COPY_DOS_SECTOR1:
00946C  2  B1 EE                LDA     (SRC),Y         ;
00946E  2  91 EC                STA     (DEST),Y        ;
009470  2  C8                   INY                     ;
009471  2  98                   TYA                     ;
009472  2  C9 80                CMP     #$80            ;
009474  2  D0 F6                BNE     COPY_DOS_SECTOR1;
009476  2  68                   PLA
009477  2  98                   TYA
009478  2  68                   PLA
009479  2  60                   RTS
00947A  2               
00947A  2               ;___INIT_PAGE_COPY_______________________________________________________________________________________
00947A  2               ;
00947A  2               ;	COPY PAGE COPY CODE TO LORAM AT "MD_PAGEBU"
00947A  2               ;
00947A  2               ;________________________________________________________________________________________________________
00947A  2               INIT_PAGE_COPY:
00947A  2               
00947A  2  A0 00                LDY     #$00
00947C  2               :
00947C  2  B9 88 94             LDA     INIT_PAGE_COPY_1,Y
00947F  2  99 00 04             STA     MD_PAGEBU,Y
009482  2  C8                   INY
009483  2  C0 00                CPY     #$00
009485  2  D0 F5                BNE     :-
009487  2  60                   RTS
009488  2               INIT_PAGE_COPY_1:
009488  2               ; COPY_PAGE_TO_HSTBUF
009488  2  85 39                STA     zptemp
00948A  2  A9 E2                LDA     #<hstbuf
00948C  2  85 17                STA     point
00948E  2  A9 94                LDA     #>hstbuf
009490  2  85 18                STA     point+1
009492  2  A2 02                LDX     #$02
009494  2  A0 00                LDY     #$00
009496  2               :
009496  2  A5 39                LDA     zptemp
009498  2  8D 78 03             STA     MPCL_RAM        ; SET PAGE TO SOURCE
00949B  2  B1 14                LDA     (pointr),Y
00949D  2  48                   PHA
00949E  2  A9 8C                LDA     #$8C            ; SET PAGE TO DRIVERSPACE
0094A0  2  8D 78 03             STA     MPCL_RAM
0094A3  2  68                   PLA
0094A4  2  91 17                STA     (point),Y
0094A6  2  C8                   INY
0094A7  2  C0 00                CPY     #$00
0094A9  2  D0 EB                BNE     :-
0094AB  2  E6 15                INC     pointr+1
0094AD  2  E6 18                INC     point+1
0094AF  2  CA                   DEX
0094B0  2  E0 00                CPX     #$00
0094B2  2  D0 E2                BNE     :-
0094B4  2  60                   RTS
0094B5  2               INIT_PAGE_COPY_2:
0094B5  2               ; COPY_HSTBUF_TO_PAGE
0094B5  2  85 39                STA     zptemp
0094B7  2  A9 E2                LDA     #<hstbuf
0094B9  2  85 17                STA     point
0094BB  2  A9 94                LDA     #>hstbuf
0094BD  2  85 18                STA     point+1
0094BF  2               
0094BF  2  A2 02                LDX     #$02
0094C1  2  A0 00                LDY     #$00
0094C3  2               :
0094C3  2  B1 17                LDA     (point),Y
0094C5  2  48                   PHA
0094C6  2  A5 39                LDA     zptemp
0094C8  2  8D 78 03             STA     MPCL_RAM        ; SET PAGE TO DESTINATION
0094CB  2  68                   PLA
0094CC  2  91 14                STA     (pointr),Y
0094CE  2  A9 8C                LDA     #$8C            ; SET PAGE TO DRIVERSPACE
0094D0  2  8D 78 03             STA     MPCL_RAM
0094D3  2  C8                   INY
0094D4  2  C0 00                CPY     #$00
0094D6  2  D0 EB                BNE     :-
0094D8  2  E6 15                INC     pointr+1
0094DA  2  E6 18                INC     point+1
0094DC  2  CA                   DEX
0094DD  2  E0 00                CPX     #$00
0094DF  2  D0 E2                BNE     :-
0094E1  2  60                   RTS
0094E2  2               
0094E2  2               COPY_PAGE_TO_HSTBUF = MD_PAGEBU
0094E2  2               COPY_HSTBUF_TOPAGE = MD_PAGEBU+INIT_PAGE_COPY_2-INIT_PAGE_COPY_1
0094E2  2               ;deblocking buffer for dba
0094E2  2               hstbuf:
0094E2  2  xx xx xx xx          .RES    512             ;256 or 512 byte sectors
0094E6  2  xx xx xx xx  
0094EA  2  xx xx xx xx  
0096E2  2               
0096E2  1                       .INCLUDE "dosflp.asm"
0096E2  2               ;__FLOPPY DRIVERS________________________________________________________________________________________________________________
0096E2  2               ;
0096E2  2               ; 	DOS/65 floppy drivers for MBC FDC card
0096E2  2               ;
0096E2  2               ;	Entry points:
0096E2  2               ;		FL_SETUP        - called during OS init
0096E2  2               ;		FL_READ_SECTOR	- read a sector from drive
0096E2  2               ;		FL_WRITE_SECTOR	- write a sector to drive
0096E2  2               ;
0096E2  2               ;________________________________________________________________________________________________________________________________
0096E2  2               ;
0096E2  2               ;*
0096E2  2               ;* HARDWARE I/O ADDRESSES
0096E2  2               ;*
0096E2  2               FDC_MSR         = $0330         ; ADDRESS OF MAIN STATUS REGISTER
0096E2  2               FDC_DATA        = $0331         ; FLOPPY DATA REGISTER
0096E2  2               FDC_RESET       = $0333         ; FLOPPY RESET
0096E2  2               FDC_DCR         = $0335         ; LOAD CONTROL REGISTER
0096E2  2               FDC_DOR         = $0336         ; CONFIGURATION CONTROL REGISTER
0096E2  2               FDC_TC          = $0337         ; TERMINAL COUNT
0096E2  2               
0096E2  2               ;
0096E2  2               ; FDC COMMANDS
0096E2  2               ;
0096E2  2               CFD_READ        = %00000110     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
0096E2  2               CFD_READDEL     = %00001100     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
0096E2  2               CFD_WRITE       = %00000101     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
0096E2  2               CFD_WRITEDEL    = %00001001     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
0096E2  2               CFD_READTRK     = %00000010     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
0096E2  2               CFD_READID      = %00001010     ; CMD,HDS/DS --> ST0,ST1,ST2,C,H,R,N
0096E2  2               CFD_FMTTRK      = %00001101     ; CMD,HDS/DS,N,SC,GPL,D --> ST0,ST1,ST2,C,H,R,N
0096E2  2               CFD_SCANEQ      = %00010001     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
0096E2  2               CFD_SCANLOEQ    = %00011001     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
0096E2  2               CFD_SCANHIEQ    = %00011101     ; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
0096E2  2               CFD_RECAL       = %00000111     ; CMD,DS --> <EMPTY>
0096E2  2               CFD_SENSEINT    = %00001000     ; CMD --> ST0,PCN
0096E2  2               CFD_SPECIFY     = %00000011     ; CMD,SRT/HUT,HLT/ND --> <EMPTY>
0096E2  2               CFD_DRVSTAT     = %00000100     ; CMD,HDS/DS --> ST3
0096E2  2               CFD_SEEK        = %00001111     ; CMD,HDS/DS --> <EMPTY>
0096E2  2               CFD_VERSION     = %00010000     ; CMD --> ST0
0096E2  2               
0096E2  2               CFD_MFM         = %01000000     ;
0096E2  2               
0096E2  2               ;
0096E2  2               ;
0096E2  2               ; Specify Command:
0096E2  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
0096E2  2               ; |Byte |  7  |	 6  |  5  |  4	|  3  |	 2  |  1  |  0	|
0096E2  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
0096E2  2               ; |  0	|  0  |	 0  |  0  |  0	|  0  |	 0  |  1  |  1	|
0096E2  2               ; |  1	| ----- STEP RATE ----- | -- HEAD UNLOAD TIME - |
0096E2  2               ; |  2	| ------------ HEAD LOAD TIME ----------- | NDM |
0096E2  2               ; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
0096E2  2               ;
0096E2  2               ;
0096E2  2               ; Step Rate (milliseconds):		 Head Unload Time (milliseconds):	Head Load Time (milliseconds):
0096E2  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
0096E2  2               ; |	 |	   BITRATE	     |	 |	|	  BITRATE	    |	|      |	 BITRATE	   |
0096E2  2               ; |  VAL | 1.0M | 500K | 300K | 250K |	 |  VAL | 1.0M | 500K | 300K | 250K |	|  VAL | 1.0M | 500K | 300K | 250K |
0096E2  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
0096E2  2               ; |    0 |  8.0 | 16.0 | 26.7 | 32.0 |	 |    0 |  128 |  256 |	 426 |	512 |	|    0 |  128 |	 256 |	426 |  512 |
0096E2  2               ; |    1 |  7.5 | 15.0 | 25.0 | 30.0 |	 |    1 |    8 |   16 | 26.7 |	 32 |	|    1 |    1 |	   2 |	3.3 |	 4 |
0096E2  2               ; |    2 |  7.0 | 14.0 | 23.3 | 28.0 |	 |    2 |   16 |   32 | 53.3 |	 64 |	|    2 |    2 |	   4 |	6.7 |	 8 |
0096E2  2               ; |  ... |  ... |  ... |  ... |	 ... |	 |  ... |  ... |  ... |	 ... |	... |	|  ... |  ... |	 ... |	... |  ... |
0096E2  2               ; |   14 |  1.0 |  2.0 |  3.3 |	 4.0 |	 |   14 |  112 |  224 |	 373 |	448 |	|  126 |  126 |	 252 |	420 |  504 |
0096E2  2               ; |   15 |  0.5 |  1.0 |  1.7 |	 2.0 |	 |   15 |  120 |  240 |	 400 |	480 |	|  127 |  127 |	 254 |	423 |  508 |
0096E2  2               ; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
0096E2  2               ;
0096E2  2               ; IBM PS/2 CALLS FOR:
0096E2  2               ;   STEP RATE: 3ms (6ms FOR ALL 41mm OR 720K DRIVES)
0096E2  2               ;   HEAD LOAD TIME: 15ms
0096E2  2               
0096E2  2               DOR_INIT        = %00001100     ; SOFT RESET INACTIVE, DMA ENABLED
0096E2  2               DOR_BR250       = DOR_INIT
0096E2  2               DOR_BR500       = DOR_INIT
0096E2  2               
0096E2  2               
0096E2  2               
0096E2  2               FLOPPY_RETRIES  = 6             ; HOW ABOUT SIX RETIRES?
0096E2  2               FLOPPY_RETRIES1 = 2             ; TWO ITERATIONS OF RECAL?
0096E2  2               
0096E2  2               ;__FL_SETUP______________________________________________________________________________________________________________________
0096E2  2               ;
0096E2  2               ;	SETUP FLOPPY DRIVE SETTINGS
0096E2  2               ;________________________________________________________________________________________________________________________________
0096E2  2               ;
0096E2  2               FL_SETUP:
0096E2  2  A9 00                LDA     #$00            ; RESET TRACK/CYL/SEC STORAGE
0096E4  2  8D 60 9B             STA     debhead         ;
0096E7  2  8D 61 9B             STA     debcyl          ;
0096EA  2  8D 62 9B             STA     debsec          ;
0096ED  2  A9 FF                LDA     #$FF            ; SET CACHE TO INVALID
0096EF  2  8D 63 9B             STA     Cdebhead        ;
0096F2  2  8D 64 9B             STA     Cdebcyl         ;
0096F5  2  8D 65 9B             STA     Cdebsec         ;
0096F8  2               
0096F8  2  48 8A 48 A8          PRTS    "FD: MODE=MBC$"
0096FC  2  48 A2 00 BD  
009700  2  15 97 E8 C9  
009722  2               ;
009722  2  48 8A 48 A8          PRTS    " IO=0x$"
009726  2  48 A2 00 BD  
00972A  2  3F 97 E8 C9  
009746  2  A9 03                LDA     #>FDC_MSR
009748  2  20 55 88             JSR     PRTHEXBYTE
00974B  2  A9 30                LDA     #<FDC_MSR
00974D  2  20 55 88             JSR     PRTHEXBYTE
009750  2  20 04 9B             JSR     FD_DETECT       ; CHECK FOR FDC
009753  2  C9 00                CMP     #$00
009755  2  F0 30                BEQ     :+              ; CONTINUE IF FOUND
009757  2  48 8A 48 A8          PRTS    " NOT PRESENT$" ; NOT ZERO, H/W NOT PRESENT
00975B  2  48 A2 00 BD  
00975F  2  74 97 E8 C9  
009781  2  20 7F 88             JSR     NEWLINE
009784  2  A9 FF                LDA     #$FF
009786  2  60                   RTS                     ; BAIL OUT
009787  2               :
009787  2  48 8A 48 A8          PRTS    " PRESENT$"     ; NOT ZERO, H/W NOT PRESENT
00978B  2  48 A2 00 BD  
00978F  2  A4 97 E8 C9  
0097AD  2  20 7F 88             JSR     NEWLINE
0097B0  2  A9 0C                LDA     #DOR_INIT       ; RESET SETTINGS
0097B2  2  8D 36 03             STA     FDC_DOR
0097B5  2               
0097B5  2  20 A2 9A             JSR     CHECKINT        ;
0097B8  2  A9 03                LDA     #CFD_SPECIFY    ; SPECIFY COMMAND
0097BA  2  20 5E 9A             JSR     PFDATA          ; OUTPUT TO FDC
0097BD  2  A9 7F                LDA     #$7F            ; 6 MS STEP, 480 MS HEAD UNLOAD
0097BF  2  20 5E 9A             JSR     PFDATA          ; OUTPUT TO FDC
0097C2  2  A9 05                LDA     #$05            ; 508 MS HEAD LOAD, NON-DMA MODE
0097C4  2  20 5E 9A             JSR     PFDATA          ; OUTPUT TO FDC
0097C7  2               
0097C7  2  20 A2 9A             JSR     CHECKINT        ; SEND SEVERAL INTERRUPTS TO ENSURE PROPER STATE
0097CA  2  20 A2 9A             JSR     CHECKINT        ;
0097CD  2  20 A2 9A             JSR     CHECKINT        ;
0097D0  2  20 A2 9A             JSR     CHECKINT        ;
0097D3  2  20 A2 9A             JSR     CHECKINT        ;
0097D6  2  20 A2 9A             JSR     CHECKINT        ;
0097D9  2               
0097D9  2  A9 00                LDA     #$00
0097DB  2  8D 13 05             STA     sekdsk
0097DE  2  A9 10                LDA     #%00010000
0097E0  2  8D 25 05             STA     DSKUNIT
0097E3  2  20 33 9A             JSR     RECAL           ;
0097E6  2  A9 27                LDA     #39             ;
0097E8  2  8D 61 9B             STA     debcyl          ;
0097EB  2  20 16 9A             JSR     SETTRK1
0097EE  2  20 33 9A             JSR     RECAL           ;
0097F1  2               
0097F1  2  A9 01                LDA     #$01
0097F3  2  8D 13 05             STA     sekdsk
0097F6  2  A9 21                LDA     #%00100001
0097F8  2  8D 25 05             STA     DSKUNIT
0097FB  2  20 33 9A             JSR     RECAL           ;
0097FE  2  A9 27                LDA     #39             ;
009800  2  8D 61 9B             STA     debcyl          ;
009803  2  20 16 9A             JSR     SETTRK1
009806  2  20 33 9A             JSR     RECAL           ;
009809  2  A9 0C                LDA     #DOR_INIT       ; RESET SETTINGS
00980B  2  8D 36 03             STA     FDC_DOR
00980E  2  60                   RTS
00980F  2               
00980F  2               
00980F  2               ;__FL_READ_SECTOR________________________________________________________________________________________________________________
00980F  2               ;
00980F  2               ; 	READ A FLOPPY SECTOR
00980F  2               ;________________________________________________________________________________________________________________________________
00980F  2               ;
00980F  2               ;
00980F  2               FL_READ_SECTOR:
00980F  2  AD 5F 9B             LDA     HARDWARE_DETCT
009812  2  C9 00                CMP     #$00
009814  2  F0 01                BEQ     :+
009816  2  60                   RTS
009817  2               :
009817  2  8D 6A 9B             STA     FLRETRY         ; BLANK RETRIES
00981A  2  8D 6B 9B             STA     FLRETRY1
00981D  2  20 26 98             JSR     FL_READ_SECTOR_RAW
009820  2  48                   PHA
009821  2  20 0A 94             JSR     DEBSECR512
009824  2  68                   PLA
009825  2  60                   RTS
009826  2               
009826  2               FL_READ_SECTOR_RAW:
009826  2  A9 0C                LDA     #DOR_INIT
009828  2  0D 25 05             ORA     DSKUNIT         ;
00982B  2  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
00982E  2  20 F1 98             JSR     SETUP_FD_CHS
009831  2  AD 60 9B             LDA     debhead         ;
009834  2  CD 63 9B             CMP     Cdebhead        ;
009837  2  D0 13                BNE     READFL_DIRTY
009839  2  AD 61 9B             LDA     debcyl          ;
00983C  2  CD 64 9B             CMP     Cdebcyl         ;
00983F  2  D0 0B                BNE     READFL_DIRTY
009841  2  AD 62 9B             LDA     debsec          ;
009844  2  CD 65 9B             CMP     Cdebsec         ;
009847  2  D0 03                BNE     READFL_DIRTY
009849  2               ; SECTOR ALREADY IN CACHE, DEBLOCK
009849  2  A9 00                LDA     #$00
00984B  2  60                   RTS
00984C  2               READFL_DIRTY:
00984C  2  AD 60 9B             LDA     debhead         ; STORE CURRENT PARMS
00984F  2  8D 63 9B             STA     Cdebhead        ;
009852  2  AD 61 9B             LDA     debcyl          ;
009855  2  8D 64 9B             STA     Cdebcyl         ;
009858  2  AD 62 9B             LDA     debsec          ;
00985B  2  8D 65 9B             STA     Cdebsec         ;
00985E  2               
00985E  2               READFL1:
00985E  2  A9 46                LDA     #CFD_READ|CFD_MFM; BIT 6 SETS MFM, 06H IS READ COMMAND
009860  2  8D 68 9B             STA     FCMD            ; SET COMMAND
009863  2  20 27 99             JSR     DSKOP           ; DO DISK OPERATION
009866  2               
009866  2  C9 00                CMP     #$00
009868  2  F0 2B                BEQ     READFLDONE      ; OPERATION SUCCESSFUL
00986A  2  EE 6A 9B             INC     FLRETRY         ; LET'S RETRY
00986D  2  AD 6A 9B             LDA     FLRETRY
009870  2  C9 06                CMP     #FLOPPY_RETRIES
009872  2  D0 EA                BNE     READFL1
009874  2  20 33 9A             JSR     RECAL           ; AFTER X RETRIES, LET'S RECAL THE HEAD
009877  2  20 04 9A             JSR     SETTRACK        ;
00987A  2  A9 00                LDA     #$00            ;
00987C  2  8D 6A 9B             STA     FLRETRY         ; MORE RETRIES!
00987F  2  EE 6B 9B             INC     FLRETRY1
009882  2  AD 6B 9B             LDA     FLRETRY1
009885  2  C9 02                CMP     #FLOPPY_RETRIES1
009887  2  D0 D5                BNE     READFL1
009889  2               
009889  2  A9 FF                LDA     #$FF            ; RETRIES FAILED, INVALIDATE CACHE AND REPORT ERROR
00988B  2  8D 63 9B             STA     Cdebhead        ;
00988E  2  8D 64 9B             STA     Cdebcyl         ;
009891  2  8D 65 9B             STA     Cdebsec         ;
009894  2  60                   RTS                     ; A = $FF ON RETURN = OPERATION ERROR
009895  2               READFLDONE:
009895  2  A9 00                LDA     #$00            ; A = 0 ON RETURN = OPERATION OK
009897  2  60                   RTS
009898  2               
009898  2               ;__FL_WRITE_SECTOR_______________________________________________________________________________________________________________
009898  2               ;
009898  2               ; 	WRITE A FLOPPY SECTOR
009898  2               ;________________________________________________________________________________________________________________________________
009898  2               ;
009898  2               FL_WRITE_SECTOR:
009898  2  AD 5F 9B             LDA     HARDWARE_DETCT
00989B  2  C9 00                CMP     #$00
00989D  2  F0 01                BEQ     :+
00989F  2  60                   RTS
0098A0  2               :
0098A0  2  20 26 98             JSR     FL_READ_SECTOR_RAW
0098A3  2  8D 6A 9B             STA     FLRETRY         ; BLANK RETRIES
0098A6  2  8D 6B 9B             STA     FLRETRY1
0098A9  2  20 33 94             JSR     BLKSECR512
0098AC  2               
0098AC  2  A9 FF                LDA     #$FF
0098AE  2  8D 63 9B             STA     Cdebhead        ; INVALIDATE CACHE
0098B1  2  8D 64 9B             STA     Cdebcyl         ;
0098B4  2  8D 65 9B             STA     Cdebsec         ;
0098B7  2               
0098B7  2               WRITEFL1:
0098B7  2  A9 45                LDA     #CFD_WRITE|CFD_MFM; BIT 6 SETS MFM, 05H IS WRITE COMMAND
0098B9  2  8D 68 9B             STA     FCMD
0098BC  2  20 27 99             JSR     DSKOP
0098BF  2               
0098BF  2  C9 00                CMP     #$00
0098C1  2  F0 2B                BEQ     WRITEFLDONE
0098C3  2  EE 6A 9B             INC     FLRETRY
0098C6  2  AD 6A 9B             LDA     FLRETRY
0098C9  2  C9 06                CMP     #FLOPPY_RETRIES
0098CB  2  D0 EA                BNE     WRITEFL1
0098CD  2  20 33 9A             JSR     RECAL
0098D0  2  20 04 9A             JSR     SETTRACK
0098D3  2  A9 00                LDA     #$00
0098D5  2  8D 6A 9B             STA     FLRETRY
0098D8  2  EE 6B 9B             INC     FLRETRY1
0098DB  2  AD 6B 9B             LDA     FLRETRY1
0098DE  2  C9 02                CMP     #FLOPPY_RETRIES1
0098E0  2  D0 D5                BNE     WRITEFL1
0098E2  2  A9 FF                LDA     #$FF            ; INVALIDATE CACHE
0098E4  2  8D 63 9B             STA     Cdebhead        ;
0098E7  2  8D 64 9B             STA     Cdebcyl         ;
0098EA  2  8D 65 9B             STA     Cdebsec         ;
0098ED  2  60                   RTS                     ; A = $FF ON RETURN = OPERATION ERROR
0098EE  2               WRITEFLDONE:
0098EE  2  A9 00                LDA     #$00            ; A = 0 ON RETURN = OPERATION OK
0098F0  2  60                   RTS
0098F1  2               
0098F1  2               
0098F1  2               ;__SETUP_FD_CHS__________________________________________________________________________________________________________________
0098F1  2               ;
0098F1  2               ; 	TRANSFORM DOS65 CHS TO FLOPPY
0098F1  2               ;________________________________________________________________________________________________________________________________
0098F1  2               ;
0098F1  2               SETUP_FD_CHS:
0098F1  2  AD 0C 05             LDA     sektrk          ; LOAD TRACK # (LOW BYTE)
0098F4  2  29 01                AND     #$01            ; FILTER OUT HEAD
0098F6  2  8D 60 9B             STA     debhead         ; STORE HEAD
0098F9  2  AD 0C 05             LDA     sektrk          ; SAVE TRACK IN A
0098FC  2  4A                   LSR     A               ; REMOVE HEAD BIT
0098FD  2  8D 61 9B             STA     debcyl          ; STORE IN TRACK
009900  2  AD 0E 05             LDA     seksec          ; LOAD SECTOR # (LOW BYTE)
009903  2  4A                   LSR     A               ;
009904  2  4A                   LSR     A               ; DIVIDE BY 4 (FOR BLOCKING)
009905  2  8D 62 9B             STA     debsec          ; STORE IN SECTOR
009908  2               
009908  2                       .IF     USEDSKY=1 || USEDSKYNG=1
009908  2                           PRTDBG  "DSKY OUTPUT 1$"
009908  2  AD 13 05                 LDA     sekdsk
00990B  2  8D 08 05                 STA     DSKY_HEXBUF
00990E  2  AD 61 9B                 LDA     debcyl
009911  2  8D 09 05                 STA     DSKY_HEXBUF+1
009914  2  AD 60 9B                 LDA     debhead
009917  2  8D 0A 05                 STA     DSKY_HEXBUF+2
00991A  2  AD 62 9B                 LDA     debsec
00991D  2  8D 0B 05                 STA     DSKY_HEXBUF+3
009920  2  20 31 91                 JSR     DSKY_BIN2SEG
009923  2  20 6A 91                 JSR     DSKY_SHOW
009926  2                       .ENDIF
009926  2               
009926  2  60                   RTS
009927  2               
009927  2               ;__DSKOP__________________________________________________________________________________________________________________________
009927  2               ;
009927  2               ; 	PERFORM A DISK OPERATION
009927  2               ;________________________________________________________________________________________________________________________________
009927  2               ;
009927  2               DSKOP:
009927  2  78                   SEI
009928  2  20 A2 9A             JSR     CHECKINT        ; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
00992B  2  C9 FF                CMP     #$FF            ; DID IT RETURN WITH ERROR CODE?
00992D  2  F0 10                BEQ     DSKEXIT         ; IF YES, EXIT WITH ERROR CODE
00992F  2               ;
00992F  2  20 04 9A             JSR     SETTRACK        ; PERFORM SEEK TO TRACK
009932  2               ;
009932  2  AD 68 9B             LDA     FCMD            ; WHAT COMMAND IS PENDING?
009935  2  C9 46                CMP     #CFD_READ|CFD_MFM; IS IT A READ COMMAND?
009937  2  D0 03                BNE     GWRR_POLL       ;
009939  2  4C 94 99             JMP     RDD_POLL        ;
00993C  2               GWRR_POLL:
00993C  2  4C DA 99             JMP     WRR_POLL        ;
00993F  2               DSKEXIT:
00993F  2  A9 00                LDA     #0              ; SET MOTOR OFF
009941  2  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
009944  2  A9 FF                LDA     #$FF            ; SET IF ERROR
009946  2  58                   CLI
009947  2  60                   RTS
009948  2               
009948  2               SNDFDWR:
009948  2  18                   CLC
009949  2  AD 25 05             LDA     DSKUNIT         ; GET DISK UNIT NUMBER
00994C  2  29 01                AND     #$01            ; MASK FOR TWO DRIVES.
00994E  2  8D 67 9B             STA     UNIT            ; PARK IT IN TEMP
009951  2  AD 60 9B             LDA     debhead         ; GET HEAD SELECTION
009954  2  29 01                AND     #$01            ; INSURE SINGLE BIT
009956  2  0A                   ASL     A               ;
009957  2  0A                   ASL     A               ; MOVE HEAD TO BIT 2 POSITION
009958  2  0D 67 9B             ORA     UNIT            ; OR HEAD TO UNIT BYTE IN COMMAND BLOCK
00995B  2  8D 67 9B             STA     UNIT            ; STORE IN UNIT
00995E  2  AD 68 9B             LDA     FCMD            ;
009961  2  20 5E 9A             JSR     PFDATA          ; PUSH COMMAND TO I8272
009964  2  AD 67 9B             LDA     UNIT            ;
009967  2  20 5E 9A             JSR     PFDATA          ;
00996A  2  AD 61 9B             LDA     debcyl          ;
00996D  2  20 5E 9A             JSR     PFDATA          ;
009970  2  AD 60 9B             LDA     debhead         ;
009973  2  20 5E 9A             JSR     PFDATA          ;
009976  2  18                   CLC                     ;
009977  2  AD 62 9B             LDA     debsec          ;
00997A  2  69 01                ADC     #$01            ;
00997C  2  20 5E 9A             JSR     PFDATA          ;
00997F  2  A9 02                LDA     #$02            ;
009981  2  20 5E 9A             JSR     PFDATA          ; WHAT DENSITY
009984  2  A9 09                LDA     #$09            ;
009986  2  20 5E 9A             JSR     PFDATA          ; ASSUME SC (SECTOR COUNT)  EOT
009989  2  A9 1B                LDA     #$1B            ;
00998B  2  20 5E 9A             JSR     PFDATA          ; WHAT GAP IS NEEDED
00998E  2  A9 FF                LDA     #$FF            ; DTL, IS THE LAST COMMAND BYTE TO I8272
009990  2  20 89 9A             JSR     PFDATAS
009993  2  60                   RTS
009994  2               
009994  2               
009994  2               ; PERFORM READ
009994  2               ; FROM READ TO READ MUST NOT EXCEED 25US WORST CASE MIN. (AT 2MHZ IS 2,000,000 CYCLES PER SECOND == 50 CYCLE BUDGET.)
009994  2               ;
009994  2               RDD_POLL:
009994  2  A2 00                LDX     #$00
009996  2  A0 00                LDY     #$00
009998  2  20 48 99             JSR     SNDFDWR         ;
00999B  2               RDS1:
00999B  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS  (4 CYCLES)
00999E  2  10 FB                BPL     RDS1            ; FDC IS NOT READY, WAIT FOR IT (UP TO 4 CYCLES)
0099A0  2  29 20                AND     #%00100000      ; EXECUTION MODE? (2 CYCLES)
0099A2  2  F0 1D                BEQ     DSKOPEND        ; NO, ERROR
0099A4  2               RDS1A:
0099A4  2  AD 31 03             LDA     FDC_DATA        ; GET DATA (4 CYCLES)
0099A7  2  99 E2 94             STA     hstbuf,Y        ; WRITE IT (5 CYCLES)
0099AA  2  C8                   INY                     ; (2 CYCLES)
0099AB  2  D0 EE                BNE     RDS1            ; KEEP GOING (UP TO 4 CYCLES)   TOTAL =
0099AD  2  A2 00                LDX     #$00
0099AF  2               RDS2:
0099AF  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS
0099B2  2  10 FB                BPL     RDS2            ; FDC IS NOT READY, WAIT FOR IT (UP TO 4 CYCLES)
0099B4  2  29 20                AND     #%00100000      ; EXECUTION MODE?
0099B6  2  F0 09                BEQ     DSKOPEND        ; NO, ERROR
0099B8  2               RDS2A:
0099B8  2  AD 31 03             LDA     FDC_DATA        ; GET DATA
0099BB  2  99 E2 95             STA     hstbuf+256,Y    ; WRITE IT
0099BE  2  C8                   INY
0099BF  2  D0 EE                BNE     RDS2            ; KEEP GOING
0099C1  2               DSKOPEND:
0099C1  2  AD 37 03             LDA     FDC_TC
0099C4  2  20 50 9B             JSR     FDDELAY
0099C7  2               ;
0099C7  2  20 EB 9A             JSR     GFDATA          ;GET ERROR TYPE
0099CA  2  8D 66 9B             STA     FLERR
0099CD  2               ;* CLEAR OUT ANY REMAINING DATA
0099CD  2               RESUL3:
0099CD  2  20 EB 9A             JSR     GFDATA          ;READ BYTE FROM FDC
0099D0  2  C9 00                CMP     #$00
0099D2  2  D0 F9                BNE     RESUL3          ;CLEAR THEM ALL
0099D4  2  AD 66 9B             LDA     FLERR           ;
0099D7  2  29 C0                AND     #%11000000      ;
0099D9  2  60                   RTS
0099DA  2               
0099DA  2               
0099DA  2               WRR_POLL:
0099DA  2  20 48 99             JSR     SNDFDWR         ;
0099DD  2               WRS1:   ;
0099DD  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS
0099E0  2  10 FB                BPL     WRS1            ; NOT READY
0099E2  2  29 20                AND     #%00100000      ; EXECUTION MODE?
0099E4  2  F0 1B                BEQ     WRS3            ; NO, ERROR
0099E6  2  B9 E2 94             LDA     hstbuf,Y        ; WRITE IT
0099E9  2  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
0099EC  2  C8                   INY
0099ED  2  D0 EE                BNE     WRS1            ; DO NEXT
0099EF  2               WRS2:   ;
0099EF  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS
0099F2  2  10 FB                BPL     WRS2            ; NOT READY
0099F4  2  29 20                AND     #%00100000      ; EXECUTION MODE?
0099F6  2  F0 09                BEQ     WRS3            ; NO, ERROR
0099F8  2  B9 E2 95             LDA     hstbuf+256,Y    ; WRITE IT
0099FB  2  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
0099FE  2  C8                   INY
0099FF  2  D0 EE                BNE     WRS2            ; DO NEXT
009A01  2               WRS3:
009A01  2  4C C1 99             JMP     DSKOPEND        ;
009A04  2               
009A04  2               
009A04  2               ;__SETTRACK__________________________________________________________________________________________________________________________
009A04  2               ;
009A04  2               ; 	SEEK TO A TRACK ON GIVEN UNIT
009A04  2               ; 	A: TRACK #
009A04  2               ;________________________________________________________________________________________________________________________________
009A04  2               ;
009A04  2               SETTRACK:
009A04  2  A9 0C                LDA     #DOR_INIT
009A06  2  0D 25 05             ORA     DSKUNIT         ; SET MOTOR ON
009A09  2  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
009A0C  2               
009A0C  2               ; ANY INTERUPT PENDING
009A0C  2               ; IF YES FIND OUT WHY/CLEAR
009A0C  2  20 A2 9A             JSR     CHECKINT        ; CHECK INTERRUPT STATUS, MAKE SURE IT IS CLEAR
009A0F  2  C9 FF                CMP     #$FF            ; DID IT RTSURN WITH ERROR CODE?
009A11  2  D0 03                BNE     SETTRK1
009A13  2  4C 5D 9A             JMP     SETTRKEXIT      ;
009A16  2               
009A16  2               ;
009A16  2               SETTRK1:
009A16  2  AD 61 9B             LDA     debcyl          ; GET TRACK
009A19  2  C9 00                CMP     #$00            ;
009A1B  2  F0 16                BEQ     RECAL           ; IF 0 PERFORM RECAL INSTEAD OF SEEK
009A1D  2  A9 0F                LDA     #CFD_SEEK       ; SEEK COMMAND
009A1F  2  20 5E 9A             JSR     PFDATA          ; PUSH COMMAND
009A22  2  AD 25 05             LDA     DSKUNIT         ; SAY WHICH UNIT
009A25  2  29 01                AND     #$01
009A27  2  20 5E 9A             JSR     PFDATA          ; SEND THAT
009A2A  2  AD 61 9B             LDA     debcyl          ; TO WHAT TRACK
009A2D  2  20 5E 9A             JSR     PFDATA          ; SEND THAT TOO
009A30  2  4C 48 9A             JMP     WAINT           ; WAIT FOR INTERRUPT SAYING DONE
009A33  2               RECAL:
009A33  2  A9 0C                LDA     #DOR_INIT
009A35  2  0D 25 05             ORA     DSKUNIT         ; SET MOTOR ON
009A38  2  8D 36 03             STA     FDC_DOR         ; OUTPUT TO CONTROLLER
009A3B  2  A9 07                LDA     #CFD_RECAL      ; RECAL TO TRACK 0
009A3D  2  20 5E 9A             JSR     PFDATA          ; SEND IT
009A40  2  AD 25 05             LDA     DSKUNIT         ; SAY WHICH UNIT
009A43  2  29 01                AND     #$01
009A45  2  20 5E 9A             JSR     PFDATA          ; SEND THAT TOO
009A48  2               ;
009A48  2               WAINT:
009A48  2  48                   PHA
009A49  2  8A                   TXA
009A4A  2  48                   PHA
009A4B  2  A2 64                LDX     #100
009A4D  2  20 55 9B             JSR     FDVDELAY
009A50  2  68                   PLA
009A51  2  AA                   TAX
009A52  2  68                   PLA
009A53  2               :
009A53  2  20 A2 9A             JSR     CHECKINT
009A56  2  AD 30 03             LDA     FDC_MSR         ; READ SEEK STATUS
009A59  2  29 0F                AND     #%00001111      ; ANY DRIVES SEEKING?
009A5B  2  D0 F6                BNE     :-              ; YES, WAIT FOR THEM
009A5D  2               ;
009A5D  2               SETTRKEXIT:
009A5D  2  60                   RTS
009A5E  2               
009A5E  2               ;__PFDATA__________________________________________________________________________________________________________________________
009A5E  2               ;
009A5E  2               ; WRITE A COMMAND OR PARAMETER SEQUENCE
009A5E  2               ;
009A5E  2               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
009A5E  2               ;	RQM  DIO
009A5E  2               ;	0	0	BUSY
009A5E  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
009A5E  2               ;	1	1	BYTE FOR READ BY HOST PENDING
009A5E  2               ;	0	1	BUSY
009A5E  2               ;
009A5E  2               ;________________________________________________________________________________________________________________________________
009A5E  2               ;
009A5E  2               PFDATA:
009A5E  2  48                   PHA                     ; SAVE DATA BYTE
009A5F  2  A0 00                LDY     #$00
009A61  2               WRF1:
009A61  2  AD 30 03             LDA     FDC_MSR         ; READ FDC STATUS
009A64  2  AA                   TAX
009A65  2  29 80                AND     #$80            ;
009A67  2  D0 07                BNE     :+
009A69  2  C8                   INY
009A6A  2  D0 F5                BNE     WRF1            ; FDC IS NOT READY, WAIT FOR IT
009A6C  2  68                   PLA
009A6D  2  A9 FF                LDA     #$FF
009A6F  2  60                   RTS
009A70  2               :
009A70  2  8A                   TXA
009A71  2  29 40                AND     #$40            ; TEST DIO BIT
009A73  2  D0 0E                BNE     WRF2            ; FDC IS OUT OF SYNC
009A75  2  68                   PLA                     ; RESTORE DATA
009A76  2  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
009A79  2  20 50 9B             JSR     FDDELAY
009A7C  2  20 50 9B             JSR     FDDELAY
009A7F  2  20 50 9B             JSR     FDDELAY
009A82  2  60                   RTS
009A83  2               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
009A83  2               WRF2:
009A83  2  AD 31 03             LDA     FDC_DATA        ; READ DATA REGISTER
009A86  2  4C 61 9A             JMP     WRF1            ; AND CONTINUE
009A89  2               
009A89  2               ;__PFDATAS_________________________________________________________________________________________________________________________
009A89  2               ;
009A89  2               ; WRITE A COMMAND OR PARAMETER SEQUENCE (NO PAUSE)
009A89  2               ;
009A89  2               ; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
009A89  2               ;	RQM  DIO
009A89  2               ;	0	0	BUSY
009A89  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
009A89  2               ;	1	1	BYTE FOR READ BY HOST PENDING
009A89  2               ;	0	1	BUSY
009A89  2               ;
009A89  2               ;________________________________________________________________________________________________________________________________
009A89  2               ;
009A89  2               PFDATAS:
009A89  2  48                   PHA                     ; SAVE DATA BYTE
009A8A  2               WRF1S:
009A8A  2  AD 30 03             LDA     FDC_MSR         ; READ FDC STATUS
009A8D  2  AA                   TAX
009A8E  2  29 80                AND     #$80            ;
009A90  2  F0 F8                BEQ     WRF1S           ; FDC IS NOT READY, WAIT FOR IT
009A92  2  8A                   TXA
009A93  2  29 40                AND     #$40            ; TEST DIO BIT
009A95  2  D0 05                BNE     WRF2S           ; FDC IS OUT OF SYNC
009A97  2  68                   PLA                     ; RESTORE DATA
009A98  2  8D 31 03             STA     FDC_DATA        ; WRITE TO FDC
009A9B  2  60                   RTS
009A9C  2               ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE-TRY
009A9C  2               WRF2S:
009A9C  2  AD 31 03             LDA     FDC_DATA        ; READ DATA REGISTER
009A9F  2  4C 8A 9A             JMP     WRF1S           ; AND CONTINUE
009AA2  2               
009AA2  2               
009AA2  2               
009AA2  2               ;__CHECKINT__________________________________________________________________________________________________________________________
009AA2  2               ;
009AA2  2               ; CHECK FOR ACTIVE FDC INTERRUPTS BEFORE GIVING I8272 COMMANDS
009AA2  2               ; POLL RQM FOR WHEN NOT BUSY AND THEN SEND FDC
009AA2  2               ; SENSE INTERRUPT COMMAND.  IF IT RTSURNS WITH NON ZERO
009AA2  2               ; ERROR CODE, PASS BACK TO JSRING ROUTINE FOR HANDLING
009AA2  2               ;________________________________________________________________________________________________________________________________
009AA2  2               ;
009AA2  2               CHECKINT:
009AA2  2  A0 00                LDY     #$00
009AA4  2               :
009AA4  2  AD 30 03             LDA     FDC_MSR         ; READING OR WRITING IS KEYS TO D7 RQM
009AA7  2  29 80                AND     #$80
009AA9  2  D0 09                BNE     :+              ; WAIT FOR RQM TO BE TRUE. WAIT UNTIL DONE
009AAB  2  20 50 9B             JSR     FDDELAY
009AAE  2  C8                   INY
009AAF  2  D0 F3                BNE     :-
009AB1  2  4C BC 9A             JMP     ERRCLR
009AB4  2               
009AB4  2               :
009AB4  2  AD 30 03             LDA     FDC_MSR         ; READING OR WRITING IS KEYS TO D7 RQM
009AB7  2  29 40                AND     #$40            ; WAITING FOR INPUT?
009AB9  2  F0 16                BEQ     SENDINT
009ABB  2  60                   RTS
009ABC  2               
009ABC  2               ERRCLR:
009ABC  2  A0 00                LDY     #$00
009ABE  2               :
009ABE  2  AD 31 03             LDA     FDC_DATA        ; CLEAR THE JUNK OUT OF DATA REGISTER
009AC1  2  AD 30 03             LDA     FDC_MSR         ; CHECK WITH RQM
009AC4  2  29 80                AND     #$80            ; IF STILL NOT READY, READ OUT MORE JUNK
009AC6  2  D0 06                BNE     :+              ;
009AC8  2  20 50 9B             JSR     FDDELAY
009ACB  2  C8                   INY
009ACC  2  D0 F0                BNE     :-
009ACE  2               :
009ACE  2  A9 FF                LDA     #$FF            ; RETURN ERROR CODE -1
009AD0  2               ;
009AD0  2  60                   RTS
009AD1  2               
009AD1  2               ;__SENDINT__________________________________________________________________________________________________________________________
009AD1  2               ;
009AD1  2               ; SENSE INTERRUPT COMMAND
009AD1  2               ;________________________________________________________________________________________________________________________________
009AD1  2               ;
009AD1  2               SENDINT:
009AD1  2  A9 08                LDA     #CFD_SENSEINT   ; SENSE INTERRUPT COMMAND
009AD3  2  20 5E 9A             JSR     PFDATA          ; SEND IT
009AD6  2  20 EB 9A             JSR     GFDATA          ; GET RESULTS
009AD9  2  8D 69 9B             STA     ST0             ; STORE THAT
009ADC  2  29 C0                AND     #$C0            ; MASK OFF INTERRUPT STATUS BITS
009ADE  2  C9 80                CMP     #$80            ; CHECK IF INVALID COMMAND
009AE0  2  F0 08                BEQ     ENDSENDINT      ; YES, EXIT
009AE2  2  20 EB 9A             JSR     GFDATA          ; GET ANOTHER (STATUS CODE 1)
009AE5  2  AD 69 9B             LDA     ST0             ; GET FIRST ONE
009AE8  2  29 C0                AND     #$C0            ; MASK OFF ALL BUT INTERRUPT CODE 00 IS NORMAL
009AEA  2               ENDSENDINT:
009AEA  2  60                   RTS                     ; ANYTHING ELSE IS AN ERROR
009AEB  2               
009AEB  2               
009AEB  2               ;__GFDATA__________________________________________________________________________________________________________________________
009AEB  2               ;
009AEB  2               ; GET DATA FROM FLOPPY CONTROLLER
009AEB  2               ;
009AEB  2               ; TRANSFERS ARE SYNCHONIZED BYT MSR D7 <RQM> AND D6 <DIO>
009AEB  2               ;	RQM  DIO
009AEB  2               ;	0	0	BUSY
009AEB  2               ;	1	0	WRITE TO DATA REGISTER PERMITTED
009AEB  2               ;	1	1	BYTE FOR READ BY HOST PENDING
009AEB  2               ;	0	1	BUSY
009AEB  2               ;
009AEB  2               ;________________________________________________________________________________________________________________________________
009AEB  2               ;
009AEB  2               GFDATA:
009AEB  2  A0 00                LDY     #$00
009AED  2               :
009AED  2  AD 30 03             LDA     FDC_MSR         ; GET STATUS
009AF0  2  AA                   TAX                     ;
009AF1  2  29 80                AND     #%10000000      ; NOT READY, WAIT
009AF3  2  D0 06                BNE     :+              ;
009AF5  2  C8                   INY
009AF6  2  D0 F5                BNE     :-
009AF8  2  A9 00                LDA     #$00
009AFA  2  60                   RTS
009AFB  2               :
009AFB  2  8A                   TXA
009AFC  2  29 40                AND     #%01000000      ; ANY DATA FOR US?
009AFE  2  F0 03                BEQ     GFDATA1         ; NO, SKIP IT
009B00  2  AD 31 03             LDA     FDC_DATA        ; GET FDC DATA
009B03  2               GFDATA1:
009B03  2  60                   RTS
009B04  2               
009B04  2               ;__FD_DETECT______________________________________________________________________________________________________________________
009B04  2               ;
009B04  2               ; 	DETECT FLOPPY HARDWARE
009B04  2               ;________________________________________________________________________________________________________________________________
009B04  2               FD_DETECT:
009B04  2               ; BLINDLY RESET FDC (WHICH MAY OR MAY NOT EXIST)
009B04  2  20 32 9B             JSR     FC_RESETFDC     ; RESET FDC
009B07  2               
009B07  2  AD 30 03             LDA     FDC_MSR         ; READ MSR
009B0A  2  C9 80                CMP     #$80
009B0C  2  F0 0A                BEQ     FD_DETECT1      ; $80 IS OK
009B0E  2  C9 D0                CMP     #$D0
009B10  2  F0 06                BEQ     FD_DETECT1      ; $D0 IS OK
009B12  2  A9 FF                LDA     #$FF            ; NOT OK
009B14  2  8D 5F 9B             STA     HARDWARE_DETCT
009B17  2  60                   RTS
009B18  2               ;
009B18  2               FD_DETECT1:
009B18  2  A2 64                LDX     #100
009B1A  2  20 55 9B             JSR     FDVDELAY        ; WAIT A BIT FOR FDC
009B1D  2  AD 30 03             LDA     FDC_MSR         ; READ MSR AGAIN
009B20  2  C9 80                CMP     #$80
009B22  2  F0 08                BEQ     :+              ; $80 IS OK
009B24  2  C9 D0                CMP     #$D0
009B26  2  A9 FF                LDA     #$FF            ; NOT OK
009B28  2  8D 5F 9B             STA     HARDWARE_DETCT
009B2B  2  60                   RTS
009B2C  2               :
009B2C  2  A9 00                LDA     #$00            ; OK
009B2E  2  8D 5F 9B             STA     HARDWARE_DETCT
009B31  2  60                   RTS
009B32  2               
009B32  2               FC_RESETFDC:
009B32  2  AD 33 03             LDA     FDC_RESET
009B35  2  AD 33 03             LDA     FDC_RESET
009B38  2  A2 96                LDX     #150
009B3A  2  20 55 9B             JSR     FDVDELAY        ; WAIT A BIT FOR FDC
009B3D  2               
009B3D  2  A9 00                LDA     #$00
009B3F  2  8D 36 03             STA     FDC_DOR
009B42  2  20 50 9B             JSR     FDDELAY
009B45  2  A9 0C                LDA     #DOR_INIT
009B47  2  8D 36 03             STA     FDC_DOR
009B4A  2  A2 96                LDX     #150            ;
009B4C  2  20 55 9B             JSR     FDVDELAY
009B4F  2  60                   RTS
009B50  2               
009B50  2               
009B50  2               FDDELAY:
009B50  2  48                   PHA
009B51  2  68                   PLA
009B52  2  48                   PHA
009B53  2  68                   PLA
009B54  2  60                   RTS
009B55  2               FDVDELAY:
009B55  2  48                   PHA
009B56  2  68                   PLA
009B57  2  48                   PHA
009B58  2  68                   PLA
009B59  2  CA                   DEX
009B5A  2  E0 00                CPX     #$00
009B5C  2  D0 F7                BNE     FDVDELAY
009B5E  2  60                   RTS
009B5F  2               
009B5F  2               
009B5F  2               
009B5F  2               HARDWARE_DETCT:
009B5F  2  00                   .BYTE   0               ; HARDWARE DETECTED
009B60  2               debhead:
009B60  2  00                   .BYTE   0               ; DEBLOCKED HEAD
009B61  2               debcyl:
009B61  2  00                   .BYTE   0               ; DEBLOCKED CYLINDER
009B62  2               debsec:
009B62  2  00                   .BYTE   0               ; DEBLOCKED SECTOR
009B63  2               Cdebhead:
009B63  2  00                   .BYTE   0               ; DEBLOCKED HEAD (cache)
009B64  2               Cdebcyl:
009B64  2  00                   .BYTE   0               ; DEBLOCKED CYLINDER (cache)
009B65  2               Cdebsec:
009B65  2  00                   .BYTE   0               ; DEBLOCKED SECTOR (cache)
009B66  2               FLERR:
009B66  2  00                   .BYTE   $00             ;
009B67  2               UNIT:
009B67  2  00                   .BYTE   $00             ;
009B68  2               FCMD:
009B68  2  00                   .BYTE   0               ; COMMAND READ OR WRITE,
009B69  2               ST0:
009B69  2  00                   .BYTE   0               ; COMMAND READ OR WRITE,
009B6A  2               FLRETRY:
009B6A  2  00                   .BYTE   00
009B6B  2               FLRETRY1:
009B6B  2  00                   .BYTE   00
009B6C  2               
009B6C  1               
009B6C  1               ;// TODO: this should be dependent on "active console. . ." and should be a driver call
009B6C  1               CONSOLE_OUT:
009B6C  1  20 D5 88             JSR     WRSER1
009B6F  1  60                   RTS
009B70  1               
009B70  1               ;// TODO: CONSOLE_IN
009B70  1               
009B70  1               
009B70  1  EA                   NOP
009B71  1  EA                   NOP
009B72  1  EA                   NOP
009B73  1  EA                   NOP
009B74  1  EA                   NOP
009B75  1  EA                   NOP
009B76  1  EA                   NOP
009B77  1  EA                   NOP
009B78  1  EA                   NOP
009B79  1  EA                   NOP
009B7A  1               
009B7A  1                       .END
