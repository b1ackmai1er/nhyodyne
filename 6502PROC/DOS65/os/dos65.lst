ca65 V2.18 - Ubuntu 2.19-1
Main file   : dos65.asm
Current file: dos65.asm

000000r 1               ;sysgen
000000r 1               ;version 2.15-a
000000r 1               ;released:	30 november 1985 (2.10)
000000r 1               ;last revised:	2 may 1996 (2.11)
000000r 1               ;			eliminated word mode for 1024 blocks
000000r 1               ;			made extent a single byte
000000r 1               ;		3 may 1996 (2.12)
000000r 1               ;			added initial exm related code
000000r 1               ;		11 may 1996 (2.13)
000000r 1               ;			added use of exm in getblk
000000r 1               ;			added code to set exm & cexm1f
000000r 1               ;			corrected errors
000000r 1               ;		19 may 1996 (2.14)
000000r 1               ;			changed ccm ren to "to from" syntax
000000r 1               ;			allowed _ in file names
000000r 1               ;		13 march 2008 (2.15)
000000r 1               ;			reformatted for TASM & ASM210+
000000r 1               ;			eliminated dependence on "IBM" format
000000r 1               ;			  by reading first sector # using SIM+51
000000r 1               ;			  TRANSLATE code. If translate
000000r 1               ;			  does not have first physical sector in first
000000r 1               ;			  position this approach may not work.
000000r 1               ;			  SIM can also perform no translation at all.
000000r 1               ;			  Also assumes BOOT & SIM both know correct
000000r 1               ;			  starting sector for cold & warm boot. It
000000r 1               ;			  should work regardless of physical sector
000000r 1               ;			  size as long as existing SIM is configured
000000r 1               ;			  correctly for destination drive. BOOT
000000r 1               ;			  must correctly handle sectors > 128 bytes
000000r 1               ;			  as must WARM BOOT in SIM.
000000r 1               ;			  In any case BOOT and WARM BOOT must
000000r 1               ;			  read sectors in sequential order, i.e.,
000000r 1               ;			  no interleave.
000000r 1               ;this program contains the complete dos/65 operating
000000r 1               ;system except for the boot and sim.
000000r 1               ;when used by the system operator this program
000000r 1               ;provides the capability to construct a new
000000r 1               ;operating system including the users boot and sim.
000000r 1               ;the system is relocated to fit the memory size
000000r 1               ;specified by the user and is written onto
000000r 1               ;the system tracks of the specified drive.
000000r 1               ;improvements over version 2.0 include:
000000r 1               ;	use of "from to" syntax for ren
000000r 1               ;	addition of go command
000000r 1               ;	addition of load command
000000r 1               ;	ability to enter numbers as decimal or hex
000000r 1               ;	address parameter added to save
000000r 1               ;	error checking in sysgen (write)
000000r 1               ;	write type for deblocking added
000000r 1               ;	page zero 0 & 1 not used
000000r 1               ;	allow _ in file names
000000r 1               
000000r 1               .include "dosdefn.asm" 		; base addresses and definitions
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               ;
000000r 2               ;	Nhyodyne dos/65 base addresses and definitions
000000r 2               ;
000000r 2               ;  DWERNER 04/24/2022 	Initial
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               
000000r 2               ;base addresses and definitions
000000r 2               btejmp	        =	$0100		; warm boot jump
000000r 2               pemjmp	        =	$0103		; jump to pem
000000r 2               iostat	        =	$0106		; i/o status
000000r 2               dflfcb	        =	$0107		; default fcb
000000r 2               dflbuf	        =	$0128		; default buffer
000000r 2               memmovr         =	$0200		; 0200-02ff subr to move data from ram/rom disks
000000r 2               MD_PAGERA       =   $0200       ; PAGE DRIVER ADDRESS
000000r 2               
000000r 2               IO              =   $0300       ; 0300-03FF Memory mapped IO
000000r 2               MPCL_ROM	    =	$037C		; ROM MAPPER
000000r 2               MPCL_RAM	    =	$0378		; RAM MAPPER
000000r 2               
000000r 2               MD_PAGEBU       =   $0400       ; 0400-04FF PAGE BUFFER ADDRESS
000000r 2               MD_PAGESE       =   pointr      ; PAGE SECTOR STORAGE
000000r 2               
000000r 2               ;
000000r 2               ; DRIVER WORKING STORAGE
000000r 2               ;
000000r 2               DSKY_BUF        =       $0500	        ; Eight Bytes DSKY display buffer
000000r 2               DSKY_BUFLEN	    =       8               ;
000000r 2               DSKY_HEXBUF     =       $0508           ; Four Bytes DSKY hex buffer
000000r 2               DSKY_HEXBUFLEN	=       4               ;
000000r 2               sektrk          =       $050C		    ; seek track number
000000r 2               seksec          =       $050E		    ; seek sector number
000000r 2               debcyll         =       $0510	        ; DEBLOCKED CYLINDER LSB
000000r 2               debcylm         =	    $0511           ; DEBLOCKED CYLINDER MSB
000000r 2               debsehd         =	    $0512           ; DEBLOCKED SECTOR AND HEAD (HS)
000000r 2               sekdsk          =       $0513           ; seek disk number
000000r 2               dskcfg          =       $0514           ; 16 bytes disk configuration table
000000r 2               DSKUNIT         =       $0525           ; seek disk number
000000r 2               
000000r 2               
000000r 2               tea	=	$800		;tea start
000000r 2               
000000r 2               ;zero page for setup
000000r 2               trknum	=	$02			;current track
000000r 2               dcbadd	=	$04			;dcb address
000000r 2               nmsstr	=	$06			;number system tracks
000000r 2               nsectr	=	$08			;number sectors per track
000000r 2               ttlsec	=	$0A			;total sectors to write
000000r 2               trkcnt	=	ttlsec
000000r 2               size	=	$0B			;ascii size
000000r 2               lokim	=	$0D			;low kim limit
000000r 2               hikim	=	$0F			;high kim limit
000000r 2               offset	=	$11			;relocation offset
000000r 2               kimcnt	=	$13			;kim counter
000000r 2               pointr	=	$14			;pointer
000000r 2               lengt	=	$16			;inst length
000000r 2               point	=	$17			;relocate pointer
000000r 2               adjust	=	$19			;relocate distance
000000r 2               kimpnt	=	$1B			;kim file index
000000r 2               savex	=	$1C			;save for x
000000r 2               savey	=	$1D			;save for y
000000r 2               number	=	$1E			;input pack buffer
000000r 2               dstdrv	=	$20			;destination drive
000000r 2               defalt	=	$21			;default drive
000000r 2               seccnt	=	$22			;sector count
000000r 2               secnum	=	$24			;sector number
000000r 2               curccm	=	$26			;start of current ccm
000000r 2               simlng	=	$28			;length of sim
000000r 2               room	=	$2A			;memory needed for sysgen
000000r 2               stksav	=	$2C			;save stack register
000000r 2               frstsc	=	$2D			;first sector number of disk
000000r 2               dskcfpc	=	$2E			;pointer to disk configuration table
000000r 2               cmdlnp	=	$30			;pointer to command line buffer
000000r 2               farfunct=   $32         ;function to call in driver area
000000r 2               farpointer= $33         ;WORD POINTER to call in driver area
000000r 2               IRQVECTOR=	$35   		; VECTOR FOR USER IRQ RTN
000000r 2               NMIVECTOR=	$37   		; VECTOR FOR USER NMI RTN
000000r 2               lastzp	=	$39
000000r 2               
000000r 2               ;pem constants on entry to write
000000r 2               wrall	=	0		;write to allocated
000000r 2               wrdir	=	1		;write to directory
000000r 2               wrual	=	2		;write to unallocated
000000r 2               
000000r 2               ;page zero and system ram assignments
000000r 2               DEST	=	$EC		;pointer for OutMsg
000000r 2               SRC	    =	$EE		;pointer for OutMsg
000000r 2               OUTMSG_W=	$F0		;pointer for OutMsg
000000r 2               mvepnt	=	$f2		;host buffer location
000000r 2               dmaadr	=	$f4		;pointer for r/w
000000r 2               
000000r 2               ;fixed parameters
000000r 2               lf	    =	$a		;linefeeed
000000r 2               cr	    =	$d		;return
000000r 2               eof	    =	$1a		;end of file
000000r 2               null	=	0		;null
000000r 2               ctlc	=	3		;abort
000000r 2               ctle	=	5		;physical cr lf
000000r 2               ctli	=	9		;tab character
000000r 2               ctlp	=	$10		;toggle printer
000000r 2               ctlr	=	$12		;repeat line
000000r 2               ctls	=	$13		;freeze
000000r 2               ctlx	=	$18		;cancel
000000r 2               semico	=	$3b		;semicolon
000000r 2               delete	=	$08		;delete character
000000r 2               numcmd	=	36		;number commands
000000r 2               
000000r 2               BANKED_DRIVER_DISPATCHER=$8800  ; LOCATION OF DRIVER DISPATCHER
000000r 2               DEBUG	=	0		; assemble with debug information on
000000r 2               
000000r 2               
000000r 2               USESERIAL 	= 	1	; SET TO ONE SERIAL CONSOLE IO
000000r 2               USEFLOPPYA 	= 	0	; SET TO ONE FOR FLOPPY = "A"
000000r 2               USEFLOPPYB 	= 	0	; SET TO ONE FOR FLOPPY = "B"
000000r 2               USEIDEC 	= 	1	; SET TO ONE FOR IDE HDD="C"
000000r 2               USEDSKY 	= 	0	; SEND INFO TO DSKY
000000r 2               USEDSKYNG 	= 	1	; SEND INFO TO DSKYNG
000000r 2               DSKY_KBD	=	1	; USE DSKY KEYBOARD?
000000r 2               DEFDRV  	=	2	; SET TO DEFAULT DRIVE LETTER
000000r 2               USEDISKIOV1 = 	0	; Floppy and IDE card is  DISK IO V1
000000r 2               USEDISKIOV3 = 	0	; Floppy and IDE card is  DISK IO V3
000000r 2               
000000r 2               FLPA35		=	0	; set to 1 if floppy a is A 3.5" 80 track drive (0= 5.25" 40 track drive)
000000r 2               FLPB35		=	0	; set to 1 if floppy a is B 3.5" 80 track drive (0= 5.25" 40 track drive)
000000r 2               
000000r 2               DSKYOSC     =	1000000
000000r 2               
000000r 1               
000000r 1               ; for Nhyodyne:
000000r 1               ; RAM BANK $0C is RAM area for Drivers
000000r 1               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
000000r 1               ; RAM BANK $0F is fixed bank $0000-$7FFF
000000r 1               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
000000r 1               
000000r 1               		.PC02
000000r 1                               .segment "OS"
000000r 1               		.ORG $D000
00D000  1               		.include "ccmnhy.asm"
00D000  2               ;________________________________________________________________________________________________________________________________
00D000  2               ;
00D000  2               ;	Nhyodyne dos/65 dos/65 console command module (ccm)
00D000  2               ;
00D000  2               ;  DWERNER 12/20/2021 	ported to Nhyodyne
00D000  2               ;  DWERNER 12/30/2021   changed .COM files to .CO6 files to reduce confusion when
00D000  2               ;                       sharing CP/M file system images
00D000  2               ;  DWERNER 02/19/2022   Strip off Most significant bit of file name in dir to
00D000  2               ;			make filesystem compatible with ROMWBW
00D000  2               ;________________________________________________________________________________________________________________________________
00D000  2               
00D000  2               ;ccm unique definitions
00D000  2               nbuilt	=	7		;number built in commands
00D000  2               ;main program
00D000  2               				; warm boot vector
00D000  2  4C AC E5     		JMP boot
00D003  2  D8           ccm:	cld			;set binary mode
00D004  2  48           	pha			;save drive number
00D005  2  20 FC D3     	jsr	rstdsk		;initialize system
00D008  2  68           	pla			;restore drive num
00D009  2  20 00 D4     	jsr	slctds		;select drive
00D00C  2  AD 8C E4     	lda	sysdef+6	;get line length
00D00F  2  4A           	lsr	a		;divide
00D010  2  4A           	lsr	a		;by
00D011  2  4A           	lsr	a		;16
00D012  2  4A           	lsr	a		;for dir
00D013  2  8D F6 D7     	sta	sixten		;and save
00D016  2  AD 43 D7     	lda	cnslng		;get buffer length
00D019  2  D0 3C        	bne	mrecmd		;if more handle it
00D01B  2  A2 FF        ccmlpe:	ldx	#$ff		;set
00D01D  2  9A           	txs			;stack
00D01E  2  D8           	cld			;set binary mode
00D01F  2  A9 11        	lda	#17		; SEND A XON
00D021  2  20 F0 D3     	jsr	chrout		; ----------
00D024  2  20 69 D4     	jsr	hdrout		;send header
00D027  2  A9 3E        	lda	#'>'		;then print
00D029  2  20 F0 D3     	jsr	chrout		;prompt
00D02C  2  AD 8B D6     	lda	cnsbvc		;point to start
00D02F  2  AC 8C D6     	ldy	cnsbvc+1	;of buffer
00D032  2  20 F4 D3     	jsr	rdebuf		;do buffer read
00D035  2  A0 00        	ldy	#0		;clear index
00D037  2  AE 43 D7     	ldx	cnslng		;get length
00D03A  2  F0 DF        	beq	ccmlpe		;loop if empty
00D03C  2  B9 44 D7     lwrupr:	lda	cnstxt,y	;else get char
00D03F  2  C9 61        	cmp	#'a'		;if less than a
00D041  2  90 09        	bcc	nxtchg		;skip convert
00D043  2  C9 7B        	cmp	#'z'+1		;if over z
00D045  2  B0 05        	bcs	nxtchg		;skip convert
00D047  2  29 5F        	and	#%01011111	;else convert
00D049  2  99 44 D7     	sta	cnstxt,y	;put back in buffer
00D04C  2  C8           nxtchg:	iny			;bump index
00D04D  2  CA           	dex			;count down
00D04E  2  D0 EC        	bne	lwrupr		;loop if more
00D050  2  8A           	txa			;set a to zero
00D051  2  99 44 D7     	sta	cnstxt,y	;insert stopper
00D054  2  8D E7 D7     	sta	cnbfpt		;initialize pointer
00D057  2  20 A4 D5     mrecmd:	jsr	stdflb		;set default buffer
00D05A  2  20 2B D4     	jsr	intdsk		;get drive number
00D05D  2  8D E8 D7     	sta	dfldsk		;store as default
00D060  2  20 A5 D4     	jsr	prslin		;parse command
00D063  2  D0 64        	bne	cmderr		;error if afn
00D065  2  AD E9 D7     	lda	tmpdsk		;get temporary
00D068  2  F0 04        	beq	nodrch		;if zero ok
00D06A  2  A9 15        	lda	#nbuilt*3	;else set and
00D06C  2  D0 2E        	bne	dotrns		;do transient
00D06E  2  A9 00        nodrch:	lda	#0		;clear
00D070  2  AA           	tax			;table index
00D071  2  8D EC D7     	sta	ccmcount		;and count
00D074  2  A0 01        tsnxfn:	ldy	#1		;set fcb index
00D076  2  BD 1D D7     tsnxch:	lda	fnctbl,x	;get table entry
00D079  2  F0 1A        	beq	gotcmd		;if zero got it
00D07B  2  D9 C3 D7     	cmp	fcbone,y	;else test
00D07E  2  D0 04        	bne	nocmpr		;no good if not =
00D080  2  E8           	inx			;bump
00D081  2  C8           	iny			;pointers
00D082  2  D0 F2        	bne	tsnxch		;and loop
00D084  2  E8           nocmpr:	inx			;go to end
00D085  2  BD 1D D7     	lda	fnctbl,x	;of table
00D088  2  D0 FA        	bne	nocmpr		;entry
00D08A  2  E8           	inx			;point to next
00D08B  2  EE EC D7     	inc	ccmcount		;bump count
00D08E  2  AD EC D7     	lda	ccmcount		;and if not
00D091  2  C9 07        	cmp	#nbuilt		;limit then
00D093  2  D0 DF        	bne	tsnxfn		;try next
00D095  2  AD EC D7     gotcmd:	lda	ccmcount		;get count
00D098  2  0A           	asl	a		;multiply by two
00D099  2  6D EC D7     	adc	ccmcount		;then add for x3
00D09C  2  AA           dotrns:	tax			;use as index
00D09D  2  E8           	inx			;bump to pass jmp
00D09E  2  BD 96 D6     	lda	xqfntb,x	;to get
00D0A1  2  BC 97 D6     	ldy	xqfntb+1,x	;entry address
00D0A4  2  8D EA D7     	sta	vector		;then set
00D0A7  2  8C EB D7     	sty	vector+1	;vector
00D0AA  2  AD 8F D6     	lda	extcvc+1	;save
00D0AD  2  48           	pha			;return
00D0AE  2  AD 8E D6     	lda	extcvc		;address
00D0B1  2  48           	pha			;on stack
00D0B2  2  6C EA D7     	jmp	(vector)	;execute
00D0B5  2  20 34 D4     extcmd:	jsr	rstddr		;restore default
00D0B8  2  20 A5 D4     extwod:	jsr	prslin		;parse more
00D0BB  2  AD C4 D7     	lda	fcbone+1	;if first
00D0BE  2  38           	sec			;character
00D0BF  2  E9 20        	sbc	#' '		;not a space
00D0C1  2  0D E9 D7     	ora	tmpdsk		;or if temporary
00D0C4  2  D0 03        	bne	cmderr		;then an error
00D0C6  2  4C 1B D0     	jmp	ccmlpe		;else loop
00D0C9  2               ;command error syntax handler
00D0C9  2  20 E1 D3     cmderr:	jsr	ccrlf		;do a cr lf
00D0CC  2  AC ED D7     	ldy	curpnt		;get command pointer
00D0CF  2  B9 44 D7     cmerlp:	lda	cnstxt,y	;get char
00D0D2  2  F0 0A        	beq	cmerex		;if null then done
00D0D4  2  C9 20        	cmp	#' '		;if space
00D0D6  2  F0 06        	beq	cmerex		;then done
00D0D8  2  20 72 D4     	jsr	cotsxy		;output with save
00D0DB  2  C8           	iny			;point to next
00D0DC  2  D0 F1        	bne	cmerlp		;and loop
00D0DE  2  A9 3F        cmerex:	lda	#'?'		;send a
00D0E0  2  20 F0 D3     	jsr	chrout		;question mark
00D0E3  2  4C 1B D0     	jmp	ccmlpe		;and start over
00D0E6  2               ;execute dir command
00D0E6  2               ; dir <afn>
00D0E6  2  20 A5 D4     dir:	jsr	prslin		;find object file
00D0E9  2  20 AB D5     	jsr	clrslt		;clear auto and select
00D0EC  2  A9 20        	lda	#' '		;if name
00D0EE  2  CD C4 D7     	cmp	fcbone+1	;and
00D0F1  2  D0 0F        	bne	findfr		;type are
00D0F3  2  CD CC D7     	cmp	fcbone+9	;not empty
00D0F6  2  D0 0A        	bne	findfr		;then use it
00D0F8  2  A9 3F        	lda	#'?'		;else
00D0FA  2  A0 0B        	ldy	#11		;fill
00D0FC  2  99 C3 D7     fillqu:	sta	fcbone,y	;fcb
00D0FF  2  88           	dey			;with
00D100  2  D0 FA        	bne	fillqu		;question marks
00D102  2  20 5F D4     findfr:	jsr	srchf1		;search for first match
00D105  2  30 58        	bmi	notfnd		;error if none
00D107  2  AD F6 D7     fnddir:	lda	sixten		;set across
00D10A  2  8D F5 D7     	sta	across		;to four
00D10D  2  20 E1 D3     	jsr	ccrlf		;do a crlf
00D110  2  20 6C D4     dirl:	jsr	hdr		;do header
00D113  2  A9 3A        	lda	#':'		;then a
00D115  2  20 F0 D3     	jsr	chrout		;colon
00D118  2  AD EE D7     	lda	diradd		;get number
00D11B  2  0A           	asl	a		;and
00D11C  2  0A           	asl	a		;multiply
00D11D  2  0A           	asl	a		;by
00D11E  2  0A           	asl	a		;thirty two
00D11F  2  0A           	asl	a		;then
00D120  2  29 60        	and	#%01100000	;mask out insignificant
00D122  2  A8           	tay			;make a pointer
00D123  2  C8           	iny			;and bump
00D124  2  A2 01        	ldx	#1		;set counter
00D126  2  B9 28 01     nmelpe:	lda	dflbuf,y	;get name
00D129  2  29 7F        	AND 	#$7F		;mask out read only bit
00D12B  2  20 72 D4     	jsr	cotsxy		;else send to console
00D12E  2  C8           noname:	iny			;bump index
00D12F  2  E8           	inx			;and count
00D130  2  E0 0C        	cpx	#12		;if count is 12
00D132  2  F0 0C        	beq	endnme		;then done
00D134  2  E0 09        	cpx	#9		;or if not 9
00D136  2  D0 EE        	bne	nmelpe		;then loop
00D138  2  A9 2E        	lda	#'.'		;else send
00D13A  2  20 72 D4     	jsr	cotsxy		;a period
00D13D  2  4C 26 D1     	jmp	nmelpe		;and loop
00D140  2  20 F8 D3     endnme:	jsr	chkcst		;check console status
00D143  2  D0 19        	bne	extdir		;if key down quit
00D145  2  20 97 D4     	jsr	setone		;else point to fcb
00D148  2  20 10 D4     	jsr	srchnx		;else search for next
00D14B  2  8D EE D7     	sta	diradd		;save number
00D14E  2  30 0E        	bmi	extdir		;quit if not found
00D150  2  CE F5 D7     	dec	across		;drop count
00D153  2  F0 B2        	beq	fnddir		;new line if 0
00D155  2  20 EE D3     	jsr	spcout		;send
00D158  2  20 EE D3     	jsr	spcout		;two spaces
00D15B  2  4C 10 D1     	jmp	dirl		;and stay
00D15E  2  60           extdir:	rts			;else done
00D15F  2               ;not found error handler
00D15F  2  A0 34        notfnd:	ldy	#ntfnms		;point to message
00D161  2  4C C0 D5     	jmp	sndmsg		;send and exit
00D164  2               ;execute ren command
00D164  2               ; ren <ufn> <ufn>
00D164  2               ;where first ufn is from name and second is to name
00D164  2  20 A5 D4     ren:	jsr	prslin		;get old name
00D167  2  D0 57        	bne	renerr		;error if afn
00D169  2  20 9E D4     	jsr	tmpold		;save drive
00D16C  2  20 AB D5     	jsr	clrslt		;clear auto and select
00D16F  2  20 5F D4     	jsr	srchf1		;if file does not exist
00D172  2  30 4F        	bmi	fntfnd		;then an error
00D174  2  20 E0 D5     	jsr	frssec		;move name to second half
00D177  2  AC E7 D7     	ldy	cnbfpt		;get pointer
00D17A  2  B9 44 D7     	lda	cnstxt,y	;and then char
00D17D  2  C9 20        	cmp	#' '		;if not a space
00D17F  2  D0 3C        	bne	rensyn		;then error
00D181  2  20 A5 D4     	jsr	prslin		;get new name
00D184  2  D0 37        	bne	rensyn		;error if afn
00D186  2  AD E9 D7     	lda	tmpdsk		;get new drive
00D189  2  F0 12        	beq	nonwdr		;if zero ok
00D18B  2  CD F2 D7     	cmp	oldtmp		;compare to old
00D18E  2  F0 0D        	beq	nonwdr		;ok if same
00D190  2  38           	sec			;drop for default check
00D191  2  E9 01        	sbc	#1
00D193  2  CD E8 D7     	cmp	dfldsk		;if not default
00D196  2  D0 25        	bne	rensyn		;is error
00D198  2  AD F2 D7     	lda	oldtmp		;and then if from not
00D19B  2  D0 20        	bne	rensyn		;default is error
00D19D  2  AD F2 D7     nonwdr:	lda	oldtmp		;else get old
00D1A0  2  8D E9 D7     	sta	tmpdsk		;and save
00D1A3  2  A9 00        	lda	#0		;clear
00D1A5  2  8D D3 D7     	sta	fcbone+16
00D1A8  2  20 AB D5     	jsr	clrslt		;reselect
00D1AB  2  20 5F D4     	jsr	srchf1		;search for old
00D1AE  2  10 09        	bpl	filexs		;error if found
00D1B0  2  20 E0 D5     	jsr	frssec		;swap names
00D1B3  2  20 97 D4     	jsr	setone		;point to fcb
00D1B6  2  4C 27 D4     	jmp	renmfl		;and do it
00D1B9  2               ;ren file exists error handler
00D1B9  2  A0 3E        filexs:	ldy	#flexms		;point to
00D1BB  2  D0 08        	bne	remsg		;and send
00D1BD  2               ;ren syntax error handler
00D1BD  2  20 34 D4     rensyn:	jsr	rstddr		;restore default
00D1C0  2  4C C9 D0     renerr:	jmp	cmderr		;do error
00D1C3  2               ;ren source file not found error handler
00D1C3  2  A0 34        fntfnd:	ldy	#ntfnms		;point to
00D1C5  2  4C C0 D5     remsg:	jmp	sndmsg		;and send
00D1C8  2               ;execute save command
00D1C8  2               ; save <length> <drive:>ufn (<address>)
00D1C8  2  A9 00        save:	lda	#<tea		;set start address to tea start
00D1CA  2  A0 08        	ldy	#>tea
00D1CC  2  8D FC D7     	sta	sadr
00D1CF  2  8C FD D7     	sty	sadr+1
00D1D2  2  20 05 D6     	jsr	bldnum		;calculate length
00D1D5  2  D0 7A        	bne	saverr		;error if > 255 pages
00D1D7  2  8D F1 D7     	sta	length		;else save low
00D1DA  2  0D F1 D7     	ora	length		;test for zero length
00D1DD  2  F0 72        	beq	saverr		;error if is
00D1DF  2  20 A5 D4     	jsr	prslin		;get file name
00D1E2  2  D0 6D        	bne	saverr		;error if afn
00D1E4  2  20 E0 D5     	jsr	frssec		;move name to second half
00D1E7  2  20 9E D4     	jsr	tmpold		;save drive
00D1EA  2  20 05 D6     	jsr	bldnum		;it is so find value
00D1ED  2  AE C4 D7     	ldx	fcbone+1	;see if there
00D1F0  2  E0 20        	cpx	#' '
00D1F2  2  F0 0A        	beq	nosadr		;it is not
00D1F4  2  8D FC D7     	sta	sadr		;and set address
00D1F7  2  8C FD D7     	sty	sadr+1
00D1FA  2  C0 02        	cpy	#2		;make sure is high enough
00D1FC  2  90 53        	bcc	saverr		;error if not
00D1FE  2  20 F3 D5     nosadr:	jsr	secfrs		;move name back
00D201  2  20 AB D5     	jsr	clrslt		;clear auto and select
00D204  2  20 14 D4     	jsr	dlt1		;delete
00D207  2  20 97 D4     	jsr	setone		;then create
00D20A  2  20 23 D4     	jsr	cratfl		;new file
00D20D  2  30 45        	bmi	noroom		;say no room if error
00D20F  2  20 4A D4     	jsr	open1		;open file
00D212  2  30 44        	bmi	noopen		;if error
00D214  2  18           	clc			;now find end page
00D215  2  AD FD D7     	lda	sadr+1
00D218  2  6D F1 D7     	adc	length
00D21B  2  8D F1 D7     	sta	length
00D21E  2  AD FC D7     	lda	sadr		;get start address
00D221  2  AC FD D7     	ldy	sadr+1
00D224  2  8D F3 D7     wrtmre:	sta	dskbuf		;set
00D227  2  8C F4 D7     	sty	dskbuf+1	;buffer
00D22A  2  20 C4 E2     	jsr	mv128		;move data to buffer
00D22D  2  20 97 D4     	jsr	setone		;point to fcb
00D230  2  20 1F D4     	jsr	wrrcrd		;write record
00D233  2  D0 27        	bne	wrterr		;exit if error
00D235  2  18           	clc			;else
00D236  2  AD F3 D7     	lda	dskbuf		;get old
00D239  2  AC F4 D7     	ldy	dskbuf+1	;buffer
00D23C  2  69 80        	adc	#128		;add 128
00D23E  2  90 03        	bcc	donotc		;if carry
00D240  2  C8           	iny			;bump upper
00D241  2  F0 05        	beq	clssav		;done if page zero
00D243  2  CC F1 D7     donotc:	cpy	length		;loop if upper
00D246  2  D0 DC        	bne	wrtmre		;not at limit
00D248  2  20 97 D4     clssav:	jsr	setone		;else point to
00D24B  2  20 08 D4     	jsr	clsefl		;and close file
00D24E  2  30 10        	bmi	cantcl		;say so if error
00D250  2  60           extera:	rts
00D251  2               ;save error handler
00D251  2  4C C9 D0     saverr:	jmp	cmderr		;do error
00D254  2               ;save no room error handler
00D254  2  A0 01        noroom:	ldy	#nospms		;point to
00D256  2  D0 0A        	bne	semsg		;and send
00D258  2               ;save can not open error handler
00D258  2  A0 55        noopen:	ldy	#cnnoms		;point to
00D25A  2  D0 06        	bne	semsg		;and send
00D25C  2               ;save write error handler
00D25C  2  A0 62        wrterr:	ldy	#wrerms		;point
00D25E  2  D0 02        	bne	semsg		;to and send
00D260  2               ;save can not close error
00D260  2  A0 0A        cantcl:	ldy	#ntclms		;point to
00D262  2  4C C0 D5     semsg:	jmp	sndmsg		;and send
00D265  2               ;execute era command
00D265  2               ; era <afn>
00D265  2  20 A5 D4     era:	jsr	prslin		;get file name
00D268  2  C9 0B        	cmp	#11		;if not all ?
00D26A  2  D0 13        	bne	nteral		;then skip verify
00D26C  2  A0 18        	ldy	#alflms		;else point to
00D26E  2  20 C0 D5     	jsr	sndmsg		;and send all files
00D271  2  20 EA D3     	jsr	cnsrde		;get an input
00D274  2  48           	pha			;and save
00D275  2  20 E1 D3     	jsr	ccrlf		;do a cr lf
00D278  2  68           	pla			;restore char
00D279  2  29 5F        	and	#$5f		;convert to upper case
00D27B  2  C9 59        	cmp	#'Y'		;if not y
00D27D  2  D0 D1        	bne	extera		;then quit
00D27F  2  20 AB D5     nteral:	jsr	clrslt		;clear auto and select
00D282  2  4C 14 D4     	jmp	dlt1		;delete first
00D285  2               ;execute type command
00D285  2               ; type d:ufn
00D285  2  20 A5 D4     type:	jsr	prslin		;get file
00D288  2  D0 30        	bne	typafn		;error if afn
00D28A  2  20 47 D4     	jsr	casdo1		;clear - select - open file 1
00D28D  2  30 32        	bmi	notype		;error if not found
00D28F  2  20 E1 D3     	jsr	ccrlf		;else do cr lf
00D292  2  20 59 D4     typmre:	jsr	read1		;read record
00D295  2  F0 04        	beq	okread		;if ok continue
00D297  2  10 20        	bpl	exttyp		;exit if just end
00D299  2  30 22        	bmi	typerr		;else error
00D29B  2  A2 00        okread:	ldx	#0		;clear index
00D29D  2  BD 28 01     typlpe:	lda	dflbuf,x	;get char
00D2A0  2  C9 1A        	cmp	#eof		;if eof
00D2A2  2  F0 15        	beq	exttyp		;then exit
00D2A4  2  20 72 D4     	jsr	cotsxy		;else send
00D2A7  2  20 F8 D3     	jsr	chkcst		;if key down
00D2AA  2  D0 08        	bne	exttok		;then exit
00D2AC  2  AE EF D7     	ldx	savx		;else get index
00D2AF  2  E8           	inx			;bump it
00D2B0  2  10 EB        	bpl	typlpe		;and loop if < 128
00D2B2  2  30 DE        	bmi	typmre		;else read more
00D2B4  2  A2 06        exttok:	ldx	#6		;clear console
00D2B6  2  20 03 01     	jsr	pemjmp		;with no echo
00D2B9  2  60           exttyp:	rts
00D2BA  2               ;type syntax error handler
00D2BA  2  4C C9 D0     typafn:	jmp	cmderr		;error return
00D2BD  2               ;type read error handler
00D2BD  2  A0 29        typerr:	ldy	#rderms		;point to
00D2BF  2  D0 02        	bne	temsg		;and send
00D2C1  2               ;type not found error handler
00D2C1  2  A0 34        notype:	ldy	#ntfnms		;point to
00D2C3  2  4C C0 D5     temsg:	jmp	sndmsg		;and send
00D2C6  2               ;execute load command
00D2C6  2               ; load <ufn> (<address>)
00D2C6  2  20 D5 D5     load:	jsr	setddb		;set load start to tea start
00D2C9  2  20 A5 D4     	jsr	prslin		;build fcb
00D2CC  2  D0 EC        	bne	typafn		;error if afn
00D2CE  2  20 E0 D5     	jsr	frssec		;save in second half
00D2D1  2  20 9E D4     	jsr	tmpold		;save file
00D2D4  2  20 05 D6     	jsr	bldnum		;find start address
00D2D7  2  AE C4 D7     	ldx	fcbone+1	;see if number
00D2DA  2  E0 20        	cpx	#' '
00D2DC  2  F0 03        	beq	usedfl		;if none use default
00D2DE  2  20 D9 D5     	jsr	setdb		;and set
00D2E1  2  20 F3 D5     usedfl:	jsr	secfrs		;move name back
00D2E4  2  20 47 D4     	jsr	casdo1		;clear - select - open file 1
00D2E7  2  30 D8        	bmi	notype		;exit if not found
00D2E9  2  AD F3 D7     	lda	dskbuf		;get load start
00D2EC  2  AC F4 D7     	ldy	dskbuf+1
00D2EF  2  20 2F D4     lcmdlp:	jsr	setbuf		;set as disk buffer
00D2F2  2  20 59 D4     	jsr	read1		;read record
00D2F5  2  D0 06        	bne	loadnd		;done if not zero
00D2F7  2  20 B1 E2     	jsr	adjdb		;bump address
00D2FA  2  4C EF D2     	jmp	lcmdlp		;and loop
00D2FD  2  30 BE        loadnd:	bmi	typerr		;if error say so
00D2FF  2  4C A4 D5     	jmp	stdflb		;back to default buffer
00D302  2               ;execute go command
00D302  2               ; go (<address>)
00D302  2  20 05 D6     go:	jsr	bldnum		;get address
00D305  2  AE C4 D7     	ldx	fcbone+1	;get first char
00D308  2  E0 20        	cpx	#' '		;see if nothing
00D30A  2  F0 03        	beq	nolnum		;nothing so use tea
00D30C  2  4C 76 D3     	jmp	godoit		;then execute
00D30F  2  4C 72 D3     nolnum:	jmp	gotea
00D312  2               ;execute trns (transient) command
00D312  2               ; <ufn> (<fn>) (<fn>)
00D312  2  AD C4 D7     trns:	lda	fcbone+1	;get first char
00D315  2  C9 20        	cmp	#' '		;if not space
00D317  2  D0 11        	bne	chktyp		;check type
00D319  2  AD E9 D7     	lda	tmpdsk		;else test temp
00D31C  2  F0 09        	beq	skpdrv		;if none skip
00D31E  2  38           	sec			;else convert
00D31F  2  E9 01        	sbc	#1		;to number
00D321  2  8D E8 D7     	sta	dfldsk		;set default
00D324  2  20 00 D4     	jsr	slctds		;and select
00D327  2  4C B8 D0     skpdrv:	jmp	extwod		;return
00D32A  2  AD CC D7     chktyp:	lda	fcbone+9	;get type
00D32D  2  C9 20        	cmp	#' '		;if space
00D32F  2  F0 03        	beq	typemp		;then ok
00D331  2  4C D9 D3     	jmp	trnerr		;else error
00D334  2  A2 02        typemp:	ldx	#2		;make
00D336  2  BD E4 D7     setcom:	lda	typcom,x	;type
00D339  2  9D CC D7     	sta	fcbone+9,x	;com
00D33C  2  CA           	dex			;then
00D33D  2  10 F7        	bpl	setcom		;continue
00D33F  2  20 47 D4     	jsr	casdo1		;clear - select - open file one
00D342  2  10 03        	bpl	gottrn		;jump if ok
00D344  2  4C D6 D3     	jmp	topner		;else do error
00D347  2  20 D5 D5     gottrn:	jsr	setddb		;set start to tea
00D34A  2  20 2F D4     nxtrcr:	jsr	setbuf		;set address
00D34D  2  20 59 D4     	jsr	read1		;read fcb 1
00D350  2  D0 1E        	bne	endlde		;branch if error or eof
00D352  2  20 B1 E2     	jsr	adjdb		;adjust address up by 128
00D355  2  CD 91 D6     	cmp	ccmvc		;if new low
00D358  2  90 07        	bcc	tryhig		;ok try high
00D35A  2  CC 92 D6     	cpy	ccmvc+1		;else if high
00D35D  2  90 EB        	bcc	nxtrcr		;ok do more
00D35F  2  B0 07        	bcs	chklnd		;else check for end
00D361  2  CC 92 D6     tryhig:	cpy	ccmvc+1		;if high less
00D364  2  90 E4        	bcc	nxtrcr		;then ok
00D366  2  F0 E2        	beq	nxtrcr		;or ok if same
00D368  2  20 A4 D5     chklnd:	jsr	stdflb		;set buffer to default
00D36B  2  20 59 D4     	jsr	read1		;read (should be eof)
00D36E  2  F0 6C        	beq	tlderr		;error if more
00D370  2  30 6A        endlde:	bmi	tlderr		;do error
00D372  2  A9 00        gotea:	lda	#<tea		;set go address to tea start
00D374  2  A0 08        	ldy	#>tea
00D376  2  8D CB D3     godoit:	sta	do+1		;set to ay
00D379  2  8C CC D3     	sty	do+2
00D37C  2  20 34 D4     	jsr	rstddr		;else restore default
00D37F  2  20 A5 D4     	jsr	prslin		;parse file
00D382  2  AD E9 D7     	lda	tmpdsk		;set auto
00D385  2  8D C3 D7     	sta	fcbone		;select position
00D388  2  A2 10        	ldx	#16		;do a second
00D38A  2  20 A7 D4     	jsr	prsmre		;fcb if there
00D38D  2  AD E9 D7     	lda	tmpdsk		;set auto select
00D390  2  8D D3 D7     	sta	fcbone+16	;again
00D393  2  A0 00        	ldy	#0		;clear record
00D395  2  8C E3 D7     	sty	fcbone+32	;counter
00D398  2  A2 20        	ldx	#32		;move
00D39A  2  BD C3 D7     movfcb:	lda	fcbone,x	;all
00D39D  2  9D 07 01     	sta	dflfcb,x	;to
00D3A0  2  CA           	dex			;default
00D3A1  2  10 F7        	bpl	movfcb		;fcb
00D3A3  2  E8           	inx			;set x to zero
00D3A4  2  B9 44 D7     tstbuf:	lda	cnstxt,y	;get char
00D3A7  2  F0 07        	beq	isnull		;if null jump
00D3A9  2  C9 20        	cmp	#' '		;or if space
00D3AB  2  F0 03        	beq	isnull		;jump
00D3AD  2  C8           	iny			;else bump pointer
00D3AE  2  D0 F4        	bne	tstbuf		;and loop
00D3B0  2  A9 00        isnull:	lda	#0		;clear
00D3B2  2  8D 28 01     	sta	dflbuf		;count
00D3B5  2  B9 44 D7     movbuf:	lda	cnstxt,y	;get char
00D3B8  2  9D 29 01     	sta	dflbuf+1,x	;and move
00D3BB  2  F0 07        	beq	fillov		;exit if null
00D3BD  2  E8           	inx			;increment
00D3BE  2  C8           	iny			;counters
00D3BF  2  EE 28 01     	inc	dflbuf		;and length
00D3C2  2  D0 F1        	bne	movbuf		;and loop
00D3C4  2  20 E1 D3     fillov:	jsr	ccrlf		;do a cr lf
00D3C7  2  20 A4 D5     	jsr	stdflb		;set default
00D3CA  2  20 00 08     do:	jsr	tea		;execute
00D3CD  2  AD E8 D7     	lda	dfldsk		;get default
00D3D0  2  20 00 D4     	jsr	slctds		;and set
00D3D3  2  4C 1B D0     	jmp	ccmlpe		;then loop
00D3D6  2               ;trns syntax error handler
00D3D6  2  20 34 D4     topner:	jsr	rstddr		;restore default
00D3D9  2  4C C9 D0     trnerr:	jmp	cmderr		;do error
00D3DC  2               ;trns load error
00D3DC  2  A0 4A        tlderr:	ldy	#lderms		;point to
00D3DE  2  4C C0 D5     	jmp	sndmsg		;and send
00D3E1  2               ;carriage return and linefeed
00D3E1  2  A9 0D        ccrlf:	lda	#cr		;get a cr
00D3E3  2  20 F0 D3     	jsr	chrout		;send
00D3E6  2  A9 0A        	lda	#lf		;get a lf
00D3E8  2  D0 06        	bne	chrout		;and send
00D3EA  2               ;pem entry routines
00D3EA  2  A2 01        cnsrde:	ldx	#1		;console read
00D3EC  2  D0 43        	bne	pemgo
00D3EE  2  A9 20        spcout:	lda	#' '		;output space
00D3F0  2  A2 02        chrout:	ldx	#2		;console output
00D3F2  2  D0 3D        	bne	pemgo
00D3F4  2  A2 0A        rdebuf:	ldx	#10		;buffered input
00D3F6  2  D0 39        	bne	pemgo
00D3F8  2  A2 0B        chkcst:	ldx	#11		;check console
00D3FA  2  D0 35        	bne	pemgo
00D3FC  2  A2 0D        rstdsk:	ldx	#13		;initialize system
00D3FE  2  D0 31        	bne	pemgo
00D400  2  A2 0E        slctds:	ldx	#14		;select drive
00D402  2  D0 2D        	bne	pemgo
00D404  2  A2 0F        openfl:	ldx	#15		;open file
00D406  2  D0 29        	bne	pemgo
00D408  2  A2 10        clsefl:	ldx	#16		;close file
00D40A  2  D0 25        	bne	pemgo
00D40C  2  A2 11        srchfr:	ldx	#17		;first match
00D40E  2  D0 21        	bne	pemgo
00D410  2  A2 12        srchnx:	ldx	#18		;next match
00D412  2  D0 1D        	bne	pemgo
00D414  2               ;delete file one
00D414  2  20 97 D4     dlt1:	jsr	setone		;point to fcb
00D417  2  A2 13        dltfil:	ldx	#19		;delete file
00D419  2  D0 16        	bne	pemgo
00D41B  2  A2 14        rdrcrd:	ldx	#20		;read record
00D41D  2  D0 12        	bne	pemgo
00D41F  2  A2 15        wrrcrd:	ldx	#21		;write record
00D421  2  D0 0E        	bne	pemgo
00D423  2  A2 16        cratfl:	ldx	#22		;create file
00D425  2  D0 0A        	bne	pemgo
00D427  2  A2 17        renmfl:	ldx	#23		;rename file
00D429  2  D0 06        	bne	pemgo
00D42B  2  A2 19        intdsk:	ldx	#25		;read drive num
00D42D  2  D0 02        	bne	pemgo
00D42F  2  A2 1A        setbuf:	ldx	#26		;set buffer add
00D431  2  4C 03 01     pemgo:	jmp	pemjmp		;go to pem
00D434  2               ;restore default drive
00D434  2  AD E9 D7     rstddr:	lda	tmpdsk		;if temp drive
00D437  2  F0 1F        	beq	extddr		;zero then exit
00D439  2  38           	sec			;else
00D43A  2  E9 01        	sbc	#1		;subtract one
00D43C  2  CD E8 D7     	cmp	dfldsk		;compare to default
00D43F  2  F0 17        	beq	extddr		;exit if same
00D441  2  AD E8 D7     seldfl:	lda	dfldsk		;else get default
00D444  2  4C 00 D4     	jmp	slctds		;select
00D447  2               ;clear auto - select disk - open file at fcbone
00D447  2  20 AB D5     casdo1:	jsr	clrslt		;clear auto and select
00D44A  2               ;open file one
00D44A  2               ; returns:n=1 if not found
00D44A  2  A9 00        open1:	lda	#0		;clear
00D44C  2  8D E3 D7     	sta	fcbone+32	;record number
00D44F  2  20 97 D4     	jsr	setone		;point to fcb
00D452  2  20 04 D4     	jsr	openfl		;open it
00D455  2  8D EE D7     	sta	diradd		;save number
00D458  2  60           extddr:	rts
00D459  2               ;read file one
00D459  2  20 97 D4     read1:	jsr	setone		;point to fcb
00D45C  2  4C 1B D4     	jmp	rdrcrd		;do read
00D45F  2               ;search for first file one
00D45F  2               ; returns:n=1 if not found
00D45F  2  20 97 D4     srchf1:	jsr	setone		;point to fcb
00D462  2  20 0C D4     	jsr	srchfr		;search for first
00D465  2  8D EE D7     	sta	diradd		;save number
00D468  2  60           	rts
00D469  2               ;header output
00D469  2  20 E1 D3     hdrout:	jsr	ccrlf		;do cr lf
00D46C  2  20 2B D4     hdr:	jsr	intdsk		;get drive number
00D46F  2  18           	clc			;make
00D470  2  69 41        	adc	#'A'		;a letter
00D472  2               ;output with save of x and y
00D472  2               ;this routine calls the pem resident routine
00D472  2               ;tstchr to see if a char is a printing char.
00D472  2               ;if it is then c=1 upon return from tstchr.
00D472  2  8E EF D7     cotsxy:	stx	savx		;save x
00D475  2  8C F0 D7     	sty	savy		;and y
00D478  2  20 BB E0     	jsr	tstchr		;see if printing
00D47B  2  B0 10        	bcs	isprnt		;jump if is
00D47D  2  48           	pha			;else save
00D47E  2  AD 8A E4     	lda	sysdef+4	;get invert
00D481  2  20 F0 D3     	jsr	chrout		;send it
00D484  2  68           	pla			;get char
00D485  2  09 40        	ora	#'@'		;make printing
00D487  2  20 F0 D3     	jsr	chrout		;send it
00D48A  2  AD 89 E4     	lda	sysdef+3	;get normal
00D48D  2  20 F0 D3     isprnt:	jsr	chrout		;do output
00D490  2  AC F0 D7     	ldy	savy		;get y
00D493  2  AE EF D7     	ldx	savx		;and x
00D496  2  60           	rts
00D497  2               ;set up fcb one pointer
00D497  2  AD 94 D6     setone:	lda	fcb1vc		;low
00D49A  2  AC 95 D6     	ldy	fcb1vc+1	;and high
00D49D  2  60           	rts
00D49E  2               ;save tmpdsk in oldtmp
00D49E  2  AD E9 D7     tmpold:	lda	tmpdsk
00D4A1  2  8D F2 D7     	sta	oldtmp
00D4A4  2  60           	rts
00D4A5  2               ;parse command line
00D4A5  2  A2 00        prslin:	ldx	#0		;clear index
00D4A7  2  8A           prsmre:	txa			;save
00D4A8  2  48           	pha			;index
00D4A9  2  A9 00        	lda	#0		;clear temp
00D4AB  2  8D E9 D7     	sta	tmpdsk		;drive flag
00D4AE  2  AC E7 D7     	ldy	cnbfpt		;get buffer pointer
00D4B1  2  20 72 D5     	jsr	skpspc		;find first non-space
00D4B4  2  8C ED D7     	sty	curpnt		;save index
00D4B7  2  F0 0D        	beq	nulchr		;jump if null
00D4B9  2  29 0F        	and	#%00001111	;else look at 4 lsbs
00D4BB  2  48           	pha			;and save
00D4BC  2  C8           	iny			;point to next char
00D4BD  2  B9 44 D7     	lda	cnstxt,y	;and get it
00D4C0  2  C9 3A        	cmp	#':'		;if a colon
00D4C2  2  F0 0A        	beq	drvinp		;jump and set drive
00D4C4  2  68           	pla			;else clear stack
00D4C5  2  88           	dey			;backup index
00D4C6  2  AD E8 D7     nulchr:	lda	dfldsk		;set automatic
00D4C9  2  9D C3 D7     	sta	fcbone,x	;to default
00D4CC  2  10 08        	bpl	trynme		;then parse name
00D4CE  2  68           drvinp:	pla			;get number
00D4CF  2  8D E9 D7     	sta	tmpdsk		;set temp flag
00D4D2  2  9D C3 D7     	sta	fcbone,x	;and fcb
00D4D5  2  C8           	iny			;point past colon
00D4D6  2  A9 08        trynme:	lda	#8		;set name count
00D4D8  2  8D EC D7     	sta	ccmcount		;to eight
00D4DB  2  20 7F D5     tstnme:	jsr	tstlgl		;test for illegal
00D4DE  2  F0 1D        	beq	flnmsp		;if illegal jump
00D4E0  2  E8           	inx			;bump pointer
00D4E1  2  C9 2A        	cmp	#'*'		;if not *
00D4E3  2  D0 07        	bne	notafn		;skip ? fill
00D4E5  2  A9 3F        	lda	#'?'		;get a ?
00D4E7  2  9D C3 D7     	sta	fcbone,x	;store
00D4EA  2  D0 04        	bne	nxtout		;and jump
00D4EC  2  9D C3 D7     notafn:	sta	fcbone,x	;store char
00D4EF  2  C8           	iny			;bump source
00D4F0  2  CE EC D7     nxtout:	dec	ccmcount		;drop counter down
00D4F3  2  D0 E6        	bne	tstnme		;and loop
00D4F5  2  20 7F D5     skpmre:	jsr	tstlgl		;if illegal
00D4F8  2  F0 11        	beq	trytyp		;try type
00D4FA  2  C8           	iny			;else bump index
00D4FB  2  D0 F8        	bne	skpmre		;and loop
00D4FD  2  E8           flnmsp:	inx			;next position
00D4FE  2  A9 20        	lda	#' '		;get a space
00D500  2  9D C3 D7     	sta	fcbone,x	;store
00D503  2  CE EC D7     	dec	ccmcount		;count down
00D506  2  D0 F5        	bne	flnmsp		;and loop
00D508  2  B9 44 D7     	lda	cnstxt,y	;get char again
00D50B  2  48           trytyp:	pha			;save char
00D50C  2  A9 03        	lda	#3		;set count
00D50E  2  8D EC D7     	sta	ccmcount		;to three
00D511  2  68           	pla			;get char
00D512  2  C9 2E        	cmp	#'.'		;if not .
00D514  2  D0 23        	bne	fltysp		;then fill spaces
00D516  2  C8           	iny			;else bump source
00D517  2  20 7F D5     tsttyp:	jsr	tstlgl		;if not legal
00D51A  2  F0 1D        	beq	fltysp		;then fill spaces
00D51C  2  E8           	inx			;else bump index
00D51D  2  C9 2A        	cmp	#'*'		;if not *
00D51F  2  D0 07        	bne	notaft		;then skip fill
00D521  2  A9 3F        	lda	#'?'		;else get ?
00D523  2  9D C3 D7     	sta	fcbone,x	;move to fcb
00D526  2  D0 04        	bne	mrtyfl		;and loop
00D528  2  9D C3 D7     notaft:	sta	fcbone,x	;move char to fcb
00D52B  2  C8           	iny			;bump source
00D52C  2  CE EC D7     mrtyfl:	dec	ccmcount		;count down
00D52F  2  D0 E6        	bne	tsttyp		;and loop
00D531  2  20 7F D5     nttype:	jsr	tstlgl		;if illegal
00D534  2  F0 0E        	beq	filnul		;fill out nulls
00D536  2  C8           	iny			;else bump source
00D537  2  D0 F8        	bne	nttype		;and loop
00D539  2  E8           fltysp:	inx			;bump fcb pointer
00D53A  2  A9 20        	lda	#' '		;get space
00D53C  2  9D C3 D7     	sta	fcbone,x	;put in fcb
00D53F  2  CE EC D7     	dec	ccmcount		;count down
00D542  2  D0 F5        	bne	fltysp		;and continue
00D544  2  A9 03        filnul:	lda	#3		;clear
00D546  2  8D EC D7     	sta	ccmcount		;three
00D549  2  E8           mrnlty:	inx			;bump fcb pointer
00D54A  2  A9 00        	lda	#0		;get a zero
00D54C  2  9D C3 D7     	sta	fcbone,x	;move to fcb
00D54F  2  CE EC D7     	dec	ccmcount		;count down
00D552  2  D0 F5        	bne	mrnlty		;loop until done
00D554  2  8C E7 D7     	sty	cnbfpt		;update start pointer
00D557  2  A9 00        	lda	#0		;clear
00D559  2  8D EC D7     	sta	ccmcount		;count
00D55C  2  68           	pla			;restore stack
00D55D  2  A8           	tay			;move to index
00D55E  2  A2 0B        	ldx	#11		;counter to 11
00D560  2  C8           tstqus:	iny			;point to
00D561  2  B9 C3 D7     	lda	fcbone,y	;and get char
00D564  2  C9 3F        	cmp	#'?'		;if not a ?
00D566  2  D0 03        	bne	nxtqus		;then jump
00D568  2  EE EC D7     	inc	ccmcount		;else bump count
00D56B  2  CA           nxtqus:	dex			;loop until
00D56C  2  D0 F2        	bne	tstqus		;11 tested
00D56E  2  AD EC D7     	lda	ccmcount		;get count
00D571  2  60           	rts			;and return
00D572  2               ;skip space
00D572  2  B9 44 D7     skpspc:	lda	cnstxt,y	;get char
00D575  2  F0 07        	beq	extskp		;jump if null
00D577  2  C9 20        	cmp	#' '		;if not space
00D579  2  D0 03        	bne	extskp		;then exit
00D57B  2  C8           	iny			;else go to next
00D57C  2  D0 F4        	bne	skpspc		;and test
00D57E  2  60           extskp:	rts
00D57F  2               ;test legal
00D57F  2  B9 44 D7     tstlgl:	lda	cnstxt,y	;get char
00D582  2  F0 1C        	beq	extlgl
00D584  2  C9 20        	cmp	#' '		;if space
00D586  2  90 19        	bcc	badinp		;ok - less is error
00D588  2  F0 16        	beq	extlgl
00D58A  2  C9 3D        	cmp	#'='
00D58C  2  F0 12        	beq	extlgl
00D58E  2  C9 2E        	cmp	#'.'
00D590  2  F0 0E        	beq	extlgl
00D592  2  C9 3A        	cmp	#':'
00D594  2  F0 0A        	beq	extlgl
00D596  2  C9 3B        	cmp	#semico
00D598  2  F0 06        	beq	extlgl
00D59A  2  C9 3C        	cmp	#'<'
00D59C  2  F0 02        	beq	extlgl
00D59E  2  C9 3E        	cmp	#'>'
00D5A0  2  60           extlgl:	rts
00D5A1  2  4C C9 D0     badinp:	jmp	cmderr
00D5A4  2               ;set default buffer address
00D5A4  2  A9 28        stdflb:	lda	#<dflbuf 	;point to
00D5A6  2  A0 01        	ldy	#>dflbuf	;location
00D5A8  2  4C 2F D4     	jmp	setbuf		;and set
00D5AB  2               ;clear automatic and select
00D5AB  2  A9 00        clrslt:	lda	#0		;clear auto
00D5AD  2  8D C3 D7     	sta	fcbone		;select
00D5B0  2  AD E9 D7     slttmp:	lda	tmpdsk		;get temp
00D5B3  2  F0 1F        	beq	extsnd		;if zero exit
00D5B5  2  38           	sec			;else subtract
00D5B6  2  E9 01        	sbc	#1		;one
00D5B8  2  CD E8 D7     	cmp	dfldsk		;if same as default
00D5BB  2  F0 17        	beq	extsnd		;then quit
00D5BD  2  4C 00 D4     	jmp	slctds		;else set
00D5C0  2               ;send message
00D5C0  2  8C F0 D7     sndmsg:	sty	savy		;save index
00D5C3  2  20 E1 D3     	jsr	ccrlf		;do cr and lf
00D5C6  2  AC F0 D7     	ldy	savy		;get index
00D5C9  2  B9 AF D6     lpesnd:	lda	msgtbl,y	;get char
00D5CC  2  F0 06        	beq	extsnd		;if null quit
00D5CE  2  20 72 D4     	jsr	cotsxy		;else send
00D5D1  2  C8           	iny			;point to next
00D5D2  2  D0 F5        	bne	lpesnd		;and loop
00D5D4  2  60           extsnd:	rts
00D5D5  2               ;set load start address
00D5D5  2  A9 00        setddb:	lda	#<tea		;to tea start
00D5D7  2  A0 08        	ldy	#>tea
00D5D9  2  8D F3 D7     setdb:	sta	dskbuf		;to ay
00D5DC  2  8C F4 D7     	sty	dskbuf+1
00D5DF  2  60           	rts
00D5E0  2               ;move first part of fcb to second half
00D5E0  2               ;and move second part to first part.
00D5E0  2               ;only ren depends upon this routine to actually
00D5E0  2               ;swap fcb halves.
00D5E0  2               ;alters:a,x,p
00D5E0  2               ;returns:x=$ff
00D5E0  2  A2 0F        frssec:	ldx	#15		;set index to last
00D5E2  2  BD C3 D7     frsclp:	lda	fcbone,x	;get byte
00D5E5  2  BC D3 D7     	ldy	fcbone+16,x
00D5E8  2  9D D3 D7     	sta	fcbone+16,x	;move it
00D5EB  2  98           	tya
00D5EC  2  9D C3 D7     	sta	fcbone,x
00D5EF  2  CA           	dex
00D5F0  2  10 F0        	bpl	frsclp		;until 16 moved
00D5F2  2  60           	rts
00D5F3  2               ;move second part of fcb to first half
00D5F3  2               ;restore tmpdsk from save location
00D5F3  2               ;alters:a,x,p
00D5F3  2               ;returns:x=$ff
00D5F3  2  A2 0F        secfrs:	ldx	#15		;set index to last
00D5F5  2  BD D3 D7     scfrlp:	lda	fcbone+16,x	;get byte
00D5F8  2  9D C3 D7     	sta	fcbone,x	;move it
00D5FB  2  CA           	dex
00D5FC  2  10 F7        	bpl	scfrlp		;loop until done
00D5FE  2  AD F2 D7     	lda	oldtmp		;get old flag
00D601  2  8D E9 D7     	sta	tmpdsk		;and set
00D604  2  60           	rts
00D605  2               ;build a number from command line and leave in num
00D605  2               ;will handle either decimal (e.g., 578) or hexadecimal (e.g., $3f2)
00D605  2               ;move parse index past number
00D605  2               ;modifies:all
00D605  2               ;returns:a,y set to low and high of number
00D605  2               ;	 flags set according to y which is high part of number
00D605  2  A9 09        bldnum:	lda	#9		;preset to decimal
00D607  2  8D F7 D7     	sta	moduls
00D60A  2  20 A5 D4     	jsr	prslin		;put in fcb
00D60D  2  AD E9 D7     	lda	tmpdsk		;if temp
00D610  2  D0 67        	bne	numerr		;is error
00D612  2  8D F8 D7     	sta	num		;else clear num
00D615  2  8D F9 D7     	sta	num+1
00D618  2  A8           	tay			;and index
00D619  2  B9 C4 D7     	lda	fcbone+1,y	;get first char
00D61C  2  C9 24        	cmp	#'$'		;see if hex signal
00D61E  2  D0 06        	bne	bnumlp		;skip if not
00D620  2  A9 0F        	lda	#15		;set for modulus
00D622  2  8D F7 D7     	sta	moduls
00D625  2  C8           	iny			;bump past $
00D626  2  C8           bnumlp:	iny			;next char
00D627  2  B9 C3 D7     	lda	fcbone,y	;get digit
00D62A  2  C9 20        	cmp	#' '		;see if space
00D62C  2  F0 4E        	beq	endnlp		;done if is
00D62E  2  20 9B E2     	jsr	tstdec		;see if decimal
00D631  2  90 0E        	bcc	usedig		;use if is
00D633  2  20 A5 E2     	jsr	tsthex		;see if hex
00D636  2  B0 41        	bcs	numerr		;error if not
00D638  2  E9 06        	sbc	#6		;remove offset
00D63A  2  A2 0F        	ldx	#15		;test for hex modulus
00D63C  2  EC F7 D7     	cpx	moduls
00D63F  2  D0 38        	bne	numerr		;error if not
00D641  2  29 0F        usedig:	and	#%00001111	;eliminate ascii bias
00D643  2  48           	pha			;save result
00D644  2  AD F8 D7     	lda	num		;move number to temp
00D647  2  8D FA D7     	sta	tnum
00D64A  2  AD F9 D7     	lda	num+1
00D64D  2  8D FB D7     	sta	tnum+1
00D650  2  AE F7 D7     	ldx	moduls		;get modulus
00D653  2  18           	clc
00D654  2  AD F8 D7     addlpe:	lda	num		;add number to itself
00D657  2  6D FA D7     	adc	tnum
00D65A  2  8D F8 D7     	sta	num
00D65D  2  AD F9 D7     	lda	num+1		;modulus times
00D660  2  6D FB D7     	adc	tnum+1
00D663  2  8D F9 D7     	sta	num+1
00D666  2  B0 11        	bcs	numerr		;error if carry out
00D668  2  CA           	dex
00D669  2  D0 E9        	bne	addlpe		;loop if more
00D66B  2  68           	pla			;get input back
00D66C  2  6D F8 D7     	adc	num		;add in
00D66F  2  8D F8 D7     	sta	num
00D672  2  90 B2        	bcc	bnumlp		;loop if no carry
00D674  2  EE F9 D7     	inc	num+1		;else bump high
00D677  2  D0 AD        	bne	bnumlp		;and loop for more
00D679  2               ;error in bldnum - handle and quit
00D679  2  4C C9 D0     numerr:	jmp	cmderr		;do general error
00D67C  2               ;end of use of name part - check type
00D67C  2  AD CC D7     endnlp:	lda	fcbone+9	;get first
00D67F  2  C9 20        	cmp	#' '		;see if space
00D681  2  D0 F6        	bne	numerr		;error if not
00D683  2  AD F8 D7     	lda	num		;return with result
00D686  2  AC F9 D7     	ldy	num+1
00D689  2  60           	rts
00D68A  2               ;relocatable vectors
00D68A  2  4C           	.byte	$4c
00D68B  2  42 D7        cnsbvc:	.word	cnsbuf
00D68D  2  4C           	.byte	$4c
00D68E  2  B4 D0        extcvc:	.word	extcmd-1
00D690  2  4C           	.byte	$4c
00D691  2  03 D0        ccmvc:	.word	ccm
00D693  2  4C           	.byte	$4c
00D694  2  C3 D7        fcb1vc:	.word	fcbone
00D696  2               ;function entry vector
00D696  2  4C E6 D0     xqfntb:	jmp	dir
00D699  2  4C C8 D1     	jmp	save
00D69C  2  4C 65 D2     	jmp	era
00D69F  2  4C 85 D2     	jmp	type
00D6A2  2  4C 64 D1     	jmp	ren
00D6A5  2  4C 02 D3     	jmp	go
00D6A8  2  4C C6 D2     	jmp	load
00D6AB  2  4C 12 D3     	jmp	trns
00D6AE  2               ;terminator for relocation
00D6AE  2  FF           	.byte	$ff
00D6AF  2               ;messages
00D6AF  2               msgtbl:
00D6AF  2  00           	.byte 0
00D6B0  2               nospms	=	*-msgtbl
00D6B0  2  4E 4F 20 53  	.byte	"NO SPACE",0
00D6B4  2  50 41 43 45  
00D6B8  2  00           
00D6B9  2               ntclms	=	*-msgtbl
00D6B9  2  43 41 4E 20  	.byte "CAN NOT CLOSE",0
00D6BD  2  4E 4F 54 20  
00D6C1  2  43 4C 4F 53  
00D6C7  2               alflms	=	*-msgtbl
00D6C7  2  41 4C 4C 20  	.byte "ALL FILES (Y/N)?",0
00D6CB  2  46 49 4C 45  
00D6CF  2  53 20 28 59  
00D6D8  2               rderms	=	*-msgtbl
00D6D8  2  52 45 41 44  	.byte	"READ ERROR",0
00D6DC  2  20 45 52 52  
00D6E0  2  4F 52 00     
00D6E3  2               ntfnms	=	*-msgtbl
00D6E3  2  4E 4F 54 20  	.byte	"NOT FOUND",0
00D6E7  2  46 4F 55 4E  
00D6EB  2  44 00        
00D6ED  2               flexms	=	*-msgtbl
00D6ED  2  46 49 4C 45  	.byte "FILE EXISTS",0
00D6F1  2  20 45 58 49  
00D6F5  2  53 54 53 00  
00D6F9  2               lderms	=	*-msgtbl
00D6F9  2  4C 4F 41 44  	.byte "LOAD ERROR",0
00D6FD  2  20 45 52 52  
00D701  2  4F 52 00     
00D704  2               cnnoms	=	*-msgtbl
00D704  2  43 41 4E 20  	.byte "CAN NOT OPEN",0
00D708  2  4E 4F 54 20  
00D70C  2  4F 50 45 4E  
00D711  2               wrerms	=	*-msgtbl
00D711  2  57 52 49 54  	.byte "WRITE ERROR",0
00D715  2  45 20 45 52  
00D719  2  52 4F 52 00  
00D71D  2               ;function name table
00D71D  2  44 49 52 20  fnctbl:	.byte	"DIR ",0
00D721  2  00           
00D722  2  53 41 56 45  	.byte	"SAVE ",0
00D726  2  20 00        
00D728  2  45 52 41 20  	.byte	"ERA ",0
00D72C  2  00           
00D72D  2  54 59 50 45  	.byte	"TYPE ",0
00D731  2  20 00        
00D733  2  52 45 4E 20  	.byte	"REN ",0
00D737  2  00           
00D738  2  47 4F 20 00  	.byte	"GO ",0
00D73C  2  4C 4F 41 44  	.byte	"LOAD ",0
00D740  2  20 00        
00D742  2               ;input buffer
00D742  2               cnsbuf:
00D742  2  7F           cnsmax: .byte 127
00D743  2  00           cnslng: .byte 0
00D744  2               cnstxt:
00D744  2  xx xx xx xx  	.res 127
00D748  2  xx xx xx xx  
00D74C  2  xx xx xx xx  
00D7C3  2               ;fcb one
00D7C3  2               fcbone:
00D7C3  2  xx xx xx xx  	.res 33
00D7C7  2  xx xx xx xx  
00D7CB  2  xx xx xx xx  
00D7E4  2               ;com type field
00D7E4  2  43 4F 36     typcom:	.byte	"CO6"
00D7E7  2               ;variable storage
00D7E7  2  00           cnbfpt:	.byte	0		;buffer index
00D7E8  2  00           dfldsk:	.byte	0		;default drive
00D7E9  2  00           tmpdsk:	.byte	0		;temporary dvive
00D7EA  2               ;align vector on word boundary
00D7EA  2               	.align 2
00D7EA  2  00 00        vector:	.word	0		;execution vector
00D7EC  2  00           ccmcount:	.byte	0		;counter
00D7ED  2  00           curpnt:	.byte	0		;input parse start
00D7EE  2  00           diradd:	.byte	0		;directory number
00D7EF  2  00           savx:	.byte	0		;save x location
00D7F0  2  00           savy:	.byte	0		;save y location
00D7F1  2  00           length:	.byte	0		;number tages to save
00D7F2  2  00           oldtmp:	.byte	0		;temp drive in ren
00D7F3  2  00 08        dskbuf:	.word	tea		;disk buffer start
00D7F5  2  00           across:	.byte	0		;dir count on line
00D7F6  2  00           sixten:	.byte	0		;line length div 16
00D7F7  2  09           moduls:	.byte	9		;modulus-1 for number input
00D7F8  2  00 00        num:	.word	0		;input number
00D7FA  2  00 00        tnum:	.word	0		;temp in bldnum
00D7FC  2  00 08        sadr:	.word	tea		;save start address
00D7FE  2               
00D7FE  1               		.include "pemnhy.asm"
00D7FE  2               ;________________________________________________________________________________________________________________________________
00D7FE  2               ;
00D7FE  2               ;	Nhyodyne dos/65 primitive execution module (pem)
00D7FE  2               ;
00D7FE  2               ;  DWERNER 02/19/2022   Strip off Most significant bit of file name in dir to
00D7FE  2               ;			make filesystem compatible with ROMWBW
00D7FE  2               ;________________________________________________________________________________________________________________________________
00D7FE  2               
00D7FE  2               ;zero page data storage
00D7FE  2               addinp	=	$02		;initialized to a,y
00D7FE  2               bufadd	=	$04		;buffer address
00D7FE  2               alcpnt	=	$06		;allocation map pointer
00D7FE  2               chkpnt	=	$08		;checksum map pointer
00D7FE  2               numvar	=	8		;eight bytes
00D7FE  2               ;main program
00D7FE  2               ; input:x=command,a=value,a&y=address
00D7FE  2               ; returns:a=value,a&y=address
00D7FE  2               ; alters:all
00D7FE  2               pem:
00D7FE  2  D8           	cld			;set binary mode
00D7FF  2  8D 92 E3     	sta	bytinp		;save input
00D802  2  8D D6 E3     	sta	lowin		;value and
00D805  2  8C 93 E3     	sty	bytinp+1	;save high
00D808  2  8C D7 E3     	sty	lowin+1		;address
00D80B  2  8E 94 E3     	stx	cmdinp		;and command
00D80E  2  E0 24        	cpx	#numcmd		;if invalid
00D810  2  B0 50        	bcs	extpem		;then exit
00D812  2  BD 4E E3     	lda	swctbl,x	;if flag zero
00D815  2  F0 08        	beq	noswin		;skip switch
00D817  2  A9 FF        	lda	#255		;else set
00D819  2  8D 91 E3     	sta	swcflg		;memory switch flag
00D81C  2  20 E9 DA     	jsr	switch		;move data to page zero
00D81F  2  A9 00        noswin:	lda	#0		;clear drive
00D821  2  8D 99 E3     	sta	tmpdrv		;switch flag
00D824  2  AD 94 E3     	lda	cmdinp		;get command
00D827  2  0A           	asl	a		;multiply by two
00D828  2  6D 94 E3     	adc	cmdinp		;then add to get x3
00D82B  2  AA           	tax			;and make a pointer
00D82C  2  E8           	inx			;bump to pass jmp
00D82D  2  BD 76 D8     	lda	cmdtbl,x	;get command
00D830  2  BC 77 D8     	ldy	cmdtbl+1,x	;address
00D833  2  8D 9A E3     	sta	xqtvec		;and put
00D836  2  8C 9B E3     	sty	xqtvec+1	;in vector
00D839  2  AD DE E2     	lda	extevc+1	;get return
00D83C  2  48           	pha			;address
00D83D  2  AD DD E2     	lda	extevc		;and push
00D840  2  48           	pha			;as return
00D841  2  AD 92 E3     	lda	bytinp		;get input value
00D844  2  AC 93 E3     	ldy	bytinp+1
00D847  2  6C 9A E3     	jmp	(xqtvec)	;then execute
00D84A  2  8D 95 E3     extexq:	sta	bytout		;save value
00D84D  2  8C 96 E3     	sty	addout+1	;and address
00D850  2  AD 99 E3     	lda	tmpdrv		;get temp drive
00D853  2  F0 0D        	beq	extpem		;if zero skip switch
00D855  2  A0 00        	ldy	#0		;else
00D857  2  91 02        	sta	(addinp),y	;put back in fcb
00D859  2  AD A3 E3     	lda	olddrv		;get old drive number
00D85C  2  8D 92 E3     	sta	bytinp		;set input value
00D85F  2  20 04 DB     	jsr	chgdrv		;then switch back
00D862  2  2C 91 E3     extpem:	bit	swcflg		;test memory switch
00D865  2  10 08        	bpl	noswot		;if not set skip
00D867  2  20 E9 DA     	jsr	switch		;else do memory switch
00D86A  2  A9 00        	lda	#0		;clear
00D86C  2  8D 91 E3     	sta	swcflg		;flag
00D86F  2  AC 96 E3     noswot:	ldy	addout+1	;get address
00D872  2  AD 95 E3     	lda	bytout		;and value (address low)
00D875  2  60           	rts
00D876  2               ;command vector table
00D876  2  4C EA D8     cmdtbl:	jmp	xwboot		;warm boot
00D879  2  4C DB DA     	jmp	xcnsin		;console input with echo
00D87C  2  4C 13 E1     	jmp	sndchr		;console output
00D87F  2  4C 65 E4     	jmp	sim+21		;tape reader
00D882  2  4C 62 E4     	jmp	sim+18		;tape punch
00D885  2  4C 5F E4     	jmp	sim+15		;printer output
00D888  2  4C 85 E0     	jmp	getcon		;console input w/o echo
00D88B  2  4C 1F D9     	jmp	xgtios		;read i/o status
00D88E  2  4C 2A D9     	jmp	xstios		;set i/o status
00D891  2  4C CA E0     	jmp	sndstr		;print buffer
00D894  2  4C 7F E1     	jmp	bufinp		;read buffer
00D897  2  4C 95 E0     	jmp	kbdsts		;test console ready
00D89A  2  4C 7D E4     	jmp	sim+45		;read list status
00D89D  2  4C 32 DB     	jmp	xintds		;initialize system
00D8A0  2  4C 04 DB     	jmp	chgdrv		;log in drive
00D8A3  2  4C AF DD     	jmp	xopen		;open file
00D8A6  2  4C EA DD     	jmp	xclose		;close file
00D8A9  2  4C 0E DE     	jmp	xfndfr		;find first match
00D8AC  2  4C 3A D9     	jmp	xfndnx		;find next match
00D8AF  2  4C A2 D9     	jmp	xdltfl		;delete file
00D8B2  2  4C 42 D9     	jmp	xread		;read record
00D8B5  2  4C C7 D9     	jmp	xwrite		;write record
00D8B8  2  4C B1 DE     	jmp	xmake		;create file
00D8BB  2  4C 80 D9     	jmp	xrenme		;rename file
00D8BE  2  4C 32 D9     	jmp	xintlg		;interrogate log in status
00D8C1  2  4C 2E D9     	jmp	xintdr		;interrogate current drive
00D8C4  2  4C F9 DA     	jmp	chgdma		;set buffer address
00D8C7  2  4C 23 D9     	jmp	xrdalv		;read allocation map start
00D8CA  2  4C 6D DD     	jmp	setron		;set r/w status
00D8CD  2  4C 36 D9     	jmp	xrdros		;read r/w status
00D8D0  2  4C E2 D8     	jmp	setlst		;set list echo status
00D8D3  2  4C E6 D8     	jmp	lststs		;read list echo status
00D8D6  2  4C FA D8     	jmp	xrtclo		;read low clock
00D8D9  2  4C 0E D9     	jmp	xrtchi		;read high clock
00D8DC  2  4C 18 D9     	jmp	xrddcb		;read dcb address
00D8DF  2  4C 83 E4     	jmp	sim+51		;translate sector
00D8E2  2               ;set list echo status
00D8E2  2  8D 8F E3     setlst:	sta	lstflg		;set flag
00D8E5  2  60           	rts
00D8E6  2               ;read list echo status
00D8E6  2  AD 8F E3     lststs:	lda	lstflg		;read flag
00D8E9  2  60           	rts
00D8EA  2               ;execute warm boot
00D8EA  2               ; ***this command does not return to pem***
00D8EA  2               ; ***instead it jumps to sim, resets	***
00D8EA  2               ; ***system and stack and jumps to ccm. ***
00D8EA  2  2C 91 E3     xwboot:	bit	swcflg		;test memory switch flag
00D8ED  2  10 08        	bpl	dowmbt		;if clear do not
00D8EF  2  20 E9 DA     	jsr	switch		;switch memory
00D8F2  2  A9 00        	lda	#0		;clear
00D8F4  2  8D 91 E3     	sta	swcflg		;flag
00D8F7  2  4C 53 E4     dowmbt:	jmp	sim+3		;go to sim
00D8FA  2               
00D8FA  2               ;execute read real time clock
00D8FA  2  20 80 E4     xrtclo:	jsr	sim+48		;read clock
00D8FD  2               
00D8FD  2  8D BF E3     	sta	rtclk		;save low
00D900  2  8C C0 E3     	sty	rtclk+1		;middle
00D903  2  8E C1 E3     	stx	rtclk+2		;high
00D906  2  8A           	txa
00D907  2  29 80        	and	#%10000000	;test for valid
00D909  2  A8           	tay
00D90A  2  AD BF E3     	lda	rtclk		;get low
00D90D  2  60           	rts
00D90E  2               ;execute read real time clock high
00D90E  2  AD C1 E3     xrtchi:	lda	rtclk+2		;get high
00D911  2  29 7F        	and	#%01111111	;clear status
00D913  2  A8           	tay
00D914  2  AD C0 E3     	lda	rtclk+1		;get middle
00D917  2  60           	rts
00D918  2               ;execute read dcb address
00D918  2  AD 6C DB     xrddcb:	lda	cptdcb+1	;get address
00D91B  2  AC 6D DB     	ldy	cptdcb+2
00D91E  2  60           	rts
00D91F  2               ;execute read i/o status
00D91F  2  AD 06 01     xgtios:	lda	iostat		;get status byte
00D922  2  60           	rts
00D923  2               ;execute read allocation map starting address
00D923  2  AD CE E3     xrdalv:	lda	alcmap		;get
00D926  2  AC CF E3     	ldy	alcmap+1	;starting address
00D929  2  60           	rts			;then return
00D92A  2               ;execute set i/o status
00D92A  2  8D 06 01     xstios:	sta	iostat		;set status
00D92D  2  60           	rts
00D92E  2               ;execute interrogate current drive
00D92E  2  AD A4 E3     xintdr:	lda	curdrv		;get number
00D931  2  60           	rts
00D932  2               ;execute read log in status
00D932  2  AD A5 E3     xintlg:	lda	lginvc		;get status
00D935  2  60           	rts
00D936  2               ;execute read read/write status
00D936  2  AD A6 E3     xrdros:	lda	ronlst		;get status
00D939  2  60           	rts
00D93A  2               ;execute find next match
00D93A  2  20 12 DB     xfndnx:	jsr	autodr		;auto drive select
00D93D  2  A9 0D        	lda	#13		;match including
00D93F  2  4C 1B DE     	jmp	search		;extent
00D942  2               ;execute read next record
00D942  2  20 12 DB     xread:	jsr	autodr		;auto drive select
00D945  2  20 8F DD     	jsr	inrcct		;initialize record counters
00D948  2  AD AF E3     	lda	nxtrec		;if next record less
00D94B  2  CD B0 E3     	cmp	numrec		;then number records
00D94E  2  90 13        	bcc	tryrde		;then try to read
00D950  2  C9 80        	cmp	#128		;but if not and
00D952  2  F0 03        	beq	tryext		;is max try to extend
00D954  2  A9 01        rdeeof:	lda	#1		;else set eof
00D956  2  60           	rts			;code and return
00D957  2  A2 01        tryext:	ldx	#1		;try for a read
00D959  2  20 ED DE     	jsr	extend		;file extension
00D95C  2  C9 00        	cmp	#0		;if not ok exit eof
00D95E  2  D0 F4        	bne	rdeeof		;with jump back
00D960  2  8D AF E3     	sta	nxtrec		;clear next record
00D963  2  20 7E DF     tryrde:	jsr	getblk		;and get block
00D966  2  AD AA E3     	lda	blknum		;if block not zero
00D969  2  0D AB E3     	ora	blknum+1
00D96C  2  D0 03        	bne	dorde		;do the read
00D96E  2  A9 02        	lda	#2		;else set unwritten
00D970  2  60           	rts			;code and exit
00D971  2  20 60 DE     dorde:	jsr	calrcn		;calculate record number
00D974  2  20 AC DC     	jsr	sttrsc		;set track and sector
00D977  2  20 37 E0     	jsr	rdesec		;do sector read
00D97A  2  20 9E DD     	jsr	updtrc		;update counters
00D97D  2  A9 00        	lda	#0		;return w/o error
00D97F  2  60           extrde:	rts
00D980  2               ;execute file rename
00D980  2  20 12 DB     xrenme:	jsr	autodr		;automatic drive select
00D983  2  20 14 E0     	jsr	tstron		;test for r/o
00D986  2  A9 0C        	lda	#12		;match name
00D988  2  20 13 DE     	jsr	frstsr		;and type
00D98B  2  30 14        	bmi	extren		;exit if not found
00D98D  2  A9 00        doren:	lda	#0		;clear drive select
00D98F  2  A0 10        	ldy	#16		;in new name
00D991  2  91 02        	sta	(addinp),y	;part of fcb
00D993  2  A9 0C        	lda	#12		;then move
00D995  2  A2 10        	ldx	#16		;new name
00D997  2  20 80 DE     	jsr	dirchg		;to directory
00D99A  2  A9 0C        	lda	#12		;see if
00D99C  2  20 1B DE     	jsr	search		;another match
00D99F  2  10 EC        	bpl	doren		;loop if found
00D9A1  2  60           extren:	rts			;number
00D9A2  2               ;execute delete file
00D9A2  2  20 12 DB     xdltfl:	jsr	autodr		;automatic drive select
00D9A5  2  20 14 E0     	jsr	tstron		;test for r/o
00D9A8  2  A9 0C        	lda	#12		;match name
00D9AA  2  20 13 DE     	jsr	frstsr		;and type
00D9AD  2  30 17        	bmi	extdlt		;done if not found
00D9AF  2  A2 00        dodlt:	ldx	#0		;else do a
00D9B1  2  20 E4 DF     	jsr	mapdir		;delete
00D9B4  2  AC A9 E3     	ldy	subrec		;then change
00D9B7  2  AD 4D E3     	lda	empty		;byte zero to
00D9BA  2  91 04        	sta	(bufadd),y	;empty code
00D9BC  2  20 3D E0     	jsr	updtck		;then update directory
00D9BF  2  A9 0C        	lda	#12		;search
00D9C1  2  20 1B DE     	jsr	search		;for next
00D9C4  2  10 E9        	bpl	dodlt		;loop if found
00D9C6  2  60           extdlt:	rts			;exit
00D9C7  2               ;execute write next record
00D9C7  2  20 12 DB     xwrite:	jsr	autodr		;automatic drive select
00D9CA  2  20 14 E0     	jsr	tstron		;test for r/o
00D9CD  2  20 8F DD     	jsr	inrcct		;initialize counters
00D9D0  2  AD AF E3     	lda	nxtrec		;get next record
00D9D3  2  C9 80        	cmp	#128		;compare to max
00D9D5  2  90 03        	bcc	ntexte		;continue if less
00D9D7  2  A9 01        	lda	#1		;else flag as extend
00D9D9  2  60           	rts			;error and exit
00D9DA  2  20 7E DF     ntexte:	jsr	getblk		;calculate block num
00D9DD  2  A9 00        	lda	#0		;say normal write
00D9DF  2  8D D3 E3     	sta	pemwrtype		;for now
00D9E2  2  AD AA E3     	lda	blknum		;get it and if
00D9E5  2  0D AB E3     	ora	blknum+1
00D9E8  2  F0 03        	beq	*+5		;zero then get number
00D9EA  2  4C AA DA     	jmp	blkopn		;else go write
00D9ED  2  A9 02        	lda	#2		;say unalloc write
00D9EF  2  8D D3 E3     	sta	pemwrtype
00D9F2  2  AD 8B E3     	lda	fcbind		;get index from prior
00D9F5  2  48           	pha			;and save
00D9F6  2  C9 10        	cmp	#16		;if first block
00D9F8  2  F0 1A        	beq	isfrst		;then don't change
00D9FA  2  A8           	tay			;else make an index
00D9FB  2  88           	dey			;point to last
00D9FC  2  2C BA E3     	bit	blmode		;test mode
00D9FF  2  10 01        	bpl	*+3		;done if byte
00DA01  2  88           	dey			;else drop for word
00DA02  2  B1 02        	lda	(addinp),y	;and get that number
00DA04  2  8D AA E3     	sta	blknum		;store as starting
00DA07  2  C8           	iny			;bump for word
00DA08  2  A9 00        	lda	#0		;preset for byte
00DA0A  2  2C BA E3     	bit	blmode		;test mode
00DA0D  2  10 02        	bpl	*+4		;done if byte
00DA0F  2  B1 02        	lda	(addinp),y	;else get high
00DA11  2  8D AB E3     	sta	blknum+1	;then set high
00DA14  2  AD AA E3     isfrst:	lda	blknum		;get block
00DA17  2  8D 9F E3     	sta	lkdown		;set lower and
00DA1A  2  8D A1 E3     	sta	lookup		;upper pointers
00DA1D  2  AD AB E3     	lda	blknum+1	;now set high part
00DA20  2  8D A0 E3     	sta	lkdown+1
00DA23  2  8D A2 E3     	sta	lookup+1
00DA26  2  AD A1 E3     srblag:	lda	lookup		;if upper pointer
00DA29  2  CD C5 E3     	cmp	maxblk		;not at max
00DA2C  2  D0 08        	bne	upnemx		;then keep going
00DA2E  2  AC A2 E3     	ldy	lookup+1	;now check high
00DA31  2  CC C6 E3     	cpy	maxblk+1
00DA34  2  F0 12        	beq	tstdwn		;go test down
00DA36  2  EE A1 E3     upnemx:	inc	lookup		;else bump upper
00DA39  2  D0 03        	bne	*+5
00DA3B  2  EE A2 E3     	inc	lookup+1
00DA3E  2  AD 9F E3     	lda	lkdown		;then if lower
00DA41  2  0D A0 E3     	ora	lkdown+1
00DA44  2  F0 18        	beq	dotest		;is zero start test
00DA46  2  D0 0B        	bne	dcdown		;else drop lower
00DA48  2  AD 9F E3     tstdwn:	lda	lkdown		;if upper & lower at
00DA4B  2  0D A0 E3     	ora	lkdown+1
00DA4E  2  D0 03        	bne	dcdown		;drop if not zero
00DA50  2  A8           	tay			;also set y
00DA51  2  F0 30        	beq	extsbl		;then exit
00DA53  2  AD 9F E3     dcdown:	lda	lkdown		;drop lower
00DA56  2  D0 03        	bne	*+5
00DA58  2  CE A0 E3     	dec	lkdown+1
00DA5B  2  CE 9F E3     	dec	lkdown
00DA5E  2  AD 9F E3     dotest:	lda	lkdown		;get lower
00DA61  2  AC A0 E3     	ldy	lkdown+1
00DA64  2  20 51 DD     	jsr	tstblk		;and test
00DA67  2  D0 09        	bne	trylup		;if full try upper
00DA69  2  AD 9F E3     	lda	lkdown		;else use lower
00DA6C  2  AC A0 E3     	ldy	lkdown+1
00DA6F  2  4C 83 DA     	jmp	extsbl		;as result
00DA72  2  AD A1 E3     trylup:	lda	lookup		;get upper
00DA75  2  AC A2 E3     	ldy	lookup+1
00DA78  2  20 51 DD     	jsr	tstblk		;if full
00DA7B  2  D0 A9        	bne	srblag		;then loop
00DA7D  2  AD A1 E3     	lda	lookup		;else use upper
00DA80  2  AC A2 E3     	ldy	lookup+1
00DA83  2  8D AA E3     extsbl:	sta	blknum		;then save number
00DA86  2  8C AB E3     	sty	blknum+1
00DA89  2  0D AB E3     	ora	blknum+1	;see if zero
00DA8C  2  D0 04        	bne	gtgood		;then proceed
00DA8E  2  68           	pla			;clear stack
00DA8F  2  A9 02        	lda	#2		;set end
00DA91  2  60           	rts			;of data return
00DA92  2  AD AA E3     gtgood:	lda	blknum		;get low again
00DA95  2  20 65 DD     	jsr	setblk		;set allocation map
00DA98  2  68           	pla			;get block
00DA99  2  A8           	tay			;pointer back
00DA9A  2  AD AA E3     	lda	blknum		;get number
00DA9D  2  91 02        	sta	(addinp),y	;and put in fcb
00DA9F  2  AD AB E3     	lda	blknum+1	;get high
00DAA2  2  C8           	iny
00DAA3  2  2C BA E3     	bit	blmode		;test mode
00DAA6  2  10 02        	bpl	*+4		;done if byte
00DAA8  2  91 02        	sta	(addinp),y	;else set high
00DAAA  2  20 60 DE     blkopn:	jsr	calrcn		;calculate record num
00DAAD  2  20 AC DC     	jsr	sttrsc		;set track and sector
00DAB0  2  20 43 E0     	jsr	wrtsec		;do write
00DAB3  2  AE AF E3     	ldx	nxtrec		;get next record
00DAB6  2  EC B0 E3     	cpx	numrec		;if less than max
00DAB9  2  90 05        	bcc	notful		;then ok
00DABB  2  E8           	inx			;else bump count
00DABC  2  8E B0 E3     	stx	numrec		;and save
00DABF  2  CA           	dex			;back down
00DAC0  2  E0 7F        notful:	cpx	#127		;if not at max
00DAC2  2  D0 11        	bne	noawex		;skip extending
00DAC4  2  20 9E DD     	jsr	updtrc		;update record counters
00DAC7  2  A2 00        	ldx	#0		;do write
00DAC9  2  20 ED DE     	jsr	extend		;file extension
00DACC  2  C9 00        	cmp	#0		;if not ok
00DACE  2  D0 0A        	bne	extwrt		;exit
00DAD0  2  A9 FF        	lda	#255		;else start counter
00DAD2  2  8D AF E3     	sta	nxtrec		;at one short
00DAD5  2  20 9E DD     noawex:	jsr	updtrc		;then update counters
00DAD8  2  A9 00        	lda	#0		;good return
00DADA  2  60           extwrt:	rts			;exit
00DADB  2               ;execute console input
00DADB  2  20 85 E0     xcnsin:	jsr	getcon		;get input
00DADE  2  20 BB E0     	jsr	tstchr		;test it and
00DAE1  2  90 05        	bcc	extxci		;if control exit
00DAE3  2  48           	pha			;else save
00DAE4  2  20 13 E1     	jsr	sndchr		;echo
00DAE7  2  68           	pla			;restore
00DAE8  2  60           extxci:	rts			;return
00DAE9  2               ;switch memory
00DAE9  2               ;page zero block begins at $02 and is numvar bytes long.
00DAE9  2  A2 07        switch:	ldx	#numvar-1	;get number to switch
00DAEB  2  B5 02        nxtswh:	lda	2,x		;get zero page
00DAED  2  BC D6 E3     	ldy	varblk,x	;and save area
00DAF0  2  9D D6 E3     	sta	varblk,x	;save zero
00DAF3  2  94 02        	sty	2,x		;and high
00DAF5  2  CA           	dex			;count down
00DAF6  2  10 F3        	bpl	nxtswh		;and loop until done
00DAF8  2  60           drvsme:	rts			;then return
00DAF9  2               ;change dma address
00DAF9  2               ; input:addinp=address
00DAF9  2               ; returns:none
00DAF9  2               ; alters:all
00DAF9  2  A5 02        chgdma:	lda	addinp		;get low
00DAFB  2  A4 03        	ldy	addinp+1	;and high address
00DAFD  2  85 04        	sta	bufadd		;then store
00DAFF  2  84 05        	sty	bufadd+1	;in address
00DB01  2  4C 74 E4     	jmp	sim+36		;then go to sim
00DB04  2               
00DB04  2               ;change drive
00DB04  2               ; input:bytinp
00DB04  2               ; returns:none
00DB04  2               ; alters:all
00DB04  2  AD 92 E3     chgdrv:	lda	bytinp		;get input
00DB07  2  CD A4 E3     	cmp	curdrv		;if same as current
00DB0A  2  F0 EC        	beq	drvsme		;do nothing
00DB0C  2  8D A4 E3     	sta	curdrv		;else change current
00DB0F  2  4C 45 DB     	jmp	mapdrv		;then log it in
00DB12  2               ;automatic drive select
00DB12  2               ; input:(addinp) 0=no change
00DB12  2               ; 1-8 or 'A'-'H' = change
00DB12  2               ; returns:none
00DB12  2               ; alters:all
00DB12  2  A0 00        autodr:	ldy	#0		;get
00DB14  2  B1 02        	lda	(addinp),y	;first byte of fcb
00DB16  2  F0 19        	beq	qtatdr		;if zero quit
00DB18  2  38           	sec			;set carry for
00DB19  2  E9 01        	sbc	#1		;subtract one
00DB1B  2  29 07        	and	#%00000111	;look at three lsbs
00DB1D  2  8D 92 E3     	sta	bytinp		;make parameter
00DB20  2  AD A4 E3     	lda	curdrv		;get current
00DB23  2  8D A3 E3     	sta	olddrv		;and save
00DB26  2  B1 02        	lda	(addinp),y	;get fcb entry
00DB28  2  8D 99 E3     	sta	tmpdrv		;and save as flag
00DB2B  2  98           	tya			;set a to 0
00DB2C  2  91 02        	sta	(addinp),y	;clear byte zero in fcb
00DB2E  2  20 04 DB     	jsr	chgdrv		;then select new drive
00DB31  2  60           qtatdr:	rts			;and return
00DB32  2               ;execute initialize system
00DB32  2               ; input:none
00DB32  2               ; returns:none
00DB32  2               ; alters:all,curdrv,lginvc,bufadd
00DB32  2  A9 02        xintds:	lda	#DEFDRV		;set current
00DB34  2  8D A4 E3     	sta	curdrv		;drive to a
00DB37  2  8D A5 E3     	sta	lginvc		;clear log in status
00DB3A  2  A9 28        	lda	#<dflbuf	;get default buffer
00DB3C  2  A0 01        	ldy	#>dflbuf	;address
00DB3E  2  85 02        	sta	addinp		;and set up
00DB40  2  84 03        	sty	addinp+1	;parameters
00DB42  2  20 F9 DA     	jsr	chgdma		;change address
00DB45  2               
00DB45  2               ;log in drive and set pointers and maps
00DB45  2               ; input:curdrv
00DB45  2               ; returns:none
00DB45  2               ; alters:all
00DB45  2  AD A4 E3     mapdrv:	lda	curdrv		;if current drive
00DB48  2  C9 08        	cmp	#8		;is 0 to 7
00DB4A  2  90 0F        	bcc	vlddrv		;then log it in
00DB4C  2  20 66 E0     drserr:	jsr	errout		;send error message
00DB4F  2  AD E0 E2     	lda	sltmvc		;point to
00DB52  2  AC E1 E2     	ldy	sltmvc+1	;select message
00DB55  2  20 CA E0     	jsr	sndstr		;and send it
00DB58  2               
00DB58  2  4C EA D8     	jmp	xwboot		;and abort
00DB5B  2               
00DB5B  2  20 6B E4     vlddrv:	jsr	sim+27		;go to sim to set
00DB5E  2  8D 6C DB     	sta	cptdcb+1	;save
00DB61  2  8C 6D DB     	sty	cptdcb+2
00DB64  2  0D 6D DB     	ora	cptdcb+2	;see if invalid
00DB67  2  F0 E3        	beq	drserr		;error if is
00DB69  2               ;capture dcb
00DB69  2  A0 0D        	ldy	#14-1		;do 14 bytes
00DB6B  2  B9 FF FF     cptdcb:	lda	$ffff,y		;get value from sim
00DB6E  2  99 C5 E3     	sta	dcb,y		;store it
00DB71  2  88           	dey
00DB72  2  10 F7        	bpl	cptdcb		;loop for more
00DB74  2  AD CB E3     	lda	blkscd		;get block size code
00DB77  2  A8           	tay			;save in y
00DB78  2  18           	clc
00DB79  2  69 03        	adc	#3		;convert to sxb
00DB7B  2  8D BE E3     	sta	sxb		;and save
00DB7E  2  B9 85 E3     	lda	sabtbl,y	;get sab
00DB81  2  8D BD E3     	sta	sab		;and set
00DB84  2  AD CC E3     	lda	maxdir		;get max dir
00DB87  2  8D BB E3     	sta	maxdrc		;set max dir record
00DB8A  2  AD CD E3     	lda	maxdir+1
00DB8D  2  4A           	lsr	a		;divide by 4
00DB8E  2  6E BB E3     	ror	maxdrc
00DB91  2  4A           	lsr	a
00DB92  2  6E BB E3     	ror	maxdrc
00DB95  2  8D BC E3     	sta	maxdrc+1	;then save high
00DB98  2  A9 00        	lda	#0		;set mode to byte
00DB9A  2  8D BA E3     	sta	blmode
00DB9D  2  AD C6 E3     	lda	maxblk+1	;branch if max block
00DBA0  2  F0 05        	beq	ntm255		;not over 255
00DBA2  2               ;if y=0 when the following line is executed it means
00DBA2  2               ;that the user has put an illegal combination into
00DBA2  2               ;the disk definition table. may want to consider
00DBA2  2               ;putting some error checking here in the future if
00DBA2  2               ;there is space in pem.
00DBA2  2  88           	dey			;back up index
00DBA3  2  38           	sec			;else set mode to word
00DBA4  2  6E BA E3     	ror	blmode
00DBA7  2  B9 82 E3     ntm255:	lda	exmtbl,y	;get extent mask
00DBAA  2  8D D4 E3     	sta	exm
00DBAD  2               
00DBAD  2  38           	sec			;now calculate cexm1f
00DBAE  2  A9 1F        	lda	#31
00DBB0  2  F9 82 E3     	sbc	exmtbl,y
00DBB3  2  8D D5 E3     	sta	cexm1f
00DBB6  2  AE A4 E3     	ldx	curdrv		;get drive as pointer
00DBB9  2  BD 7A E3     	lda	bitmap,x	;get bit
00DBBC  2  2D A5 E3     	and	lginvc		;if logged in
00DBBF  2  D0 0C        	bne	extstm		;then exit
00DBC1  2  BD 7A E3     	lda	bitmap,x	;get bit back
00DBC4  2  0D A5 E3     	ora	lginvc		;set in log-in
00DBC7  2  8D A5 E3     	sta	lginvc		;and update
00DBCA  2  4C CE DB     	jmp	flinal		;then fill in maps
00DBCD  2               
00DBCD  2  60           extstm:	rts			;and return
00DBCE  2               ;fill in allocation map
00DBCE  2  20 28 E0     flinal:	jsr	setrw		;set to read/write
00DBD1  2  AD C5 E3     	lda	maxblk		;divide max block by
00DBD4  2  8D C2 E3     	sta	gpcnt		;eight to get max
00DBD7  2  AD C6 E3     	lda	maxblk+1
00DBDA  2  A2 03        	ldx	#3
00DBDC  2  4A           clcnab:	lsr	a		;use a for speed
00DBDD  2  6E C2 E3     	ror	gpcnt
00DBE0  2  CA           	dex
00DBE1  2  D0 F9        	bne	clcnab		;loop if more
00DBE3  2  8D C3 E3     	sta	gpcnt+1		;save high
00DBE6  2  EE C2 E3     	inc	gpcnt		;bump by one
00DBE9  2  D0 03        	bne	*+5
00DBEB  2  EE C3 E3     	inc	gpcnt+1		;with carry
00DBEE  2  AD CE E3     	lda	alcmap		;get map start
00DBF1  2  AC CF E3     	ldy	alcmap+1
00DBF4  2  85 06        	sta	alcpnt		;set pointer to start
00DBF6  2  84 07        	sty	alcpnt+1
00DBF8  2  A0 00        	ldy	#0		;clear index
00DBFA  2  A9 00        clraml:	lda	#0		;clear byte
00DBFC  2  91 06        	sta	(alcpnt),y	;put in map
00DBFE  2  E6 06        	inc	alcpnt		;bump pointer
00DC00  2  D0 02        	bne	*+4
00DC02  2  E6 07        	inc	alcpnt+1	;with carry
00DC04  2  AD C2 E3     	lda	gpcnt		;get low of count
00DC07  2  D0 03        	bne	*+5		;skip if not zero
00DC09  2  CE C3 E3     	dec	gpcnt+1		;else drop high
00DC0C  2  CE C2 E3     	dec	gpcnt		;always drop low
00DC0F  2  AD C2 E3     	lda	gpcnt		;test for zero
00DC12  2  0D C3 E3     	ora	gpcnt+1
00DC15  2  D0 E3        	bne	clraml		;loop if more
00DC17  2               ;at this point complete map is cleared
00DC17  2  AD BB E3     	lda	maxdrc		;get low of max dir record
00DC1A  2  8D C2 E3     	sta	gpcnt
00DC1D  2  AD BC E3     	lda	maxdrc+1	;high in a
00DC20  2  AE BE E3     	ldx	sxb		;set x according to block size
00DC23  2  4A           clcmdb:	lsr	a		;do division
00DC24  2  6E C2 E3     	ror	gpcnt
00DC27  2  CA           	dex
00DC28  2  D0 F9        	bne	clcmdb		;until x is zero
00DC2A  2  8D C3 E3     	sta	gpcnt+1		;set high
00DC2D  2  EE C2 E3     	inc	gpcnt		;then bump by one
00DC30  2  D0 03        	bne	*+5
00DC32  2  EE C3 E3     	inc	gpcnt+1
00DC35  2  8E AA E3     	stx	blknum		;clear block number
00DC38  2  8E AB E3     	stx	blknum+1
00DC3B  2  AD AA E3     fildal:	lda	blknum		;get block number
00DC3E  2  AC AB E3     	ldy	blknum+1
00DC41  2  20 65 DD     	jsr	setblk		;set bit
00DC44  2  EE AA E3     	inc	blknum		;bump block number
00DC47  2  D0 03        	bne	*+5
00DC49  2  EE AB E3     	inc	blknum+1
00DC4C  2  AD C2 E3     	lda	gpcnt		;get low of count
00DC4F  2  D0 03        	bne	*+5		;skip if not zero
00DC51  2  CE C3 E3     	dec	gpcnt+1		;else drop high
00DC54  2  CE C2 E3     	dec	gpcnt		;always do low
00DC57  2  AD C2 E3     	lda	gpcnt		;test for zero
00DC5A  2  0D C3 E3     	ora	gpcnt+1
00DC5D  2  D0 DC        	bne	fildal		;loop if more
00DC5F  2               ;at this point directory space is mapped
00DC5F  2  20 7E DC     	jsr	intdrv		;initialize drive
00DC62  2  20 D8 DF     	jsr	cldrnm		;clear directory number
00DC65  2  A2 01        fillpe:	ldx	#1		;parameter for fill
00DC67  2  20 20 DF     	jsr	nxtdir		;execute for next directory
00DC6A  2  30 11        	bmi	extfil		;done if invalid
00DC6C  2  AC A9 E3     	ldy	subrec		;get offset
00DC6F  2  B1 04        	lda	(bufadd),y	;get empty/valid flag
00DC71  2  C9 E5        	cmp	#$e5		;if empty
00DC73  2  F0 F0        	beq	fillpe		;try next
00DC75  2  A2 01        	ldx	#1		;parameter for fill in
00DC77  2  20 E4 DF     	jsr	mapdir		;do directory map
00DC7A  2  4C 65 DC     	jmp	fillpe		;then loop
00DC7D  2  60           extfil:	rts			;return
00DC7E  2               ;initialize drive
00DC7E  2               ; input:nsystr
00DC7E  2               ; returns:none
00DC7E  2               ; alters:all
00DC7E  2  20 68 E4     intdrv:	jsr	sim+24		;home then
00DC81  2               
00DC81  2  AD C9 E3     	lda	nsystr		;get number of system tracks
00DC84  2  AC CA E3     	ldy	nsystr+1
00DC87  2  4C 6E E4     	jmp	sim+30		;and set in sim
00DC8A  2               
00DC8A  2               ;directory record set up
00DC8A  2               ; input:dirnum
00DC8A  2               ; returns:none
00DC8A  2               ; alters:all,recnum,dirrec
00DC8A  2  AD A8 E3     drrcsu:	lda	dirnum+1	;move high dir number
00DC8D  2  8D AB E3     	sta	recnum+1	;to record number
00DC90  2  AD A7 E3     	lda	dirnum		;divide
00DC93  2  4E AB E3     	lsr	recnum+1	;directory by four
00DC96  2  6A           	ror	a
00DC97  2  4E AB E3     	lsr	recnum+1
00DC9A  2  6A           	ror	a
00DC9B  2  8D B1 E3     	sta	dirrec		;and save
00DC9E  2  8D AA E3     	sta	recnum		;set low record number
00DCA1  2  AD AB E3     	lda	recnum+1	;get high
00DCA4  2  8D B2 E3     	sta	dirrec+1	;and set
00DCA7  2  A9 00        	lda	#0		;clear top byte
00DCA9  2  8D AC E3     	sta	recnum+2
00DCAC  2               ;set track and sector
00DCAC  2               ; input:recnum
00DCAC  2               ; returns:none
00DCAC  2               ; alters:all,countr,trkctr
00DCAC  2  A2 00        sttrsc:	ldx	#0		;clear track counter
00DCAE  2  8E C4 E3     	stx	trkctr
00DCB1  2  8E 9C E3     	stx	countr		;and record
00DCB4  2  8E 9D E3     	stx	countr+1	;counter
00DCB7  2  8E 9E E3     	stx	countr+2
00DCBA  2  AD AA E3     trnxtr:	lda	recnum		;from
00DCBD  2  CD 9C E3     	cmp	countr		;record number
00DCC0  2  AD AB E3     	lda	recnum+1	;and if a
00DCC3  2  ED 9D E3     	sbc	countr+1	;borrow then
00DCC6  2  AD AC E3     	lda	recnum+2
00DCC9  2  ED 9E E3     	sbc	countr+2
00DCCC  2  90 21        	bcc	higher		;gone too far
00DCCE  2  18           	clc			;else
00DCCF  2  AD 9C E3     	lda	countr		;get counter
00DCD2  2  6D C7 E3     	adc	sectrk		;add sectors per track
00DCD5  2  8D 9C E3     	sta	countr		;sectors per track
00DCD8  2  AD 9D E3     	lda	countr+1
00DCDB  2  6D C8 E3     	adc	sectrk+1
00DCDE  2  8D 9D E3     	sta	countr+1
00DCE1  2  90 03        	bcc	bumptr		;done if no carry
00DCE3  2  EE 9E E3     	inc	countr+2	;else bump high
00DCE6  2  E8           bumptr:	inx			;increase track count
00DCE7  2  D0 D1        	bne	trnxtr		;with carry
00DCE9  2  EE C4 E3     	inc	trkctr
00DCEC  2  4C BA DC     	jmp	trnxtr		;then loop
00DCEF  2  CA           higher:	dex			;back up track
00DCF0  2  E0 FF        	cpx	#$ff		;see if wrap around
00DCF2  2  D0 03        	bne	*+5		;wasn't
00DCF4  2  CE C4 E3     	dec	trkctr		;else drop high
00DCF7  2  8A           	txa			;move to a
00DCF8  2  18           	clc			;add starting track
00DCF9  2  6D C9 E3     	adc	nsystr
00DCFC  2  AA           	tax			;save in x
00DCFD  2  AD C4 E3     	lda	trkctr
00DD00  2  6D CA E3     	adc	nsystr+1
00DD03  2  A8           	tay			;move to correct registers
00DD04  2  8A           	txa
00DD05  2  20 6E E4     	jsr	sim+30		;then set in sim
00DD08  2               
00DD08  2  38           	sec			;back
00DD09  2  AD 9C E3     	lda	countr		;counter down
00DD0C  2  ED C7 E3     	sbc	sectrk		;by sectors per track
00DD0F  2  8D 9C E3     	sta	countr		;and save
00DD12  2  AD 9D E3     	lda	countr+1
00DD15  2  ED C8 E3     	sbc	sectrk+1
00DD18  2  8D 9D E3     	sta	countr+1
00DD1B  2  38           	sec			;now
00DD1C  2  AD AA E3     	lda	recnum		;find difference
00DD1F  2  ED 9C E3     	sbc	countr		;as sector
00DD22  2  AA           	tax			;save in x
00DD23  2  AD AB E3     	lda	recnum+1
00DD26  2  ED 9D E3     	sbc	countr+1
00DD29  2  A8           	tay			;move to correct registers
00DD2A  2  8A           	txa
00DD2B  2  20 83 E4     	jsr	sim+51		;translate
00DD2E  2               
00DD2E  2  4C 71 E4     	jmp	sim+33		;and set through sim
00DD31  2               
00DD31  2               ;get block bit mask and index
00DD31  2               ; input:a&y=block number
00DD31  2               ; returns:a=bit mask and y=0
00DD31  2               ; alters:all and alcpnt
00DD31  2  48           blkmsk:	pha			;save block number
00DD32  2  84 07        	sty	alcpnt+1	;including high
00DD34  2  A0 03        	ldy	#3		;divide by eight
00DD36  2  46 07        blkmlp:	lsr	alcpnt+1	;shift high
00DD38  2  6A           	ror	a
00DD39  2  88           	dey			;loop until done
00DD3A  2  D0 FA        	bne	blkmlp
00DD3C  2  18           	clc			;now add map start
00DD3D  2  6D CE E3     	adc	alcmap
00DD40  2  85 06        	sta	alcpnt
00DD42  2  A5 07        	lda	alcpnt+1
00DD44  2  6D CF E3     	adc	alcmap+1
00DD47  2  85 07        	sta	alcpnt+1
00DD49  2  68           	pla			;get number back
00DD4A  2  29 07        	and	#%00000111	;look at 3 lsbs
00DD4C  2  AA           	tax			;get
00DD4D  2  BD 72 E3     	lda	bitmsk,x	;mask
00DD50  2  60           	rts			;and return
00DD51  2               ;test block
00DD51  2               ; input:a&y=block number
00DD51  2               ; returns:z=1 if unassigned
00DD51  2               ; 	   =0 if assigned and bit in a is set
00DD51  2               ; alters:all
00DD51  2  20 31 DD     tstblk:	jsr	blkmsk		;get mask and index
00DD54  2  31 06        	and	(alcpnt),y	;mask with map entry
00DD56  2  60           	rts			;then return
00DD57  2               ;alter block status
00DD57  2               ; input:a&y=block number,x=1 if set
00DD57  2               ;		   	  =0 if reset
00DD57  2               ; returns:none
00DD57  2               ; alters:all and allocation map
00DD57  2  E0 01        altalc:	cpx	#1		;if set
00DD59  2  F0 0A        	beq	setblk		;go do it
00DD5B  2  20 31 DD     clrblk:	jsr	blkmsk		;else get mask
00DD5E  2  49 FF        	eor	#$ff		;and complement
00DD60  2  31 06        	and	(alcpnt),y	;preserve others
00DD62  2  91 06        	sta	(alcpnt),y	;and save
00DD64  2  60           	rts			;then return
00DD65  2  20 31 DD     setblk:	jsr	blkmsk		;get mask
00DD68  2  11 06        	ora	(alcpnt),y	;set bit
00DD6A  2  91 06        	sta	(alcpnt),y	;and put back
00DD6C  2  60           	rts			;then return
00DD6D  2               ;set current drive to read only
00DD6D  2               ; input:curdrv,ronlst,bitmap
00DD6D  2               ; returns:none
00DD6D  2               ; alters:a,x,p and ronlst
00DD6D  2  AE A4 E3     setron:	ldx	curdrv		;get number
00DD70  2  BD 7A E3     	lda	bitmap,x	;and get mask
00DD73  2  0D A6 E3     	ora	ronlst		;or with status
00DD76  2  8D A6 E3     	sta	ronlst		;and put back
00DD79  2  60           	rts			;then return
00DD7A  2               ;calculate checksum of buffer @ bufadd
00DD7A  2               ; input: buffer@(bufadd)
00DD7A  2               ; returns:a=checksum
00DD7A  2               ; alters:a,y,p
00DD7A  2  A9 00        clcchk:	lda	#0		;clear accumulator
00DD7C  2  A0 7F        	ldy	#127		;start at end
00DD7E  2  18           chkmre:	clc			;no carry
00DD7F  2  71 04        	adc	(bufadd),y	;add byte
00DD81  2  88           	dey			;count down
00DD82  2  10 FA        	bpl	chkmre		;and loop until done
00DD84  2  60           	rts			;then return
00DD85  2               ;check read/write status
00DD85  2               ; input:curdrv,ronlst
00DD85  2               ; returns:z=0 if r/o or z=1 if r/w
00DD85  2               ; alters:a,x,p
00DD85  2  AE A4 E3     chkron:	ldx	curdrv		;get current drive
00DD88  2  BD 7A E3     	lda	bitmap,x	;get mask
00DD8B  2  2D A6 E3     	and	ronlst		;and test status
00DD8E  2  60           	rts
00DD8F  2               ;initialize record counters from fcb
00DD8F  2               ; input:fcb@(addinp)
00DD8F  2               ; returns:none
00DD8F  2               ; alters:a,y,p,nxtrec,numrec
00DD8F  2  A0 20        inrcct:	ldy	#32		;next record offset
00DD91  2  B1 02        	lda	(addinp),y	;get next record
00DD93  2  8D AF E3     	sta	nxtrec		;and save
00DD96  2  A0 0F        	ldy	#15		;number records offset
00DD98  2  B1 02        	lda	(addinp),y	;get number
00DD9A  2  8D B0 E3     	sta	numrec		;and save
00DD9D  2  60           	rts			;and return
00DD9E  2               ;update record counters in fcb
00DD9E  2               ; input:nxtrec,numrec
00DD9E  2               ; returns:none
00DD9E  2               ; alters:all,fcb@(addinp)
00DD9E  2  AE AF E3     updtrc:	ldx	nxtrec		;get next record
00DDA1  2  E8           	inx			;bump it
00DDA2  2  8A           	txa			;transfer
00DDA3  2  A0 20        	ldy	#32		;set offset
00DDA5  2  91 02        	sta	(addinp),y	;and store in fcb
00DDA7  2  AD B0 E3     	lda	numrec		;get number
00DDAA  2  A0 0F        	ldy	#15		;and its offset
00DDAC  2  91 02        	sta	(addinp),y	;and store
00DDAE  2  60           	rts			;then return
00DDAF  2               ;execute open file
00DDAF  2  20 12 DB     xopen:	jsr	autodr		;auto drive select
00DDB2  2               ;open file
00DDB2  2               ; input:fcb @ (addinp)
00DDB2  2               ; returns:n=1 if not found,a=dirmod (255 if not found)
00DDB2  2               ; alters:all
00DDB2  2  20 11 DE     opnfle:	jsr	fndf13		;match all including extent
00DDB5  2  30 32        	bmi	extopn		;done if not found
00DDB7  2  A9 0C        	lda	#12		;point to first char
00DDB9  2  0D A9 E3     	ora	subrec		;add offset
00DDBC  2  A8           	tay			;make it a pointer
00DDBD  2  B1 04        nxopmv:	lda	(bufadd),y	;get buffer contents
00DDBF  2  AA           	tax			;and save
00DDC0  2  98           	tya			;save index
00DDC1  2  29 1F        	and	#%00011111	;remove offset
00DDC3  2  A8           	tay			;back to index
00DDC4  2  8A           	txa			;get byte back
00DDC5  2  91 02        	sta	(addinp),y	;and store in fcb
00DDC7  2  98           	tya			;get index
00DDC8  2  0D A9 E3     	ora	subrec		;add offset back
00DDCB  2  A8           	tay			;and make index again
00DDCC  2  C8           	iny			;next position
00DDCD  2  98           	tya			;if index
00DDCE  2  29 1F        	and	#%00011111	;not gone past
00DDD0  2  D0 EB        	bne	nxopmv		;end then loop
00DDD2  2               ;now correct extent and max records
00DDD2  2  A0 0C        	ldy	#12		;point at extent in fcb
00DDD4  2  AD 8C E3     	lda	savext		;get save from search
00DDD7  2  D1 02        	cmp	(addinp),y	;compare
00DDD9  2  F0 0B        	beq	extsme		;jump ahead if same
00DDDB  2  91 02        	sta	(addinp),y	;else change extent
00DDDD  2  A9 80        	lda	#128		;assume fcb ext < dir ext
00DDDF  2  90 01        	bcc	fcbxls		;jump ahead if true
00DDE1  2  0A           	asl	a		;clear a
00DDE2  2  A0 0F        fcbxls:	ldy	#15		;point to max
00DDE4  2  91 02        	sta	(addinp),y	;and set
00DDE6  2  AD B3 E3     extsme:	lda	dirmod		;else get number
00DDE9  2  60           extopn:	rts			;and return
00DDEA  2               ;execute close file
00DDEA  2  20 12 DB     xclose:	jsr	autodr		;auto drive select
00DDED  2               ;close file
00DDED  2               ;if file is r/o then no actual close
00DDED  2               ;operation is performed.
00DDED  2               ; input:fcb @ (addinp)
00DDED  2               ; returns:n=1 if not valid,a=dirmod (255 if invalid)
00DDED  2               ; alters:all
00DDED  2  20 11 DE     clsfle:	jsr	fndf13		;match including extent
00DDF0  2  30 1B        	bmi	extcls		;exit if not found
00DDF2  2  20 85 DD     	jsr	chkron		;see if r/o
00DDF5  2  D0 13        	bne	noclse		;branch if is
00DDF7  2               ;now set flag to ensure directory extent and number of
00DDF7  2               ;records fields are only changed if necessary.
00DDF7  2               ;The decision to change is determined by whether or
00DDF7  2               ;not the system is closing an extent less than the
00DDF7  2               ;maximum extent in the directory entry. If that is
00DDF7  2               ;the case, the directory extent and number of record
00DDF7  2               ;fields are not changed.
00DDF7  2  A0 0C        	ldy	#12		;get extent
00DDF9  2  B1 02        	lda	(addinp),y
00DDFB  2  48           	pha			;save it
00DDFC  2  98           	tya			;now look in directory
00DDFD  2  0D A9 E3     	ora	subrec
00DE00  2  A8           	tay
00DE01  2  68           	pla			;get extent back
00DE02  2  D1 04        	cmp	(bufadd),y
00DE04  2  6E 8A E3     	ror	skpdir		;save result
00DE07  2               ;now go do it
00DE07  2  20 7C DE     	jsr	updtdr		;update directory
00DE0A  2  AD B3 E3     noclse:	lda	dirmod		;get directory number
00DE0D  2  60           extcls:	rts			;and return
00DE0E  2               ;execute find first match
00DE0E  2  20 12 DB     xfndfr:	jsr	autodr		;auto drive select
00DE11  2  A9 0D        fndf13:	lda	#13		;match including extent
00DE13  2               ;search for first match
00DE13  2               ; input:a=number char to match
00DE13  2               ; returns:n=1 if invalid,a=dirmod (255 if invalid)
00DE13  2               ; alters:all
00DE13  2  48           frstsr:	pha			;save number to match
00DE14  2  20 D8 DF     	jsr	cldrnm		;clear directory number to -1
00DE17  2  20 7E DC     	jsr	intdrv		;and drive
00DE1A  2  68           	pla			;get number to match
00DE1B  2               ;search for directory match
00DE1B  2               ; input:a=number char to match
00DE1B  2               ; returns:n=1 if not found,a=dirmod (255 if invalid)
00DE1B  2               ; alters:all
00DE1B  2  8D AD E3     search:	sta	chrcnt		;save number
00DE1E  2  A2 00        newtry:	ldx	#0		;set for search
00DE20  2  8E AE E3     	stx	cmppnt		;clear pointer
00DE23  2  20 20 DF     	jsr	nxtdir		;get next entry
00DE26  2  30 37        	bmi	exitsr		;exit if not found
00DE28  2  AE AD E3     	ldx	chrcnt		;get count
00DE2B  2  AC AE E3     mremch:	ldy	cmppnt		;get pointer
00DE2E  2  EE AE E3     	inc	cmppnt		;and bump
00DE31  2  B1 02        	lda	(addinp),y	;get fcb entry
00DE33  2  C0 0C        	cpy	#12		;see if at extent
00DE35  2  D0 13        	bne	notaex		;jump if not
00DE37  2  8D 8C E3     	sta	savext		;save for later use
00DE3A  2  48           	pha			;save extent
00DE3B  2  98           	tya			;change to directory
00DE3C  2  0D A9 E3     	ora	subrec		;coordinates
00DE3F  2  A8           	tay
00DE40  2  68           	pla			;get extent back
00DE41  2  51 04        	eor	(bufadd),y	;exclusive or with dir
00DE43  2  2D D5 E3     	and	cexm1f		;and with exm complement + 1f
00DE46  2  F0 11        	beq	trynxt		;ok if zero
00DE48  2  D0 D4        	bne	newtry		;else get next directory
00DE4A  2  C9 3F        notaex:	cmp	#'?'		;if a ? then
00DE4C  2  F0 0B        	beq	trynxt		;is a match
00DE4E  2  48           	pha			;save char
00DE4F  2  98           	tya			;then add
00DE50  2  0D A9 E3     	ora	subrec		;offset to
00DE53  2  A8           	tay			;make pointer
00DE54  2  68           	pla			;get char back
00DE55  2               ;        sta     savex
00DE55  2               ;        lda	(bufadd),y	;if not same
00DE55  2               ;        and     #$7F            ; strip off high bit for ROMWBW Read only filesystem
00DE55  2               ;	cmp	savex	        ;if not same
00DE55  2  D1 04                cmp	(bufadd),y	;if not same
00DE57  2  D0 C5        	bne	newtry		;try next directory
00DE59  2  CA           trynxt:	dex			;else count number down
00DE5A  2  D0 CF        	bne	mremch		;and loop if more
00DE5C  2  AD B3 E3     	lda	dirmod		;return with directory
00DE5F  2  60           exitsr:	rts			;number mod 4
00DE60  2               ;calculate logical record number
00DE60  2               ; input:blknum
00DE60  2               ; returns:none
00DE60  2               ; alters:a,x,p,recnum
00DE60  2  AE BE E3     calrcn:	ldx	sxb		;set x according to blkscd
00DE63  2  0E AA E3     mulmre:	asl	blknum		;multiply block
00DE66  2  2E AB E3     	rol	blknum+1	;number
00DE69  2  2E AC E3     	rol	blknum+2
00DE6C  2  CA           	dex			;by code
00DE6D  2  D0 F4        	bne	mulmre
00DE6F  2  AD BD E3     	lda	sab		;set mask in a
00DE72  2  2D AF E3     	and	nxtrec		;and with next record
00DE75  2  0D AA E3     	ora	recnum		;or with number
00DE78  2  8D AA E3     	sta	recnum		;and save
00DE7B  2  60           	rts
00DE7C  2               ;update directory
00DE7C  2  A9 20        updtdr:	lda	#32		;change all
00DE7E  2  A2 00        	ldx	#0		;from start
00DE80  2               ;change directory entry
00DE80  2               ; input:a=number char to change,x=starting position,fcb@(addinp)
00DE80  2               ; returns:none
00DE80  2               ; alters:all,directory,checksums
00DE80  2  8D AD E3     dirchg:	sta	chrcnt		;save count
00DE83  2  CE AD E3     	dec	chrcnt		;back up
00DE86  2  18           mrechg:	clc			;clear carry
00DE87  2  8A           	txa			;get offset
00DE88  2  6D AD E3     	adc	chrcnt		;compute index
00DE8B  2  A8           	tay			;and set
00DE8C  2  C0 0C        	cpy	#12		;see if at extent
00DE8E  2  F0 04        	beq	docare		;if so do special
00DE90  2  C0 0F        	cpy	#15		;see if at number rec
00DE92  2  D0 05        	bne	dntcar		;if not skip
00DE94  2  2C 8A E3     docare:	bit	skpdir		;check flag
00DE97  2  10 0D        	bpl	nochng		;skip if ok
00DE99  2  B1 02        dntcar:	lda	(addinp),y	;get char
00DE9B  2  48           	pha			;save it
00DE9C  2  AD AD E3     	lda	chrcnt		;get count
00DE9F  2  0D A9 E3     	ora	subrec		;add offset
00DEA2  2  A8           	tay			;make an index
00DEA3  2  68           	pla			;get char back
00DEA4  2  91 04        	sta	(bufadd),y	;and put in buffer
00DEA6  2  CE AD E3     nochng:	dec	chrcnt		;count down
00DEA9  2  10 DB        	bpl	mrechg		;and loop
00DEAB  2  20 8A DC     	jsr	drrcsu		;set it up
00DEAE  2  4C 3D E0     	jmp	updtck		;and do change
00DEB1  2               ;execute create file
00DEB1  2  20 12 DB     xmake:	jsr	autodr		;auto drive select
00DEB4  2               ;create file
00DEB4  2               ; input:fcb@(addinp)
00DEB4  2               ; returns:n=1 if not valid,a=dirmod (255 if not valid)
00DEB4  2               ; alters:dirnum,dirmod,fcb@(addinp)
00DEB4  2  20 14 E0     mkefle:	jsr	tstron		;test for r/o
00DEB7  2  A5 02        	lda	addinp		;save fcb
00DEB9  2  48           	pha			;address
00DEBA  2  A5 03        	lda	addinp+1	;on
00DEBC  2  48           	pha			;stack
00DEBD  2  AD E3 E2     	lda	empdvc		;then point
00DEC0  2  AC E4 E2     	ldy	empdvc+1	;to empty
00DEC3  2  85 02        	sta	addinp		;dummy
00DEC5  2  84 03        	sty	addinp+1	;fcb
00DEC7  2  A9 01        	lda	#1		;match only
00DEC9  2  20 13 DE     	jsr	frstsr		;first char
00DECC  2  68           	pla			;restore
00DECD  2  85 03        	sta	addinp+1	;fcb
00DECF  2  68           	pla			;address
00DED0  2  85 02        	sta	addinp		;from stack
00DED2  2  AD B3 E3     	lda	dirmod		;get number mod 4
00DED5  2  30 15        	bmi	extmke		;quit if not found
00DED7  2  A0 0D        	ldy	#13		;else set up
00DED9  2  A9 00        	lda	#0		;to clear
00DEDB  2  91 02        mkeagn:	sta	(addinp),y	;rest of
00DEDD  2  C8           	iny			;fcb
00DEDE  2  C0 21        	cpy	#33		;including next
00DEE0  2  D0 F9        	bne	mkeagn		;record
00DEE2  2               ;the next two lines ensure that the extent and
00DEE2  2               ;number of records fields are updated
00DEE2  2  38           	sec
00DEE3  2  6E 8A E3     	ror	skpdir
00DEE6  2  20 7C DE     	jsr	updtdr		;update directory
00DEE9  2  AD B3 E3     	lda	dirmod		;get number
00DEEC  2  60           extmke:	rts			;and quit
00DEED  2               ;extend file
00DEED  2               ; input:fcb@(addinp), x=1 read
00DEED  2               ;		        0 write
00DEED  2  8E 98 E3     extend:	stx	exrwfl		;save parameter
00DEF0  2  20 ED DD     	jsr	clsfle		;close current extent
00DEF3  2  30 2A        	bmi	extext		;exit if not found
00DEF5  2  A0 0C        	ldy	#12		;else
00DEF7  2  B1 02        	lda	(addinp),y	;get extent
00DEF9  2  18           	clc			;and
00DEFA  2  69 01        	adc	#1		;add one
00DEFC  2  29 1F        	and	#%00011111	;see if overflow
00DEFE  2  F0 17        	beq	exteof		;eof if so
00DF00  2  91 02        	sta	(addinp),y	;and save
00DF02  2  20 11 DE     	jsr	fndf13		;see if next extent exists
00DF05  2  10 0B        	bpl	opnext		;if so open
00DF07  2  AD 98 E3     	lda	exrwfl		;if not and is write then create
00DF0A  2  D0 13        	bne	extext		;else return as eof
00DF0C  2  20 B4 DE     dwrtex:	jsr	mkefle		;create file
00DF0F  2  4C 15 DF     	jmp	tstext		;and test
00DF12  2  20 B2 DD     opnext:	jsr	opnfle		;open
00DF15  2  10 03        tstext:	bpl	extnok		;continue if ok
00DF17  2  A9 01        exteof:	lda	#1		;else set eof
00DF19  2  60           	rts			;and return
00DF1A  2  20 8F DD     extnok:	jsr	inrcct		;initialize counters
00DF1D  2  A9 00        	lda	#0		;good
00DF1F  2  60           extext:	rts			;return
00DF20  2               ;set up next directory block
00DF20  2               ; input:dirnum,x=1 for update checksum
00DF20  2               ; returns:a=dirmod (255 if invalid),n=1 if invalid
00DF20  2               ; alters:alll,dirnum,dirmod
00DF20  2  8A           nxtdir:	txa			;save operation
00DF21  2  48           	pha			;on stack
00DF22  2  EE A7 E3     	inc	dirnum		;bump directory
00DF25  2  D0 03        	bne	*+5
00DF27  2  EE A8 E3     	inc	dirnum+1
00DF2A  2  AD CC E3     	lda	maxdir		;if not at limit continue
00DF2D  2  CD A7 E3     	cmp	dirnum
00DF30  2  AD CD E3     	lda	maxdir+1
00DF33  2  ED A8 E3     	sbc	dirnum+1
00DF36  2  B0 05        	bcs	gtnxdr		;then continue
00DF38  2  68           	pla			;else clear stack
00DF39  2  AA           	tax			;and set x
00DF3A  2  4C D8 DF     	jmp	cldrnm		;set to invalid
00DF3D  2  AD A7 E3     gtnxdr:	lda	dirnum		;get low again
00DF40  2  29 03        	and	#%00000011	;look at 2 lsbs
00DF42  2  8D B3 E3     	sta	dirmod		;save mod 4
00DF45  2  0A           	asl	a		;multiply
00DF46  2  0A           	asl	a		;by
00DF47  2  0A           	asl	a		;32 to
00DF48  2  0A           	asl	a		;get pointer
00DF49  2  0A           	asl	a		;offset
00DF4A  2  8D A9 E3     	sta	subrec		;and save
00DF4D  2  F0 05        	beq	getdir		;if zero read new
00DF4F  2  68           	pla			;else clear stack
00DF50  2  AA           	tax			;set x
00DF51  2  4C 5C DF     	jmp	gotdir		;and exit
00DF54  2  20 8A DC     getdir:	jsr	drrcsu		;set up to read
00DF57  2  20 37 E0     	jsr	rdesec		;do read
00DF5A  2  68           	pla			;get operation
00DF5B  2  AA           	tax			;code
00DF5C  2               ;;;;;;	jsr	chksop		;do it
00DF5C  2  AD B3 E3     gotdir:	lda	dirmod		;and return
00DF5F  2  60           exnxdr:	rts			;with number
00DF60  2               ;checksum operation
00DF60  2               ;this routine assumes calling routine has checked for
00DF60  2               ;valid dirnum and hence valid dirrec
00DF60  2               ; input:chkflg,dirrec,x (1=update else check)
00DF60  2               ; returns:none
00DF60  2               ; alters:map@(chkmap)
00DF60  2  2C D0 E3     chksop:	bit	chkflg		;check flag
00DF63  2  30 FA        	bmi	exnxdr		;done if set
00DF65  2  CA           	dex			;dec code
00DF66  2  D0 09        	bne	tstchk		;if not zero test
00DF68  2  20 7A DD     	jsr	clcchk		;else calculate
00DF6B  2  20 C2 DF     	jsr	clcckp		;calculate pointer
00DF6E  2  91 08        	sta	(chkpnt),y	;and save
00DF70  2  60           	rts			;then return
00DF71  2  20 7A DD     tstchk:	jsr	clcchk		;do calculation
00DF74  2  20 C2 DF     	jsr	clcckp		;calculate pointer
00DF77  2  D1 08        	cmp	(chkpnt),y	;compare to old
00DF79  2  F0 E4        	beq	exnxdr		;if equal ok
00DF7B  2  4C 6D DD     	jmp	setron		;else set to r/o
00DF7E  2               ;get block number
00DF7E  2               ; input:nxtrec,blmode,fcb@(addinp),sxb,exm
00DF7E  2               ; returns:none
00DF7E  2               ; alters:all,blknum
00DF7E  2  AE BE E3     getblk:	ldx	sxb		;set x according to blkscd
00DF81  2  AD AF E3     	lda	nxtrec		;get next record
00DF84  2  4A           gblp:	lsr	a		;divide by 2 x times
00DF85  2  CA           	dex
00DF86  2  D0 FC        	bne	gblp
00DF88  2  8D AA E3     	sta	blknum		;save previous as temp
00DF8B  2               ;use extent as offset but first use sxb to create param
00DF8B  2  38           	sec
00DF8C  2  A9 08        	lda	#8
00DF8E  2  ED BE E3     	sbc	sxb
00DF91  2  AA           	tax
00DF92  2               ;now get extent from fcb
00DF92  2  A0 0C        	ldy	#12
00DF94  2  B1 02        	lda	(addinp),y
00DF96  2  2D D4 E3     	and	exm		;and with mask
00DF99  2  4A           	lsr	a		;shift with lsb to c
00DF9A  2  2A           gbxlp:	rol	a		;now go other way
00DF9B  2  CA           	dex
00DF9C  2  D0 FC        	bne	gbxlp
00DF9E  2  18           	clc			;now add saved value
00DF9F  2  6D AA E3     	adc	blknum		;back
00DFA2  2  2C BA E3     	bit	blmode		;test mode
00DFA5  2  10 01        	bpl	*+3		;skip if byte
00DFA7  2  0A           	asl	a		;else times two
00DFA8  2  18           	clc			;then add
00DFA9  2  69 10        	adc	#16		;offset into fcb
00DFAB  2  8D 8B E3     	sta	fcbind		;save for later
00DFAE  2  A8           	tay			;set index
00DFAF  2  B1 02        	lda	(addinp),y	;get number
00DFB1  2  8D AA E3     	sta	blknum		;store
00DFB4  2  C8           	iny
00DFB5  2  A9 00        	lda	#0		;clear
00DFB7  2  2C BA E3     	bit	blmode		;test mode
00DFBA  2  10 02        	bpl	*+4		;skip if byte
00DFBC  2  B1 02        	lda	(addinp),y	;else get high
00DFBE  2  8D AB E3     	sta	blknum+1	;high byte
00DFC1  2  60           	rts			;and return
00DFC2  2               ;calculate chkpnt as function of dirrec and chkmap
00DFC2  2               ; input:dirrec,chkmap
00DFC2  2               ; returns:y=0
00DFC2  2               ; alters:y,p,chkpnt
00DFC2  2  48           clcckp:	pha			;save a
00DFC3  2  18           	clc
00DFC4  2  AD B1 E3     	lda	dirrec		;add record number
00DFC7  2  6D D1 E3     	adc	chkmap		;to start
00DFCA  2  85 08        	sta	chkpnt
00DFCC  2  AD B2 E3     	lda	dirrec+1
00DFCF  2  6D D2 E3     	adc	chkmap+1
00DFD2  2  85 09        	sta	chkpnt+1
00DFD4  2  A0 00        	ldy	#0
00DFD6  2  68           	pla			;get a back
00DFD7  2  60           	rts
00DFD8  2               ;clear directory number to $ffff
00DFD8  2               ; input:none
00DFD8  2               ; returns:a=$ff,n=1,z=0
00DFD8  2               ; alters:a,p,dirnum,dirmod
00DFD8  2  A9 FF        cldrnm:	lda	#$ff		;set to $ff
00DFDA  2  8D A7 E3     	sta	dirnum
00DFDD  2  8D A8 E3     	sta	dirnum+1
00DFE0  2  8D B3 E3     	sta	dirmod
00DFE3  2  60           	rts
00DFE4  2               ;change allocation map
00DFE4  2               ; input:subrec,directory record @ (bufadd)
00DFE4  2               ; returns:none
00DFE4  2               ; alters:all,allocation map
00DFE4  2  18           mapdir:	clc			;add 16 to
00DFE5  2  AD A9 E3     	lda	subrec		;to subrec to point
00DFE8  2  69 10        	adc	#16		;to block number field
00DFEA  2  A8           	tay			;make index
00DFEB  2  8C B8 E3     lpmpdr:	sty	mpdrsy		;save index
00DFEE  2  8A           	txa			;save x
00DFEF  2  48           	pha			;operation
00DFF0  2  B1 04        	lda	(bufadd),y	;get block number
00DFF2  2  8D B9 E3     	sta	mpdrtm		;save in temp
00DFF5  2  C8           	iny			;bump index for word
00DFF6  2  20 78 E0     	jsr	gthibn		;get high part of number
00DFF9  2  0D B9 E3     mpdrnw:	ora	mpdrtm		;see if zero
00DFFC  2  F0 0A        	beq	skpedr		;skip if zero
00DFFE  2  20 78 E0     	jsr	gthibn		;get high again
00E001  2  A8           	tay			;move to y
00E002  2  AD B9 E3     	lda	mpdrtm		;get low again
00E005  2  20 57 DD     	jsr	altalc		;else alter map
00E008  2  68           skpedr:	pla			;get operation
00E009  2  AA           	tax			;back
00E00A  2  AC B8 E3     	ldy	mpdrsy		;get index back
00E00D  2  C8           	iny			;bump it
00E00E  2  98           	tya			;if still
00E00F  2  29 0F        	and	#%00001111	;in field
00E011  2  D0 D8        	bne	lpmpdr		;then loop
00E013  2  60           	rts			;else quit
00E014  2               ;test r/w status
00E014  2               ;does warm boot if r/o
00E014  2               ; input:curdrv,ronlst
00E014  2               ; returns:none
00E014  2               ; alters:a,x,p
00E014  2  20 85 DD     tstron:	jsr	chkron		;test bit
00E017  2  F0 1D        	beq	exttro		;exit if r/w
00E019  2  20 66 E0     	jsr	errout		;else send error
00E01C  2  AD E6 E2     	lda	rommvc		;point to r/o
00E01F  2  AC E7 E2     	ldy	rommvc+1	;message
00E022  2  20 CA E0     	jsr	sndstr		;send it
00E025  2  4C EA D8     	jmp	xwboot		;then abort
00E028  2               ;set current drive to r/w
00E028  2               ; input:curdrv,ronlst
00E028  2               ; returns:ronlst
00E028  2               ; alters:a,x,p,ronlst
00E028  2  AE A4 E3     setrw:	ldx	curdrv		;get drive
00E02B  2  BD 7A E3     	lda	bitmap,x	;and mask
00E02E  2  49 FF        	eor	#$ff		;complement
00E030  2  2D A6 E3     	and	ronlst		;and with status
00E033  2  8D A6 E3     	sta	ronlst		;save
00E036  2  60           exttro:	rts			;return
00E037  2               ;read sector
00E037  2  20 77 E4     rdesec:	jsr	sim+39		;do read
00E03A  2               
00E03A  2  4C 49 E0     	jmp	chkrwe		;check for error
00E03D  2               ;update checksum and directory
00E03D  2  A2 01        updtck:	ldx	#1		;set for update
00E03F  2               ;;;;;	jsr	chksop		;do it
00E03F  2  A9 01        	lda	#1		;say is directory op
00E041  2  D0 03        	bne	secwrt		;do it
00E043  2               ;write sector
00E043  2  AD D3 E3     wrtsec:	lda	pemwrtype		;get write type
00E046  2  20 7A E4     secwrt:	jsr	sim+42		;do write
00E049  2               
00E049  2  C9 00        chkrwe:	cmp	#0		;if not ok
00E04B  2  F0 E9        	beq	exttro		;done if zero
00E04D  2               ;read/write error
00E04D  2  20 66 E0     rwerrt:	jsr	errout		;send error message
00E050  2  AD E9 E2     	lda	bdsmvc		;point to
00E053  2  AC EA E2     	ldy	bdsmvc+1	;bad sector message
00E056  2  20 CA E0     	jsr	sndstr		;and send
00E059  2  20 85 E0     	jsr	getcon		;get input
00E05C  2  C9 0D        	cmp	#cr		;if a cr
00E05E  2  F0 03        	beq	ignerr		;then continue
00E060  2  4C EA D8     	jmp	xwboot		;else abort
00E063  2  4C 61 E2     ignerr:	jmp	pcrlf		;crlf and return
00E066  2               ;error output routine
00E066  2               ; input:curdrv,pemmvc
00E066  2               ; returns:none
00E066  2               ; alters:all
00E066  2  AD EC E2     errout:	lda	pemmvc		;point to
00E069  2  AC ED E2     	ldy	pemmvc+1	;error message
00E06C  2  20 CA E0     	jsr	sndstr		;send it
00E06F  2  AD A4 E3     	lda	curdrv		;get drive number
00E072  2  18           	clc			;add
00E073  2  69 41        	adc	#'A'		;ascii a
00E075  2  4C 13 E1     	jmp	sndchr		;and send it
00E078  2               ;get high part of block number if word (zero if byte)
00E078  2               ; input:y=index to high,blmode,directory@(bufadd)+subrec
00E078  2               ; returns:a=high part of block number
00E078  2               ; alters:a,p,mpdrsy iff word
00E078  2  A9 00        gthibn:	lda	#0		;preset for byte
00E07A  2  2C BA E3     	bit	blmode		;test mode
00E07D  2  10 05        	bpl	gthiex		;done if byte
00E07F  2  B1 04        	lda	(bufadd),y	;get high
00E081  2  8C B8 E3     	sty	mpdrsy		;alter y
00E084  2  60           gthiex:	rts
00E085  2               ;get console input
00E085  2               ; input:pndkey
00E085  2               ; returns:a=character
00E085  2               ; alters:all,pndkey
00E085  2               getcon:
00E085  2  AD 8E E3     	lda	pndkey		;get pending
00E088  2  48           	pha			;save it
00E089  2  A9 00        	lda	#0		;clear
00E08B  2  8D 8E E3     	sta	pndkey		;pending
00E08E  2  68           	pla			;restore
00E08F  2  D0 03        	bne	extget		;exit if not null
00E091  2  20 59 E4     	jsr	sim+9		;else get new
00E094  2               
00E094  2  60           extget:	rts			;and return
00E095  2               ;check keyboard status
00E095  2               ;handles <ctl-s> for freeze and <ctl-c> for boot
00E095  2               ; input:pndkey
00E095  2               ; returns:a=0 if no input or <>0 if input
00E095  2               ; alters:all,pndkey
00E095  2               kbdsts:
00E095  2  AD 8E E3     	lda	pndkey		;get pending
00E098  2  D0 20        	bne	extkbd		;if there quit
00E09A  2  20 56 E4     	jsr	sim+6		;else test
00E09D  2  C9 00        	CMP	#$00		;if zero
00E09F  2  F0 19        	beq	extkbd		;exit
00E0A1  2  20 59 E4     	jsr	sim+9		;else get input
00E0A4  2  C9 13        	cmp	#ctls		;if not freeze
00E0A6  2  D0 0D        	bne	newpnd		;save input
00E0A8  2  20 59 E4     	jsr	sim+9		;else wait for more
00E0AB  2  C9 03        	cmp	#ctlc		;if not abort
00E0AD  2  D0 03        	bne	nowarm		;then jump
00E0AF  2  4C EA D8     	jmp	xwboot		;else do warm boot
00E0B2  2  A9 00        nowarm:	lda	#0		;clear
00E0B4  2  60           	rts			;and return
00E0B5  2  8D 8E E3     newpnd:	sta	pndkey		;save
00E0B8  2  A9 FF        	lda	#$ff		;set ready
00E0BA  2               extkbd:
00E0BA  2  60           	rts			;and return
00E0BB  2               ;test character
00E0BB  2               ; input:a=character
00E0BB  2               ; returns:c=0 if control or c=1 if printing
00E0BB  2               ; alters:p
00E0BB  2  C9 0D        tstchr:	cmp	#cr		;if cr
00E0BD  2  F0 0A        	beq	chtext		;quit
00E0BF  2  C9 0A        	cmp	#lf		;if linefeed
00E0C1  2  F0 06        	beq	chtext		;quit
00E0C3  2  C9 09        	cmp	#ctli		;if tab
00E0C5  2  F0 02        	beq	chtext		;quit
00E0C7  2  C9 20        	cmp	#' '		;see if control
00E0C9  2  60           chtext:	rts			;and return
00E0CA  2               ;send string ending in $
00E0CA  2               ; input:ay=string address
00E0CA  2               ; returns:none
00E0CA  2               ; alters:all,index,sndlpe+1 and +2
00E0CA  2  8D D3 E0     sndstr:	sta	sndlpe+1	;set pointer
00E0CD  2  8C D4 E0     	sty	sndlpe+2
00E0D0  2  A0 00        	ldy	#0
00E0D2  2  B9 FF FF     sndlpe:	lda	$ffff,y		;get char
00E0D5  2  C9 24        	cmp	#'$'		;if terminator
00E0D7  2  F0 0C        	beq	sndext		;then exit
00E0D9  2  C8           	iny			;else bump
00E0DA  2  8C B4 E3     	sty	index		;and save
00E0DD  2  20 13 E1     	jsr	sndchr		;send char
00E0E0  2  AC B4 E3     	ldy	index		;get index
00E0E3  2  D0 ED        	bne	sndlpe		;and loop
00E0E5  2  60           sndext:	rts			;return
00E0E6  2               ;send char to printer if enabled
00E0E6  2               ; input:a=character,lstflg
00E0E6  2               ; returns:a=character
00E0E6  2               ; alters:x,y,p
00E0E6  2               lstout:
00E0E6  2  2C 8F E3     	bit	lstflg		;test flag
00E0E9  2  10 0A        	bpl	extlst		;exit if off
00E0EB  2  2C B6 E3     	bit	outflg		;test output flag
00E0EE  2  30 05        	bmi	extlst		;done if set
00E0F0  2  48           	pha			;save char
00E0F1  2  20 5F E4     	jsr	sim+15		;send
00E0F4  2  68           	pla			;get char
00E0F5  2  60           extlst:	rts			;and done
00E0F6  2               ;output a character
00E0F6  2               ; input:a=character,console definition block in sim
00E0F6  2               ; returns:none
00E0F6  2               ; alters:all,positn
00E0F6  2  20 BB E0     output:	jsr	tstchr		;test it
00E0F9  2  B0 18        	bcs	sndchr		;if not control jump
00E0FB  2  48           	pha			;else save
00E0FC  2  AD 8A E4     	lda	sysdef+4	;get invert
00E0FF  2  20 2C E1     	jsr	nolist		;send to console
00E102  2  A9 5E        	lda	#'^'		;get arrow
00E104  2  20 E6 E0     	jsr	lstout		;send to printer
00E107  2  68           	pla			;get character
00E108  2  09 40        	ora	#'A'-1		;convert to ascii
00E10A  2  20 24 E1     	jsr	pchrot		;send to all
00E10D  2  AD 89 E4     	lda	sysdef+3	;get normal
00E110  2  4C 2C E1     	jmp	nolist		;to console
00E113  2  C9 09        sndchr:	cmp	#ctli		;if not tab
00E115  2  D0 0D        	bne	pchrot		;send
00E117  2  A9 20        tabspc:	lda	#' '		;else get space
00E119  2  20 24 E1     	jsr	pchrot		;send
00E11C  2  AD 90 E3     	lda	positn		;get count
00E11F  2  29 07        	and	#7		;if not mod 8
00E121  2  D0 F4        	bne	tabspc		;loop
00E123  2  60           	rts			;else exit
00E124  2  48           pchrot:	pha			;save char
00E125  2  20 95 E0     	jsr	kbdsts		;test input
00E128  2  68           	pla			;restore
00E129  2  20 E6 E0     	jsr	lstout		;to printer if on
00E12C  2  48           nolist:	pha			;save again
00E12D  2  2C B6 E3     	bit	outflg		;test flag
00E130  2  30 03        	bmi	*+5		;done if set
00E132  2  20 5C E4     	jsr	sim+12		;to console
00E135  2  68           	pla			;restore
00E136  2  EE 90 E3     	inc	positn		;bump col
00E139  2  C9 20        	cmp	#' '		;if space or more
00E13B  2  B0 26        	bcs	extchr		;is ok
00E13D  2  CD 88 E4     	cmp	sysdef+2	;also ok
00E140  2  F0 21        	beq	extchr		;if forward
00E142  2  CE 90 E3     	dec	positn		;else drop back
00E145  2  CD 86 E4     	cmp	sysdef+0	;see if bs
00E148  2  D0 06        	bne	tryotr		;branch if not
00E14A  2  CE 90 E3     	dec	positn		;else drop again
00E14D  2  30 0F        	bmi	zrocol		;zero if <0
00E14F  2  60           	rts			;else ok
00E150  2  C9 0D        tryotr:	cmp	#cr		;if a cr
00E152  2  F0 0A        	beq	zrocol		;clear col
00E154  2  CD 8D E4     	cmp	sysdef+7	;if a formfeed
00E157  2  F0 05        	beq	zrocol		;also clear
00E159  2  CD 8E E4     	cmp	sysdef+8	;if not home
00E15C  2  D0 05        	bne	extchr		;then done
00E15E  2  A9 00        zrocol:	lda	#0		;clear
00E160  2  8D 90 E3     	sta	positn		;column
00E163  2  60           extchr:	rts			;and exit
00E164  2               ;go to left and space past prompt
00E164  2               ; input:frscol,positn
00E164  2               ; returns:none
00E164  2               ; alters:positn
00E164  2  A9 0D        spcovr:	lda	#cr		;get cr
00E166  2  20 24 E1     	jsr	pchrot		;send to all
00E169  2  A9 0A        	lda	#lf		;send lf
00E16B  2  20 E6 E0     	jsr	lstout		;only to printer
00E16E  2  AD 8D E3     mreovr:	lda	frscol		;get first
00E171  2  CD 90 E3     	cmp	positn		;see if there
00E174  2  F0 ED        	beq	extchr		;done if is
00E176  2  AD 88 E4     	lda	sysdef+2	;get forward
00E179  2  20 2C E1     	jsr	nolist		;send it
00E17C  2  4C 6E E1     	jmp	mreovr		;and loop
00E17F  2               ;buffered read
00E17F  2               ; input:buffer@(addinp)
00E17F  2               ; returns:none
00E17F  2               ; alters:all,buffer@(addinp)
00E17F  2  A9 00        bufinp:	lda	#0		;clear
00E181  2  A0 01        	ldy	#1		;length
00E183  2  91 02        	sta	(addinp),y	;position in buffer
00E185  2  8C 97 E3     	sty	bufpsn		;set point to 1
00E188  2  AD 90 E3     	lda	positn		;get current
00E18B  2  8D 8D E3     	sta	frscol		;and save
00E18E  2  20 85 E0     nxtinp:	jsr	getcon		;get input
00E191  2  AC 97 E3     	ldy	bufpsn		;get index
00E194  2  C9 0D        	cmp	#cr		;if not a cr
00E196  2  D0 03        	bne	notcr		;then jump
00E198  2  4C 5E E2     	jmp	endlin		;else done
00E19B  2  C9 08        notcr:	cmp	#delete		;if not delete
00E19D  2  D0 5E        	bne	ntdelt		;then jump
00E19F  2  C0 01        	cpy	#1		;else if start
00E1A1  2  F0 EB        	beq	nxtinp		;then loop
00E1A3  2  B1 02        	lda	(addinp),y	;get last
00E1A5  2  48           	pha			;save char
00E1A6  2  A0 01        	ldy	#1		;point to count
00E1A8  2  38           	sec			;set carry
00E1A9  2  B1 02        	lda	(addinp),y	;get count
00E1AB  2  E9 01        	sbc	#1		;decrement
00E1AD  2  91 02        	sta	(addinp),y	;then save
00E1AF  2  68           	pla			;restore char
00E1B0  2  CE 97 E3     	dec	bufpsn		;backup pointer
00E1B3  2  C9 20        	cmp	#' '		;if space or more
00E1B5  2  B0 40        	bcs	nrmbs		;just backspace
00E1B7  2  C9 09        	cmp	#ctli		;see if tab
00E1B9  2  D0 30        	bne	ctlbs		;if not is control
00E1BB  2  38           	sec			;set flag
00E1BC  2  6E B6 E3     	ror	outflg
00E1BF  2  AD 90 E3     	lda	positn		;get position and save
00E1C2  2  8D B7 E3     	sta	lstcol
00E1C5  2  20 64 E1     	jsr	spcovr		;else go back
00E1C8  2  20 6B E2     	jsr	rptlne		;and retype
00E1CB  2  AD 90 E3     	lda	positn		;get new last position
00E1CE  2  48           	pha			;save on stack
00E1CF  2  38           	sec			;subtract to get delta
00E1D0  2  AD B7 E3     	lda	lstcol
00E1D3  2  ED 90 E3     	sbc	positn
00E1D6  2  8D B7 E3     	sta	lstcol		;and save
00E1D9  2  0E B6 E3     	asl	outflg		;clear flag
00E1DC  2  20 8B E2     bstab:	jsr	dobs		;do one
00E1DF  2  CE B7 E3     	dec	lstcol		;drop count
00E1E2  2  D0 F8        	bne	bstab		;loop if more
00E1E4  2  68           	pla			;get position
00E1E5  2  8D 90 E3     	sta	positn		;and set
00E1E8  2  4C 8E E1     	jmp	nxtinp		;then loop
00E1EB  2  AD 89 E4     ctlbs:	lda	sysdef+3	;get normal
00E1EE  2  20 87 E2     	jsr	chkbs		;bs if printing
00E1F1  2  AD 8A E4     	lda	sysdef+4	;same for invert
00E1F4  2  20 87 E2     	jsr	chkbs		;then delete char itself
00E1F7  2  20 8B E2     nrmbs:	jsr	dobs		;do a backspace
00E1FA  2  4C 8E E1     	jmp	nxtinp		;and loop
00E1FD  2  C9 10        ntdelt:	cmp	#ctlp		;if not ctl-p
00E1FF  2  D0 0B        	bne	ntctlp		;then jump
00E201  2  AD 8F E3     	lda	lstflg		;else get printer flag
00E204  2  49 FF        	eor	#$ff		;complement
00E206  2  8D 8F E3     	sta	lstflg		;save
00E209  2  4C 8E E1     	jmp	nxtinp		;and loop
00E20C  2  C9 18        ntctlp:	cmp	#ctlx		;if not ctl-x
00E20E  2  D0 0C        	bne	ntctlx		;then jump
00E210  2  20 64 E1     	jsr	spcovr		;restart
00E213  2  AD 87 E4     	lda	sysdef+1	;get clear to eol
00E216  2  20 2C E1     	jsr	nolist		;send it
00E219  2  4C 7F E1     	jmp	bufinp		;and start over
00E21C  2  C9 12        ntctlx:	cmp	#ctlr		;if not ctl-r
00E21E  2  D0 09        	bne	ntctlr		;then jump
00E220  2  20 64 E1     	jsr	spcovr		;restart
00E223  2  20 6B E2     	jsr	rptlne		;retype line
00E226  2  4C 8E E1     	jmp	nxtinp		;and start over
00E229  2  C8           ntctlr:	iny			;next position
00E22A  2  91 02        	sta	(addinp),y	;store char
00E22C  2  48           	pha			;and save
00E22D  2  8C 97 E3     	sty	bufpsn		;index
00E230  2  A0 01        	ldy	#1		;point to count
00E232  2  98           	tya			;set a to 1
00E233  2  18           	clc			;then
00E234  2  71 02        	adc	(addinp),y	;add count
00E236  2  91 02        	sta	(addinp),y	;and save
00E238  2  68           	pla			;restore char
00E239  2  20 F6 E0     dontsv:	jsr	output		;send char
00E23C  2  AC 97 E3     	ldy	bufpsn		;get index
00E23F  2  B1 02        	lda	(addinp),y	;get char
00E241  2  C9 03        	cmp	#ctlc		;if not ctl-c
00E243  2  D0 0B        	bne	ignrcc		;ignore
00E245  2  A0 01        	ldy	#1		;get count
00E247  2  B1 02        	lda	(addinp),y	;from buffer
00E249  2  C9 01        	cmp	#1		;if not at start
00E24B  2  D0 03        	bne	ignrcc		;ignore
00E24D  2  4C EA D8     	jmp	xwboot		;else do warm boot
00E250  2  A0 01        ignrcc:	ldy	#1		;get
00E252  2  B1 02        	lda	(addinp),y	;count
00E254  2  88           	dey			;point to max
00E255  2  D1 02        	cmp	(addinp),y	;if length
00E257  2  B0 03        	bcs	lineen		;at max jump
00E259  2  4C 8E E1     	jmp	nxtinp		;else loop
00E25C  2  A9 0D        lineen:	lda	#cr		;get a cr
00E25E  2  4C 24 E1     endlin:	jmp	pchrot		;and send
00E261  2               ;cr and lf
00E261  2  A9 0D        pcrlf:	lda	#cr		;then a
00E263  2  20 24 E1     	jsr	pchrot		;cr
00E266  2  A9 0A        	lda	#lf		;and a
00E268  2  4C 24 E1     	jmp	pchrot		;lf
00E26B  2               ;retype line
00E26B  2  AD 97 E3     rptlne:	lda	bufpsn		;save point
00E26E  2  8D B5 E3     	sta	numcnt		;as count
00E271  2  A9 01        	lda	#1		;start position
00E273  2  48           	pha			;save
00E274  2  68           mrerpt:	pla			;get position
00E275  2  CE B5 E3     	dec	numcnt		;count down
00E278  2  D0 01        	bne	*+3		;continue if more
00E27A  2  60           	rts			;else done
00E27B  2  A8           	tay			;else make index
00E27C  2  C8           	iny			;and bump
00E27D  2  98           	tya			;save
00E27E  2  48           	pha			;on stack
00E27F  2  B1 02        	lda	(addinp),y	;get char
00E281  2  20 F6 E0     	jsr	output		;send
00E284  2  4C 74 E2     	jmp	mrerpt		;and loop
00E287  2               ;check for printing and backspace if needed
00E287  2  C9 20        chkbs:	cmp	#' '		;compare to space
00E289  2  90 19        	bcc	extdec		;not printing so done
00E28B  2               ;do a backspace
00E28B  2  AD 86 E4     dobs:	lda	sysdef+0	;get backspace
00E28E  2  48           	pha			;save it
00E28F  2  20 2C E1     	jsr	nolist		;send
00E292  2  A9 20        	lda	#' '		;get space
00E294  2  20 2C E1     	jsr	nolist		;send
00E297  2  68           	pla			;get backspace
00E298  2  4C 2C E1     	jmp	nolist		;send it
00E29B  2               ;test for decimal digit
00E29B  2               ;if decimal then c=0 else c=1
00E29B  2  C9 30        tstdec:	cmp	#'0'		;if under 0
00E29D  2  90 04        	bcc	notdec		;then not decimal
00E29F  2  C9 3A        	cmp	#'9'+1		;if 9 or under is ok
00E2A1  2  90 01        	bcc	extdec
00E2A3  2  38           notdec:	sec			;else not a match
00E2A4  2  60           extdec:	rts
00E2A5  2               ;test for hexadecimal digit
00E2A5  2               ;if hex then c=0 else c=1
00E2A5  2  20 9B E2     tsthex:	jsr	tstdec		;first try decimal
00E2A8  2  90 FA        	bcc	extdec		;ok if dec
00E2AA  2  C9 41        	cmp	#'A'		;if under A
00E2AC  2  90 F5        	bcc	notdec		;then not hex
00E2AE  2  C9 47        	cmp	#'F'+1		;set c in F compare
00E2B0  2  60           	rts
00E2B1  2               ;bump load address by 128 and return in ay
00E2B1  2  AD F3 D7     adjdb:	lda	dskbuf		;get old
00E2B4  2  AC F4 D7     	ldy	dskbuf+1	;address
00E2B7  2  18           	clc			;and bump
00E2B8  2  69 80        	adc	#128		;by 128
00E2BA  2  8D F3 D7     	sta	dskbuf		;save low
00E2BD  2  90 04        	bcc	*+6		;then bump
00E2BF  2  C8           	iny			;and save
00E2C0  2  8C F4 D7     	sty	dskbuf+1	;high as needed
00E2C3  2  60           	rts
00E2C4  2               ;move record from disk buffer to default buffer
00E2C4  2  AD F3 D7     mv128:	lda	dskbuf		;get address
00E2C7  2  AC F4 D7     	ldy	dskbuf+1
00E2CA  2  8D D3 E2     	sta	mvfrom+1	;and set pointer
00E2CD  2  8C D4 E2     	sty	mvfrom+2
00E2D0  2  A2 00        	ldx	#0		;clear index
00E2D2  2  BD FF FF     mvfrom:	lda	$ffff,x		;get byte
00E2D5  2  9D 28 01     	sta	dflbuf,x	;move it
00E2D8  2  E8           	inx
00E2D9  2  10 F7        	bpl	mvfrom		;loop until done
00E2DB  2  60           	rts
00E2DC  2               
00E2DC  2               ;relocatable vectors
00E2DC  2  4C           	.byte	$4c
00E2DD  2  49 D8        extevc:	.word	extexq-1
00E2DF  2  4C           	.byte	$4c
00E2E0  2  3C E3        sltmvc:	.word	sltmsg
00E2E2  2  4C           	.byte	$4c
00E2E3  2  4D E3        empdvc:	.word	empty
00E2E5  2  4C           	.byte	$4c
00E2E6  2  F2 E2        rommvc:	.word	romsg
00E2E8  2  4C           	.byte	$4c
00E2E9  2  F9 E2        bdsmvc:	.word	bdsmsg
00E2EB  2  4C           	.byte	$4c
00E2EC  2  2C E3        pemmvc:	.word	pemmsg
00E2EE  2  4C           	.byte	$4c
00E2EF  2  C5 E3        dcbevc:	.word	dcb
00E2F1  2               ;relocation stopper
00E2F1  2  FF           	.byte	$ff
00E2F2  2               ;messages
00E2F2  2  20 2D 20 52  romsg:	.byte	" - R/O$"
00E2F6  2  2F 4F 24     
00E2F9  2  20 2D 20 42  bdsmsg:	.byte	" - BAD SECTOR"
00E2FD  2  41 44 20 53  
00E301  2  45 43 54 4F  
00E306  2  0D 0A 3C 52  	.byte	cr,lf,"<RET> TO IGNORE -- <OTHER> "
00E30A  2  45 54 3E 20  
00E30E  2  54 4F 20 49  
00E323  2  54 4F 20 41  	.byte	"TO ABORT$"
00E327  2  42 4F 52 54  
00E32B  2  24           
00E32C  2  0D 0A 50 45  pemmsg:	.byte	cr,lf,"PEM ERROR ON $"
00E330  2  4D 20 45 52  
00E334  2  52 4F 52 20  
00E33C  2  20 2D 20 49  sltmsg:	.byte	" - INVALID DRIVE$"
00E340  2  4E 56 41 4C  
00E344  2  49 44 20 44  
00E34D  2               
00E34D  2               ;dummy fcb
00E34D  2  E5           empty:	.byte	$e5
00E34E  2               ;zero page switch enable table
00E34E  2  00 00 00 00  swctbl:	.byte	0,0,0,0,0,0,0,0
00E352  2  00 00 00 00  
00E356  2  00 00 01 00  	.byte	0,0,1,0,0,1,1,1
00E35A  2  00 01 01 01  
00E35E  2  01 01 01 01  	.byte	1,1,1,1,1,1,1,1
00E362  2  01 01 01 01  
00E366  2  00 00 01 00  	.byte	0,0,1,0,0,0,0,0
00E36A  2  00 00 00 00  
00E36E  2  00 00 00 00  	.byte	0,0,0,0
00E372  2               ;bit mask table
00E372  2  80 40 20 10  bitmsk:	.byte	128,64,32,16,8,4,2,1
00E376  2  08 04 02 01  
00E37A  2               ;bit map table
00E37A  2  01 02 04 08  bitmap:	.byte	1,2,4,8,16,32,64,128
00E37E  2  10 20 40 80  
00E382  2               ;extent mask table (also uses 3 bytes in sabtbl
00E382  2  00 01 03     exmtbl:	.byte	0,1,3
00E385  2               ;sab table
00E385  2  07 0F 1F 3F  sabtbl:	.byte	7,15,31,63,127
00E389  2  7F           
00E38A  2               ;variable storage
00E38A  2  00           skpdir:	.byte	0		;positive if no change
00E38B  2  00           fcbind:	.byte	0		;index to block number
00E38C  2  00           savext:	.byte	0		;save extent
00E38D  2  00           frscol:	.byte	0		;first col
00E38E  2  00           pndkey:	.byte	0		;pending input
00E38F  2  00           lstflg:	.byte	0		;printer flag
00E390  2  00           positn:	.byte	0		;print position
00E391  2  00           swcflg:	.byte	0		;zero page switch flag
00E392  2  00 00        bytinp:	.word	0		;input value
00E394  2  00           cmdinp:	.byte	0		;input command
00E395  2  00 00        addout:	.word	0		;output address
00E397  2               bytout	=	addout		;output value
00E397  2  00           bufpsn:	.byte	0		;input buffer position
00E398  2  00           exrwfl:	.byte	0		;extend flag
00E399  2  00           tmpdrv:	.byte	0		;temporary drive number
00E39A  2               ;align xqtvec on word boundary
00E39A  2               	.align 2
00E39A  2  00 00        xqtvec:	.word	0		;command vector
00E39C  2  00 00        countr:	.word	0		;record counter
00E39E  2  00           	.byte	0		;overflow
00E39F  2  00 00        lkdown:	.word	0		;down pnt. for block search
00E3A1  2  00 00        lookup:	.word	0		;up pnt. for block search
00E3A3  2  00           olddrv:	.byte	0		;old drive number
00E3A4  2  00           curdrv:	.byte	0		;current drive
00E3A5  2  00           lginvc:	.byte	0		;log in status
00E3A6  2  00           ronlst:	.byte	0		;read write status
00E3A7  2  00 00        dirnum:	.word	0		;directory number
00E3A9  2  00           subrec:	.byte	0		;directory offset
00E3AA  2  00 00        recnum:	.word	0		;record number
00E3AC  2               blknum	=	recnum		;block number
00E3AC  2  00           	.byte	0		;overflow
00E3AD  2  00           chrcnt:	.byte	0		;character count
00E3AE  2  00           cmppnt:	.byte	0		;comparison pointer
00E3AF  2  00           nxtrec:	.byte	0		;next record
00E3B0  2  00           numrec:	.byte	0		;number records
00E3B1  2  00 00        dirrec:	.word	0		;directory record
00E3B3  2  00           dirmod:	.byte	0		;directory mod 4
00E3B4  2  00           index:	.byte	0		;buffer index
00E3B5  2  00           numcnt:	.byte	0		;counter
00E3B6  2  00           outflg:	.byte	0		;output enable flag
00E3B7  2  00           lstcol:	.byte	0		;last column
00E3B8  2  00           mpdrsy:	.byte	0		;save for y in mapdir
00E3B9  2  00           mpdrtm:	.byte	0		;temp in mapdir
00E3BA  2  00           blmode:	.byte	0		;<128 if byte else word
00E3BB  2  00 00        maxdrc:	.word	0		;max directory record
00E3BD  2  00           sab:	.byte	0		;mask for block
00E3BE  2  00           sxb:	.byte	0		;shift for block
00E3BF  2  00 00 00     rtclk:	.byte	0,0,0		;real time clock
00E3C2  2  00 00        gpcnt:	.word	0		;gp counter
00E3C4  2  00           trkctr:	.byte	0		;track counter
00E3C5  2               ;following region is used to capture dcb
00E3C5  2               dcb:
00E3C5  2  00 00        maxblk:	.word	0		;maximum block number
00E3C7  2  00 00        sectrk:	.word	0		;sectors per track
00E3C9  2  00 00        nsystr:	.word	0		;number system tracks
00E3CB  2  00           blkscd:	.byte	0		;block size code
00E3CC  2  00 00        maxdir:	.word	0		;maximum directory number
00E3CE  2  00 00        alcmap:	.word	0		;address of allocation map
00E3D0  2  00           chkflg:	.byte	0		;check flag
00E3D1  2  00 00        chkmap:	.word	0		;address of checksum map
00E3D3  2  00           pemwrtype:	.byte	0		;write type 0=norm,1=dir,2=unalloc
00E3D4  2  00           exm:	.byte	0		;extent mask
00E3D5  2  00           cexm1f:	.byte	0		;exm complemented and 1f
00E3D6  2               ;zero page save block
00E3D6  2               varblk:
00E3D6  2  00 00        lowin:	.word	0
00E3D8  2  00 00        	.word	0		;save bufadd
00E3DA  2  00 00        	.word	0		;save alcpnt
00E3DC  2  00 00        	.word	0		;save chkpnt
00E3DE  2               
00E3DE  1               		.include "simnhy.asm"
00E3DE  2               ;________________________________________________________________________________________________________________________________
00E3DE  2               ;
00E3DE  2               ; Nhyodyne dos / 65 system interface module (sim)
00E3DE  2               ;
00E3DE  2               ; DWERNER 12 / 20 / 2021 ported to Nhyodyne
00E3DE  2               ;________________________________________________________________________________________________________________________________
00E3DE  2               
00E3DE  2               .include "macro.asm"
00E3DE  3               ;__MACRO___________________________________________________________________________________________________________________
00E3DE  3               ;
00E3DE  3               ; 	Macros for the betterment of Mankind
00E3DE  3               ;________________________________________________________________________________________________________________________________
00E3DE  3               ;
00E3DE  3               
00E3DE  3               .macro          PRTDBG      message
00E3DE  3               .LOCAL p1
00E3DE  3               .LOCAL p2
00E3DE  3               .LOCAL p3
00E3DE  3               .LOCAL p4
00E3DE  3               .LOCAL p5
00E3DE  3                 .if     .paramcount <> 1
00E3DE  3                       .error  "Too few parameters for macro PRTDBG"
00E3DE  3                       .endif
00E3DE  3                       .if DEBUG=1
00E3DE  3                       PHA
00E3DE  3                       PHX
00E3DE  3                       PHY
00E3DE  3                       LDX #$00
00E3DE  3               p1:
00E3DE  3                       LDA p4,x
00E3DE  3                       INX
00E3DE  3                       CMP #'$'
00E3DE  3                       BEQ p2
00E3DE  3                       JSR conwrt
00E3DE  3                       JMP p1
00E3DE  3               p2:
00E3DE  3                       LDA #13
00E3DE  3                       jsr conwrt
00E3DE  3                       LDA #10
00E3DE  3                       jsr conwrt
00E3DE  3                       PLY
00E3DE  3                       plx
00E3DE  3                       pla
00E3DE  3                       JMP p5
00E3DE  3               p4:
00E3DE  3                       .BYTE message
00E3DE  3               p5:
00E3DE  3                       .endif
00E3DE  3               .endmacro
00E3DE  3               
00E3DE  3               .macro          PRTS      message
00E3DE  3               .LOCAL p1
00E3DE  3               .LOCAL p2
00E3DE  3               .LOCAL p3
00E3DE  3               .LOCAL p4
00E3DE  3               .LOCAL p5
00E3DE  3                 .if     .paramcount <> 1
00E3DE  3                       .error  "Too few parameters for macro PRTS"
00E3DE  3                       .endif
00E3DE  3                       PHA
00E3DE  3                       PHX
00E3DE  3                       PHY
00E3DE  3                       LDX #$00
00E3DE  3               p1:
00E3DE  3                       LDA p4,x
00E3DE  3                       INX
00E3DE  3                       CMP #'$'
00E3DE  3                       BEQ p2
00E3DE  3                       JSR conwrt
00E3DE  3                       JMP p1
00E3DE  3               p2:
00E3DE  3                       PLY
00E3DE  3                       plx
00E3DE  3                       pla
00E3DE  3                       JMP p5
00E3DE  3               p4:
00E3DE  3                       .BYTE message
00E3DE  3               p5:
00E3DE  3               .endmacro
00E3DE  3               
00E3DE  3               
00E3DE  3               
00E3DE  3               
00E3DE  3               ;__PRTHEXBYTE__________________________________________________
00E3DE  3               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
00E3DE  3               ;______________________________________________________________
00E3DE  3               PRTHEXBYTE:
00E3DE  3  48                   PHA
00E3DF  3  DA                   PHX
00E3E0  3  5A                   PHY
00E3E1  3  AA                   TAX				; SAVE A REGISTER
00E3E2  3  4A                   LSR 				; SHIFT HIGH NIBBLE TO LOW NIBBLE
00E3E3  3  4A                   LSR 				;
00E3E4  3  4A                   LSR 				;
00E3E5  3  4A                   LSR 				;
00E3E6  3  18                   CLC               		; CLEAR CARRY
00E3E7  3  20 F2 E3             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
00E3EA  3  8A                   TXA				; RESTORE ACCUMULATOR
00E3EB  3  20 F2 E3             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
00E3EE  3  7A                   PLY
00E3EF  3  FA                   plx
00E3F0  3  68                   PLA
00E3F1  3  60                   RTS
00E3F2  3               
00E3F2  3               ;__PRINT_DIGIT_________________________________________________
00E3F2  3               ;
00E3F2  3               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
00E3F2  3               ;
00E3F2  3               ;______________________________________________________________
00E3F2  3               PRINT_DIGIT:
00E3F2  3  29 0F                       AND #$0F				; STRIP OFF HIGH NIBBLE
00E3F4  3  09 30                       ORA #$30				; ADD $30 TO PRODUCE ASCII
00E3F6  3  C9 3A                       CMP #$3A               		; IS GREATER THAN 9
00E3F8  3  30 03                       BMI PRINT_DIGIT_OUT		; NO, SKIP ADD
00E3FA  3  18                          CLC				; CLEAR CARRY
00E3FB  3  69 07                       ADC #$07				; ADD ON FOR LETTER VALUES
00E3FD  3               PRINT_DIGIT_OUT:					;
00E3FD  3  4C 02 E7                    JMP conwrt              		; PRINT OUT CHAR
00E400  3               
00E400  3               NEWLINE:
00E400  3  48                           pha
00E401  3  DA                           PHX
00E402  3  5A                           phy
00E403  3  A9 0D                        LDA #$0D
00E405  3  20 02 E7                     JSR conwrt
00E408  3  A9 0A                        LDA #$0A
00E40A  3  20 02 E7                     Jsr conwrt
00E40D  3  7A                           ply
00E40E  3  FA                           plx
00E40F  3  68                           pla
00E410  3  60                           rts
00E411  3               
00E411  3               PRTDEC:
00E411  3  5A                           phy
00E412  3  DA                           PHX
00E413  3  48                           PHA
00E414  3  A0 00                        ldy #00
00E416  3  A2 FF                        LDX #$FF
00E418  3  38                           SEC
00E419  3               PrDec100:
00E419  3  E8                           INX
00E41A  3  E9 64                        SBC #100
00E41C  3  B0 FB                        BCS PrDec100            ;Count how many 100s
00E41E  3  69 64                        ADC #100
00E420  3  20 3A E4                     JSR PrDecDigit          ;Print the 100s
00E423  3  A2 FF                        LDX #$FF
00E425  3  38                           SEC                     ;Prepare for subtraction
00E426  3               PrDec10:
00E426  3  E8                           INX
00E427  3  E9 0A                        SBC #10
00E429  3  B0 FB                        BCS PrDec10             ;Count how many 10s
00E42B  3  69 0A                        ADC #10
00E42D  3  20 3A E4                     JSR PrDecDigit          ;Print the 10s
00E430  3  AA                           TAX                     ;Pass 1s into X
00E431  3  A0 01                        ldy #1
00E433  3  20 3A E4                     JSR PrDecDigit          ;Print the 1s
00E436  3  68                           PLA
00E437  3  FA                           PLX
00E438  3  7A                           ply
00E439  3  60                           RTS
00E43A  3               PrDecDigit:
00E43A  3  48                           PHA
00E43B  3  C0 00                        cpy #$00
00E43D  3  D0 09                        bne PrDecDigit1
00E43F  3  8A                           txa
00E440  3  A8                           tay
00E441  3  C0 00                        cpy #$00
00E443  3  D0 03                        bne PrDecDigit1
00E445  3  4C 4E E4                     jmp PrDecDigit2
00E448  3               PrDecDigit1:
00E448  3  8A                           TXA                     ;Save A, pass digit to A
00E449  3  09 30                        ORA #'0'
00E44B  3  20 02 E7                     JSR  conwrt             ;Convert to character and print it
00E44E  3               PrDecDigit2:
00E44E  3  68                           PLA
00E44F  3  60                           RTS                     ;Restore A and return
00E450  3               
00E450  2               DO_FARCALL = farcall - md_pagecode + $0200
00E450  2               
00E450  2               ;dos / 65 system interface module (sim)
00E450  2               ;version 3.00
00E450  2               ;this version is designed to work with the N8VEM Host Processor
00E450  2               
00E450  2               ;fixed parameters
00E450  2               simstart:
00E450  2               
00E450  2               ;my system i / o routines in rom
00E450  2               nsects = (simstart - ccm) / 128 ;number sectors
00E450  2               
00E450  2               ;main program
00E450  2               ;jump vector used by pem
00E450  2  4C AC E5     sim: jmp boot                 ;from cold start
00E453  2  4C 54 E6     wboote: jmp wboot             ;from warm boot
00E456  2  4C F4 E6     	jmp consts                   ;check for input
00E459  2  4C FB E6     	jmp conrde                   ;get input
00E45C  2  4C 02 E7     	jmp conwrt                   ;send to terminal
00E45F  2  4C 0B E7     	jmp prnwrt                   ;printer output
00E462  2  4C 0C E7     	jmp punwrt                   ;punch output
00E465  2  4C 0D E7     	jmp rdrinp                   ;reader input
00E468  2  4C 7D E6     	jmp home                     ;home drive
00E46B  2  4C 5C E6     	jmp seldsk                   ;select disk
00E46E  2  4C 81 E6     	jmp seltrk                   ;set track
00E471  2  4C 89 E6     	jmp selsec                   ;set sector
00E474  2  4C EF E6     	jmp setdma                   ;set buffer address
00E477  2  4C 90 E6     	jmp read                     ;read sector
00E47A  2  4C C3 E6     	jmp write                    ;write sector
00E47D  2  A9 01        	lda #1                       ;printer always ready
00E47F  2  60           	rts
00E480  2  4C 0E E7     	jmp rdtime                   ;clock entry
00E483  2  4C 0F E7     	jmp xlate                    ;translate
00E486  2               
00E486  2               ;console definition block
00E486  2               sysdef:
00E486  2  08           	.byte 8                      ;backspace
00E487  2  01           	.byte 1                      ;clear to end of line
00E488  2  0C           	.byte $c                     ;forward space
00E489  2  00           	.byte 0                      ;normal video
00E48A  2  5E           	.byte '^'                    ;invert video
00E48B  2  18           	.byte 24                     ;lines per screen
00E48C  2  50           	.byte 80                     ;char per line
00E48D  2  0C           	.byte $c                     ;formfeed
00E48E  2  1E           	.byte $1e                    ;home
00E48F  2  02           	.byte 2                      ;clear to end of screen
00E490  2               
00E490  2               ;opening id message
00E490  2  0D 0A        opnmsg: .byte cr, lf
00E492  2               
00E492  2  64 38 38 38  	.BYTE "d8888b.  .d88b.  .d8888.    dD     ooooo", cr, lf
00E496  2  38 62 2E 20  
00E49A  2  20 2E 64 38  
00E4BC  2  38 38 20 20  	.BYTE "88  `8D .8P  Y8. 88'  YP   d8'    8P~~~~", cr, lf
00E4C0  2  60 38 44 20  
00E4C4  2  2E 38 50 20  
00E4E6  2  38 38 20 20  	.BYTE "88   88 88    88 `8bo.    d8'    dP", cr, lf
00E4EA  2  20 38 38 20  
00E4EE  2  38 38 20 20  
00E50B  2  38 38 20 20  	.BYTE "88   88 88    88   `Y8b. d8888b. V8888b.", cr, lf,0
00E50F  2  20 38 38 20  
00E513  2  38 38 20 20  
00E536  2               opnmsg1:
00E536  2  38 38 20 20  	.BYTE "88  .8D `8b  d8' db   8D 88' `8D     `8D ", cr, lf
00E53A  2  2E 38 44 20  
00E53E  2  60 38 62 20  
00E561  2  59 38 38 38  	.BYTE "Y8888D'  `Y88P'  `8888Y' `8888P  88oobY'", cr, lf
00E565  2  38 44 27 20  
00E569  2  20 60 59 38  
00E58B  2  11 44 4F 53  	.byte 17, "DOS / 65 ON THE NHYODYNE 3.00", cr, lf, 0
00E58F  2  20 2F 20 36  
00E593  2  35 20 4F 4E  
00E5AC  2               
00E5AC  2               
00E5AC  2               ;cold entry from loader
00E5AC  2               boot:
00E5AC  2  78           	SEI                          ; DISABLE INTERRUPTS
00E5AD  2  A2 FF        	ldx #$ff                     ;set stack
00E5AF  2  9A           	txs                          ;pointer
00E5B0  2  D8           	cld                          ;set binary mode
00E5B1  2               
00E5B1  2  20 7B E8     	JSR PAGER_INIT               ;setup paging for device drivers
00E5B4  2               
00E5B4  2               	PRTDBG "OS Starting$"
00E5B4  2               
00E5B4  2  A9 90        	lda #<opnmsg                 ;point to message
00E5B6  2  A0 E4        	ldy #>opnmsg
00E5B8  2  20 10 E7     	jsr outmsg                   ;send it
00E5BB  2  A9 36        	lda #<opnmsg1
00E5BD  2  A0 E5        	ldy #>opnmsg1
00E5BF  2  20 10 E7     	jsr outmsg                   ;send it
00E5C2  2               
00E5C2  2  20 00 E4     	JSR NEWLINE
00E5C5  2               
00E5C5  2               ; setup diskconfig table
00E5C5  2  A2 00        	ldx #0
00E5C7  2               @2:
00E5C7  2  BD 2F F2     	lda dftdskcfg, x
00E5CA  2  9D 14 05     	sta dskcfg, x
00E5CD  2  E8           	inx
00E5CE  2  E0 10        	cpx #$10
00E5D0  2  D0 F5        	bne @2
00E5D2  2               
00E5D2  2               	PRTDBG "DISK CFG TABLE COPIED$"
00E5D2  2               
00E5D2  2  A9 00        	lda #0                       ;set zero
00E5D4  2  20 5C E6     	jsr seldsk                   ;and select drive zero
00E5D7  2               
00E5D7  2  A9 16        	lda #22                      ;MD_SHOW
00E5D9  2  85 32        	sta farfunct
00E5DB  2  20 6A 02     	JSR DO_FARCALL
00E5DE  2               
00E5DE  2  A9 19         	lda #25 					 ;FD_INIT
00E5E0  2  85 32        	sta farfunct
00E5E2  2  20 6A 02     	JSR DO_FARCALL
00E5E5  2               
00E5E5  2  A9 04        	lda #04                      ;PPIDE_INIT
00E5E7  2  85 32        	sta farfunct
00E5E9  2  20 6A 02     	JSR DO_FARCALL
00E5EC  2               
00E5EC  2                .IF USEDSKYNG=1 || USEDSKY=1
00E5EC  2  A9 07         	lda #07 					;DSKY_INIT
00E5EE  2  85 32         	sta farfunct
00E5F0  2  20 6A 02      	JSR DO_FARCALL
00E5F3  2               
00E5F3  2  A2 00         	LDX #$00
00E5F5  2               @1:
00E5F5  2  BD 42 E9      	LDA DOS65DSKYINIT, X
00E5F8  2  9D 00 05      	STA DSKY_BUF, X
00E5FB  2  E8            	INX
00E5FC  2  E0 08         	CPX #8
00E5FE  2  D0 F5         	BNE @1
00E600  2  A9 08         	lda #08 					;DSKY_SHOW
00E602  2  85 32         	sta farfunct
00E604  2  20 6A 02      	JSR DO_FARCALL
00E607  2               
00E607  2  A9 0D         	lda #13 					;DSKY_BEEP
00E609  2  85 32         	sta farfunct
00E60B  2  20 6A 02      	JSR DO_FARCALL
00E60E  2               .ENDIF
00E60E  2               
00E60E  2  A9 44        	LDA #<cnstxt                 ; STORE POINTER TO COMMAND LINE
00E610  2  85 30        	STA cmdlnp
00E612  2  A9 D7        	LDA #>cnstxt
00E614  2  85 31        	STA cmdlnp + 1
00E616  2               
00E616  2  A9 14        	LDA #<dskcfg                 ; STORE POINTER TO DISK CONFIG TABLE FOR APPS
00E618  2  85 2E        	STA dskcfpc
00E61A  2  A9 05        	LDA #>dskcfg
00E61C  2  85 2F        	STA dskcfpc + 1
00E61E  2  20 47 E7     	JSR DSPL_DSK_CFG             ; DISPLAY DISK CONFIG TO USERS
00E621  2               
00E621  2               
00E621  2               ;set up jumps into dos / 65 in page one
00E621  2               setup:
00E621  2  20 7B E8     	JSR PAGER_INIT
00E624  2  A2 00        	ldx #0                       ;clear index
00E626  2               ;first clear key dba variables
00E626  2  8E BD E9     	stx hstact                   ;host buffer inactive
00E629  2  8E BE E9     	stx unacnt                   ;clear unalloc count
00E62C  2  BD 4E E6     setupl: lda inttbl, x         ;get byte
00E62F  2  9D 00 01     	sta $100, x                  ;insert at start
00E632  2  E8           	inx
00E633  2  E0 06        	cpx #6
00E635  2  D0 F5        	bne setupl                   ;loop until done
00E637  2  A9 28        	lda #<dflbuf                 ;get low buffer
00E639  2  A0 01        	ldy #>dflbuf                 ;and high
00E63B  2  20 EF E6     	jsr setdma                   ;and set
00E63E  2  AD 13 05     	lda sekdsk                   ;get disk
00E641  2               
00E641  2  A9 02        	lda #DEFDRV                  ;set zero
00E643  2  20 5C E6     	jsr seldsk                   ;and select drive zero
00E646  2  20 7D E6     	jsr home                     ;home that drive
00E649  2               
00E649  2               	PRTDBG "Start CCM$"
00E649  2  A9 02        	lda #DEFDRV                  ;set zero
00E64B  2  4C 03 D0     	jmp ccm                      ;and go to ccm
00E64E  2               ;initialization table
00E64E  2  4C 53 E4 4C  inttbl: .byte $4c, <wboote, >wboote, $4c, <pem, >pem
00E652  2  FE D7        
00E654  2               ;warm boot - read dos / 65 back except sim and then
00E654  2               ; jump to ccm.
00E654  2               
00E654  2               
00E654  2               wboot:
00E654  2  78           	SEI                          ; DISABLE INTERRUPTS
00E655  2  A2 FF        	ldx #$ff                     ;set stack
00E657  2  9A           	txs                          ;pointer
00E658  2  D8           	cld                          ;set binary mode
00E659  2               
00E659  2  4C 21 E6     	jmp setup                    ;go setup
00E65C  2               
00E65C  2               
00E65C  2               
00E65C  2               ;__SELDSK_________________________________________________________________________________________________
00E65C  2               ;
00E65C  2               ; PERFORM DOS / 65 DISK DRIVE SELECT
00E65C  2               ;________________________________________________________________________________________________________
00E65C  2               ;select disk
00E65C  2               seldsk:
00E65C  2  29 07        	and #7                       ;three lsbs only
00E65E  2  8D 13 05     	sta sekdsk                   ;save for later
00E661  2  AD 13 05     	LDA sekdsk                   ;save for later
00E664  2  0A           	asl a                        ;multiply by two
00E665  2  AA           	tax                          ;make an Index
00E666  2  BD 6D E6     	lda dcbtbl, x                ;get address
00E669  2  BC 6E E6     	ldy dcbtbl + 1, x
00E66C  2  60           	rts
00E66D  2               
00E66D  2               ;table of dcb addresses
00E66D  2  4A E9        dcbtbl: .word dcba            ; A
00E66F  2  58 E9        	.word dcbb                   ; B
00E671  2  66 E9        	.word dcbc                   ; C
00E673  2  74 E9        	.word dcbd                   ; D
00E675  2  82 E9        	.word dcbe                   ; E
00E677  2  90 E9        	.word dcbf                   ; F
00E679  2  9E E9        	.word dcbg                   ; G
00E67B  2  AC E9        	.word dcbh                   ; H
00E67D  2               
00E67D  2               ;__HOME__________________________________________________________________________________________________
00E67D  2               ;
00E67D  2               ; PERFORM DOS / 65 HEAD HOME
00E67D  2               ;________________________________________________________________________________________________________
00E67D  2               home:
00E67D  2  A9 00        	lda #$00
00E67F  2  A0 00        	ldy #$00
00E681  2               
00E681  2               ;__SELTRK________________________________________________________________________________________________
00E681  2               ;
00E681  2               ; PERFORM DOS / 65 SELECT TRACK
00E681  2               ;
00E681  2               ; A=TRACK LOW BYTE
00E681  2               ; Y=TRACK HIGH BYTE
00E681  2               ;________________________________________________________________________________________________________
00E681  2               seltrk:
00E681  2  18           	CLC
00E682  2  8D 0C 05     	sta sektrk                   ;save number
00E685  2  8C 0D 05     	sty sektrk + 1
00E688  2  60           	rts
00E689  2               
00E689  2               ;__SELSEC________________________________________________________________________________________________
00E689  2               ;
00E689  2               ; PERFORM DOS / 65 SECTOR SELECT
00E689  2               ;
00E689  2               ; A=SECTOR LOW BYTE
00E689  2               ; Y=SECTOR HIGH BYTE
00E689  2               ;________________________________________________________________________________________________________
00E689  2               selsec:
00E689  2  8D 0E 05     	sta seksec                   ;save low and high
00E68C  2  8C 0F 05     	sty seksec + 1
00E68F  2  60           	rts
00E690  2               
00E690  2               ;__READ__________________________________________________________________________________________________
00E690  2               ;
00E690  2               ; PERFORM DOS / 65 SECTOR READ
00E690  2               ;________________________________________________________________________________________________________
00E690  2               read:
00E690  2  20 24 E7     	JSR GET_DRIVE_DEVICE         ;
00E693  2  29 F0        	and #$F0                     ; only want first nybble
00E695  2  C9 00        	CMP #$00
00E697  2  D0 0A        	BNE :+                       ; not MD drive
00E699  2               	;RAM
00E699  2  A9 14        	lda #20                      ;MD_READ_SECTOR
00E69B  2  85 32        	sta farfunct
00E69D  2  20 6A 02     	JSR DO_FARCALL
00E6A0  2  4C 07 E9     	JMP MOVEBUFTODMA
00E6A3  2               :
00E6A3  2  C9 20        	CMP #$20
00E6A5  2  D0 0B        	BNE :+ 			; not floppy drive
00E6A7  2               	;FD
00E6A7  2  A9 17        	lda #23 ;FD_READ_SECTOR
00E6A9  2  85 32        	sta farfunct
00E6AB  2  20 6A 02     	JSR DO_FARCALL
00E6AE  2  4C 07 E9     	JMP MOVEBUFTODMA
00E6B1  2  60           	RTS ;
00E6B2  2               :
00E6B2  2  C9 30        	CMP #$30
00E6B4  2  D0 0A        	BNE :+                       ; invalid drive
00E6B6  2               	;PPIDE
00E6B6  2  A9 05        	lda #05                      ;IDE_READ_SECTOR
00E6B8  2  85 32        	sta farfunct
00E6BA  2  20 6A 02     	JSR DO_FARCALL
00E6BD  2  4C 07 E9     	JMP MOVEBUFTODMA
00E6C0  2               :
00E6C0  2  A9 FF        	LDA #$FF                     ; signal error
00E6C2  2  60           	RTS                          ;
00E6C3  2               
00E6C3  2               
00E6C3  2               ;__WRITE_________________________________________________________________________________________________
00E6C3  2               ;
00E6C3  2               ; PERFORM DOS / 65 SECTOR WRITE
00E6C3  2               ;________________________________________________________________________________________________________
00E6C3  2               write:
00E6C3  2  20 24 E7     	JSR GET_DRIVE_DEVICE         ;
00E6C6  2  20 1D E9     	JSR MOVEDMATOBUF
00E6C9  2               
00E6C9  2  29 F0        	and #$F0                     ; only want first nybble
00E6CB  2               
00E6CB  2  C9 00        	CMP #$00
00E6CD  2  D0 07        	BNE :+                       ; not MD Drive
00E6CF  2               	;MD
00E6CF  2  A9 15        	lda #21                      ;MD_WRITE_SECTOR
00E6D1  2  85 32        	sta farfunct
00E6D3  2  4C 6A 02     	jmp DO_FARCALL
00E6D6  2               :
00E6D6  2  C9 20        	CMP #$20
00E6D8  2  D0 07        	BNE :+ 						; not floppy drive
00E6DA  2               	;FD
00E6DA  2  A9 18        	lda #24 ;FD_WRITE_SECTOR
00E6DC  2  85 32        	sta farfunct
00E6DE  2  4C 6A 02     	JMP DO_FARCALL
00E6E1  2               :
00E6E1  2  C9 30        	CMP #$30
00E6E3  2  D0 07        	BNE writex                   ; not ppide
00E6E5  2               	;PPIDE
00E6E5  2  A9 06        	lda #06                      ;IDE_WRITE_SECTOR
00E6E7  2  85 32        	sta farfunct
00E6E9  2  4C 6A 02     	jmp DO_FARCALL
00E6EC  2               writex:
00E6EC  2  A9 FF        	LDA #$FF                     ; signal error
00E6EE  2  60           	RTS                          ;
00E6EF  2               
00E6EF  2               
00E6EF  2               ;__SETDMA________________________________________________________________________________________________
00E6EF  2               ;
00E6EF  2               ; PERFORM DOS / 65 BUFFER ADDRESS SELECTION
00E6EF  2               ;
00E6EF  2               ; A=BUFFER LOW BYTE
00E6EF  2               ; Y=BUFFER HIGH BYTE
00E6EF  2               ;________________________________________________________________________________________________________
00E6EF  2               setdma:
00E6EF  2  85 F4        	sta dmaadr                   ;store low
00E6F1  2  84 F5        	sty dmaadr + 1               ;and high
00E6F3  2  60           	rts
00E6F4  2               
00E6F4  2               
00E6F4  2               ;__CONSTS________________________________________________________________________________________________
00E6F4  2               ;
00E6F4  2               ; GET DOS / 65 CONSOLE STATUS
00E6F4  2               ;________________________________________________________________________________________________________
00E6F4  2               consts:
00E6F4  2  A9 03        	lda #03
00E6F6  2  85 32        	sta farfunct
00E6F8  2  4C 6A 02     	jmp DO_FARCALL
00E6FB  2               
00E6FB  2               ;__CONRDE________________________________________________________________________________________________
00E6FB  2               ;
00E6FB  2               ; PERFORM DOS / 65 CONSOLE READ
00E6FB  2               ;________________________________________________________________________________________________________
00E6FB  2               conrde:
00E6FB  2  A9 02        	lda #02
00E6FD  2  85 32        	sta farfunct
00E6FF  2  4C 6A 02     	jmp DO_FARCALL
00E702  2               
00E702  2               
00E702  2               ;__CONWRT________________________________________________________________________________________________
00E702  2               ;
00E702  2               ; PERFORM DOS / 65 CONSOLE WRITE
00E702  2               ;________________________________________________________________________________________________________
00E702  2               conwrt:
00E702  2  48           	pha
00E703  2  A9 00        	lda #00
00E705  2  85 32        	sta farfunct
00E707  2  68           	pla
00E708  2  4C 6A 02     	jmp DO_FARCALL
00E70B  2               
00E70B  2               prnwrt:
00E70B  2  60           	rts                          ;printer
00E70C  2               punwrt:
00E70C  2  60           	rts                          ;punch output
00E70D  2               rdrinp:
00E70D  2  60           	rts                          ;reader input
00E70E  2               rdtime:
00E70E  2  60           	rts                          ;read clock
00E70F  2               xlate:
00E70F  2  60           	rts                          ;sector translate
00E710  2               
00E710  2               
00E710  2               ;__OUTMSG________________________________________________________________________________________________
00E710  2               ;
00E710  2               ; WRITE A NULL TERMINATED STRING TO THE CONSOLE
00E710  2               ;
00E710  2               ; A=POINTER LOW BYTE
00E710  2               ; Y=POINTER HIGH BYTE
00E710  2               ;________________________________________________________________________________________________________
00E710  2               outmsg:                       ;output message
00E710  2  85 F0        	STA OUTMSG_W
00E712  2  84 F1        	STY OUTMSG_W + 1
00E714  2  A0 00        	LDY #$00
00E716  2               OUTSTRLP:
00E716  2  B1 F0        	LDA (OUTMSG_W), Y            ; LOAD NEXT CHAR FROM STRING INTO ACC
00E718  2  C9 00        	CMP #$00                     ; IS NULL?
00E71A  2  F0 07        	BEQ ENDOUTSTR                ; YES, END PRINT OUT
00E71C  2  20 02 E7     	JSR conwrt                   ; PRINT CHAR IN ACC
00E71F  2  C8           	INY                          ; Y=Y + 1 (BUMP INDEX)
00E720  2  4C 16 E7     	JMP OUTSTRLP                 ; DO NEXT CHAR
00E723  2               ENDOUTSTR:
00E723  2  60           	RTS                          ; RETURN
00E724  2               
00E724  2               ;___GET_DRIVE_DEVICE_____________________________________________________________________________________
00E724  2               ;
00E724  2               ; GET SELECTED DEVICE TYPE AND UNIT, RETURN IN "A"
00E724  2               ;
00E724  2               ;________________________________________________________________________________________________________
00E724  2               GET_DRIVE_DEVICE:
00E724  2  DA           	PHX
00E725  2  AD 13 05     	LDA sekdsk                   ; GET DRIVE
00E728  2  29 07        	AND #7                       ; ONLY FIRST 8 DEVICES SUPPORTED
00E72A  2  0A           	asl a                        ; DOUBLE NUMBER FOR TABLE LOOKUP
00E72B  2  AA           	TAX                          ; MOVE TO X REGISTER
00E72C  2  BD 14 05     	LDA dskcfg, X                ; GET device
00E72F  2               								 ; SETUP FLOPPY CONTROL WHILE WE ARE HERE
00E72F  2  29 01        	AND #$01
00E731  2  C9 00        	CMP #$00
00E733  2  D0 08        	BNE	:+
00E735  2  A9 10        	LDA #%00010000
00E737  2  8D 25 05     	STA DSKUNIT
00E73A  2  4C 42 E7     	JMP GET_DRIVE_DEVICE_1
00E73D  2               :
00E73D  2  A9 21        	LDA #%00100001
00E73F  2  8D 25 05     	STA DSKUNIT
00E742  2               GET_DRIVE_DEVICE_1:
00E742  2  BD 14 05     	LDA dskcfg, X                ; GET device
00E745  2  FA           	PLX
00E746  2  60           	RTS
00E747  2               
00E747  2               ;___DSPL_DSK_CFG_________________________________________________________________________________________
00E747  2               ;
00E747  2               ; DISPLAY THE DISK CONFIGURATION FOR THE USER
00E747  2               ;
00E747  2               ;________________________________________________________________________________________________________
00E747  2               DSPL_DSK_CFG:
00E747  2  20 00 E4     	JSR NEWLINE
00E74A  2  48 DA 5A A2  PRTS "Disk Configuration:$"
00E74E  2  00 BD 63 E7  
00E752  2  E8 C9 24 F0  
00E777  2  20 00 E4     	JSR NEWLINE
00E77A  2  A2 00        	ldx #0
00E77C  2               DSPL_DSK_CFG_1:
00E77C  2  48 DA 5A A2  	PRTS " $"                    ; MAKE IT PRETTY :)
00E780  2  00 BD 95 E7  
00E784  2  E8 C9 24 F0  
00E797  2  8A           	TXA
00E798  2  4A           	LSR A
00E799  2  18           	CLC
00E79A  2  69 41        	ADC #'A'
00E79C  2  20 02 E7     	JSR conwrt
00E79F  2  A9 3A        	LDA #':'
00E7A1  2  20 02 E7     	JSR conwrt
00E7A4  2  A9 3D        	LDA #'='
00E7A6  2  20 02 E7     	JSR conwrt
00E7A9  2  20 C1 E7     	JSR prtdevice                ; PRINT DEVICE NAME FROM TABLE (X)
00E7AC  2  A9 3A        	LDA #':'
00E7AE  2  20 02 E7     	JSR conwrt
00E7B1  2  E8           	INX                          ; WANT SECOND BYTE OF ENTRY
00E7B2  2  BD 14 05     	LDA dskcfg, x                ; GET SLICE
00E7B5  2  20 11 E4     	JSR PRTDEC                   ; PRINT SLICE IN DECIMAL (A)
00E7B8  2  E8           	INX
00E7B9  2  20 00 E4     	JSR NEWLINE
00E7BC  2  E0 10        	CPX #16
00E7BE  2  D0 BC        	BNE DSPL_DSK_CFG_1
00E7C0  2  60           	RTS
00E7C1  2               
00E7C1  2               	; DEVICE TABLE:
00E7C1  2               	; $00 MD
00E7C1  2               	; $2x FLOPPY
00E7C1  2               	; $3x IDE
00E7C1  2               prtdevice:
00E7C1  2  BD 14 05     	LDA dskcfg, X                ; GET DEVICE TYPE
00E7C4  2  48           	PHA
00E7C5  2  29 F0        	AND #$F0                     ; FILTER OUT UNIT
00E7C7  2  C9 00        	CMP #$00
00E7C9  2  D0 1F        	BNE prtdevice1
00E7CB  2  48 DA 5A A2  	PRTS "MD$"
00E7CF  2  00 BD E4 E7  
00E7D3  2  E8 C9 24 F0  
00E7E7  2  4C 74 E8     	jmp prtdevice_done
00E7EA  2               prtdevice1:
00E7EA  2  C9 10        	CMP #$10
00E7EC  2  D0 20        	BNE prtdevice2
00E7EE  2  48 DA 5A A2  	PRTS "UNK$"
00E7F2  2  00 BD 07 E8  
00E7F6  2  E8 C9 24 F0  
00E80B  2  4C 74 E8     	jmp prtdevice_done
00E80E  2               prtdevice2:
00E80E  2  C9 20        	CMP #$20
00E810  2  D0 1F        	BNE prtdevice3
00E812  2  48 DA 5A A2  	PRTS "FD$"
00E816  2  00 BD 2B E8  
00E81A  2  E8 C9 24 F0  
00E82E  2  4C 74 E8     	jmp prtdevice_done
00E831  2               prtdevice3:
00E831  2  C9 30        	CMP #$30
00E833  2  D0 22        	BNE prtdevicex
00E835  2  48 DA 5A A2  	PRTS "PPIDE$"
00E839  2  00 BD 4E E8  
00E83D  2  E8 C9 24 F0  
00E854  2  4C 74 E8     	jmp prtdevice_done
00E857  2               prtdevicex:
00E857  2  48 DA 5A A2  	PRTS "UNK$"
00E85B  2  00 BD 70 E8  
00E85F  2  E8 C9 24 F0  
00E874  2               prtdevice_done:
00E874  2  68           	PLA
00E875  2  29 0F        	AND #$0F                     ; FILTER OUT DEVICE
00E877  2  20 11 E4     	JSR PRTDEC
00E87A  2  60           	RTS
00E87B  2               
00E87B  2               	.INCLUDE "dospager.asm"
00E87B  3               ;__pager_________________________________________________________________________________________________________________________
00E87B  3               ;
00E87B  3               ; 	Nhyodyne Memory page management code
00E87B  3               ;
00E87B  3               ;	Entry points:
00E87B  3               ;		PAGER_INIT          - called during OS init
00E87B  3               ;________________________________________________________________________________________________________________________________
00E87B  3               ;
00E87B  3               ; RAM BANK $0C is RAM area for Drivers
00E87B  3               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
00E87B  3               ; RAM BANK $0F is fixed bank $0000-$7FFF
00E87B  3               ;
00E87B  3               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
00E87B  3               ;
00E87B  3               ; ROM MEMORY PAGE CONFIGURATION LATCH CONTROL PORT
00E87B  3               ;       A15 IS INVERTED FOR THE NYHODYNE 65C02 CPU . . .
00E87B  3               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
00E87B  3               ;	^ ^ ^ ^  ^ ^ ^ ^
00E87B  3               ;	: : : :  : : : :--0 = A15 ROM ONLY ADDRESS LINE DEFAULT IS 0 x
00E87B  3               ;	: : : :  : : :----0 = A16 ROM ONLY ADDRESS LINE DEFAULT IS 0
00E87B  3               ;	: : : :  : :------0 = A17 ROM ONLY ADDRESS LINE DEFAULT IS 0
00E87B  3               ;	: : : :  :--------0 = A18 ROM ONLY ADDRESS LINE DEFAULT IS 0 X
00E87B  3               ;	: : : :-----------0 = A19 ROM ONLY ADDRESS LINE DEFAULT IS 0
00E87B  3               ;	: : :-------------0 = A20 ROM ONLY ADDRESS LINE DEFAULT IS 0
00E87B  3               ;	: :---------------0 = ROM BOOT OVERRIDE DEFAULT IS 0
00E87B  3               ;	:-----------------0 = LOWER PAGE ROM SELECT (0=ROM, 1=NOTHING) DEFAULT IS 0
00E87B  3               ;
00E87B  3               ; RAM PAGE CONFIGURATION LATCH CONTROL PORT
00E87B  3               ;
00E87B  3               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
00E87B  3               ;	^ ^ ^ ^  ^ ^ ^ ^
00E87B  3               ;	: : : :  : : : :--0 = A15 RAM ONLY ADDRESS LINE DEFAULT IS 0
00E87B  3               ;	: : : :  : : :----0 = A16 RAM ONLY ADDRESS LINE DEFAULT IS 0
00E87B  3               ;	: : : :  : :------0 = A17 RAM ONLY ADDRESS LINE DEFAULT IS 0
00E87B  3               ;	: : : :  :--------0 = A18 RAM ONLY ADDRESS LINE DEFAULT IS 0
00E87B  3               ;	: : : :-----------0 = A19 RAM ONLY ADDRESS LINE DEFAULT IS 0
00E87B  3               ;	: : :-------------0 = UNDEFINED DEFAULT IS 0
00E87B  3               ;	: :---------------0 = RAM BOOT OVERRIDE DEFAULT IS 0
00E87B  3               ;	:-----------------0 = LOWER PAGE RAM SELECT (0=NOTHING, 1=RAM) DEFAULT IS 0;
00E87B  3               
00E87B  3               
00E87B  3               ;__PAGER_INIT___________________________________________________________________________________________
00E87B  3               ;
00E87B  3               ;  INIT -- Copy code into $0200-$02FF for controling banking and copying
00E87B  3               ;____________________________________________________________________________________________________
00E87B  3               PAGER_INIT:
00E87B  3  A2 00                LDX     #$00
00E87D  3               :
00E87D  3  BD 89 E8             LDA     md_pagecode,X
00E880  3  9D 00 02             STA     MD_PAGERA,X
00E883  3  E8                   INX
00E884  3  E0 00                CPX     #$00
00E886  3  D0 F5                BNE     :-
00E888  3  60                   RTS
00E889  3               
00E889  3               ;       X=Control Word
00E889  3               ;	7 6 5 4  3 2 1 0
00E889  3               ;	^ ^ ^ ^  ^ ^ ^ ^
00E889  3               ;       : : : X  X X X X    = UNUSED
00E889  3               ;	: : :-------------0 = Read=0, Write=1
00E889  3               ;	: :---------------0 = RAM=0, ROM=1
00E889  3               ;	:-----------------0 = LOW=0, HIGH=1
00E889  3               ;       A= bank
00E889  3               ;       Y= page
00E889  3               ;
00E889  3                 .IF RAMDRIVERS=1
00E889  3               md_pagecode:
00E889  3  48                   PHA
00E88A  3  84 15                STY     MD_PAGESE+1     ; setup copy from pointer
00E88C  3  8A                   TXA
00E88D  3  29 80                AND     #$80
00E88F  3  A8                   TAY
00E890  3  84 14                STY     MD_PAGESE
00E892  3  8A                   TXA
00E893  3  29 20                AND     #%00100000
00E895  3  C9 00                CMP     #$00
00E897  3  D0 3D                BNE     MD_PAGE_WRITE
00E899  3               ; PERFORM READ HERE
00E899  3  8A                   TXA
00E89A  3  29 40                AND     #%01000000
00E89C  3  C9 00                CMP     #$00
00E89E  3  D0 0D                BNE     MD_PAGE_ROREAD
00E8A0  3               ; DO RAM READ
00E8A0  3  A9 80                LDA     #$80
00E8A2  3  8D 7C 03             STA     MPCL_ROM
00E8A5  3  68                   PLA
00E8A6  3  09 80                ORA     #$80
00E8A8  3  8D 78 03             STA     MPCL_RAM
00E8AB  3  80 0B                BRA     MD_PAGE_COPYFRM
00E8AD  3               MD_PAGE_ROREAD:
00E8AD  3  A9 00                LDA     #$00
00E8AF  3  8D 78 03             STA     MPCL_RAM
00E8B2  3  68                   PLA
00E8B3  3  29 7F                AND     #$7F
00E8B5  3  8D 7C 03             STA     MPCL_ROM
00E8B8  3               MD_PAGE_COPYFRM:
00E8B8  3               ; DO THE COPY
00E8B8  3  A2 00                LDX     #$00
00E8BA  3  A0 00                LDY     #$00
00E8BC  3               :
00E8BC  3  B1 14                LDA     (MD_PAGESE),Y
00E8BE  3  9D 00 04             STA     MD_PAGEBU,X
00E8C1  3  E8                   INX
00E8C2  3  C8                   INY
00E8C3  3  E0 80                CPX     #$80
00E8C5  3  D0 F5                BNE     :-
00E8C7  3  A9 80                LDA     #$80
00E8C9  3  8D 7C 03             STA     MPCL_ROM
00E8CC  3  EA                   NOP
00E8CD  3  EA                   NOP
00E8CE  3  A9 8C                LDA     #$8C
00E8D0  3  8D 78 03             STA     MPCL_RAM
00E8D3  3  EA                   nop
00E8D4  3  EA                   nop
00E8D5  3  60                   RTS
00E8D6  3               MD_PAGE_WRITE:
00E8D6  3  68                   PLA
00E8D7  3  09 80                ORA     #%10000000
00E8D9  3  8D 78 03             STA     MPCL_RAM
00E8DC  3               ; DO THE COPY
00E8DC  3  A2 00                LDX     #$00
00E8DE  3  A0 00                LDY     #$00
00E8E0  3               :
00E8E0  3  BD 00 04             LDA     MD_PAGEBU,X
00E8E3  3  91 14                STA     (MD_PAGESE),Y
00E8E5  3  E8                   INX
00E8E6  3  C8                   INY
00E8E7  3  E0 80                CPX     #$80
00E8E9  3  D0 F5                BNE     :-
00E8EB  3  A9 8C                LDA     #$8C
00E8ED  3  8D 78 03             STA     MPCL_RAM
00E8F0  3  EA                   nop
00E8F1  3  EA                   nop
00E8F2  3  60                   RTS
00E8F3  3                 .ENDIF
00E8F3  3                 .IF ROMDRIVERS=1 || ROMRAMDRIVERS=1
00E8F3  3               md_pagecode:
00E8F3  3                       PHA
00E8F3  3                       STY     MD_PAGESE+1     ; setup copy from pointer
00E8F3  3                       TXA
00E8F3  3                       AND     #$80
00E8F3  3                       TAY
00E8F3  3                       STY     MD_PAGESE
00E8F3  3                       TXA
00E8F3  3                       AND     #%00100000
00E8F3  3                       CMP     #$00
00E8F3  3                       BNE     MD_PAGE_WRITE
00E8F3  3               ; PERFORM READ HERE
00E8F3  3                       TXA
00E8F3  3                       AND     #%01000000
00E8F3  3                       CMP     #$00
00E8F3  3                       BNE     MD_PAGE_ROREAD
00E8F3  3               ; DO RAM READ
00E8F3  3                       LDA     #$80
00E8F3  3                       STA     MPCL_ROM
00E8F3  3                       PLA
00E8F3  3                       ORA     #$80
00E8F3  3                       STA     MPCL_RAM
00E8F3  3                       BRA     MD_PAGE_COPYFRM
00E8F3  3               MD_PAGE_ROREAD:
00E8F3  3                       LDA     #$00
00E8F3  3                       STA     MPCL_RAM
00E8F3  3                       PLA
00E8F3  3                       AND     #$7F
00E8F3  3                       STA     MPCL_ROM
00E8F3  3               MD_PAGE_COPYFRM:
00E8F3  3               ; DO THE COPY
00E8F3  3                       LDX     #$00
00E8F3  3                       LDY     #$00
00E8F3  3               :
00E8F3  3                       LDA     (MD_PAGESE),Y
00E8F3  3                       STA     MD_PAGEBU,X
00E8F3  3                       INX
00E8F3  3                       INY
00E8F3  3                       CPX     #$80
00E8F3  3                       BNE     :-
00E8F3  3                       LDA     #$00
00E8F3  3                       STA     MPCL_RAM
00E8F3  3                       NOP
00E8F3  3                       NOP
00E8F3  3                       LDA     #$0D
00E8F3  3                       STA     MPCL_ROM
00E8F3  3                       nop
00E8F3  3                       nop
00E8F3  3                       RTS
00E8F3  3               MD_PAGE_WRITE:
00E8F3  3                       PLA
00E8F3  3                       ORA     #%10000000
00E8F3  3                       STA     MPCL_RAM
00E8F3  3               ; DO THE COPY
00E8F3  3                       LDX     #$00
00E8F3  3                       LDY     #$00
00E8F3  3               :
00E8F3  3                       LDA     MD_PAGEBU,X
00E8F3  3                       STA     (MD_PAGESE),Y
00E8F3  3                       INX
00E8F3  3                       INY
00E8F3  3                       CPX     #$80
00E8F3  3                       BNE     :-
00E8F3  3                       LDA     #$00
00E8F3  3                       STA     MPCL_RAM
00E8F3  3                       NOP
00E8F3  3                       NOP
00E8F3  3                       LDA     #$0D
00E8F3  3                       STA     MPCL_ROM
00E8F3  3                       nop
00E8F3  3                       nop
00E8F3  3                       RTS
00E8F3  3                 .ENDIF
00E8F3  3               md_pagecodeend:
00E8F3  3               farcall:
00E8F3  3                 .IF ROMDRIVERS=1
00E8F3  3                       PHA
00E8F3  3                       LDA     #$0D
00E8F3  3                       STA     MPCL_ROM
00E8F3  3                       nop
00E8F3  3                       nop
00E8F3  3                       PLA
00E8F3  3                       JSR     BANKED_DRIVER_DISPATCHER
00E8F3  3                       pha
00E8F3  3                       LDA     #$00
00E8F3  3                       STA     MPCL_ROM
00E8F3  3                       pla
00E8F3  3                       RTS
00E8F3  3                 .ENDIF
00E8F3  3                 .IF RAMDRIVERS=1
00E8F3  3  48                   PHA
00E8F4  3  A9 8C                LDA     #$8C
00E8F6  3  8D 78 03             STA     MPCL_RAM
00E8F9  3  EA                   nop
00E8FA  3  EA                   nop
00E8FB  3  68                   PLA
00E8FC  3  20 00 88             JSR     BANKED_DRIVER_DISPATCHER
00E8FF  3  48                   pha
00E900  3  A9 8E                LDA     #$8E
00E902  3  8D 78 03             STA     MPCL_RAM
00E905  3  68                   pla
00E906  3  60                   RTS
00E907  3                 .ENDIF
00E907  3                 .IF ROMRAMDRIVERS=1
00E907  3                       PHA
00E907  3                       LDA     #$00
00E907  3                       STA     MPCL_RAM
00E907  3                       nop
00E907  3                       nop
00E907  3                       LDA     #$0D
00E907  3                       STA     MPCL_ROM
00E907  3                       nop
00E907  3                       nop
00E907  3                       PLA
00E907  3                       JSR     BANKED_DRIVER_DISPATCHER
00E907  3                       pha
00E907  3                       LDA     #$80
00E907  3                       STA     MPCL_ROM
00E907  3                       nop
00E907  3                       nop
00E907  3                       LDA     #$8E
00E907  3                       STA     MPCL_RAM
00E907  3                       pla
00E907  3                       RTS
00E907  3                 .ENDIF
00E907  3               
00E907  2               ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
00E907  2               ;___MOVEBUFTODMA_________________________________________________________________________________________
00E907  2               ;
00E907  2               ; MOVE BUFFER TO DMA
00E907  2               ;
00E907  2               ;________________________________________________________________________________________________________
00E907  2               MOVEBUFTODMA:
00E907  2  48           	PHA
00E908  2  A9 00        	LDA #$00                     ;
00E90A  2  85 EE        	STA SRC
00E90C  2  A9 04        	LDA #>MD_PAGEBU              ;
00E90E  2  85 EF        	STA SRC + 1                  ;
00E910  2  A5 F4        	LDA dmaadr                   ;
00E912  2  85 EC        	STA DEST                     ;
00E914  2  A5 F5        	LDA dmaadr + 1               ;
00E916  2  85 ED        	STA DEST + 1                 ;
00E918  2  20 33 E9     	JSR COPY_DOS_SECTOR          ;
00E91B  2  68           	PLA
00E91C  2  60           	RTS
00E91D  2               
00E91D  2               ;___MOVEDMATOBUF_________________________________________________________________________________________
00E91D  2               ;
00E91D  2               ; MOVE DMA TO BUFFER
00E91D  2               ;
00E91D  2               ;________________________________________________________________________________________________________
00E91D  2               MOVEDMATOBUF:
00E91D  2  48           	PHA
00E91E  2  A9 00        	LDA #$00                     ;
00E920  2  85 EC        	STA DEST
00E922  2  A9 04        	LDA #>MD_PAGEBU              ;
00E924  2  85 ED        	STA DEST + 1                 ;
00E926  2  A5 F4        	LDA dmaadr                   ;
00E928  2  85 EE        	STA SRC                      ;
00E92A  2  A5 F5        	LDA dmaadr + 1               ;
00E92C  2  85 EF        	STA SRC + 1                  ;
00E92E  2  20 33 E9     	JSR COPY_DOS_SECTOR          ;
00E931  2  68           	PLA
00E932  2  60           	RTS
00E933  2               
00E933  2               
00E933  2               
00E933  2               ;___COPY_DOS_SECTOR______________________________________________________________________________________
00E933  2               ;
00E933  2               ; COPY 128 BYTE SECTOR FOR DOS / 65
00E933  2               ;
00E933  2               ;________________________________________________________________________________________________________
00E933  2               COPY_DOS_SECTOR:
00E933  2  5A           	PHY
00E934  2  A0 00        	LDY #$00                     ;
00E936  2               COPY_DOS_SECTOR1:
00E936  2  B1 EE        	LDA (SRC), Y                 ;
00E938  2  91 EC        	STA (DEST), Y                ;
00E93A  2  C8           	INY                          ;
00E93B  2  98           	TYA                          ;
00E93C  2  C9 80        	CMP #$80                     ;
00E93E  2  D0 F6        	BNE COPY_DOS_SECTOR1         ;
00E940  2  7A           	PLY
00E941  2  60           	RTS
00E942  2               
00E942  2               DOS65DSKYINIT:
00E942  2  54 6E 5C 5E  	.BYTE $54, $6E, $5C, $5E, $6E, $54, $79, $40
00E946  2  6E 54 79 40  
00E94A  2               
00E94A  2               	;disk control blocks
00E94A  2  7F 00        dcba: .word 127               ;max block number
00E94C  2  40 00        	.word 64                     ;sectors per track
00E94E  2  00 00        	.word 0                      ;number system tracks
00E950  2  01           	.byte 1                      ;block size = 2048
00E951  2  FF 00        	.word 255                    ;max directory number
00E953  2  BF E9        	.word almpa                  ;address of map for a
00E955  2  00           	.byte 00                     ;do checksums
00E956  2  AF F1        	.word ckmp                   ;checksum map
00E958  2  BF 00        dcbb: .word 191               ;max block number
00E95A  2  40 00        	.word 64                     ;sectors per track
00E95C  2  00 00        	.word 0                      ;number system tracks
00E95E  2  01           	.byte 1                      ;block size = 2048
00E95F  2  9B 00        	.word 155                    ;max directory number
00E961  2  BD EA        	.word almpb                  ;address of map for b
00E963  2  00           	.byte 00                     ;do checksums
00E964  2  AF F1        	.word ckmp                   ;checksum map
00E966  2  FF 07        dcbc: .word 2047              ;max block number
00E968  2  40 00        	.word 64                     ;sectors per track
00E96A  2  10 00        	.word 16                     ;number system tracks
00E96C  2  02           	.byte 2                      ;block size = 4096
00E96D  2  FF 01        	.word 511                    ;max directory number
00E96F  2  BB EB        	.word almpc                  ;address of map for C
00E971  2  00           	.byte 0                      ;do checksums
00E972  2  AF F1        	.word ckmp                   ;checksum map
00E974  2  5E 01        dcbd: .word 350              ;max block number
00E976  2  24 00        	.word 36                     ;sectors per track
00E978  2  04 00        	.word 4                      ;number system tracks
00E97A  2  01           	.byte 1                      ;block size = 2048
00E97B  2  7F 00        	.word 127                    ;max directory number
00E97D  2  B9 EC        	.word almpd                  ;address of map for d
00E97F  2  00           	.byte 0                      ;do checksums
00E980  2  AF F1        	.word ckmp                   ;checksum map
00E982  2  5E 01        dcbe: .word 350		             ;max block number
00E984  2  24 00        	.word 36                     ;sectors per track
00E986  2  04 00        	.word 4                      ;number system tracks
00E988  2  01           	.byte 1                      ;block size = 2048
00E989  2  7F 00        	.word 127                    ;max directory number
00E98B  2  B7 ED        	.word almpe                  ;address of map for e
00E98D  2  00           	.byte 0                      ;do checksums
00E98E  2  AF F1        	.word ckmp                   ;checksum map
00E990  2  FF 07        dcbf: .word 2047                 ;max block number
00E992  2  40 00        	.word 64                     ;sectors per track
00E994  2  10 00        	.word 16                     ;number system tracks
00E996  2  02           	.byte 2                      ;block size = 4096
00E997  2  FF 01        	.word 511                    ;max directory number
00E999  2  B5 EE        	.word almpf                  ;address of map for f
00E99B  2  00           	.byte 0                      ;do checksums
00E99C  2  AF F1        	.word ckmp                   ;checksum map
00E99E  2  FF 07        dcbg: .word 2047                 ;max block number
00E9A0  2  40 00        	.word 64                     ;sectors per track
00E9A2  2  10 00        	.word 16                     ;number system tracks
00E9A4  2  02           	.byte 2                      ;block size = 4096
00E9A5  2  FF 01        	.word 511                    ;max directory number
00E9A7  2  B3 EF        	.word almpg                  ;address of map for g
00E9A9  2  00           	.byte 0                      ;do checksums
00E9AA  2  AF F1        	.word ckmp                   ;checksum map
00E9AC  2  FF 07        dcbh: .word 2047                 ;max block number
00E9AE  2  40 00        	.word 64                     ;sectors per track
00E9B0  2  10 00        	.word 16                     ;number system tracks
00E9B2  2  02           	.byte 2                      ;block size = 4096
00E9B3  2  FF 01        	.word 511                    ;max directory number
00E9B5  2  B1 F0        	.word almph                  ;address of map for h
00E9B7  2  00           	.byte 0                      ;do checksums
00E9B8  2  AF F1        	.word ckmp                   ;checksum map
00E9BA  2               
00E9BA  2               	;data area
00E9BA  2               
00E9BA  2  00           hstwrt: .byte 0               ;0=written, 1=pending host write
00E9BB  2  00 00        debtmp: .word 0               ; DEBLOCK TEMP VAR
00E9BD  2  00           hstact: .byte 0               ;host active flag
00E9BE  2  00           unacnt: .byte 0               ;unalloc rec cnt
00E9BF  2               
00E9BF  2               
00E9BF  2               	;allocation maps
00E9BF  2  xx xx xx xx  almpa: .res 254
00E9C3  2  xx xx xx xx  
00E9C7  2  xx xx xx xx  
00EABD  2  xx xx xx xx  almpb: .res 254
00EAC1  2  xx xx xx xx  
00EAC5  2  xx xx xx xx  
00EBBB  2  xx xx xx xx  almpc: .res 254
00EBBF  2  xx xx xx xx  
00EBC3  2  xx xx xx xx  
00ECB9  2  xx xx xx xx  almpd: .res 254
00ECBD  2  xx xx xx xx  
00ECC1  2  xx xx xx xx  
00EDB7  2  xx xx xx xx  almpe: .res 254
00EDBB  2  xx xx xx xx  
00EDBF  2  xx xx xx xx  
00EEB5  2  xx xx xx xx  almpf: .res 254
00EEB9  2  xx xx xx xx  
00EEBD  2  xx xx xx xx  
00EFB3  2  xx xx xx xx  almpg: .res 254
00EFB7  2  xx xx xx xx  
00EFBB  2  xx xx xx xx  
00F0B1  2  xx xx xx xx  almph: .res 254
00F0B5  2  xx xx xx xx  
00F0B9  2  xx xx xx xx  
00F1AF  2               	;checksum maps - not used
00F1AF  2  xx xx xx xx  ckmp: .res 128
00F1B3  2  xx xx xx xx  
00F1B7  2  xx xx xx xx  
00F22F  2               
00F22F  2               dftdskcfg:
00F22F  2  00 00        	.byte $00, $00               ; disk A: unit, slice (invalid for floppy and RAM disks)
00F231  2  01 00        	.byte $01, $00               ; disk B: unit, slice (invalid for floppy and RAM disks)
00F233  2  30 06        	.byte $30, $06               ; disk C: unit, slice
00F235  2  20 00        	.byte $20, $00               ; disk D: unit, slice
00F237  2  21 00        	.byte $21, $00               ; disk E: unit, slice
00F239  2  30 03        	.byte $30, $03               ; disk F: unit, slice
00F23B  2  30 04        	.byte $30, $04               ; disk G: unit, slice
00F23D  2  30 00        	.byte $30, $00               ; disk H: unit, slice
00F23F  2               
00F23F  1               
00F23F  1               	.end
