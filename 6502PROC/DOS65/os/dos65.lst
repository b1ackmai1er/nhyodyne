ca65 V2.18 - Ubuntu 2.19-1
Main file   : dos65.asm
Current file: dos65.asm

000000r 1               ;sysgen
000000r 1               ;version 2.15-a
000000r 1               ;released:	30 november 1985 (2.10)
000000r 1               ;last revised:	2 may 1996 (2.11)
000000r 1               ;			eliminated word mode for 1024 blocks
000000r 1               ;			made extent a single byte
000000r 1               ;		3 may 1996 (2.12)
000000r 1               ;			added initial exm related code
000000r 1               ;		11 may 1996 (2.13)
000000r 1               ;			added use of exm in getblk
000000r 1               ;			added code to set exm & cexm1f
000000r 1               ;			corrected errors
000000r 1               ;		19 may 1996 (2.14)
000000r 1               ;			changed ccm ren to "to from" syntax
000000r 1               ;			allowed _ in file names
000000r 1               ;		13 march 2008 (2.15)
000000r 1               ;			reformatted for TASM & ASM210+
000000r 1               ;			eliminated dependence on "IBM" format
000000r 1               ;			  by reading first sector # using SIM+51
000000r 1               ;			  TRANSLATE code. If translate
000000r 1               ;			  does not have first physical sector in first
000000r 1               ;			  position this approach may not work.
000000r 1               ;			  SIM can also perform no translation at all.
000000r 1               ;			  Also assumes BOOT & SIM both know correct
000000r 1               ;			  starting sector for cold & warm boot. It
000000r 1               ;			  should work regardless of physical sector
000000r 1               ;			  size as long as existing SIM is configured
000000r 1               ;			  correctly for destination drive. BOOT
000000r 1               ;			  must correctly handle sectors > 128 bytes
000000r 1               ;			  as must WARM BOOT in SIM.
000000r 1               ;			  In any case BOOT and WARM BOOT must
000000r 1               ;			  read sectors in sequential order, i.e.,
000000r 1               ;			  no interleave.
000000r 1               ;this program contains the complete dos/65 operating
000000r 1               ;system except for the boot and sim.
000000r 1               ;when used by the system operator this program
000000r 1               ;provides the capability to construct a new
000000r 1               ;operating system including the users boot and sim.
000000r 1               ;the system is relocated to fit the memory size
000000r 1               ;specified by the user and is written onto
000000r 1               ;the system tracks of the specified drive.
000000r 1               ;improvements over version 2.0 include:
000000r 1               ;	use of "from to" syntax for ren
000000r 1               ;	addition of go command
000000r 1               ;	addition of load command
000000r 1               ;	ability to enter numbers as decimal or hex
000000r 1               ;	address parameter added to save
000000r 1               ;	error checking in sysgen (write)
000000r 1               ;	write type for deblocking added
000000r 1               ;	page zero 0 & 1 not used
000000r 1               ;	allow _ in file names
000000r 1               
000000r 1               .include "dosdefn.asm" 		; base addresses and definitions
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               ;
000000r 2               ;	Nhyodyne dos/65 base addresses and definitions
000000r 2               ;
000000r 2               ;  DWERNER 04/24/2022 	Initial
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               
000000r 2               ;base addresses and definitions
000000r 2               btejmp	=	$100		;warm boot jump
000000r 2               pemjmp	=	$103		;jump to pem
000000r 2               iostat	=	$106		;i/o status
000000r 2               dflfcb	=	$107		;default fcb
000000r 2               dflbuf	=	$128		;default buffer
000000r 2               memmovr =	$200		;subr to move data from ram/rom disks
000000r 2               
000000r 2               ;
000000r 2               ; DSKY DISPLAY WORKING STORAGE
000000r 2               ;
000000r 2               DSKY_BUF        =       $0300	        ; Eight Bytes DSKY display buffer
000000r 2               DSKY_BUFLEN	=       8               ;
000000r 2               DSKY_HEXBUF     =       $0308           ; Four Bytes DSKY hex buffer
000000r 2               DSKY_HEXBUFLEN	=       4               ;
000000r 2               sektrk          =       $030C		;seek track number
000000r 2               seksec          =       $030E		;seek sector number
000000r 2               debcyll         =       $0310	        ; DEBLOCKED CYLINDER LSB
000000r 2               debcylm         =	$0311           ; DEBLOCKED CYLINDER MSB
000000r 2               debsehd         =	$0312           ; DEBLOCKED SECTOR AND HEAD (HS)
000000r 2               sekdsk          =       $0313           ;seek disk number
000000r 2               dskcfg          =       $0314           ; 16 bytes disk configuration table
000000r 2               
000000r 2               MPCL_ROM	=	$037C		; ROM MAPPER
000000r 2               MPCL_RAM	=	$0378		; RAM MAPPER
000000r 2               MD_PAGERA       =       $0200           ; PAGE DRIVER ADDRESS
000000r 2               MD_PAGEBU       =       $0400           ; PAGE BUFFER ADDRESS
000000r 2               MD_PAGESE       =       pointr          ; PAGE SECTOR STORAGE
000000r 2               
000000r 2               
000000r 2               tea	=	$800		;tea start
000000r 2               
000000r 2               ;zero page for setup
000000r 2               trknum	=	$02			;current track
000000r 2               dcbadd	=	$04			;dcb address
000000r 2               nmsstr	=	$06			;number system tracks
000000r 2               nsectr	=	$08			;number sectors per track
000000r 2               ttlsec	=	$0A			;total sectors to write
000000r 2               trkcnt	=	ttlsec
000000r 2               size	=	$0B			;ascii size
000000r 2               lokim	=	$0D			;low kim limit
000000r 2               hikim	=	$0F			;high kim limit
000000r 2               offset	=	$11			;relocation offset
000000r 2               kimcnt	=	$13			;kim counter
000000r 2               pointr	=	$14			;pointer
000000r 2               lengt	=	$16			;inst length
000000r 2               point	=	$17			;relocate pointer
000000r 2               adjust	=	$19			;relocate distance
000000r 2               kimpnt	=	$1B			;kim file index
000000r 2               savex	=	$1C			;save for x
000000r 2               savey	=	$1D			;save for y
000000r 2               number	=	$1E			;input pack buffer
000000r 2               dstdrv	=	$20			;destination drive
000000r 2               defalt	=	$21			;default drive
000000r 2               seccnt	=	$22			;sector count
000000r 2               secnum	=	$24			;sector number
000000r 2               curccm	=	$26			;start of current ccm
000000r 2               simlng	=	$28			;length of sim
000000r 2               room	=	$2A			;memory needed for sysgen
000000r 2               stksav	=	$2C			;save stack register
000000r 2               frstsc	=	$2D			;first sector number of disk
000000r 2               dskcfpc	=	$2E			;pointer to disk configuration table
000000r 2               cmdlnp	=	$30			;pointer to command line buffer
000000r 2               farfunct=       $32                     ;function to call in driver area
000000r 2               farpointer=     $33                     ;WORD POINTER to call in driver area
000000r 2               lastzp	=	$35
000000r 2               
000000r 2               ;pem constants on entry to write
000000r 2               wrall	=	0		;write to allocated
000000r 2               wrdir	=	1		;write to directory
000000r 2               wrual	=	2		;write to unallocated
000000r 2               
000000r 2               ;page zero and system ram assignments
000000r 2               DEST	 =	$EC		;pointer for OutMsg
000000r 2               SRC	 =	$EE		;pointer for OutMsg
000000r 2               OUTMSG_W =	$F0		;pointer for OutMsg
000000r 2               mvepnt	=	$f2		;host buffer location
000000r 2               dmaadr	=	$f4		;pointer for r/w
000000r 2               
000000r 2               ;fixed parameters
000000r 2               lf	=	$a		;linefeeed
000000r 2               cr	=	$d		;return
000000r 2               eof	=	$1a		;end of file
000000r 2               null	=	0		;null
000000r 2               ctlc	=	3		;abort
000000r 2               ctle	=	5		;physical cr lf
000000r 2               ctli	=	9		;tab character
000000r 2               ctlp	=	$10		;toggle printer
000000r 2               ctlr	=	$12		;repeat line
000000r 2               ctls	=	$13		;freeze
000000r 2               ctlx	=	$18		;cancel
000000r 2               semico	=	$3b		;semicolon
000000r 2               delete	=	$08		;delete character
000000r 2               numcmd	=	36		;number commands
000000r 2               
000000r 2               BANKED_DRIVER_DISPATCHER=$8800  ; LOCATION OF DRIVER DISPATCHER
000000r 2               DEBUG	=	0		; assemble with debug information on
000000r 2               
000000r 2               
000000r 2               USESERIAL 	= 	1	; SET TO ONE SERIAL CONSOLE IO
000000r 2               USEFLOPPYA 	= 	0	; SET TO ONE FOR FLOPPY = "A"
000000r 2               USEFLOPPYB 	= 	0	; SET TO ONE FOR FLOPPY = "B"
000000r 2               USEIDEC 	= 	1	; SET TO ONE FOR IDE HDD="C"
000000r 2               USEDSKY 	= 	0	; SEND INFO TO DSKY
000000r 2               USEDSKYNG 	= 	1	; SEND INFO TO DSKYNG
000000r 2               DSKY_KBD	=	1	; USE DSKY KEYBOARD?
000000r 2               DEFDRV  	=	2	; SET TO DEFAULT DRIVE LETTER
000000r 2               USEDISKIOV1     = 	0	; Floppy and IDE card is  DISK IO V1
000000r 2               USEDISKIOV3     = 	0	; Floppy and IDE card is  DISK IO V3
000000r 2               
000000r 2               FLPA35		=	0	; set to 1 if floppy a is A 3.5" 80 track drive (0= 5.25" 40 track drive)
000000r 2               FLPB35		=	0	; set to 1 if floppy a is B 3.5" 80 track drive (0= 5.25" 40 track drive)
000000r 2               
000000r 2               DSKYOSC         =	100000
000000r 2               
000000r 1               
000000r 1               ; for Nhyodyne:
000000r 1               ; RAM BANK $0C is RAM area for Drivers
000000r 1               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
000000r 1               ; RAM BANK $0F is fixed bank $0000-$7FFF
000000r 1               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
000000r 1               
000000r 1               		.PC02
000000r 1                               .segment "OS"
000000r 1               		.ORG $B800
00B800  1               		.include "ccmnhy.asm"
00B800  2               ;________________________________________________________________________________________________________________________________
00B800  2               ;
00B800  2               ;	Nhyodyne dos/65 dos/65 console command module (ccm)
00B800  2               ;
00B800  2               ;  DWERNER 12/20/2021 	ported to Nhyodyne
00B800  2               ;  DWERNER 12/30/2021   changed .COM files to .CO6 files to reduce confusion when
00B800  2               ;                       sharing CP/M file system images
00B800  2               ;  DWERNER 02/19/2022   Strip off Most significant bit of file name in dir to
00B800  2               ;			make filesystem compatible with ROMWBW
00B800  2               ;________________________________________________________________________________________________________________________________
00B800  2               
00B800  2               ;ccm unique definitions
00B800  2               nbuilt	=	7		;number built in commands
00B800  2               ;main program
00B800  2               				; warm boot vector
00B800  2  4C A8 CD     		JMP boot
00B803  2  D8           ccm:	cld			;set binary mode
00B804  2  48           	pha			;save drive number
00B805  2  20 FC BB     	jsr	rstdsk		;initialize system
00B808  2  68           	pla			;restore drive num
00B809  2  20 00 BC     	jsr	slctds		;select drive
00B80C  2  AD 8C CC     	lda	sysdef+6	;get line length
00B80F  2  4A           	lsr	a		;divide
00B810  2  4A           	lsr	a		;by
00B811  2  4A           	lsr	a		;16
00B812  2  4A           	lsr	a		;for dir
00B813  2  8D F6 BF     	sta	sixten		;and save
00B816  2  AD 43 BF     	lda	cnslng		;get buffer length
00B819  2  D0 3C        	bne	mrecmd		;if more handle it
00B81B  2  A2 FF        ccmlpe:	ldx	#$ff		;set
00B81D  2  9A           	txs			;stack
00B81E  2  D8           	cld			;set binary mode
00B81F  2  A9 11        	lda	#17		; SEND A XON
00B821  2  20 F0 BB     	jsr	chrout		; ----------
00B824  2  20 69 BC     	jsr	hdrout		;send header
00B827  2  A9 3E        	lda	#'>'		;then print
00B829  2  20 F0 BB     	jsr	chrout		;prompt
00B82C  2  AD 8B BE     	lda	cnsbvc		;point to start
00B82F  2  AC 8C BE     	ldy	cnsbvc+1	;of buffer
00B832  2  20 F4 BB     	jsr	rdebuf		;do buffer read
00B835  2  A0 00        	ldy	#0		;clear index
00B837  2  AE 43 BF     	ldx	cnslng		;get length
00B83A  2  F0 DF        	beq	ccmlpe		;loop if empty
00B83C  2  B9 44 BF     lwrupr:	lda	cnstxt,y	;else get char
00B83F  2  C9 61        	cmp	#'a'		;if less than a
00B841  2  90 09        	bcc	nxtchg		;skip convert
00B843  2  C9 7B        	cmp	#'z'+1		;if over z
00B845  2  B0 05        	bcs	nxtchg		;skip convert
00B847  2  29 5F        	and	#%01011111	;else convert
00B849  2  99 44 BF     	sta	cnstxt,y	;put back in buffer
00B84C  2  C8           nxtchg:	iny			;bump index
00B84D  2  CA           	dex			;count down
00B84E  2  D0 EC        	bne	lwrupr		;loop if more
00B850  2  8A           	txa			;set a to zero
00B851  2  99 44 BF     	sta	cnstxt,y	;insert stopper
00B854  2  8D E7 BF     	sta	cnbfpt		;initialize pointer
00B857  2  20 A4 BD     mrecmd:	jsr	stdflb		;set default buffer
00B85A  2  20 2B BC     	jsr	intdsk		;get drive number
00B85D  2  8D E8 BF     	sta	dfldsk		;store as default
00B860  2  20 A5 BC     	jsr	prslin		;parse command
00B863  2  D0 64        	bne	cmderr		;error if afn
00B865  2  AD E9 BF     	lda	tmpdsk		;get temporary
00B868  2  F0 04        	beq	nodrch		;if zero ok
00B86A  2  A9 15        	lda	#nbuilt*3	;else set and
00B86C  2  D0 2E        	bne	dotrns		;do transient
00B86E  2  A9 00        nodrch:	lda	#0		;clear
00B870  2  AA           	tax			;table index
00B871  2  8D EC BF     	sta	ccmcount		;and count
00B874  2  A0 01        tsnxfn:	ldy	#1		;set fcb index
00B876  2  BD 1D BF     tsnxch:	lda	fnctbl,x	;get table entry
00B879  2  F0 1A        	beq	gotcmd		;if zero got it
00B87B  2  D9 C3 BF     	cmp	fcbone,y	;else test
00B87E  2  D0 04        	bne	nocmpr		;no good if not =
00B880  2  E8           	inx			;bump
00B881  2  C8           	iny			;pointers
00B882  2  D0 F2        	bne	tsnxch		;and loop
00B884  2  E8           nocmpr:	inx			;go to end
00B885  2  BD 1D BF     	lda	fnctbl,x	;of table
00B888  2  D0 FA        	bne	nocmpr		;entry
00B88A  2  E8           	inx			;point to next
00B88B  2  EE EC BF     	inc	ccmcount		;bump count
00B88E  2  AD EC BF     	lda	ccmcount		;and if not
00B891  2  C9 07        	cmp	#nbuilt		;limit then
00B893  2  D0 DF        	bne	tsnxfn		;try next
00B895  2  AD EC BF     gotcmd:	lda	ccmcount		;get count
00B898  2  0A           	asl	a		;multiply by two
00B899  2  6D EC BF     	adc	ccmcount		;then add for x3
00B89C  2  AA           dotrns:	tax			;use as index
00B89D  2  E8           	inx			;bump to pass jmp
00B89E  2  BD 96 BE     	lda	xqfntb,x	;to get
00B8A1  2  BC 97 BE     	ldy	xqfntb+1,x	;entry address
00B8A4  2  8D EA BF     	sta	vector		;then set
00B8A7  2  8C EB BF     	sty	vector+1	;vector
00B8AA  2  AD 8F BE     	lda	extcvc+1	;save
00B8AD  2  48           	pha			;return
00B8AE  2  AD 8E BE     	lda	extcvc		;address
00B8B1  2  48           	pha			;on stack
00B8B2  2  6C EA BF     	jmp	(vector)	;execute
00B8B5  2  20 34 BC     extcmd:	jsr	rstddr		;restore default
00B8B8  2  20 A5 BC     extwod:	jsr	prslin		;parse more
00B8BB  2  AD C4 BF     	lda	fcbone+1	;if first
00B8BE  2  38           	sec			;character
00B8BF  2  E9 20        	sbc	#' '		;not a space
00B8C1  2  0D E9 BF     	ora	tmpdsk		;or if temporary
00B8C4  2  D0 03        	bne	cmderr		;then an error
00B8C6  2  4C 1B B8     	jmp	ccmlpe		;else loop
00B8C9  2               ;command error syntax handler
00B8C9  2  20 E1 BB     cmderr:	jsr	ccrlf		;do a cr lf
00B8CC  2  AC ED BF     	ldy	curpnt		;get command pointer
00B8CF  2  B9 44 BF     cmerlp:	lda	cnstxt,y	;get char
00B8D2  2  F0 0A        	beq	cmerex		;if null then done
00B8D4  2  C9 20        	cmp	#' '		;if space
00B8D6  2  F0 06        	beq	cmerex		;then done
00B8D8  2  20 72 BC     	jsr	cotsxy		;output with save
00B8DB  2  C8           	iny			;point to next
00B8DC  2  D0 F1        	bne	cmerlp		;and loop
00B8DE  2  A9 3F        cmerex:	lda	#'?'		;send a
00B8E0  2  20 F0 BB     	jsr	chrout		;question mark
00B8E3  2  4C 1B B8     	jmp	ccmlpe		;and start over
00B8E6  2               ;execute dir command
00B8E6  2               ; dir <afn>
00B8E6  2  20 A5 BC     dir:	jsr	prslin		;find object file
00B8E9  2  20 AB BD     	jsr	clrslt		;clear auto and select
00B8EC  2  A9 20        	lda	#' '		;if name
00B8EE  2  CD C4 BF     	cmp	fcbone+1	;and
00B8F1  2  D0 0F        	bne	findfr		;type are
00B8F3  2  CD CC BF     	cmp	fcbone+9	;not empty
00B8F6  2  D0 0A        	bne	findfr		;then use it
00B8F8  2  A9 3F        	lda	#'?'		;else
00B8FA  2  A0 0B        	ldy	#11		;fill
00B8FC  2  99 C3 BF     fillqu:	sta	fcbone,y	;fcb
00B8FF  2  88           	dey			;with
00B900  2  D0 FA        	bne	fillqu		;question marks
00B902  2  20 5F BC     findfr:	jsr	srchf1		;search for first match
00B905  2  30 58        	bmi	notfnd		;error if none
00B907  2  AD F6 BF     fnddir:	lda	sixten		;set across
00B90A  2  8D F5 BF     	sta	across		;to four
00B90D  2  20 E1 BB     	jsr	ccrlf		;do a crlf
00B910  2  20 6C BC     dirl:	jsr	hdr		;do header
00B913  2  A9 3A        	lda	#':'		;then a
00B915  2  20 F0 BB     	jsr	chrout		;colon
00B918  2  AD EE BF     	lda	diradd		;get number
00B91B  2  0A           	asl	a		;and
00B91C  2  0A           	asl	a		;multiply
00B91D  2  0A           	asl	a		;by
00B91E  2  0A           	asl	a		;thirty two
00B91F  2  0A           	asl	a		;then
00B920  2  29 60        	and	#%01100000	;mask out insignificant
00B922  2  A8           	tay			;make a pointer
00B923  2  C8           	iny			;and bump
00B924  2  A2 01        	ldx	#1		;set counter
00B926  2  B9 28 01     nmelpe:	lda	dflbuf,y	;get name
00B929  2  29 7F        	AND 	#$7F		;mask out read only bit
00B92B  2  20 72 BC     	jsr	cotsxy		;else send to console
00B92E  2  C8           noname:	iny			;bump index
00B92F  2  E8           	inx			;and count
00B930  2  E0 0C        	cpx	#12		;if count is 12
00B932  2  F0 0C        	beq	endnme		;then done
00B934  2  E0 09        	cpx	#9		;or if not 9
00B936  2  D0 EE        	bne	nmelpe		;then loop
00B938  2  A9 2E        	lda	#'.'		;else send
00B93A  2  20 72 BC     	jsr	cotsxy		;a period
00B93D  2  4C 26 B9     	jmp	nmelpe		;and loop
00B940  2  20 F8 BB     endnme:	jsr	chkcst		;check console status
00B943  2  D0 19        	bne	extdir		;if key down quit
00B945  2  20 97 BC     	jsr	setone		;else point to fcb
00B948  2  20 10 BC     	jsr	srchnx		;else search for next
00B94B  2  8D EE BF     	sta	diradd		;save number
00B94E  2  30 0E        	bmi	extdir		;quit if not found
00B950  2  CE F5 BF     	dec	across		;drop count
00B953  2  F0 B2        	beq	fnddir		;new line if 0
00B955  2  20 EE BB     	jsr	spcout		;send
00B958  2  20 EE BB     	jsr	spcout		;two spaces
00B95B  2  4C 10 B9     	jmp	dirl		;and stay
00B95E  2  60           extdir:	rts			;else done
00B95F  2               ;not found error handler
00B95F  2  A0 34        notfnd:	ldy	#ntfnms		;point to message
00B961  2  4C C0 BD     	jmp	sndmsg		;send and exit
00B964  2               ;execute ren command
00B964  2               ; ren <ufn> <ufn>
00B964  2               ;where first ufn is from name and second is to name
00B964  2  20 A5 BC     ren:	jsr	prslin		;get old name
00B967  2  D0 57        	bne	renerr		;error if afn
00B969  2  20 9E BC     	jsr	tmpold		;save drive
00B96C  2  20 AB BD     	jsr	clrslt		;clear auto and select
00B96F  2  20 5F BC     	jsr	srchf1		;if file does not exist
00B972  2  30 4F        	bmi	fntfnd		;then an error
00B974  2  20 E0 BD     	jsr	frssec		;move name to second half
00B977  2  AC E7 BF     	ldy	cnbfpt		;get pointer
00B97A  2  B9 44 BF     	lda	cnstxt,y	;and then char
00B97D  2  C9 20        	cmp	#' '		;if not a space
00B97F  2  D0 3C        	bne	rensyn		;then error
00B981  2  20 A5 BC     	jsr	prslin		;get new name
00B984  2  D0 37        	bne	rensyn		;error if afn
00B986  2  AD E9 BF     	lda	tmpdsk		;get new drive
00B989  2  F0 12        	beq	nonwdr		;if zero ok
00B98B  2  CD F2 BF     	cmp	oldtmp		;compare to old
00B98E  2  F0 0D        	beq	nonwdr		;ok if same
00B990  2  38           	sec			;drop for default check
00B991  2  E9 01        	sbc	#1
00B993  2  CD E8 BF     	cmp	dfldsk		;if not default
00B996  2  D0 25        	bne	rensyn		;is error
00B998  2  AD F2 BF     	lda	oldtmp		;and then if from not
00B99B  2  D0 20        	bne	rensyn		;default is error
00B99D  2  AD F2 BF     nonwdr:	lda	oldtmp		;else get old
00B9A0  2  8D E9 BF     	sta	tmpdsk		;and save
00B9A3  2  A9 00        	lda	#0		;clear
00B9A5  2  8D D3 BF     	sta	fcbone+16
00B9A8  2  20 AB BD     	jsr	clrslt		;reselect
00B9AB  2  20 5F BC     	jsr	srchf1		;search for old
00B9AE  2  10 09        	bpl	filexs		;error if found
00B9B0  2  20 E0 BD     	jsr	frssec		;swap names
00B9B3  2  20 97 BC     	jsr	setone		;point to fcb
00B9B6  2  4C 27 BC     	jmp	renmfl		;and do it
00B9B9  2               ;ren file exists error handler
00B9B9  2  A0 3E        filexs:	ldy	#flexms		;point to
00B9BB  2  D0 08        	bne	remsg		;and send
00B9BD  2               ;ren syntax error handler
00B9BD  2  20 34 BC     rensyn:	jsr	rstddr		;restore default
00B9C0  2  4C C9 B8     renerr:	jmp	cmderr		;do error
00B9C3  2               ;ren source file not found error handler
00B9C3  2  A0 34        fntfnd:	ldy	#ntfnms		;point to
00B9C5  2  4C C0 BD     remsg:	jmp	sndmsg		;and send
00B9C8  2               ;execute save command
00B9C8  2               ; save <length> <drive:>ufn (<address>)
00B9C8  2  A9 00        save:	lda	#<tea		;set start address to tea start
00B9CA  2  A0 08        	ldy	#>tea
00B9CC  2  8D FC BF     	sta	sadr
00B9CF  2  8C FD BF     	sty	sadr+1
00B9D2  2  20 05 BE     	jsr	bldnum		;calculate length
00B9D5  2  D0 7A        	bne	saverr		;error if > 255 pages
00B9D7  2  8D F1 BF     	sta	length		;else save low
00B9DA  2  0D F1 BF     	ora	length		;test for zero length
00B9DD  2  F0 72        	beq	saverr		;error if is
00B9DF  2  20 A5 BC     	jsr	prslin		;get file name
00B9E2  2  D0 6D        	bne	saverr		;error if afn
00B9E4  2  20 E0 BD     	jsr	frssec		;move name to second half
00B9E7  2  20 9E BC     	jsr	tmpold		;save drive
00B9EA  2  20 05 BE     	jsr	bldnum		;it is so find value
00B9ED  2  AE C4 BF     	ldx	fcbone+1	;see if there
00B9F0  2  E0 20        	cpx	#' '
00B9F2  2  F0 0A        	beq	nosadr		;it is not
00B9F4  2  8D FC BF     	sta	sadr		;and set address
00B9F7  2  8C FD BF     	sty	sadr+1
00B9FA  2  C0 02        	cpy	#2		;make sure is high enough
00B9FC  2  90 53        	bcc	saverr		;error if not
00B9FE  2  20 F3 BD     nosadr:	jsr	secfrs		;move name back
00BA01  2  20 AB BD     	jsr	clrslt		;clear auto and select
00BA04  2  20 14 BC     	jsr	dlt1		;delete
00BA07  2  20 97 BC     	jsr	setone		;then create
00BA0A  2  20 23 BC     	jsr	cratfl		;new file
00BA0D  2  30 45        	bmi	noroom		;say no room if error
00BA0F  2  20 4A BC     	jsr	open1		;open file
00BA12  2  30 44        	bmi	noopen		;if error
00BA14  2  18           	clc			;now find end page
00BA15  2  AD FD BF     	lda	sadr+1
00BA18  2  6D F1 BF     	adc	length
00BA1B  2  8D F1 BF     	sta	length
00BA1E  2  AD FC BF     	lda	sadr		;get start address
00BA21  2  AC FD BF     	ldy	sadr+1
00BA24  2  8D F3 BF     wrtmre:	sta	dskbuf		;set
00BA27  2  8C F4 BF     	sty	dskbuf+1	;buffer
00BA2A  2  20 C4 CA     	jsr	mv128		;move data to buffer
00BA2D  2  20 97 BC     	jsr	setone		;point to fcb
00BA30  2  20 1F BC     	jsr	wrrcrd		;write record
00BA33  2  D0 27        	bne	wrterr		;exit if error
00BA35  2  18           	clc			;else
00BA36  2  AD F3 BF     	lda	dskbuf		;get old
00BA39  2  AC F4 BF     	ldy	dskbuf+1	;buffer
00BA3C  2  69 80        	adc	#128		;add 128
00BA3E  2  90 03        	bcc	donotc		;if carry
00BA40  2  C8           	iny			;bump upper
00BA41  2  F0 05        	beq	clssav		;done if page zero
00BA43  2  CC F1 BF     donotc:	cpy	length		;loop if upper
00BA46  2  D0 DC        	bne	wrtmre		;not at limit
00BA48  2  20 97 BC     clssav:	jsr	setone		;else point to
00BA4B  2  20 08 BC     	jsr	clsefl		;and close file
00BA4E  2  30 10        	bmi	cantcl		;say so if error
00BA50  2  60           extera:	rts
00BA51  2               ;save error handler
00BA51  2  4C C9 B8     saverr:	jmp	cmderr		;do error
00BA54  2               ;save no room error handler
00BA54  2  A0 01        noroom:	ldy	#nospms		;point to
00BA56  2  D0 0A        	bne	semsg		;and send
00BA58  2               ;save can not open error handler
00BA58  2  A0 55        noopen:	ldy	#cnnoms		;point to
00BA5A  2  D0 06        	bne	semsg		;and send
00BA5C  2               ;save write error handler
00BA5C  2  A0 62        wrterr:	ldy	#wrerms		;point
00BA5E  2  D0 02        	bne	semsg		;to and send
00BA60  2               ;save can not close error
00BA60  2  A0 0A        cantcl:	ldy	#ntclms		;point to
00BA62  2  4C C0 BD     semsg:	jmp	sndmsg		;and send
00BA65  2               ;execute era command
00BA65  2               ; era <afn>
00BA65  2  20 A5 BC     era:	jsr	prslin		;get file name
00BA68  2  C9 0B        	cmp	#11		;if not all ?
00BA6A  2  D0 13        	bne	nteral		;then skip verify
00BA6C  2  A0 18        	ldy	#alflms		;else point to
00BA6E  2  20 C0 BD     	jsr	sndmsg		;and send all files
00BA71  2  20 EA BB     	jsr	cnsrde		;get an input
00BA74  2  48           	pha			;and save
00BA75  2  20 E1 BB     	jsr	ccrlf		;do a cr lf
00BA78  2  68           	pla			;restore char
00BA79  2  29 5F        	and	#$5f		;convert to upper case
00BA7B  2  C9 59        	cmp	#'Y'		;if not y
00BA7D  2  D0 D1        	bne	extera		;then quit
00BA7F  2  20 AB BD     nteral:	jsr	clrslt		;clear auto and select
00BA82  2  4C 14 BC     	jmp	dlt1		;delete first
00BA85  2               ;execute type command
00BA85  2               ; type d:ufn
00BA85  2  20 A5 BC     type:	jsr	prslin		;get file
00BA88  2  D0 30        	bne	typafn		;error if afn
00BA8A  2  20 47 BC     	jsr	casdo1		;clear - select - open file 1
00BA8D  2  30 32        	bmi	notype		;error if not found
00BA8F  2  20 E1 BB     	jsr	ccrlf		;else do cr lf
00BA92  2  20 59 BC     typmre:	jsr	read1		;read record
00BA95  2  F0 04        	beq	okread		;if ok continue
00BA97  2  10 20        	bpl	exttyp		;exit if just end
00BA99  2  30 22        	bmi	typerr		;else error
00BA9B  2  A2 00        okread:	ldx	#0		;clear index
00BA9D  2  BD 28 01     typlpe:	lda	dflbuf,x	;get char
00BAA0  2  C9 1A        	cmp	#eof		;if eof
00BAA2  2  F0 15        	beq	exttyp		;then exit
00BAA4  2  20 72 BC     	jsr	cotsxy		;else send
00BAA7  2  20 F8 BB     	jsr	chkcst		;if key down
00BAAA  2  D0 08        	bne	exttok		;then exit
00BAAC  2  AE EF BF     	ldx	savx		;else get index
00BAAF  2  E8           	inx			;bump it
00BAB0  2  10 EB        	bpl	typlpe		;and loop if < 128
00BAB2  2  30 DE        	bmi	typmre		;else read more
00BAB4  2  A2 06        exttok:	ldx	#6		;clear console
00BAB6  2  20 03 01     	jsr	pemjmp		;with no echo
00BAB9  2  60           exttyp:	rts
00BABA  2               ;type syntax error handler
00BABA  2  4C C9 B8     typafn:	jmp	cmderr		;error return
00BABD  2               ;type read error handler
00BABD  2  A0 29        typerr:	ldy	#rderms		;point to
00BABF  2  D0 02        	bne	temsg		;and send
00BAC1  2               ;type not found error handler
00BAC1  2  A0 34        notype:	ldy	#ntfnms		;point to
00BAC3  2  4C C0 BD     temsg:	jmp	sndmsg		;and send
00BAC6  2               ;execute load command
00BAC6  2               ; load <ufn> (<address>)
00BAC6  2  20 D5 BD     load:	jsr	setddb		;set load start to tea start
00BAC9  2  20 A5 BC     	jsr	prslin		;build fcb
00BACC  2  D0 EC        	bne	typafn		;error if afn
00BACE  2  20 E0 BD     	jsr	frssec		;save in second half
00BAD1  2  20 9E BC     	jsr	tmpold		;save file
00BAD4  2  20 05 BE     	jsr	bldnum		;find start address
00BAD7  2  AE C4 BF     	ldx	fcbone+1	;see if number
00BADA  2  E0 20        	cpx	#' '
00BADC  2  F0 03        	beq	usedfl		;if none use default
00BADE  2  20 D9 BD     	jsr	setdb		;and set
00BAE1  2  20 F3 BD     usedfl:	jsr	secfrs		;move name back
00BAE4  2  20 47 BC     	jsr	casdo1		;clear - select - open file 1
00BAE7  2  30 D8        	bmi	notype		;exit if not found
00BAE9  2  AD F3 BF     	lda	dskbuf		;get load start
00BAEC  2  AC F4 BF     	ldy	dskbuf+1
00BAEF  2  20 2F BC     lcmdlp:	jsr	setbuf		;set as disk buffer
00BAF2  2  20 59 BC     	jsr	read1		;read record
00BAF5  2  D0 06        	bne	loadnd		;done if not zero
00BAF7  2  20 B1 CA     	jsr	adjdb		;bump address
00BAFA  2  4C EF BA     	jmp	lcmdlp		;and loop
00BAFD  2  30 BE        loadnd:	bmi	typerr		;if error say so
00BAFF  2  4C A4 BD     	jmp	stdflb		;back to default buffer
00BB02  2               ;execute go command
00BB02  2               ; go (<address>)
00BB02  2  20 05 BE     go:	jsr	bldnum		;get address
00BB05  2  AE C4 BF     	ldx	fcbone+1	;get first char
00BB08  2  E0 20        	cpx	#' '		;see if nothing
00BB0A  2  F0 03        	beq	nolnum		;nothing so use tea
00BB0C  2  4C 76 BB     	jmp	godoit		;then execute
00BB0F  2  4C 72 BB     nolnum:	jmp	gotea
00BB12  2               ;execute trns (transient) command
00BB12  2               ; <ufn> (<fn>) (<fn>)
00BB12  2  AD C4 BF     trns:	lda	fcbone+1	;get first char
00BB15  2  C9 20        	cmp	#' '		;if not space
00BB17  2  D0 11        	bne	chktyp		;check type
00BB19  2  AD E9 BF     	lda	tmpdsk		;else test temp
00BB1C  2  F0 09        	beq	skpdrv		;if none skip
00BB1E  2  38           	sec			;else convert
00BB1F  2  E9 01        	sbc	#1		;to number
00BB21  2  8D E8 BF     	sta	dfldsk		;set default
00BB24  2  20 00 BC     	jsr	slctds		;and select
00BB27  2  4C B8 B8     skpdrv:	jmp	extwod		;return
00BB2A  2  AD CC BF     chktyp:	lda	fcbone+9	;get type
00BB2D  2  C9 20        	cmp	#' '		;if space
00BB2F  2  F0 03        	beq	typemp		;then ok
00BB31  2  4C D9 BB     	jmp	trnerr		;else error
00BB34  2  A2 02        typemp:	ldx	#2		;make
00BB36  2  BD E4 BF     setcom:	lda	typcom,x	;type
00BB39  2  9D CC BF     	sta	fcbone+9,x	;com
00BB3C  2  CA           	dex			;then
00BB3D  2  10 F7        	bpl	setcom		;continue
00BB3F  2  20 47 BC     	jsr	casdo1		;clear - select - open file one
00BB42  2  10 03        	bpl	gottrn		;jump if ok
00BB44  2  4C D6 BB     	jmp	topner		;else do error
00BB47  2  20 D5 BD     gottrn:	jsr	setddb		;set start to tea
00BB4A  2  20 2F BC     nxtrcr:	jsr	setbuf		;set address
00BB4D  2  20 59 BC     	jsr	read1		;read fcb 1
00BB50  2  D0 1E        	bne	endlde		;branch if error or eof
00BB52  2  20 B1 CA     	jsr	adjdb		;adjust address up by 128
00BB55  2  CD 91 BE     	cmp	ccmvc		;if new low
00BB58  2  90 07        	bcc	tryhig		;ok try high
00BB5A  2  CC 92 BE     	cpy	ccmvc+1		;else if high
00BB5D  2  90 EB        	bcc	nxtrcr		;ok do more
00BB5F  2  B0 07        	bcs	chklnd		;else check for end
00BB61  2  CC 92 BE     tryhig:	cpy	ccmvc+1		;if high less
00BB64  2  90 E4        	bcc	nxtrcr		;then ok
00BB66  2  F0 E2        	beq	nxtrcr		;or ok if same
00BB68  2  20 A4 BD     chklnd:	jsr	stdflb		;set buffer to default
00BB6B  2  20 59 BC     	jsr	read1		;read (should be eof)
00BB6E  2  F0 6C        	beq	tlderr		;error if more
00BB70  2  30 6A        endlde:	bmi	tlderr		;do error
00BB72  2  A9 00        gotea:	lda	#<tea		;set go address to tea start
00BB74  2  A0 08        	ldy	#>tea
00BB76  2  8D CB BB     godoit:	sta	do+1		;set to ay
00BB79  2  8C CC BB     	sty	do+2
00BB7C  2  20 34 BC     	jsr	rstddr		;else restore default
00BB7F  2  20 A5 BC     	jsr	prslin		;parse file
00BB82  2  AD E9 BF     	lda	tmpdsk		;set auto
00BB85  2  8D C3 BF     	sta	fcbone		;select position
00BB88  2  A2 10        	ldx	#16		;do a second
00BB8A  2  20 A7 BC     	jsr	prsmre		;fcb if there
00BB8D  2  AD E9 BF     	lda	tmpdsk		;set auto select
00BB90  2  8D D3 BF     	sta	fcbone+16	;again
00BB93  2  A0 00        	ldy	#0		;clear record
00BB95  2  8C E3 BF     	sty	fcbone+32	;counter
00BB98  2  A2 20        	ldx	#32		;move
00BB9A  2  BD C3 BF     movfcb:	lda	fcbone,x	;all
00BB9D  2  9D 07 01     	sta	dflfcb,x	;to
00BBA0  2  CA           	dex			;default
00BBA1  2  10 F7        	bpl	movfcb		;fcb
00BBA3  2  E8           	inx			;set x to zero
00BBA4  2  B9 44 BF     tstbuf:	lda	cnstxt,y	;get char
00BBA7  2  F0 07        	beq	isnull		;if null jump
00BBA9  2  C9 20        	cmp	#' '		;or if space
00BBAB  2  F0 03        	beq	isnull		;jump
00BBAD  2  C8           	iny			;else bump pointer
00BBAE  2  D0 F4        	bne	tstbuf		;and loop
00BBB0  2  A9 00        isnull:	lda	#0		;clear
00BBB2  2  8D 28 01     	sta	dflbuf		;count
00BBB5  2  B9 44 BF     movbuf:	lda	cnstxt,y	;get char
00BBB8  2  9D 29 01     	sta	dflbuf+1,x	;and move
00BBBB  2  F0 07        	beq	fillov		;exit if null
00BBBD  2  E8           	inx			;increment
00BBBE  2  C8           	iny			;counters
00BBBF  2  EE 28 01     	inc	dflbuf		;and length
00BBC2  2  D0 F1        	bne	movbuf		;and loop
00BBC4  2  20 E1 BB     fillov:	jsr	ccrlf		;do a cr lf
00BBC7  2  20 A4 BD     	jsr	stdflb		;set default
00BBCA  2  20 00 08     do:	jsr	tea		;execute
00BBCD  2  AD E8 BF     	lda	dfldsk		;get default
00BBD0  2  20 00 BC     	jsr	slctds		;and set
00BBD3  2  4C 1B B8     	jmp	ccmlpe		;then loop
00BBD6  2               ;trns syntax error handler
00BBD6  2  20 34 BC     topner:	jsr	rstddr		;restore default
00BBD9  2  4C C9 B8     trnerr:	jmp	cmderr		;do error
00BBDC  2               ;trns load error
00BBDC  2  A0 4A        tlderr:	ldy	#lderms		;point to
00BBDE  2  4C C0 BD     	jmp	sndmsg		;and send
00BBE1  2               ;carriage return and linefeed
00BBE1  2  A9 0D        ccrlf:	lda	#cr		;get a cr
00BBE3  2  20 F0 BB     	jsr	chrout		;send
00BBE6  2  A9 0A        	lda	#lf		;get a lf
00BBE8  2  D0 06        	bne	chrout		;and send
00BBEA  2               ;pem entry routines
00BBEA  2  A2 01        cnsrde:	ldx	#1		;console read
00BBEC  2  D0 43        	bne	pemgo
00BBEE  2  A9 20        spcout:	lda	#' '		;output space
00BBF0  2  A2 02        chrout:	ldx	#2		;console output
00BBF2  2  D0 3D        	bne	pemgo
00BBF4  2  A2 0A        rdebuf:	ldx	#10		;buffered input
00BBF6  2  D0 39        	bne	pemgo
00BBF8  2  A2 0B        chkcst:	ldx	#11		;check console
00BBFA  2  D0 35        	bne	pemgo
00BBFC  2  A2 0D        rstdsk:	ldx	#13		;initialize system
00BBFE  2  D0 31        	bne	pemgo
00BC00  2  A2 0E        slctds:	ldx	#14		;select drive
00BC02  2  D0 2D        	bne	pemgo
00BC04  2  A2 0F        openfl:	ldx	#15		;open file
00BC06  2  D0 29        	bne	pemgo
00BC08  2  A2 10        clsefl:	ldx	#16		;close file
00BC0A  2  D0 25        	bne	pemgo
00BC0C  2  A2 11        srchfr:	ldx	#17		;first match
00BC0E  2  D0 21        	bne	pemgo
00BC10  2  A2 12        srchnx:	ldx	#18		;next match
00BC12  2  D0 1D        	bne	pemgo
00BC14  2               ;delete file one
00BC14  2  20 97 BC     dlt1:	jsr	setone		;point to fcb
00BC17  2  A2 13        dltfil:	ldx	#19		;delete file
00BC19  2  D0 16        	bne	pemgo
00BC1B  2  A2 14        rdrcrd:	ldx	#20		;read record
00BC1D  2  D0 12        	bne	pemgo
00BC1F  2  A2 15        wrrcrd:	ldx	#21		;write record
00BC21  2  D0 0E        	bne	pemgo
00BC23  2  A2 16        cratfl:	ldx	#22		;create file
00BC25  2  D0 0A        	bne	pemgo
00BC27  2  A2 17        renmfl:	ldx	#23		;rename file
00BC29  2  D0 06        	bne	pemgo
00BC2B  2  A2 19        intdsk:	ldx	#25		;read drive num
00BC2D  2  D0 02        	bne	pemgo
00BC2F  2  A2 1A        setbuf:	ldx	#26		;set buffer add
00BC31  2  4C 03 01     pemgo:	jmp	pemjmp		;go to pem
00BC34  2               ;restore default drive
00BC34  2  AD E9 BF     rstddr:	lda	tmpdsk		;if temp drive
00BC37  2  F0 1F        	beq	extddr		;zero then exit
00BC39  2  38           	sec			;else
00BC3A  2  E9 01        	sbc	#1		;subtract one
00BC3C  2  CD E8 BF     	cmp	dfldsk		;compare to default
00BC3F  2  F0 17        	beq	extddr		;exit if same
00BC41  2  AD E8 BF     seldfl:	lda	dfldsk		;else get default
00BC44  2  4C 00 BC     	jmp	slctds		;select
00BC47  2               ;clear auto - select disk - open file at fcbone
00BC47  2  20 AB BD     casdo1:	jsr	clrslt		;clear auto and select
00BC4A  2               ;open file one
00BC4A  2               ; returns:n=1 if not found
00BC4A  2  A9 00        open1:	lda	#0		;clear
00BC4C  2  8D E3 BF     	sta	fcbone+32	;record number
00BC4F  2  20 97 BC     	jsr	setone		;point to fcb
00BC52  2  20 04 BC     	jsr	openfl		;open it
00BC55  2  8D EE BF     	sta	diradd		;save number
00BC58  2  60           extddr:	rts
00BC59  2               ;read file one
00BC59  2  20 97 BC     read1:	jsr	setone		;point to fcb
00BC5C  2  4C 1B BC     	jmp	rdrcrd		;do read
00BC5F  2               ;search for first file one
00BC5F  2               ; returns:n=1 if not found
00BC5F  2  20 97 BC     srchf1:	jsr	setone		;point to fcb
00BC62  2  20 0C BC     	jsr	srchfr		;search for first
00BC65  2  8D EE BF     	sta	diradd		;save number
00BC68  2  60           	rts
00BC69  2               ;header output
00BC69  2  20 E1 BB     hdrout:	jsr	ccrlf		;do cr lf
00BC6C  2  20 2B BC     hdr:	jsr	intdsk		;get drive number
00BC6F  2  18           	clc			;make
00BC70  2  69 41        	adc	#'A'		;a letter
00BC72  2               ;output with save of x and y
00BC72  2               ;this routine calls the pem resident routine
00BC72  2               ;tstchr to see if a char is a printing char.
00BC72  2               ;if it is then c=1 upon return from tstchr.
00BC72  2  8E EF BF     cotsxy:	stx	savx		;save x
00BC75  2  8C F0 BF     	sty	savy		;and y
00BC78  2  20 BB C8     	jsr	tstchr		;see if printing
00BC7B  2  B0 10        	bcs	isprnt		;jump if is
00BC7D  2  48           	pha			;else save
00BC7E  2  AD 8A CC     	lda	sysdef+4	;get invert
00BC81  2  20 F0 BB     	jsr	chrout		;send it
00BC84  2  68           	pla			;get char
00BC85  2  09 40        	ora	#'@'		;make printing
00BC87  2  20 F0 BB     	jsr	chrout		;send it
00BC8A  2  AD 89 CC     	lda	sysdef+3	;get normal
00BC8D  2  20 F0 BB     isprnt:	jsr	chrout		;do output
00BC90  2  AC F0 BF     	ldy	savy		;get y
00BC93  2  AE EF BF     	ldx	savx		;and x
00BC96  2  60           	rts
00BC97  2               ;set up fcb one pointer
00BC97  2  AD 94 BE     setone:	lda	fcb1vc		;low
00BC9A  2  AC 95 BE     	ldy	fcb1vc+1	;and high
00BC9D  2  60           	rts
00BC9E  2               ;save tmpdsk in oldtmp
00BC9E  2  AD E9 BF     tmpold:	lda	tmpdsk
00BCA1  2  8D F2 BF     	sta	oldtmp
00BCA4  2  60           	rts
00BCA5  2               ;parse command line
00BCA5  2  A2 00        prslin:	ldx	#0		;clear index
00BCA7  2  8A           prsmre:	txa			;save
00BCA8  2  48           	pha			;index
00BCA9  2  A9 00        	lda	#0		;clear temp
00BCAB  2  8D E9 BF     	sta	tmpdsk		;drive flag
00BCAE  2  AC E7 BF     	ldy	cnbfpt		;get buffer pointer
00BCB1  2  20 72 BD     	jsr	skpspc		;find first non-space
00BCB4  2  8C ED BF     	sty	curpnt		;save index
00BCB7  2  F0 0D        	beq	nulchr		;jump if null
00BCB9  2  29 0F        	and	#%00001111	;else look at 4 lsbs
00BCBB  2  48           	pha			;and save
00BCBC  2  C8           	iny			;point to next char
00BCBD  2  B9 44 BF     	lda	cnstxt,y	;and get it
00BCC0  2  C9 3A        	cmp	#':'		;if a colon
00BCC2  2  F0 0A        	beq	drvinp		;jump and set drive
00BCC4  2  68           	pla			;else clear stack
00BCC5  2  88           	dey			;backup index
00BCC6  2  AD E8 BF     nulchr:	lda	dfldsk		;set automatic
00BCC9  2  9D C3 BF     	sta	fcbone,x	;to default
00BCCC  2  10 08        	bpl	trynme		;then parse name
00BCCE  2  68           drvinp:	pla			;get number
00BCCF  2  8D E9 BF     	sta	tmpdsk		;set temp flag
00BCD2  2  9D C3 BF     	sta	fcbone,x	;and fcb
00BCD5  2  C8           	iny			;point past colon
00BCD6  2  A9 08        trynme:	lda	#8		;set name count
00BCD8  2  8D EC BF     	sta	ccmcount		;to eight
00BCDB  2  20 7F BD     tstnme:	jsr	tstlgl		;test for illegal
00BCDE  2  F0 1D        	beq	flnmsp		;if illegal jump
00BCE0  2  E8           	inx			;bump pointer
00BCE1  2  C9 2A        	cmp	#'*'		;if not *
00BCE3  2  D0 07        	bne	notafn		;skip ? fill
00BCE5  2  A9 3F        	lda	#'?'		;get a ?
00BCE7  2  9D C3 BF     	sta	fcbone,x	;store
00BCEA  2  D0 04        	bne	nxtout		;and jump
00BCEC  2  9D C3 BF     notafn:	sta	fcbone,x	;store char
00BCEF  2  C8           	iny			;bump source
00BCF0  2  CE EC BF     nxtout:	dec	ccmcount		;drop counter down
00BCF3  2  D0 E6        	bne	tstnme		;and loop
00BCF5  2  20 7F BD     skpmre:	jsr	tstlgl		;if illegal
00BCF8  2  F0 11        	beq	trytyp		;try type
00BCFA  2  C8           	iny			;else bump index
00BCFB  2  D0 F8        	bne	skpmre		;and loop
00BCFD  2  E8           flnmsp:	inx			;next position
00BCFE  2  A9 20        	lda	#' '		;get a space
00BD00  2  9D C3 BF     	sta	fcbone,x	;store
00BD03  2  CE EC BF     	dec	ccmcount		;count down
00BD06  2  D0 F5        	bne	flnmsp		;and loop
00BD08  2  B9 44 BF     	lda	cnstxt,y	;get char again
00BD0B  2  48           trytyp:	pha			;save char
00BD0C  2  A9 03        	lda	#3		;set count
00BD0E  2  8D EC BF     	sta	ccmcount		;to three
00BD11  2  68           	pla			;get char
00BD12  2  C9 2E        	cmp	#'.'		;if not .
00BD14  2  D0 23        	bne	fltysp		;then fill spaces
00BD16  2  C8           	iny			;else bump source
00BD17  2  20 7F BD     tsttyp:	jsr	tstlgl		;if not legal
00BD1A  2  F0 1D        	beq	fltysp		;then fill spaces
00BD1C  2  E8           	inx			;else bump index
00BD1D  2  C9 2A        	cmp	#'*'		;if not *
00BD1F  2  D0 07        	bne	notaft		;then skip fill
00BD21  2  A9 3F        	lda	#'?'		;else get ?
00BD23  2  9D C3 BF     	sta	fcbone,x	;move to fcb
00BD26  2  D0 04        	bne	mrtyfl		;and loop
00BD28  2  9D C3 BF     notaft:	sta	fcbone,x	;move char to fcb
00BD2B  2  C8           	iny			;bump source
00BD2C  2  CE EC BF     mrtyfl:	dec	ccmcount		;count down
00BD2F  2  D0 E6        	bne	tsttyp		;and loop
00BD31  2  20 7F BD     nttype:	jsr	tstlgl		;if illegal
00BD34  2  F0 0E        	beq	filnul		;fill out nulls
00BD36  2  C8           	iny			;else bump source
00BD37  2  D0 F8        	bne	nttype		;and loop
00BD39  2  E8           fltysp:	inx			;bump fcb pointer
00BD3A  2  A9 20        	lda	#' '		;get space
00BD3C  2  9D C3 BF     	sta	fcbone,x	;put in fcb
00BD3F  2  CE EC BF     	dec	ccmcount		;count down
00BD42  2  D0 F5        	bne	fltysp		;and continue
00BD44  2  A9 03        filnul:	lda	#3		;clear
00BD46  2  8D EC BF     	sta	ccmcount		;three
00BD49  2  E8           mrnlty:	inx			;bump fcb pointer
00BD4A  2  A9 00        	lda	#0		;get a zero
00BD4C  2  9D C3 BF     	sta	fcbone,x	;move to fcb
00BD4F  2  CE EC BF     	dec	ccmcount		;count down
00BD52  2  D0 F5        	bne	mrnlty		;loop until done
00BD54  2  8C E7 BF     	sty	cnbfpt		;update start pointer
00BD57  2  A9 00        	lda	#0		;clear
00BD59  2  8D EC BF     	sta	ccmcount		;count
00BD5C  2  68           	pla			;restore stack
00BD5D  2  A8           	tay			;move to index
00BD5E  2  A2 0B        	ldx	#11		;counter to 11
00BD60  2  C8           tstqus:	iny			;point to
00BD61  2  B9 C3 BF     	lda	fcbone,y	;and get char
00BD64  2  C9 3F        	cmp	#'?'		;if not a ?
00BD66  2  D0 03        	bne	nxtqus		;then jump
00BD68  2  EE EC BF     	inc	ccmcount		;else bump count
00BD6B  2  CA           nxtqus:	dex			;loop until
00BD6C  2  D0 F2        	bne	tstqus		;11 tested
00BD6E  2  AD EC BF     	lda	ccmcount		;get count
00BD71  2  60           	rts			;and return
00BD72  2               ;skip space
00BD72  2  B9 44 BF     skpspc:	lda	cnstxt,y	;get char
00BD75  2  F0 07        	beq	extskp		;jump if null
00BD77  2  C9 20        	cmp	#' '		;if not space
00BD79  2  D0 03        	bne	extskp		;then exit
00BD7B  2  C8           	iny			;else go to next
00BD7C  2  D0 F4        	bne	skpspc		;and test
00BD7E  2  60           extskp:	rts
00BD7F  2               ;test legal
00BD7F  2  B9 44 BF     tstlgl:	lda	cnstxt,y	;get char
00BD82  2  F0 1C        	beq	extlgl
00BD84  2  C9 20        	cmp	#' '		;if space
00BD86  2  90 19        	bcc	badinp		;ok - less is error
00BD88  2  F0 16        	beq	extlgl
00BD8A  2  C9 3D        	cmp	#'='
00BD8C  2  F0 12        	beq	extlgl
00BD8E  2  C9 2E        	cmp	#'.'
00BD90  2  F0 0E        	beq	extlgl
00BD92  2  C9 3A        	cmp	#':'
00BD94  2  F0 0A        	beq	extlgl
00BD96  2  C9 3B        	cmp	#semico
00BD98  2  F0 06        	beq	extlgl
00BD9A  2  C9 3C        	cmp	#'<'
00BD9C  2  F0 02        	beq	extlgl
00BD9E  2  C9 3E        	cmp	#'>'
00BDA0  2  60           extlgl:	rts
00BDA1  2  4C C9 B8     badinp:	jmp	cmderr
00BDA4  2               ;set default buffer address
00BDA4  2  A9 28        stdflb:	lda	#<dflbuf 	;point to
00BDA6  2  A0 01        	ldy	#>dflbuf	;location
00BDA8  2  4C 2F BC     	jmp	setbuf		;and set
00BDAB  2               ;clear automatic and select
00BDAB  2  A9 00        clrslt:	lda	#0		;clear auto
00BDAD  2  8D C3 BF     	sta	fcbone		;select
00BDB0  2  AD E9 BF     slttmp:	lda	tmpdsk		;get temp
00BDB3  2  F0 1F        	beq	extsnd		;if zero exit
00BDB5  2  38           	sec			;else subtract
00BDB6  2  E9 01        	sbc	#1		;one
00BDB8  2  CD E8 BF     	cmp	dfldsk		;if same as default
00BDBB  2  F0 17        	beq	extsnd		;then quit
00BDBD  2  4C 00 BC     	jmp	slctds		;else set
00BDC0  2               ;send message
00BDC0  2  8C F0 BF     sndmsg:	sty	savy		;save index
00BDC3  2  20 E1 BB     	jsr	ccrlf		;do cr and lf
00BDC6  2  AC F0 BF     	ldy	savy		;get index
00BDC9  2  B9 AF BE     lpesnd:	lda	msgtbl,y	;get char
00BDCC  2  F0 06        	beq	extsnd		;if null quit
00BDCE  2  20 72 BC     	jsr	cotsxy		;else send
00BDD1  2  C8           	iny			;point to next
00BDD2  2  D0 F5        	bne	lpesnd		;and loop
00BDD4  2  60           extsnd:	rts
00BDD5  2               ;set load start address
00BDD5  2  A9 00        setddb:	lda	#<tea		;to tea start
00BDD7  2  A0 08        	ldy	#>tea
00BDD9  2  8D F3 BF     setdb:	sta	dskbuf		;to ay
00BDDC  2  8C F4 BF     	sty	dskbuf+1
00BDDF  2  60           	rts
00BDE0  2               ;move first part of fcb to second half
00BDE0  2               ;and move second part to first part.
00BDE0  2               ;only ren depends upon this routine to actually
00BDE0  2               ;swap fcb halves.
00BDE0  2               ;alters:a,x,p
00BDE0  2               ;returns:x=$ff
00BDE0  2  A2 0F        frssec:	ldx	#15		;set index to last
00BDE2  2  BD C3 BF     frsclp:	lda	fcbone,x	;get byte
00BDE5  2  BC D3 BF     	ldy	fcbone+16,x
00BDE8  2  9D D3 BF     	sta	fcbone+16,x	;move it
00BDEB  2  98           	tya
00BDEC  2  9D C3 BF     	sta	fcbone,x
00BDEF  2  CA           	dex
00BDF0  2  10 F0        	bpl	frsclp		;until 16 moved
00BDF2  2  60           	rts
00BDF3  2               ;move second part of fcb to first half
00BDF3  2               ;restore tmpdsk from save location
00BDF3  2               ;alters:a,x,p
00BDF3  2               ;returns:x=$ff
00BDF3  2  A2 0F        secfrs:	ldx	#15		;set index to last
00BDF5  2  BD D3 BF     scfrlp:	lda	fcbone+16,x	;get byte
00BDF8  2  9D C3 BF     	sta	fcbone,x	;move it
00BDFB  2  CA           	dex
00BDFC  2  10 F7        	bpl	scfrlp		;loop until done
00BDFE  2  AD F2 BF     	lda	oldtmp		;get old flag
00BE01  2  8D E9 BF     	sta	tmpdsk		;and set
00BE04  2  60           	rts
00BE05  2               ;build a number from command line and leave in num
00BE05  2               ;will handle either decimal (e.g., 578) or hexadecimal (e.g., $3f2)
00BE05  2               ;move parse index past number
00BE05  2               ;modifies:all
00BE05  2               ;returns:a,y set to low and high of number
00BE05  2               ;	 flags set according to y which is high part of number
00BE05  2  A9 09        bldnum:	lda	#9		;preset to decimal
00BE07  2  8D F7 BF     	sta	moduls
00BE0A  2  20 A5 BC     	jsr	prslin		;put in fcb
00BE0D  2  AD E9 BF     	lda	tmpdsk		;if temp
00BE10  2  D0 67        	bne	numerr		;is error
00BE12  2  8D F8 BF     	sta	num		;else clear num
00BE15  2  8D F9 BF     	sta	num+1
00BE18  2  A8           	tay			;and index
00BE19  2  B9 C4 BF     	lda	fcbone+1,y	;get first char
00BE1C  2  C9 24        	cmp	#'$'		;see if hex signal
00BE1E  2  D0 06        	bne	bnumlp		;skip if not
00BE20  2  A9 0F        	lda	#15		;set for modulus
00BE22  2  8D F7 BF     	sta	moduls
00BE25  2  C8           	iny			;bump past $
00BE26  2  C8           bnumlp:	iny			;next char
00BE27  2  B9 C3 BF     	lda	fcbone,y	;get digit
00BE2A  2  C9 20        	cmp	#' '		;see if space
00BE2C  2  F0 4E        	beq	endnlp		;done if is
00BE2E  2  20 9B CA     	jsr	tstdec		;see if decimal
00BE31  2  90 0E        	bcc	usedig		;use if is
00BE33  2  20 A5 CA     	jsr	tsthex		;see if hex
00BE36  2  B0 41        	bcs	numerr		;error if not
00BE38  2  E9 06        	sbc	#6		;remove offset
00BE3A  2  A2 0F        	ldx	#15		;test for hex modulus
00BE3C  2  EC F7 BF     	cpx	moduls
00BE3F  2  D0 38        	bne	numerr		;error if not
00BE41  2  29 0F        usedig:	and	#%00001111	;eliminate ascii bias
00BE43  2  48           	pha			;save result
00BE44  2  AD F8 BF     	lda	num		;move number to temp
00BE47  2  8D FA BF     	sta	tnum
00BE4A  2  AD F9 BF     	lda	num+1
00BE4D  2  8D FB BF     	sta	tnum+1
00BE50  2  AE F7 BF     	ldx	moduls		;get modulus
00BE53  2  18           	clc
00BE54  2  AD F8 BF     addlpe:	lda	num		;add number to itself
00BE57  2  6D FA BF     	adc	tnum
00BE5A  2  8D F8 BF     	sta	num
00BE5D  2  AD F9 BF     	lda	num+1		;modulus times
00BE60  2  6D FB BF     	adc	tnum+1
00BE63  2  8D F9 BF     	sta	num+1
00BE66  2  B0 11        	bcs	numerr		;error if carry out
00BE68  2  CA           	dex
00BE69  2  D0 E9        	bne	addlpe		;loop if more
00BE6B  2  68           	pla			;get input back
00BE6C  2  6D F8 BF     	adc	num		;add in
00BE6F  2  8D F8 BF     	sta	num
00BE72  2  90 B2        	bcc	bnumlp		;loop if no carry
00BE74  2  EE F9 BF     	inc	num+1		;else bump high
00BE77  2  D0 AD        	bne	bnumlp		;and loop for more
00BE79  2               ;error in bldnum - handle and quit
00BE79  2  4C C9 B8     numerr:	jmp	cmderr		;do general error
00BE7C  2               ;end of use of name part - check type
00BE7C  2  AD CC BF     endnlp:	lda	fcbone+9	;get first
00BE7F  2  C9 20        	cmp	#' '		;see if space
00BE81  2  D0 F6        	bne	numerr		;error if not
00BE83  2  AD F8 BF     	lda	num		;return with result
00BE86  2  AC F9 BF     	ldy	num+1
00BE89  2  60           	rts
00BE8A  2               ;relocatable vectors
00BE8A  2  4C           	.byte	$4c
00BE8B  2  42 BF        cnsbvc:	.word	cnsbuf
00BE8D  2  4C           	.byte	$4c
00BE8E  2  B4 B8        extcvc:	.word	extcmd-1
00BE90  2  4C           	.byte	$4c
00BE91  2  03 B8        ccmvc:	.word	ccm
00BE93  2  4C           	.byte	$4c
00BE94  2  C3 BF        fcb1vc:	.word	fcbone
00BE96  2               ;function entry vector
00BE96  2  4C E6 B8     xqfntb:	jmp	dir
00BE99  2  4C C8 B9     	jmp	save
00BE9C  2  4C 65 BA     	jmp	era
00BE9F  2  4C 85 BA     	jmp	type
00BEA2  2  4C 64 B9     	jmp	ren
00BEA5  2  4C 02 BB     	jmp	go
00BEA8  2  4C C6 BA     	jmp	load
00BEAB  2  4C 12 BB     	jmp	trns
00BEAE  2               ;terminator for relocation
00BEAE  2  FF           	.byte	$ff
00BEAF  2               ;messages
00BEAF  2               msgtbl:
00BEAF  2  00           	.byte 0
00BEB0  2               nospms	=	*-msgtbl
00BEB0  2  4E 4F 20 53  	.byte	"NO SPACE",0
00BEB4  2  50 41 43 45  
00BEB8  2  00           
00BEB9  2               ntclms	=	*-msgtbl
00BEB9  2  43 41 4E 20  	.byte "CAN NOT CLOSE",0
00BEBD  2  4E 4F 54 20  
00BEC1  2  43 4C 4F 53  
00BEC7  2               alflms	=	*-msgtbl
00BEC7  2  41 4C 4C 20  	.byte "ALL FILES (Y/N)?",0
00BECB  2  46 49 4C 45  
00BECF  2  53 20 28 59  
00BED8  2               rderms	=	*-msgtbl
00BED8  2  52 45 41 44  	.byte	"READ ERROR",0
00BEDC  2  20 45 52 52  
00BEE0  2  4F 52 00     
00BEE3  2               ntfnms	=	*-msgtbl
00BEE3  2  4E 4F 54 20  	.byte	"NOT FOUND",0
00BEE7  2  46 4F 55 4E  
00BEEB  2  44 00        
00BEED  2               flexms	=	*-msgtbl
00BEED  2  46 49 4C 45  	.byte "FILE EXISTS",0
00BEF1  2  20 45 58 49  
00BEF5  2  53 54 53 00  
00BEF9  2               lderms	=	*-msgtbl
00BEF9  2  4C 4F 41 44  	.byte "LOAD ERROR",0
00BEFD  2  20 45 52 52  
00BF01  2  4F 52 00     
00BF04  2               cnnoms	=	*-msgtbl
00BF04  2  43 41 4E 20  	.byte "CAN NOT OPEN",0
00BF08  2  4E 4F 54 20  
00BF0C  2  4F 50 45 4E  
00BF11  2               wrerms	=	*-msgtbl
00BF11  2  57 52 49 54  	.byte "WRITE ERROR",0
00BF15  2  45 20 45 52  
00BF19  2  52 4F 52 00  
00BF1D  2               ;function name table
00BF1D  2  44 49 52 20  fnctbl:	.byte	"DIR ",0
00BF21  2  00           
00BF22  2  53 41 56 45  	.byte	"SAVE ",0
00BF26  2  20 00        
00BF28  2  45 52 41 20  	.byte	"ERA ",0
00BF2C  2  00           
00BF2D  2  54 59 50 45  	.byte	"TYPE ",0
00BF31  2  20 00        
00BF33  2  52 45 4E 20  	.byte	"REN ",0
00BF37  2  00           
00BF38  2  47 4F 20 00  	.byte	"GO ",0
00BF3C  2  4C 4F 41 44  	.byte	"LOAD ",0
00BF40  2  20 00        
00BF42  2               ;input buffer
00BF42  2               cnsbuf:
00BF42  2  7F           cnsmax: .byte 127
00BF43  2  00           cnslng: .byte 0
00BF44  2               cnstxt:
00BF44  2  xx xx xx xx  	.res 127
00BF48  2  xx xx xx xx  
00BF4C  2  xx xx xx xx  
00BFC3  2               ;fcb one
00BFC3  2               fcbone:
00BFC3  2  xx xx xx xx  	.res 33
00BFC7  2  xx xx xx xx  
00BFCB  2  xx xx xx xx  
00BFE4  2               ;com type field
00BFE4  2  43 4F 36     typcom:	.byte	"CO6"
00BFE7  2               ;variable storage
00BFE7  2  00           cnbfpt:	.byte	0		;buffer index
00BFE8  2  00           dfldsk:	.byte	0		;default drive
00BFE9  2  00           tmpdsk:	.byte	0		;temporary dvive
00BFEA  2               ;align vector on word boundary
00BFEA  2               	.align 2
00BFEA  2  00 00        vector:	.word	0		;execution vector
00BFEC  2  00           ccmcount:	.byte	0		;counter
00BFED  2  00           curpnt:	.byte	0		;input parse start
00BFEE  2  00           diradd:	.byte	0		;directory number
00BFEF  2  00           savx:	.byte	0		;save x location
00BFF0  2  00           savy:	.byte	0		;save y location
00BFF1  2  00           length:	.byte	0		;number tages to save
00BFF2  2  00           oldtmp:	.byte	0		;temp drive in ren
00BFF3  2  00 08        dskbuf:	.word	tea		;disk buffer start
00BFF5  2  00           across:	.byte	0		;dir count on line
00BFF6  2  00           sixten:	.byte	0		;line length div 16
00BFF7  2  09           moduls:	.byte	9		;modulus-1 for number input
00BFF8  2  00 00        num:	.word	0		;input number
00BFFA  2  00 00        tnum:	.word	0		;temp in bldnum
00BFFC  2  00 08        sadr:	.word	tea		;save start address
00BFFE  2               
00BFFE  1               		.include "pemnhy.asm"
00BFFE  2               ;________________________________________________________________________________________________________________________________
00BFFE  2               ;
00BFFE  2               ;	Nhyodyne dos/65 primitive execution module (pem)
00BFFE  2               ;
00BFFE  2               ;  DWERNER 02/19/2022   Strip off Most significant bit of file name in dir to
00BFFE  2               ;			make filesystem compatible with ROMWBW
00BFFE  2               ;________________________________________________________________________________________________________________________________
00BFFE  2               
00BFFE  2               ;zero page data storage
00BFFE  2               addinp	=	$02		;initialized to a,y
00BFFE  2               bufadd	=	$04		;buffer address
00BFFE  2               alcpnt	=	$06		;allocation map pointer
00BFFE  2               chkpnt	=	$08		;checksum map pointer
00BFFE  2               numvar	=	8		;eight bytes
00BFFE  2               ;main program
00BFFE  2               ; input:x=command,a=value,a&y=address
00BFFE  2               ; returns:a=value,a&y=address
00BFFE  2               ; alters:all
00BFFE  2               pem:
00BFFE  2  D8           	cld			;set binary mode
00BFFF  2  8D 92 CB     	sta	bytinp		;save input
00C002  2  8D D6 CB     	sta	lowin		;value and
00C005  2  8C 93 CB     	sty	bytinp+1	;save high
00C008  2  8C D7 CB     	sty	lowin+1		;address
00C00B  2  8E 94 CB     	stx	cmdinp		;and command
00C00E  2  E0 24        	cpx	#numcmd		;if invalid
00C010  2  B0 50        	bcs	extpem		;then exit
00C012  2  BD 4E CB     	lda	swctbl,x	;if flag zero
00C015  2  F0 08        	beq	noswin		;skip switch
00C017  2  A9 FF        	lda	#255		;else set
00C019  2  8D 91 CB     	sta	swcflg		;memory switch flag
00C01C  2  20 E9 C2     	jsr	switch		;move data to page zero
00C01F  2  A9 00        noswin:	lda	#0		;clear drive
00C021  2  8D 99 CB     	sta	tmpdrv		;switch flag
00C024  2  AD 94 CB     	lda	cmdinp		;get command
00C027  2  0A           	asl	a		;multiply by two
00C028  2  6D 94 CB     	adc	cmdinp		;then add to get x3
00C02B  2  AA           	tax			;and make a pointer
00C02C  2  E8           	inx			;bump to pass jmp
00C02D  2  BD 76 C0     	lda	cmdtbl,x	;get command
00C030  2  BC 77 C0     	ldy	cmdtbl+1,x	;address
00C033  2  8D 9A CB     	sta	xqtvec		;and put
00C036  2  8C 9B CB     	sty	xqtvec+1	;in vector
00C039  2  AD DE CA     	lda	extevc+1	;get return
00C03C  2  48           	pha			;address
00C03D  2  AD DD CA     	lda	extevc		;and push
00C040  2  48           	pha			;as return
00C041  2  AD 92 CB     	lda	bytinp		;get input value
00C044  2  AC 93 CB     	ldy	bytinp+1
00C047  2  6C 9A CB     	jmp	(xqtvec)	;then execute
00C04A  2  8D 95 CB     extexq:	sta	bytout		;save value
00C04D  2  8C 96 CB     	sty	addout+1	;and address
00C050  2  AD 99 CB     	lda	tmpdrv		;get temp drive
00C053  2  F0 0D        	beq	extpem		;if zero skip switch
00C055  2  A0 00        	ldy	#0		;else
00C057  2  91 02        	sta	(addinp),y	;put back in fcb
00C059  2  AD A3 CB     	lda	olddrv		;get old drive number
00C05C  2  8D 92 CB     	sta	bytinp		;set input value
00C05F  2  20 04 C3     	jsr	chgdrv		;then switch back
00C062  2  2C 91 CB     extpem:	bit	swcflg		;test memory switch
00C065  2  10 08        	bpl	noswot		;if not set skip
00C067  2  20 E9 C2     	jsr	switch		;else do memory switch
00C06A  2  A9 00        	lda	#0		;clear
00C06C  2  8D 91 CB     	sta	swcflg		;flag
00C06F  2  AC 96 CB     noswot:	ldy	addout+1	;get address
00C072  2  AD 95 CB     	lda	bytout		;and value (address low)
00C075  2  60           	rts
00C076  2               ;command vector table
00C076  2  4C EA C0     cmdtbl:	jmp	xwboot		;warm boot
00C079  2  4C DB C2     	jmp	xcnsin		;console input with echo
00C07C  2  4C 13 C9     	jmp	sndchr		;console output
00C07F  2  4C 65 CC     	jmp	sim+21		;tape reader
00C082  2  4C 62 CC     	jmp	sim+18		;tape punch
00C085  2  4C 5F CC     	jmp	sim+15		;printer output
00C088  2  4C 85 C8     	jmp	getcon		;console input w/o echo
00C08B  2  4C 1F C1     	jmp	xgtios		;read i/o status
00C08E  2  4C 2A C1     	jmp	xstios		;set i/o status
00C091  2  4C CA C8     	jmp	sndstr		;print buffer
00C094  2  4C 7F C9     	jmp	bufinp		;read buffer
00C097  2  4C 95 C8     	jmp	kbdsts		;test console ready
00C09A  2  4C 7D CC     	jmp	sim+45		;read list status
00C09D  2  4C 32 C3     	jmp	xintds		;initialize system
00C0A0  2  4C 04 C3     	jmp	chgdrv		;log in drive
00C0A3  2  4C AF C5     	jmp	xopen		;open file
00C0A6  2  4C EA C5     	jmp	xclose		;close file
00C0A9  2  4C 0E C6     	jmp	xfndfr		;find first match
00C0AC  2  4C 3A C1     	jmp	xfndnx		;find next match
00C0AF  2  4C A2 C1     	jmp	xdltfl		;delete file
00C0B2  2  4C 42 C1     	jmp	xread		;read record
00C0B5  2  4C C7 C1     	jmp	xwrite		;write record
00C0B8  2  4C B1 C6     	jmp	xmake		;create file
00C0BB  2  4C 80 C1     	jmp	xrenme		;rename file
00C0BE  2  4C 32 C1     	jmp	xintlg		;interrogate log in status
00C0C1  2  4C 2E C1     	jmp	xintdr		;interrogate current drive
00C0C4  2  4C F9 C2     	jmp	chgdma		;set buffer address
00C0C7  2  4C 23 C1     	jmp	xrdalv		;read allocation map start
00C0CA  2  4C 6D C5     	jmp	setron		;set r/w status
00C0CD  2  4C 36 C1     	jmp	xrdros		;read r/w status
00C0D0  2  4C E2 C0     	jmp	setlst		;set list echo status
00C0D3  2  4C E6 C0     	jmp	lststs		;read list echo status
00C0D6  2  4C FA C0     	jmp	xrtclo		;read low clock
00C0D9  2  4C 0E C1     	jmp	xrtchi		;read high clock
00C0DC  2  4C 18 C1     	jmp	xrddcb		;read dcb address
00C0DF  2  4C 83 CC     	jmp	sim+51		;translate sector
00C0E2  2               ;set list echo status
00C0E2  2  8D 8F CB     setlst:	sta	lstflg		;set flag
00C0E5  2  60           	rts
00C0E6  2               ;read list echo status
00C0E6  2  AD 8F CB     lststs:	lda	lstflg		;read flag
00C0E9  2  60           	rts
00C0EA  2               ;execute warm boot
00C0EA  2               ; ***this command does not return to pem***
00C0EA  2               ; ***instead it jumps to sim, resets	***
00C0EA  2               ; ***system and stack and jumps to ccm. ***
00C0EA  2  2C 91 CB     xwboot:	bit	swcflg		;test memory switch flag
00C0ED  2  10 08        	bpl	dowmbt		;if clear do not
00C0EF  2  20 E9 C2     	jsr	switch		;switch memory
00C0F2  2  A9 00        	lda	#0		;clear
00C0F4  2  8D 91 CB     	sta	swcflg		;flag
00C0F7  2  4C 53 CC     dowmbt:	jmp	sim+3		;go to sim
00C0FA  2               
00C0FA  2               ;execute read real time clock
00C0FA  2  20 80 CC     xrtclo:	jsr	sim+48		;read clock
00C0FD  2               
00C0FD  2  8D BF CB     	sta	rtclk		;save low
00C100  2  8C C0 CB     	sty	rtclk+1		;middle
00C103  2  8E C1 CB     	stx	rtclk+2		;high
00C106  2  8A           	txa
00C107  2  29 80        	and	#%10000000	;test for valid
00C109  2  A8           	tay
00C10A  2  AD BF CB     	lda	rtclk		;get low
00C10D  2  60           	rts
00C10E  2               ;execute read real time clock high
00C10E  2  AD C1 CB     xrtchi:	lda	rtclk+2		;get high
00C111  2  29 7F        	and	#%01111111	;clear status
00C113  2  A8           	tay
00C114  2  AD C0 CB     	lda	rtclk+1		;get middle
00C117  2  60           	rts
00C118  2               ;execute read dcb address
00C118  2  AD 6C C3     xrddcb:	lda	cptdcb+1	;get address
00C11B  2  AC 6D C3     	ldy	cptdcb+2
00C11E  2  60           	rts
00C11F  2               ;execute read i/o status
00C11F  2  AD 06 01     xgtios:	lda	iostat		;get status byte
00C122  2  60           	rts
00C123  2               ;execute read allocation map starting address
00C123  2  AD CE CB     xrdalv:	lda	alcmap		;get
00C126  2  AC CF CB     	ldy	alcmap+1	;starting address
00C129  2  60           	rts			;then return
00C12A  2               ;execute set i/o status
00C12A  2  8D 06 01     xstios:	sta	iostat		;set status
00C12D  2  60           	rts
00C12E  2               ;execute interrogate current drive
00C12E  2  AD A4 CB     xintdr:	lda	curdrv		;get number
00C131  2  60           	rts
00C132  2               ;execute read log in status
00C132  2  AD A5 CB     xintlg:	lda	lginvc		;get status
00C135  2  60           	rts
00C136  2               ;execute read read/write status
00C136  2  AD A6 CB     xrdros:	lda	ronlst		;get status
00C139  2  60           	rts
00C13A  2               ;execute find next match
00C13A  2  20 12 C3     xfndnx:	jsr	autodr		;auto drive select
00C13D  2  A9 0D        	lda	#13		;match including
00C13F  2  4C 1B C6     	jmp	search		;extent
00C142  2               ;execute read next record
00C142  2  20 12 C3     xread:	jsr	autodr		;auto drive select
00C145  2  20 8F C5     	jsr	inrcct		;initialize record counters
00C148  2  AD AF CB     	lda	nxtrec		;if next record less
00C14B  2  CD B0 CB     	cmp	numrec		;then number records
00C14E  2  90 13        	bcc	tryrde		;then try to read
00C150  2  C9 80        	cmp	#128		;but if not and
00C152  2  F0 03        	beq	tryext		;is max try to extend
00C154  2  A9 01        rdeeof:	lda	#1		;else set eof
00C156  2  60           	rts			;code and return
00C157  2  A2 01        tryext:	ldx	#1		;try for a read
00C159  2  20 ED C6     	jsr	extend		;file extension
00C15C  2  C9 00        	cmp	#0		;if not ok exit eof
00C15E  2  D0 F4        	bne	rdeeof		;with jump back
00C160  2  8D AF CB     	sta	nxtrec		;clear next record
00C163  2  20 7E C7     tryrde:	jsr	getblk		;and get block
00C166  2  AD AA CB     	lda	blknum		;if block not zero
00C169  2  0D AB CB     	ora	blknum+1
00C16C  2  D0 03        	bne	dorde		;do the read
00C16E  2  A9 02        	lda	#2		;else set unwritten
00C170  2  60           	rts			;code and exit
00C171  2  20 60 C6     dorde:	jsr	calrcn		;calculate record number
00C174  2  20 AC C4     	jsr	sttrsc		;set track and sector
00C177  2  20 37 C8     	jsr	rdesec		;do sector read
00C17A  2  20 9E C5     	jsr	updtrc		;update counters
00C17D  2  A9 00        	lda	#0		;return w/o error
00C17F  2  60           extrde:	rts
00C180  2               ;execute file rename
00C180  2  20 12 C3     xrenme:	jsr	autodr		;automatic drive select
00C183  2  20 14 C8     	jsr	tstron		;test for r/o
00C186  2  A9 0C        	lda	#12		;match name
00C188  2  20 13 C6     	jsr	frstsr		;and type
00C18B  2  30 14        	bmi	extren		;exit if not found
00C18D  2  A9 00        doren:	lda	#0		;clear drive select
00C18F  2  A0 10        	ldy	#16		;in new name
00C191  2  91 02        	sta	(addinp),y	;part of fcb
00C193  2  A9 0C        	lda	#12		;then move
00C195  2  A2 10        	ldx	#16		;new name
00C197  2  20 80 C6     	jsr	dirchg		;to directory
00C19A  2  A9 0C        	lda	#12		;see if
00C19C  2  20 1B C6     	jsr	search		;another match
00C19F  2  10 EC        	bpl	doren		;loop if found
00C1A1  2  60           extren:	rts			;number
00C1A2  2               ;execute delete file
00C1A2  2  20 12 C3     xdltfl:	jsr	autodr		;automatic drive select
00C1A5  2  20 14 C8     	jsr	tstron		;test for r/o
00C1A8  2  A9 0C        	lda	#12		;match name
00C1AA  2  20 13 C6     	jsr	frstsr		;and type
00C1AD  2  30 17        	bmi	extdlt		;done if not found
00C1AF  2  A2 00        dodlt:	ldx	#0		;else do a
00C1B1  2  20 E4 C7     	jsr	mapdir		;delete
00C1B4  2  AC A9 CB     	ldy	subrec		;then change
00C1B7  2  AD 4D CB     	lda	empty		;byte zero to
00C1BA  2  91 04        	sta	(bufadd),y	;empty code
00C1BC  2  20 3D C8     	jsr	updtck		;then update directory
00C1BF  2  A9 0C        	lda	#12		;search
00C1C1  2  20 1B C6     	jsr	search		;for next
00C1C4  2  10 E9        	bpl	dodlt		;loop if found
00C1C6  2  60           extdlt:	rts			;exit
00C1C7  2               ;execute write next record
00C1C7  2  20 12 C3     xwrite:	jsr	autodr		;automatic drive select
00C1CA  2  20 14 C8     	jsr	tstron		;test for r/o
00C1CD  2  20 8F C5     	jsr	inrcct		;initialize counters
00C1D0  2  AD AF CB     	lda	nxtrec		;get next record
00C1D3  2  C9 80        	cmp	#128		;compare to max
00C1D5  2  90 03        	bcc	ntexte		;continue if less
00C1D7  2  A9 01        	lda	#1		;else flag as extend
00C1D9  2  60           	rts			;error and exit
00C1DA  2  20 7E C7     ntexte:	jsr	getblk		;calculate block num
00C1DD  2  A9 00        	lda	#0		;say normal write
00C1DF  2  8D D3 CB     	sta	pemwrtype		;for now
00C1E2  2  AD AA CB     	lda	blknum		;get it and if
00C1E5  2  0D AB CB     	ora	blknum+1
00C1E8  2  F0 03        	beq	*+5		;zero then get number
00C1EA  2  4C AA C2     	jmp	blkopn		;else go write
00C1ED  2  A9 02        	lda	#2		;say unalloc write
00C1EF  2  8D D3 CB     	sta	pemwrtype
00C1F2  2  AD 8B CB     	lda	fcbind		;get index from prior
00C1F5  2  48           	pha			;and save
00C1F6  2  C9 10        	cmp	#16		;if first block
00C1F8  2  F0 1A        	beq	isfrst		;then don't change
00C1FA  2  A8           	tay			;else make an index
00C1FB  2  88           	dey			;point to last
00C1FC  2  2C BA CB     	bit	blmode		;test mode
00C1FF  2  10 01        	bpl	*+3		;done if byte
00C201  2  88           	dey			;else drop for word
00C202  2  B1 02        	lda	(addinp),y	;and get that number
00C204  2  8D AA CB     	sta	blknum		;store as starting
00C207  2  C8           	iny			;bump for word
00C208  2  A9 00        	lda	#0		;preset for byte
00C20A  2  2C BA CB     	bit	blmode		;test mode
00C20D  2  10 02        	bpl	*+4		;done if byte
00C20F  2  B1 02        	lda	(addinp),y	;else get high
00C211  2  8D AB CB     	sta	blknum+1	;then set high
00C214  2  AD AA CB     isfrst:	lda	blknum		;get block
00C217  2  8D 9F CB     	sta	lkdown		;set lower and
00C21A  2  8D A1 CB     	sta	lookup		;upper pointers
00C21D  2  AD AB CB     	lda	blknum+1	;now set high part
00C220  2  8D A0 CB     	sta	lkdown+1
00C223  2  8D A2 CB     	sta	lookup+1
00C226  2  AD A1 CB     srblag:	lda	lookup		;if upper pointer
00C229  2  CD C5 CB     	cmp	maxblk		;not at max
00C22C  2  D0 08        	bne	upnemx		;then keep going
00C22E  2  AC A2 CB     	ldy	lookup+1	;now check high
00C231  2  CC C6 CB     	cpy	maxblk+1
00C234  2  F0 12        	beq	tstdwn		;go test down
00C236  2  EE A1 CB     upnemx:	inc	lookup		;else bump upper
00C239  2  D0 03        	bne	*+5
00C23B  2  EE A2 CB     	inc	lookup+1
00C23E  2  AD 9F CB     	lda	lkdown		;then if lower
00C241  2  0D A0 CB     	ora	lkdown+1
00C244  2  F0 18        	beq	dotest		;is zero start test
00C246  2  D0 0B        	bne	dcdown		;else drop lower
00C248  2  AD 9F CB     tstdwn:	lda	lkdown		;if upper & lower at
00C24B  2  0D A0 CB     	ora	lkdown+1
00C24E  2  D0 03        	bne	dcdown		;drop if not zero
00C250  2  A8           	tay			;also set y
00C251  2  F0 30        	beq	extsbl		;then exit
00C253  2  AD 9F CB     dcdown:	lda	lkdown		;drop lower
00C256  2  D0 03        	bne	*+5
00C258  2  CE A0 CB     	dec	lkdown+1
00C25B  2  CE 9F CB     	dec	lkdown
00C25E  2  AD 9F CB     dotest:	lda	lkdown		;get lower
00C261  2  AC A0 CB     	ldy	lkdown+1
00C264  2  20 51 C5     	jsr	tstblk		;and test
00C267  2  D0 09        	bne	trylup		;if full try upper
00C269  2  AD 9F CB     	lda	lkdown		;else use lower
00C26C  2  AC A0 CB     	ldy	lkdown+1
00C26F  2  4C 83 C2     	jmp	extsbl		;as result
00C272  2  AD A1 CB     trylup:	lda	lookup		;get upper
00C275  2  AC A2 CB     	ldy	lookup+1
00C278  2  20 51 C5     	jsr	tstblk		;if full
00C27B  2  D0 A9        	bne	srblag		;then loop
00C27D  2  AD A1 CB     	lda	lookup		;else use upper
00C280  2  AC A2 CB     	ldy	lookup+1
00C283  2  8D AA CB     extsbl:	sta	blknum		;then save number
00C286  2  8C AB CB     	sty	blknum+1
00C289  2  0D AB CB     	ora	blknum+1	;see if zero
00C28C  2  D0 04        	bne	gtgood		;then proceed
00C28E  2  68           	pla			;clear stack
00C28F  2  A9 02        	lda	#2		;set end
00C291  2  60           	rts			;of data return
00C292  2  AD AA CB     gtgood:	lda	blknum		;get low again
00C295  2  20 65 C5     	jsr	setblk		;set allocation map
00C298  2  68           	pla			;get block
00C299  2  A8           	tay			;pointer back
00C29A  2  AD AA CB     	lda	blknum		;get number
00C29D  2  91 02        	sta	(addinp),y	;and put in fcb
00C29F  2  AD AB CB     	lda	blknum+1	;get high
00C2A2  2  C8           	iny
00C2A3  2  2C BA CB     	bit	blmode		;test mode
00C2A6  2  10 02        	bpl	*+4		;done if byte
00C2A8  2  91 02        	sta	(addinp),y	;else set high
00C2AA  2  20 60 C6     blkopn:	jsr	calrcn		;calculate record num
00C2AD  2  20 AC C4     	jsr	sttrsc		;set track and sector
00C2B0  2  20 43 C8     	jsr	wrtsec		;do write
00C2B3  2  AE AF CB     	ldx	nxtrec		;get next record
00C2B6  2  EC B0 CB     	cpx	numrec		;if less than max
00C2B9  2  90 05        	bcc	notful		;then ok
00C2BB  2  E8           	inx			;else bump count
00C2BC  2  8E B0 CB     	stx	numrec		;and save
00C2BF  2  CA           	dex			;back down
00C2C0  2  E0 7F        notful:	cpx	#127		;if not at max
00C2C2  2  D0 11        	bne	noawex		;skip extending
00C2C4  2  20 9E C5     	jsr	updtrc		;update record counters
00C2C7  2  A2 00        	ldx	#0		;do write
00C2C9  2  20 ED C6     	jsr	extend		;file extension
00C2CC  2  C9 00        	cmp	#0		;if not ok
00C2CE  2  D0 0A        	bne	extwrt		;exit
00C2D0  2  A9 FF        	lda	#255		;else start counter
00C2D2  2  8D AF CB     	sta	nxtrec		;at one short
00C2D5  2  20 9E C5     noawex:	jsr	updtrc		;then update counters
00C2D8  2  A9 00        	lda	#0		;good return
00C2DA  2  60           extwrt:	rts			;exit
00C2DB  2               ;execute console input
00C2DB  2  20 85 C8     xcnsin:	jsr	getcon		;get input
00C2DE  2  20 BB C8     	jsr	tstchr		;test it and
00C2E1  2  90 05        	bcc	extxci		;if control exit
00C2E3  2  48           	pha			;else save
00C2E4  2  20 13 C9     	jsr	sndchr		;echo
00C2E7  2  68           	pla			;restore
00C2E8  2  60           extxci:	rts			;return
00C2E9  2               ;switch memory
00C2E9  2               ;page zero block begins at $02 and is numvar bytes long.
00C2E9  2  A2 07        switch:	ldx	#numvar-1	;get number to switch
00C2EB  2  B5 02        nxtswh:	lda	2,x		;get zero page
00C2ED  2  BC D6 CB     	ldy	varblk,x	;and save area
00C2F0  2  9D D6 CB     	sta	varblk,x	;save zero
00C2F3  2  94 02        	sty	2,x		;and high
00C2F5  2  CA           	dex			;count down
00C2F6  2  10 F3        	bpl	nxtswh		;and loop until done
00C2F8  2  60           drvsme:	rts			;then return
00C2F9  2               ;change dma address
00C2F9  2               ; input:addinp=address
00C2F9  2               ; returns:none
00C2F9  2               ; alters:all
00C2F9  2  A5 02        chgdma:	lda	addinp		;get low
00C2FB  2  A4 03        	ldy	addinp+1	;and high address
00C2FD  2  85 04        	sta	bufadd		;then store
00C2FF  2  84 05        	sty	bufadd+1	;in address
00C301  2  4C 74 CC     	jmp	sim+36		;then go to sim
00C304  2               
00C304  2               ;change drive
00C304  2               ; input:bytinp
00C304  2               ; returns:none
00C304  2               ; alters:all
00C304  2  AD 92 CB     chgdrv:	lda	bytinp		;get input
00C307  2  CD A4 CB     	cmp	curdrv		;if same as current
00C30A  2  F0 EC        	beq	drvsme		;do nothing
00C30C  2  8D A4 CB     	sta	curdrv		;else change current
00C30F  2  4C 45 C3     	jmp	mapdrv		;then log it in
00C312  2               ;automatic drive select
00C312  2               ; input:(addinp) 0=no change
00C312  2               ; 1-8 or 'A'-'H' = change
00C312  2               ; returns:none
00C312  2               ; alters:all
00C312  2  A0 00        autodr:	ldy	#0		;get
00C314  2  B1 02        	lda	(addinp),y	;first byte of fcb
00C316  2  F0 19        	beq	qtatdr		;if zero quit
00C318  2  38           	sec			;set carry for
00C319  2  E9 01        	sbc	#1		;subtract one
00C31B  2  29 07        	and	#%00000111	;look at three lsbs
00C31D  2  8D 92 CB     	sta	bytinp		;make parameter
00C320  2  AD A4 CB     	lda	curdrv		;get current
00C323  2  8D A3 CB     	sta	olddrv		;and save
00C326  2  B1 02        	lda	(addinp),y	;get fcb entry
00C328  2  8D 99 CB     	sta	tmpdrv		;and save as flag
00C32B  2  98           	tya			;set a to 0
00C32C  2  91 02        	sta	(addinp),y	;clear byte zero in fcb
00C32E  2  20 04 C3     	jsr	chgdrv		;then select new drive
00C331  2  60           qtatdr:	rts			;and return
00C332  2               ;execute initialize system
00C332  2               ; input:none
00C332  2               ; returns:none
00C332  2               ; alters:all,curdrv,lginvc,bufadd
00C332  2  A9 02        xintds:	lda	#DEFDRV		;set current
00C334  2  8D A4 CB     	sta	curdrv		;drive to a
00C337  2  8D A5 CB     	sta	lginvc		;clear log in status
00C33A  2  A9 28        	lda	#<dflbuf	;get default buffer
00C33C  2  A0 01        	ldy	#>dflbuf	;address
00C33E  2  85 02        	sta	addinp		;and set up
00C340  2  84 03        	sty	addinp+1	;parameters
00C342  2  20 F9 C2     	jsr	chgdma		;change address
00C345  2               
00C345  2               ;log in drive and set pointers and maps
00C345  2               ; input:curdrv
00C345  2               ; returns:none
00C345  2               ; alters:all
00C345  2  AD A4 CB     mapdrv:	lda	curdrv		;if current drive
00C348  2  C9 08        	cmp	#8		;is 0 to 7
00C34A  2  90 0F        	bcc	vlddrv		;then log it in
00C34C  2  20 66 C8     drserr:	jsr	errout		;send error message
00C34F  2  AD E0 CA     	lda	sltmvc		;point to
00C352  2  AC E1 CA     	ldy	sltmvc+1	;select message
00C355  2  20 CA C8     	jsr	sndstr		;and send it
00C358  2               
00C358  2  4C EA C0     	jmp	xwboot		;and abort
00C35B  2               
00C35B  2  20 6B CC     vlddrv:	jsr	sim+27		;go to sim to set
00C35E  2  8D 6C C3     	sta	cptdcb+1	;save
00C361  2  8C 6D C3     	sty	cptdcb+2
00C364  2  0D 6D C3     	ora	cptdcb+2	;see if invalid
00C367  2  F0 E3        	beq	drserr		;error if is
00C369  2               ;capture dcb
00C369  2  A0 0D        	ldy	#14-1		;do 14 bytes
00C36B  2  B9 FF FF     cptdcb:	lda	$ffff,y		;get value from sim
00C36E  2  99 C5 CB     	sta	dcb,y		;store it
00C371  2  88           	dey
00C372  2  10 F7        	bpl	cptdcb		;loop for more
00C374  2  AD CB CB     	lda	blkscd		;get block size code
00C377  2  A8           	tay			;save in y
00C378  2  18           	clc
00C379  2  69 03        	adc	#3		;convert to sxb
00C37B  2  8D BE CB     	sta	sxb		;and save
00C37E  2  B9 85 CB     	lda	sabtbl,y	;get sab
00C381  2  8D BD CB     	sta	sab		;and set
00C384  2  AD CC CB     	lda	maxdir		;get max dir
00C387  2  8D BB CB     	sta	maxdrc		;set max dir record
00C38A  2  AD CD CB     	lda	maxdir+1
00C38D  2  4A           	lsr	a		;divide by 4
00C38E  2  6E BB CB     	ror	maxdrc
00C391  2  4A           	lsr	a
00C392  2  6E BB CB     	ror	maxdrc
00C395  2  8D BC CB     	sta	maxdrc+1	;then save high
00C398  2  A9 00        	lda	#0		;set mode to byte
00C39A  2  8D BA CB     	sta	blmode
00C39D  2  AD C6 CB     	lda	maxblk+1	;branch if max block
00C3A0  2  F0 05        	beq	ntm255		;not over 255
00C3A2  2               ;if y=0 when the following line is executed it means
00C3A2  2               ;that the user has put an illegal combination into
00C3A2  2               ;the disk definition table. may want to consider
00C3A2  2               ;putting some error checking here in the future if
00C3A2  2               ;there is space in pem.
00C3A2  2  88           	dey			;back up index
00C3A3  2  38           	sec			;else set mode to word
00C3A4  2  6E BA CB     	ror	blmode
00C3A7  2  B9 82 CB     ntm255:	lda	exmtbl,y	;get extent mask
00C3AA  2  8D D4 CB     	sta	exm
00C3AD  2               
00C3AD  2  38           	sec			;now calculate cexm1f
00C3AE  2  A9 1F        	lda	#31
00C3B0  2  F9 82 CB     	sbc	exmtbl,y
00C3B3  2  8D D5 CB     	sta	cexm1f
00C3B6  2  AE A4 CB     	ldx	curdrv		;get drive as pointer
00C3B9  2  BD 7A CB     	lda	bitmap,x	;get bit
00C3BC  2  2D A5 CB     	and	lginvc		;if logged in
00C3BF  2  D0 0C        	bne	extstm		;then exit
00C3C1  2  BD 7A CB     	lda	bitmap,x	;get bit back
00C3C4  2  0D A5 CB     	ora	lginvc		;set in log-in
00C3C7  2  8D A5 CB     	sta	lginvc		;and update
00C3CA  2  4C CE C3     	jmp	flinal		;then fill in maps
00C3CD  2               
00C3CD  2  60           extstm:	rts			;and return
00C3CE  2               ;fill in allocation map
00C3CE  2  20 28 C8     flinal:	jsr	setrw		;set to read/write
00C3D1  2  AD C5 CB     	lda	maxblk		;divide max block by
00C3D4  2  8D C2 CB     	sta	gpcnt		;eight to get max
00C3D7  2  AD C6 CB     	lda	maxblk+1
00C3DA  2  A2 03        	ldx	#3
00C3DC  2  4A           clcnab:	lsr	a		;use a for speed
00C3DD  2  6E C2 CB     	ror	gpcnt
00C3E0  2  CA           	dex
00C3E1  2  D0 F9        	bne	clcnab		;loop if more
00C3E3  2  8D C3 CB     	sta	gpcnt+1		;save high
00C3E6  2  EE C2 CB     	inc	gpcnt		;bump by one
00C3E9  2  D0 03        	bne	*+5
00C3EB  2  EE C3 CB     	inc	gpcnt+1		;with carry
00C3EE  2  AD CE CB     	lda	alcmap		;get map start
00C3F1  2  AC CF CB     	ldy	alcmap+1
00C3F4  2  85 06        	sta	alcpnt		;set pointer to start
00C3F6  2  84 07        	sty	alcpnt+1
00C3F8  2  A0 00        	ldy	#0		;clear index
00C3FA  2  A9 00        clraml:	lda	#0		;clear byte
00C3FC  2  91 06        	sta	(alcpnt),y	;put in map
00C3FE  2  E6 06        	inc	alcpnt		;bump pointer
00C400  2  D0 02        	bne	*+4
00C402  2  E6 07        	inc	alcpnt+1	;with carry
00C404  2  AD C2 CB     	lda	gpcnt		;get low of count
00C407  2  D0 03        	bne	*+5		;skip if not zero
00C409  2  CE C3 CB     	dec	gpcnt+1		;else drop high
00C40C  2  CE C2 CB     	dec	gpcnt		;always drop low
00C40F  2  AD C2 CB     	lda	gpcnt		;test for zero
00C412  2  0D C3 CB     	ora	gpcnt+1
00C415  2  D0 E3        	bne	clraml		;loop if more
00C417  2               ;at this point complete map is cleared
00C417  2  AD BB CB     	lda	maxdrc		;get low of max dir record
00C41A  2  8D C2 CB     	sta	gpcnt
00C41D  2  AD BC CB     	lda	maxdrc+1	;high in a
00C420  2  AE BE CB     	ldx	sxb		;set x according to block size
00C423  2  4A           clcmdb:	lsr	a		;do division
00C424  2  6E C2 CB     	ror	gpcnt
00C427  2  CA           	dex
00C428  2  D0 F9        	bne	clcmdb		;until x is zero
00C42A  2  8D C3 CB     	sta	gpcnt+1		;set high
00C42D  2  EE C2 CB     	inc	gpcnt		;then bump by one
00C430  2  D0 03        	bne	*+5
00C432  2  EE C3 CB     	inc	gpcnt+1
00C435  2  8E AA CB     	stx	blknum		;clear block number
00C438  2  8E AB CB     	stx	blknum+1
00C43B  2  AD AA CB     fildal:	lda	blknum		;get block number
00C43E  2  AC AB CB     	ldy	blknum+1
00C441  2  20 65 C5     	jsr	setblk		;set bit
00C444  2  EE AA CB     	inc	blknum		;bump block number
00C447  2  D0 03        	bne	*+5
00C449  2  EE AB CB     	inc	blknum+1
00C44C  2  AD C2 CB     	lda	gpcnt		;get low of count
00C44F  2  D0 03        	bne	*+5		;skip if not zero
00C451  2  CE C3 CB     	dec	gpcnt+1		;else drop high
00C454  2  CE C2 CB     	dec	gpcnt		;always do low
00C457  2  AD C2 CB     	lda	gpcnt		;test for zero
00C45A  2  0D C3 CB     	ora	gpcnt+1
00C45D  2  D0 DC        	bne	fildal		;loop if more
00C45F  2               ;at this point directory space is mapped
00C45F  2  20 7E C4     	jsr	intdrv		;initialize drive
00C462  2  20 D8 C7     	jsr	cldrnm		;clear directory number
00C465  2  A2 01        fillpe:	ldx	#1		;parameter for fill
00C467  2  20 20 C7     	jsr	nxtdir		;execute for next directory
00C46A  2  30 11        	bmi	extfil		;done if invalid
00C46C  2  AC A9 CB     	ldy	subrec		;get offset
00C46F  2  B1 04        	lda	(bufadd),y	;get empty/valid flag
00C471  2  C9 E5        	cmp	#$e5		;if empty
00C473  2  F0 F0        	beq	fillpe		;try next
00C475  2  A2 01        	ldx	#1		;parameter for fill in
00C477  2  20 E4 C7     	jsr	mapdir		;do directory map
00C47A  2  4C 65 C4     	jmp	fillpe		;then loop
00C47D  2  60           extfil:	rts			;return
00C47E  2               ;initialize drive
00C47E  2               ; input:nsystr
00C47E  2               ; returns:none
00C47E  2               ; alters:all
00C47E  2  20 68 CC     intdrv:	jsr	sim+24		;home then
00C481  2               
00C481  2  AD C9 CB     	lda	nsystr		;get number of system tracks
00C484  2  AC CA CB     	ldy	nsystr+1
00C487  2  4C 6E CC     	jmp	sim+30		;and set in sim
00C48A  2               
00C48A  2               ;directory record set up
00C48A  2               ; input:dirnum
00C48A  2               ; returns:none
00C48A  2               ; alters:all,recnum,dirrec
00C48A  2  AD A8 CB     drrcsu:	lda	dirnum+1	;move high dir number
00C48D  2  8D AB CB     	sta	recnum+1	;to record number
00C490  2  AD A7 CB     	lda	dirnum		;divide
00C493  2  4E AB CB     	lsr	recnum+1	;directory by four
00C496  2  6A           	ror	a
00C497  2  4E AB CB     	lsr	recnum+1
00C49A  2  6A           	ror	a
00C49B  2  8D B1 CB     	sta	dirrec		;and save
00C49E  2  8D AA CB     	sta	recnum		;set low record number
00C4A1  2  AD AB CB     	lda	recnum+1	;get high
00C4A4  2  8D B2 CB     	sta	dirrec+1	;and set
00C4A7  2  A9 00        	lda	#0		;clear top byte
00C4A9  2  8D AC CB     	sta	recnum+2
00C4AC  2               ;set track and sector
00C4AC  2               ; input:recnum
00C4AC  2               ; returns:none
00C4AC  2               ; alters:all,countr,trkctr
00C4AC  2  A2 00        sttrsc:	ldx	#0		;clear track counter
00C4AE  2  8E C4 CB     	stx	trkctr
00C4B1  2  8E 9C CB     	stx	countr		;and record
00C4B4  2  8E 9D CB     	stx	countr+1	;counter
00C4B7  2  8E 9E CB     	stx	countr+2
00C4BA  2  AD AA CB     trnxtr:	lda	recnum		;from
00C4BD  2  CD 9C CB     	cmp	countr		;record number
00C4C0  2  AD AB CB     	lda	recnum+1	;and if a
00C4C3  2  ED 9D CB     	sbc	countr+1	;borrow then
00C4C6  2  AD AC CB     	lda	recnum+2
00C4C9  2  ED 9E CB     	sbc	countr+2
00C4CC  2  90 21        	bcc	higher		;gone too far
00C4CE  2  18           	clc			;else
00C4CF  2  AD 9C CB     	lda	countr		;get counter
00C4D2  2  6D C7 CB     	adc	sectrk		;add sectors per track
00C4D5  2  8D 9C CB     	sta	countr		;sectors per track
00C4D8  2  AD 9D CB     	lda	countr+1
00C4DB  2  6D C8 CB     	adc	sectrk+1
00C4DE  2  8D 9D CB     	sta	countr+1
00C4E1  2  90 03        	bcc	bumptr		;done if no carry
00C4E3  2  EE 9E CB     	inc	countr+2	;else bump high
00C4E6  2  E8           bumptr:	inx			;increase track count
00C4E7  2  D0 D1        	bne	trnxtr		;with carry
00C4E9  2  EE C4 CB     	inc	trkctr
00C4EC  2  4C BA C4     	jmp	trnxtr		;then loop
00C4EF  2  CA           higher:	dex			;back up track
00C4F0  2  E0 FF        	cpx	#$ff		;see if wrap around
00C4F2  2  D0 03        	bne	*+5		;wasn't
00C4F4  2  CE C4 CB     	dec	trkctr		;else drop high
00C4F7  2  8A           	txa			;move to a
00C4F8  2  18           	clc			;add starting track
00C4F9  2  6D C9 CB     	adc	nsystr
00C4FC  2  AA           	tax			;save in x
00C4FD  2  AD C4 CB     	lda	trkctr
00C500  2  6D CA CB     	adc	nsystr+1
00C503  2  A8           	tay			;move to correct registers
00C504  2  8A           	txa
00C505  2  20 6E CC     	jsr	sim+30		;then set in sim
00C508  2               
00C508  2  38           	sec			;back
00C509  2  AD 9C CB     	lda	countr		;counter down
00C50C  2  ED C7 CB     	sbc	sectrk		;by sectors per track
00C50F  2  8D 9C CB     	sta	countr		;and save
00C512  2  AD 9D CB     	lda	countr+1
00C515  2  ED C8 CB     	sbc	sectrk+1
00C518  2  8D 9D CB     	sta	countr+1
00C51B  2  38           	sec			;now
00C51C  2  AD AA CB     	lda	recnum		;find difference
00C51F  2  ED 9C CB     	sbc	countr		;as sector
00C522  2  AA           	tax			;save in x
00C523  2  AD AB CB     	lda	recnum+1
00C526  2  ED 9D CB     	sbc	countr+1
00C529  2  A8           	tay			;move to correct registers
00C52A  2  8A           	txa
00C52B  2  20 83 CC     	jsr	sim+51		;translate
00C52E  2               
00C52E  2  4C 71 CC     	jmp	sim+33		;and set through sim
00C531  2               
00C531  2               ;get block bit mask and index
00C531  2               ; input:a&y=block number
00C531  2               ; returns:a=bit mask and y=0
00C531  2               ; alters:all and alcpnt
00C531  2  48           blkmsk:	pha			;save block number
00C532  2  84 07        	sty	alcpnt+1	;including high
00C534  2  A0 03        	ldy	#3		;divide by eight
00C536  2  46 07        blkmlp:	lsr	alcpnt+1	;shift high
00C538  2  6A           	ror	a
00C539  2  88           	dey			;loop until done
00C53A  2  D0 FA        	bne	blkmlp
00C53C  2  18           	clc			;now add map start
00C53D  2  6D CE CB     	adc	alcmap
00C540  2  85 06        	sta	alcpnt
00C542  2  A5 07        	lda	alcpnt+1
00C544  2  6D CF CB     	adc	alcmap+1
00C547  2  85 07        	sta	alcpnt+1
00C549  2  68           	pla			;get number back
00C54A  2  29 07        	and	#%00000111	;look at 3 lsbs
00C54C  2  AA           	tax			;get
00C54D  2  BD 72 CB     	lda	bitmsk,x	;mask
00C550  2  60           	rts			;and return
00C551  2               ;test block
00C551  2               ; input:a&y=block number
00C551  2               ; returns:z=1 if unassigned
00C551  2               ; 	   =0 if assigned and bit in a is set
00C551  2               ; alters:all
00C551  2  20 31 C5     tstblk:	jsr	blkmsk		;get mask and index
00C554  2  31 06        	and	(alcpnt),y	;mask with map entry
00C556  2  60           	rts			;then return
00C557  2               ;alter block status
00C557  2               ; input:a&y=block number,x=1 if set
00C557  2               ;		   	  =0 if reset
00C557  2               ; returns:none
00C557  2               ; alters:all and allocation map
00C557  2  E0 01        altalc:	cpx	#1		;if set
00C559  2  F0 0A        	beq	setblk		;go do it
00C55B  2  20 31 C5     clrblk:	jsr	blkmsk		;else get mask
00C55E  2  49 FF        	eor	#$ff		;and complement
00C560  2  31 06        	and	(alcpnt),y	;preserve others
00C562  2  91 06        	sta	(alcpnt),y	;and save
00C564  2  60           	rts			;then return
00C565  2  20 31 C5     setblk:	jsr	blkmsk		;get mask
00C568  2  11 06        	ora	(alcpnt),y	;set bit
00C56A  2  91 06        	sta	(alcpnt),y	;and put back
00C56C  2  60           	rts			;then return
00C56D  2               ;set current drive to read only
00C56D  2               ; input:curdrv,ronlst,bitmap
00C56D  2               ; returns:none
00C56D  2               ; alters:a,x,p and ronlst
00C56D  2  AE A4 CB     setron:	ldx	curdrv		;get number
00C570  2  BD 7A CB     	lda	bitmap,x	;and get mask
00C573  2  0D A6 CB     	ora	ronlst		;or with status
00C576  2  8D A6 CB     	sta	ronlst		;and put back
00C579  2  60           	rts			;then return
00C57A  2               ;calculate checksum of buffer @ bufadd
00C57A  2               ; input: buffer@(bufadd)
00C57A  2               ; returns:a=checksum
00C57A  2               ; alters:a,y,p
00C57A  2  A9 00        clcchk:	lda	#0		;clear accumulator
00C57C  2  A0 7F        	ldy	#127		;start at end
00C57E  2  18           chkmre:	clc			;no carry
00C57F  2  71 04        	adc	(bufadd),y	;add byte
00C581  2  88           	dey			;count down
00C582  2  10 FA        	bpl	chkmre		;and loop until done
00C584  2  60           	rts			;then return
00C585  2               ;check read/write status
00C585  2               ; input:curdrv,ronlst
00C585  2               ; returns:z=0 if r/o or z=1 if r/w
00C585  2               ; alters:a,x,p
00C585  2  AE A4 CB     chkron:	ldx	curdrv		;get current drive
00C588  2  BD 7A CB     	lda	bitmap,x	;get mask
00C58B  2  2D A6 CB     	and	ronlst		;and test status
00C58E  2  60           	rts
00C58F  2               ;initialize record counters from fcb
00C58F  2               ; input:fcb@(addinp)
00C58F  2               ; returns:none
00C58F  2               ; alters:a,y,p,nxtrec,numrec
00C58F  2  A0 20        inrcct:	ldy	#32		;next record offset
00C591  2  B1 02        	lda	(addinp),y	;get next record
00C593  2  8D AF CB     	sta	nxtrec		;and save
00C596  2  A0 0F        	ldy	#15		;number records offset
00C598  2  B1 02        	lda	(addinp),y	;get number
00C59A  2  8D B0 CB     	sta	numrec		;and save
00C59D  2  60           	rts			;and return
00C59E  2               ;update record counters in fcb
00C59E  2               ; input:nxtrec,numrec
00C59E  2               ; returns:none
00C59E  2               ; alters:all,fcb@(addinp)
00C59E  2  AE AF CB     updtrc:	ldx	nxtrec		;get next record
00C5A1  2  E8           	inx			;bump it
00C5A2  2  8A           	txa			;transfer
00C5A3  2  A0 20        	ldy	#32		;set offset
00C5A5  2  91 02        	sta	(addinp),y	;and store in fcb
00C5A7  2  AD B0 CB     	lda	numrec		;get number
00C5AA  2  A0 0F        	ldy	#15		;and its offset
00C5AC  2  91 02        	sta	(addinp),y	;and store
00C5AE  2  60           	rts			;then return
00C5AF  2               ;execute open file
00C5AF  2  20 12 C3     xopen:	jsr	autodr		;auto drive select
00C5B2  2               ;open file
00C5B2  2               ; input:fcb @ (addinp)
00C5B2  2               ; returns:n=1 if not found,a=dirmod (255 if not found)
00C5B2  2               ; alters:all
00C5B2  2  20 11 C6     opnfle:	jsr	fndf13		;match all including extent
00C5B5  2  30 32        	bmi	extopn		;done if not found
00C5B7  2  A9 0C        	lda	#12		;point to first char
00C5B9  2  0D A9 CB     	ora	subrec		;add offset
00C5BC  2  A8           	tay			;make it a pointer
00C5BD  2  B1 04        nxopmv:	lda	(bufadd),y	;get buffer contents
00C5BF  2  AA           	tax			;and save
00C5C0  2  98           	tya			;save index
00C5C1  2  29 1F        	and	#%00011111	;remove offset
00C5C3  2  A8           	tay			;back to index
00C5C4  2  8A           	txa			;get byte back
00C5C5  2  91 02        	sta	(addinp),y	;and store in fcb
00C5C7  2  98           	tya			;get index
00C5C8  2  0D A9 CB     	ora	subrec		;add offset back
00C5CB  2  A8           	tay			;and make index again
00C5CC  2  C8           	iny			;next position
00C5CD  2  98           	tya			;if index
00C5CE  2  29 1F        	and	#%00011111	;not gone past
00C5D0  2  D0 EB        	bne	nxopmv		;end then loop
00C5D2  2               ;now correct extent and max records
00C5D2  2  A0 0C        	ldy	#12		;point at extent in fcb
00C5D4  2  AD 8C CB     	lda	savext		;get save from search
00C5D7  2  D1 02        	cmp	(addinp),y	;compare
00C5D9  2  F0 0B        	beq	extsme		;jump ahead if same
00C5DB  2  91 02        	sta	(addinp),y	;else change extent
00C5DD  2  A9 80        	lda	#128		;assume fcb ext < dir ext
00C5DF  2  90 01        	bcc	fcbxls		;jump ahead if true
00C5E1  2  0A           	asl	a		;clear a
00C5E2  2  A0 0F        fcbxls:	ldy	#15		;point to max
00C5E4  2  91 02        	sta	(addinp),y	;and set
00C5E6  2  AD B3 CB     extsme:	lda	dirmod		;else get number
00C5E9  2  60           extopn:	rts			;and return
00C5EA  2               ;execute close file
00C5EA  2  20 12 C3     xclose:	jsr	autodr		;auto drive select
00C5ED  2               ;close file
00C5ED  2               ;if file is r/o then no actual close
00C5ED  2               ;operation is performed.
00C5ED  2               ; input:fcb @ (addinp)
00C5ED  2               ; returns:n=1 if not valid,a=dirmod (255 if invalid)
00C5ED  2               ; alters:all
00C5ED  2  20 11 C6     clsfle:	jsr	fndf13		;match including extent
00C5F0  2  30 1B        	bmi	extcls		;exit if not found
00C5F2  2  20 85 C5     	jsr	chkron		;see if r/o
00C5F5  2  D0 13        	bne	noclse		;branch if is
00C5F7  2               ;now set flag to ensure directory extent and number of
00C5F7  2               ;records fields are only changed if necessary.
00C5F7  2               ;The decision to change is determined by whether or
00C5F7  2               ;not the system is closing an extent less than the
00C5F7  2               ;maximum extent in the directory entry. If that is
00C5F7  2               ;the case, the directory extent and number of record
00C5F7  2               ;fields are not changed.
00C5F7  2  A0 0C        	ldy	#12		;get extent
00C5F9  2  B1 02        	lda	(addinp),y
00C5FB  2  48           	pha			;save it
00C5FC  2  98           	tya			;now look in directory
00C5FD  2  0D A9 CB     	ora	subrec
00C600  2  A8           	tay
00C601  2  68           	pla			;get extent back
00C602  2  D1 04        	cmp	(bufadd),y
00C604  2  6E 8A CB     	ror	skpdir		;save result
00C607  2               ;now go do it
00C607  2  20 7C C6     	jsr	updtdr		;update directory
00C60A  2  AD B3 CB     noclse:	lda	dirmod		;get directory number
00C60D  2  60           extcls:	rts			;and return
00C60E  2               ;execute find first match
00C60E  2  20 12 C3     xfndfr:	jsr	autodr		;auto drive select
00C611  2  A9 0D        fndf13:	lda	#13		;match including extent
00C613  2               ;search for first match
00C613  2               ; input:a=number char to match
00C613  2               ; returns:n=1 if invalid,a=dirmod (255 if invalid)
00C613  2               ; alters:all
00C613  2  48           frstsr:	pha			;save number to match
00C614  2  20 D8 C7     	jsr	cldrnm		;clear directory number to -1
00C617  2  20 7E C4     	jsr	intdrv		;and drive
00C61A  2  68           	pla			;get number to match
00C61B  2               ;search for directory match
00C61B  2               ; input:a=number char to match
00C61B  2               ; returns:n=1 if not found,a=dirmod (255 if invalid)
00C61B  2               ; alters:all
00C61B  2  8D AD CB     search:	sta	chrcnt		;save number
00C61E  2  A2 00        newtry:	ldx	#0		;set for search
00C620  2  8E AE CB     	stx	cmppnt		;clear pointer
00C623  2  20 20 C7     	jsr	nxtdir		;get next entry
00C626  2  30 37        	bmi	exitsr		;exit if not found
00C628  2  AE AD CB     	ldx	chrcnt		;get count
00C62B  2  AC AE CB     mremch:	ldy	cmppnt		;get pointer
00C62E  2  EE AE CB     	inc	cmppnt		;and bump
00C631  2  B1 02        	lda	(addinp),y	;get fcb entry
00C633  2  C0 0C        	cpy	#12		;see if at extent
00C635  2  D0 13        	bne	notaex		;jump if not
00C637  2  8D 8C CB     	sta	savext		;save for later use
00C63A  2  48           	pha			;save extent
00C63B  2  98           	tya			;change to directory
00C63C  2  0D A9 CB     	ora	subrec		;coordinates
00C63F  2  A8           	tay
00C640  2  68           	pla			;get extent back
00C641  2  51 04        	eor	(bufadd),y	;exclusive or with dir
00C643  2  2D D5 CB     	and	cexm1f		;and with exm complement + 1f
00C646  2  F0 11        	beq	trynxt		;ok if zero
00C648  2  D0 D4        	bne	newtry		;else get next directory
00C64A  2  C9 3F        notaex:	cmp	#'?'		;if a ? then
00C64C  2  F0 0B        	beq	trynxt		;is a match
00C64E  2  48           	pha			;save char
00C64F  2  98           	tya			;then add
00C650  2  0D A9 CB     	ora	subrec		;offset to
00C653  2  A8           	tay			;make pointer
00C654  2  68           	pla			;get char back
00C655  2               ;        sta     savex
00C655  2               ;        lda	(bufadd),y	;if not same
00C655  2               ;        and     #$7F            ; strip off high bit for ROMWBW Read only filesystem
00C655  2               ;	cmp	savex	        ;if not same
00C655  2  D1 04                cmp	(bufadd),y	;if not same
00C657  2  D0 C5        	bne	newtry		;try next directory
00C659  2  CA           trynxt:	dex			;else count number down
00C65A  2  D0 CF        	bne	mremch		;and loop if more
00C65C  2  AD B3 CB     	lda	dirmod		;return with directory
00C65F  2  60           exitsr:	rts			;number mod 4
00C660  2               ;calculate logical record number
00C660  2               ; input:blknum
00C660  2               ; returns:none
00C660  2               ; alters:a,x,p,recnum
00C660  2  AE BE CB     calrcn:	ldx	sxb		;set x according to blkscd
00C663  2  0E AA CB     mulmre:	asl	blknum		;multiply block
00C666  2  2E AB CB     	rol	blknum+1	;number
00C669  2  2E AC CB     	rol	blknum+2
00C66C  2  CA           	dex			;by code
00C66D  2  D0 F4        	bne	mulmre
00C66F  2  AD BD CB     	lda	sab		;set mask in a
00C672  2  2D AF CB     	and	nxtrec		;and with next record
00C675  2  0D AA CB     	ora	recnum		;or with number
00C678  2  8D AA CB     	sta	recnum		;and save
00C67B  2  60           	rts
00C67C  2               ;update directory
00C67C  2  A9 20        updtdr:	lda	#32		;change all
00C67E  2  A2 00        	ldx	#0		;from start
00C680  2               ;change directory entry
00C680  2               ; input:a=number char to change,x=starting position,fcb@(addinp)
00C680  2               ; returns:none
00C680  2               ; alters:all,directory,checksums
00C680  2  8D AD CB     dirchg:	sta	chrcnt		;save count
00C683  2  CE AD CB     	dec	chrcnt		;back up
00C686  2  18           mrechg:	clc			;clear carry
00C687  2  8A           	txa			;get offset
00C688  2  6D AD CB     	adc	chrcnt		;compute index
00C68B  2  A8           	tay			;and set
00C68C  2  C0 0C        	cpy	#12		;see if at extent
00C68E  2  F0 04        	beq	docare		;if so do special
00C690  2  C0 0F        	cpy	#15		;see if at number rec
00C692  2  D0 05        	bne	dntcar		;if not skip
00C694  2  2C 8A CB     docare:	bit	skpdir		;check flag
00C697  2  10 0D        	bpl	nochng		;skip if ok
00C699  2  B1 02        dntcar:	lda	(addinp),y	;get char
00C69B  2  48           	pha			;save it
00C69C  2  AD AD CB     	lda	chrcnt		;get count
00C69F  2  0D A9 CB     	ora	subrec		;add offset
00C6A2  2  A8           	tay			;make an index
00C6A3  2  68           	pla			;get char back
00C6A4  2  91 04        	sta	(bufadd),y	;and put in buffer
00C6A6  2  CE AD CB     nochng:	dec	chrcnt		;count down
00C6A9  2  10 DB        	bpl	mrechg		;and loop
00C6AB  2  20 8A C4     	jsr	drrcsu		;set it up
00C6AE  2  4C 3D C8     	jmp	updtck		;and do change
00C6B1  2               ;execute create file
00C6B1  2  20 12 C3     xmake:	jsr	autodr		;auto drive select
00C6B4  2               ;create file
00C6B4  2               ; input:fcb@(addinp)
00C6B4  2               ; returns:n=1 if not valid,a=dirmod (255 if not valid)
00C6B4  2               ; alters:dirnum,dirmod,fcb@(addinp)
00C6B4  2  20 14 C8     mkefle:	jsr	tstron		;test for r/o
00C6B7  2  A5 02        	lda	addinp		;save fcb
00C6B9  2  48           	pha			;address
00C6BA  2  A5 03        	lda	addinp+1	;on
00C6BC  2  48           	pha			;stack
00C6BD  2  AD E3 CA     	lda	empdvc		;then point
00C6C0  2  AC E4 CA     	ldy	empdvc+1	;to empty
00C6C3  2  85 02        	sta	addinp		;dummy
00C6C5  2  84 03        	sty	addinp+1	;fcb
00C6C7  2  A9 01        	lda	#1		;match only
00C6C9  2  20 13 C6     	jsr	frstsr		;first char
00C6CC  2  68           	pla			;restore
00C6CD  2  85 03        	sta	addinp+1	;fcb
00C6CF  2  68           	pla			;address
00C6D0  2  85 02        	sta	addinp		;from stack
00C6D2  2  AD B3 CB     	lda	dirmod		;get number mod 4
00C6D5  2  30 15        	bmi	extmke		;quit if not found
00C6D7  2  A0 0D        	ldy	#13		;else set up
00C6D9  2  A9 00        	lda	#0		;to clear
00C6DB  2  91 02        mkeagn:	sta	(addinp),y	;rest of
00C6DD  2  C8           	iny			;fcb
00C6DE  2  C0 21        	cpy	#33		;including next
00C6E0  2  D0 F9        	bne	mkeagn		;record
00C6E2  2               ;the next two lines ensure that the extent and
00C6E2  2               ;number of records fields are updated
00C6E2  2  38           	sec
00C6E3  2  6E 8A CB     	ror	skpdir
00C6E6  2  20 7C C6     	jsr	updtdr		;update directory
00C6E9  2  AD B3 CB     	lda	dirmod		;get number
00C6EC  2  60           extmke:	rts			;and quit
00C6ED  2               ;extend file
00C6ED  2               ; input:fcb@(addinp), x=1 read
00C6ED  2               ;		        0 write
00C6ED  2  8E 98 CB     extend:	stx	exrwfl		;save parameter
00C6F0  2  20 ED C5     	jsr	clsfle		;close current extent
00C6F3  2  30 2A        	bmi	extext		;exit if not found
00C6F5  2  A0 0C        	ldy	#12		;else
00C6F7  2  B1 02        	lda	(addinp),y	;get extent
00C6F9  2  18           	clc			;and
00C6FA  2  69 01        	adc	#1		;add one
00C6FC  2  29 1F        	and	#%00011111	;see if overflow
00C6FE  2  F0 17        	beq	exteof		;eof if so
00C700  2  91 02        	sta	(addinp),y	;and save
00C702  2  20 11 C6     	jsr	fndf13		;see if next extent exists
00C705  2  10 0B        	bpl	opnext		;if so open
00C707  2  AD 98 CB     	lda	exrwfl		;if not and is write then create
00C70A  2  D0 13        	bne	extext		;else return as eof
00C70C  2  20 B4 C6     dwrtex:	jsr	mkefle		;create file
00C70F  2  4C 15 C7     	jmp	tstext		;and test
00C712  2  20 B2 C5     opnext:	jsr	opnfle		;open
00C715  2  10 03        tstext:	bpl	extnok		;continue if ok
00C717  2  A9 01        exteof:	lda	#1		;else set eof
00C719  2  60           	rts			;and return
00C71A  2  20 8F C5     extnok:	jsr	inrcct		;initialize counters
00C71D  2  A9 00        	lda	#0		;good
00C71F  2  60           extext:	rts			;return
00C720  2               ;set up next directory block
00C720  2               ; input:dirnum,x=1 for update checksum
00C720  2               ; returns:a=dirmod (255 if invalid),n=1 if invalid
00C720  2               ; alters:alll,dirnum,dirmod
00C720  2  8A           nxtdir:	txa			;save operation
00C721  2  48           	pha			;on stack
00C722  2  EE A7 CB     	inc	dirnum		;bump directory
00C725  2  D0 03        	bne	*+5
00C727  2  EE A8 CB     	inc	dirnum+1
00C72A  2  AD CC CB     	lda	maxdir		;if not at limit continue
00C72D  2  CD A7 CB     	cmp	dirnum
00C730  2  AD CD CB     	lda	maxdir+1
00C733  2  ED A8 CB     	sbc	dirnum+1
00C736  2  B0 05        	bcs	gtnxdr		;then continue
00C738  2  68           	pla			;else clear stack
00C739  2  AA           	tax			;and set x
00C73A  2  4C D8 C7     	jmp	cldrnm		;set to invalid
00C73D  2  AD A7 CB     gtnxdr:	lda	dirnum		;get low again
00C740  2  29 03        	and	#%00000011	;look at 2 lsbs
00C742  2  8D B3 CB     	sta	dirmod		;save mod 4
00C745  2  0A           	asl	a		;multiply
00C746  2  0A           	asl	a		;by
00C747  2  0A           	asl	a		;32 to
00C748  2  0A           	asl	a		;get pointer
00C749  2  0A           	asl	a		;offset
00C74A  2  8D A9 CB     	sta	subrec		;and save
00C74D  2  F0 05        	beq	getdir		;if zero read new
00C74F  2  68           	pla			;else clear stack
00C750  2  AA           	tax			;set x
00C751  2  4C 5C C7     	jmp	gotdir		;and exit
00C754  2  20 8A C4     getdir:	jsr	drrcsu		;set up to read
00C757  2  20 37 C8     	jsr	rdesec		;do read
00C75A  2  68           	pla			;get operation
00C75B  2  AA           	tax			;code
00C75C  2               ;;;;;;	jsr	chksop		;do it
00C75C  2  AD B3 CB     gotdir:	lda	dirmod		;and return
00C75F  2  60           exnxdr:	rts			;with number
00C760  2               ;checksum operation
00C760  2               ;this routine assumes calling routine has checked for
00C760  2               ;valid dirnum and hence valid dirrec
00C760  2               ; input:chkflg,dirrec,x (1=update else check)
00C760  2               ; returns:none
00C760  2               ; alters:map@(chkmap)
00C760  2  2C D0 CB     chksop:	bit	chkflg		;check flag
00C763  2  30 FA        	bmi	exnxdr		;done if set
00C765  2  CA           	dex			;dec code
00C766  2  D0 09        	bne	tstchk		;if not zero test
00C768  2  20 7A C5     	jsr	clcchk		;else calculate
00C76B  2  20 C2 C7     	jsr	clcckp		;calculate pointer
00C76E  2  91 08        	sta	(chkpnt),y	;and save
00C770  2  60           	rts			;then return
00C771  2  20 7A C5     tstchk:	jsr	clcchk		;do calculation
00C774  2  20 C2 C7     	jsr	clcckp		;calculate pointer
00C777  2  D1 08        	cmp	(chkpnt),y	;compare to old
00C779  2  F0 E4        	beq	exnxdr		;if equal ok
00C77B  2  4C 6D C5     	jmp	setron		;else set to r/o
00C77E  2               ;get block number
00C77E  2               ; input:nxtrec,blmode,fcb@(addinp),sxb,exm
00C77E  2               ; returns:none
00C77E  2               ; alters:all,blknum
00C77E  2  AE BE CB     getblk:	ldx	sxb		;set x according to blkscd
00C781  2  AD AF CB     	lda	nxtrec		;get next record
00C784  2  4A           gblp:	lsr	a		;divide by 2 x times
00C785  2  CA           	dex
00C786  2  D0 FC        	bne	gblp
00C788  2  8D AA CB     	sta	blknum		;save previous as temp
00C78B  2               ;use extent as offset but first use sxb to create param
00C78B  2  38           	sec
00C78C  2  A9 08        	lda	#8
00C78E  2  ED BE CB     	sbc	sxb
00C791  2  AA           	tax
00C792  2               ;now get extent from fcb
00C792  2  A0 0C        	ldy	#12
00C794  2  B1 02        	lda	(addinp),y
00C796  2  2D D4 CB     	and	exm		;and with mask
00C799  2  4A           	lsr	a		;shift with lsb to c
00C79A  2  2A           gbxlp:	rol	a		;now go other way
00C79B  2  CA           	dex
00C79C  2  D0 FC        	bne	gbxlp
00C79E  2  18           	clc			;now add saved value
00C79F  2  6D AA CB     	adc	blknum		;back
00C7A2  2  2C BA CB     	bit	blmode		;test mode
00C7A5  2  10 01        	bpl	*+3		;skip if byte
00C7A7  2  0A           	asl	a		;else times two
00C7A8  2  18           	clc			;then add
00C7A9  2  69 10        	adc	#16		;offset into fcb
00C7AB  2  8D 8B CB     	sta	fcbind		;save for later
00C7AE  2  A8           	tay			;set index
00C7AF  2  B1 02        	lda	(addinp),y	;get number
00C7B1  2  8D AA CB     	sta	blknum		;store
00C7B4  2  C8           	iny
00C7B5  2  A9 00        	lda	#0		;clear
00C7B7  2  2C BA CB     	bit	blmode		;test mode
00C7BA  2  10 02        	bpl	*+4		;skip if byte
00C7BC  2  B1 02        	lda	(addinp),y	;else get high
00C7BE  2  8D AB CB     	sta	blknum+1	;high byte
00C7C1  2  60           	rts			;and return
00C7C2  2               ;calculate chkpnt as function of dirrec and chkmap
00C7C2  2               ; input:dirrec,chkmap
00C7C2  2               ; returns:y=0
00C7C2  2               ; alters:y,p,chkpnt
00C7C2  2  48           clcckp:	pha			;save a
00C7C3  2  18           	clc
00C7C4  2  AD B1 CB     	lda	dirrec		;add record number
00C7C7  2  6D D1 CB     	adc	chkmap		;to start
00C7CA  2  85 08        	sta	chkpnt
00C7CC  2  AD B2 CB     	lda	dirrec+1
00C7CF  2  6D D2 CB     	adc	chkmap+1
00C7D2  2  85 09        	sta	chkpnt+1
00C7D4  2  A0 00        	ldy	#0
00C7D6  2  68           	pla			;get a back
00C7D7  2  60           	rts
00C7D8  2               ;clear directory number to $ffff
00C7D8  2               ; input:none
00C7D8  2               ; returns:a=$ff,n=1,z=0
00C7D8  2               ; alters:a,p,dirnum,dirmod
00C7D8  2  A9 FF        cldrnm:	lda	#$ff		;set to $ff
00C7DA  2  8D A7 CB     	sta	dirnum
00C7DD  2  8D A8 CB     	sta	dirnum+1
00C7E0  2  8D B3 CB     	sta	dirmod
00C7E3  2  60           	rts
00C7E4  2               ;change allocation map
00C7E4  2               ; input:subrec,directory record @ (bufadd)
00C7E4  2               ; returns:none
00C7E4  2               ; alters:all,allocation map
00C7E4  2  18           mapdir:	clc			;add 16 to
00C7E5  2  AD A9 CB     	lda	subrec		;to subrec to point
00C7E8  2  69 10        	adc	#16		;to block number field
00C7EA  2  A8           	tay			;make index
00C7EB  2  8C B8 CB     lpmpdr:	sty	mpdrsy		;save index
00C7EE  2  8A           	txa			;save x
00C7EF  2  48           	pha			;operation
00C7F0  2  B1 04        	lda	(bufadd),y	;get block number
00C7F2  2  8D B9 CB     	sta	mpdrtm		;save in temp
00C7F5  2  C8           	iny			;bump index for word
00C7F6  2  20 78 C8     	jsr	gthibn		;get high part of number
00C7F9  2  0D B9 CB     mpdrnw:	ora	mpdrtm		;see if zero
00C7FC  2  F0 0A        	beq	skpedr		;skip if zero
00C7FE  2  20 78 C8     	jsr	gthibn		;get high again
00C801  2  A8           	tay			;move to y
00C802  2  AD B9 CB     	lda	mpdrtm		;get low again
00C805  2  20 57 C5     	jsr	altalc		;else alter map
00C808  2  68           skpedr:	pla			;get operation
00C809  2  AA           	tax			;back
00C80A  2  AC B8 CB     	ldy	mpdrsy		;get index back
00C80D  2  C8           	iny			;bump it
00C80E  2  98           	tya			;if still
00C80F  2  29 0F        	and	#%00001111	;in field
00C811  2  D0 D8        	bne	lpmpdr		;then loop
00C813  2  60           	rts			;else quit
00C814  2               ;test r/w status
00C814  2               ;does warm boot if r/o
00C814  2               ; input:curdrv,ronlst
00C814  2               ; returns:none
00C814  2               ; alters:a,x,p
00C814  2  20 85 C5     tstron:	jsr	chkron		;test bit
00C817  2  F0 1D        	beq	exttro		;exit if r/w
00C819  2  20 66 C8     	jsr	errout		;else send error
00C81C  2  AD E6 CA     	lda	rommvc		;point to r/o
00C81F  2  AC E7 CA     	ldy	rommvc+1	;message
00C822  2  20 CA C8     	jsr	sndstr		;send it
00C825  2  4C EA C0     	jmp	xwboot		;then abort
00C828  2               ;set current drive to r/w
00C828  2               ; input:curdrv,ronlst
00C828  2               ; returns:ronlst
00C828  2               ; alters:a,x,p,ronlst
00C828  2  AE A4 CB     setrw:	ldx	curdrv		;get drive
00C82B  2  BD 7A CB     	lda	bitmap,x	;and mask
00C82E  2  49 FF        	eor	#$ff		;complement
00C830  2  2D A6 CB     	and	ronlst		;and with status
00C833  2  8D A6 CB     	sta	ronlst		;save
00C836  2  60           exttro:	rts			;return
00C837  2               ;read sector
00C837  2  20 77 CC     rdesec:	jsr	sim+39		;do read
00C83A  2               
00C83A  2  4C 49 C8     	jmp	chkrwe		;check for error
00C83D  2               ;update checksum and directory
00C83D  2  A2 01        updtck:	ldx	#1		;set for update
00C83F  2               ;;;;;	jsr	chksop		;do it
00C83F  2  A9 01        	lda	#1		;say is directory op
00C841  2  D0 03        	bne	secwrt		;do it
00C843  2               ;write sector
00C843  2  AD D3 CB     wrtsec:	lda	pemwrtype		;get write type
00C846  2  20 7A CC     secwrt:	jsr	sim+42		;do write
00C849  2               
00C849  2  C9 00        chkrwe:	cmp	#0		;if not ok
00C84B  2  F0 E9        	beq	exttro		;done if zero
00C84D  2               ;read/write error
00C84D  2  20 66 C8     rwerrt:	jsr	errout		;send error message
00C850  2  AD E9 CA     	lda	bdsmvc		;point to
00C853  2  AC EA CA     	ldy	bdsmvc+1	;bad sector message
00C856  2  20 CA C8     	jsr	sndstr		;and send
00C859  2  20 85 C8     	jsr	getcon		;get input
00C85C  2  C9 0D        	cmp	#cr		;if a cr
00C85E  2  F0 03        	beq	ignerr		;then continue
00C860  2  4C EA C0     	jmp	xwboot		;else abort
00C863  2  4C 61 CA     ignerr:	jmp	pcrlf		;crlf and return
00C866  2               ;error output routine
00C866  2               ; input:curdrv,pemmvc
00C866  2               ; returns:none
00C866  2               ; alters:all
00C866  2  AD EC CA     errout:	lda	pemmvc		;point to
00C869  2  AC ED CA     	ldy	pemmvc+1	;error message
00C86C  2  20 CA C8     	jsr	sndstr		;send it
00C86F  2  AD A4 CB     	lda	curdrv		;get drive number
00C872  2  18           	clc			;add
00C873  2  69 41        	adc	#'A'		;ascii a
00C875  2  4C 13 C9     	jmp	sndchr		;and send it
00C878  2               ;get high part of block number if word (zero if byte)
00C878  2               ; input:y=index to high,blmode,directory@(bufadd)+subrec
00C878  2               ; returns:a=high part of block number
00C878  2               ; alters:a,p,mpdrsy iff word
00C878  2  A9 00        gthibn:	lda	#0		;preset for byte
00C87A  2  2C BA CB     	bit	blmode		;test mode
00C87D  2  10 05        	bpl	gthiex		;done if byte
00C87F  2  B1 04        	lda	(bufadd),y	;get high
00C881  2  8C B8 CB     	sty	mpdrsy		;alter y
00C884  2  60           gthiex:	rts
00C885  2               ;get console input
00C885  2               ; input:pndkey
00C885  2               ; returns:a=character
00C885  2               ; alters:all,pndkey
00C885  2               getcon:
00C885  2  AD 8E CB     	lda	pndkey		;get pending
00C888  2  48           	pha			;save it
00C889  2  A9 00        	lda	#0		;clear
00C88B  2  8D 8E CB     	sta	pndkey		;pending
00C88E  2  68           	pla			;restore
00C88F  2  D0 03        	bne	extget		;exit if not null
00C891  2  20 59 CC     	jsr	sim+9		;else get new
00C894  2               
00C894  2  60           extget:	rts			;and return
00C895  2               ;check keyboard status
00C895  2               ;handles <ctl-s> for freeze and <ctl-c> for boot
00C895  2               ; input:pndkey
00C895  2               ; returns:a=0 if no input or <>0 if input
00C895  2               ; alters:all,pndkey
00C895  2               kbdsts:
00C895  2  AD 8E CB     	lda	pndkey		;get pending
00C898  2  D0 20        	bne	extkbd		;if there quit
00C89A  2  20 56 CC     	jsr	sim+6		;else test
00C89D  2  C9 00        	CMP	#$00		;if zero
00C89F  2  F0 19        	beq	extkbd		;exit
00C8A1  2  20 59 CC     	jsr	sim+9		;else get input
00C8A4  2  C9 13        	cmp	#ctls		;if not freeze
00C8A6  2  D0 0D        	bne	newpnd		;save input
00C8A8  2  20 59 CC     	jsr	sim+9		;else wait for more
00C8AB  2  C9 03        	cmp	#ctlc		;if not abort
00C8AD  2  D0 03        	bne	nowarm		;then jump
00C8AF  2  4C EA C0     	jmp	xwboot		;else do warm boot
00C8B2  2  A9 00        nowarm:	lda	#0		;clear
00C8B4  2  60           	rts			;and return
00C8B5  2  8D 8E CB     newpnd:	sta	pndkey		;save
00C8B8  2  A9 FF        	lda	#$ff		;set ready
00C8BA  2               extkbd:
00C8BA  2  60           	rts			;and return
00C8BB  2               ;test character
00C8BB  2               ; input:a=character
00C8BB  2               ; returns:c=0 if control or c=1 if printing
00C8BB  2               ; alters:p
00C8BB  2  C9 0D        tstchr:	cmp	#cr		;if cr
00C8BD  2  F0 0A        	beq	chtext		;quit
00C8BF  2  C9 0A        	cmp	#lf		;if linefeed
00C8C1  2  F0 06        	beq	chtext		;quit
00C8C3  2  C9 09        	cmp	#ctli		;if tab
00C8C5  2  F0 02        	beq	chtext		;quit
00C8C7  2  C9 20        	cmp	#' '		;see if control
00C8C9  2  60           chtext:	rts			;and return
00C8CA  2               ;send string ending in $
00C8CA  2               ; input:ay=string address
00C8CA  2               ; returns:none
00C8CA  2               ; alters:all,index,sndlpe+1 and +2
00C8CA  2  8D D3 C8     sndstr:	sta	sndlpe+1	;set pointer
00C8CD  2  8C D4 C8     	sty	sndlpe+2
00C8D0  2  A0 00        	ldy	#0
00C8D2  2  B9 FF FF     sndlpe:	lda	$ffff,y		;get char
00C8D5  2  C9 24        	cmp	#'$'		;if terminator
00C8D7  2  F0 0C        	beq	sndext		;then exit
00C8D9  2  C8           	iny			;else bump
00C8DA  2  8C B4 CB     	sty	index		;and save
00C8DD  2  20 13 C9     	jsr	sndchr		;send char
00C8E0  2  AC B4 CB     	ldy	index		;get index
00C8E3  2  D0 ED        	bne	sndlpe		;and loop
00C8E5  2  60           sndext:	rts			;return
00C8E6  2               ;send char to printer if enabled
00C8E6  2               ; input:a=character,lstflg
00C8E6  2               ; returns:a=character
00C8E6  2               ; alters:x,y,p
00C8E6  2               lstout:
00C8E6  2  2C 8F CB     	bit	lstflg		;test flag
00C8E9  2  10 0A        	bpl	extlst		;exit if off
00C8EB  2  2C B6 CB     	bit	outflg		;test output flag
00C8EE  2  30 05        	bmi	extlst		;done if set
00C8F0  2  48           	pha			;save char
00C8F1  2  20 5F CC     	jsr	sim+15		;send
00C8F4  2  68           	pla			;get char
00C8F5  2  60           extlst:	rts			;and done
00C8F6  2               ;output a character
00C8F6  2               ; input:a=character,console definition block in sim
00C8F6  2               ; returns:none
00C8F6  2               ; alters:all,positn
00C8F6  2  20 BB C8     output:	jsr	tstchr		;test it
00C8F9  2  B0 18        	bcs	sndchr		;if not control jump
00C8FB  2  48           	pha			;else save
00C8FC  2  AD 8A CC     	lda	sysdef+4	;get invert
00C8FF  2  20 2C C9     	jsr	nolist		;send to console
00C902  2  A9 5E        	lda	#'^'		;get arrow
00C904  2  20 E6 C8     	jsr	lstout		;send to printer
00C907  2  68           	pla			;get character
00C908  2  09 40        	ora	#'A'-1		;convert to ascii
00C90A  2  20 24 C9     	jsr	pchrot		;send to all
00C90D  2  AD 89 CC     	lda	sysdef+3	;get normal
00C910  2  4C 2C C9     	jmp	nolist		;to console
00C913  2  C9 09        sndchr:	cmp	#ctli		;if not tab
00C915  2  D0 0D        	bne	pchrot		;send
00C917  2  A9 20        tabspc:	lda	#' '		;else get space
00C919  2  20 24 C9     	jsr	pchrot		;send
00C91C  2  AD 90 CB     	lda	positn		;get count
00C91F  2  29 07        	and	#7		;if not mod 8
00C921  2  D0 F4        	bne	tabspc		;loop
00C923  2  60           	rts			;else exit
00C924  2  48           pchrot:	pha			;save char
00C925  2  20 95 C8     	jsr	kbdsts		;test input
00C928  2  68           	pla			;restore
00C929  2  20 E6 C8     	jsr	lstout		;to printer if on
00C92C  2  48           nolist:	pha			;save again
00C92D  2  2C B6 CB     	bit	outflg		;test flag
00C930  2  30 03        	bmi	*+5		;done if set
00C932  2  20 5C CC     	jsr	sim+12		;to console
00C935  2  68           	pla			;restore
00C936  2  EE 90 CB     	inc	positn		;bump col
00C939  2  C9 20        	cmp	#' '		;if space or more
00C93B  2  B0 26        	bcs	extchr		;is ok
00C93D  2  CD 88 CC     	cmp	sysdef+2	;also ok
00C940  2  F0 21        	beq	extchr		;if forward
00C942  2  CE 90 CB     	dec	positn		;else drop back
00C945  2  CD 86 CC     	cmp	sysdef+0	;see if bs
00C948  2  D0 06        	bne	tryotr		;branch if not
00C94A  2  CE 90 CB     	dec	positn		;else drop again
00C94D  2  30 0F        	bmi	zrocol		;zero if <0
00C94F  2  60           	rts			;else ok
00C950  2  C9 0D        tryotr:	cmp	#cr		;if a cr
00C952  2  F0 0A        	beq	zrocol		;clear col
00C954  2  CD 8D CC     	cmp	sysdef+7	;if a formfeed
00C957  2  F0 05        	beq	zrocol		;also clear
00C959  2  CD 8E CC     	cmp	sysdef+8	;if not home
00C95C  2  D0 05        	bne	extchr		;then done
00C95E  2  A9 00        zrocol:	lda	#0		;clear
00C960  2  8D 90 CB     	sta	positn		;column
00C963  2  60           extchr:	rts			;and exit
00C964  2               ;go to left and space past prompt
00C964  2               ; input:frscol,positn
00C964  2               ; returns:none
00C964  2               ; alters:positn
00C964  2  A9 0D        spcovr:	lda	#cr		;get cr
00C966  2  20 24 C9     	jsr	pchrot		;send to all
00C969  2  A9 0A        	lda	#lf		;send lf
00C96B  2  20 E6 C8     	jsr	lstout		;only to printer
00C96E  2  AD 8D CB     mreovr:	lda	frscol		;get first
00C971  2  CD 90 CB     	cmp	positn		;see if there
00C974  2  F0 ED        	beq	extchr		;done if is
00C976  2  AD 88 CC     	lda	sysdef+2	;get forward
00C979  2  20 2C C9     	jsr	nolist		;send it
00C97C  2  4C 6E C9     	jmp	mreovr		;and loop
00C97F  2               ;buffered read
00C97F  2               ; input:buffer@(addinp)
00C97F  2               ; returns:none
00C97F  2               ; alters:all,buffer@(addinp)
00C97F  2  A9 00        bufinp:	lda	#0		;clear
00C981  2  A0 01        	ldy	#1		;length
00C983  2  91 02        	sta	(addinp),y	;position in buffer
00C985  2  8C 97 CB     	sty	bufpsn		;set point to 1
00C988  2  AD 90 CB     	lda	positn		;get current
00C98B  2  8D 8D CB     	sta	frscol		;and save
00C98E  2  20 85 C8     nxtinp:	jsr	getcon		;get input
00C991  2  AC 97 CB     	ldy	bufpsn		;get index
00C994  2  C9 0D        	cmp	#cr		;if not a cr
00C996  2  D0 03        	bne	notcr		;then jump
00C998  2  4C 5E CA     	jmp	endlin		;else done
00C99B  2  C9 08        notcr:	cmp	#delete		;if not delete
00C99D  2  D0 5E        	bne	ntdelt		;then jump
00C99F  2  C0 01        	cpy	#1		;else if start
00C9A1  2  F0 EB        	beq	nxtinp		;then loop
00C9A3  2  B1 02        	lda	(addinp),y	;get last
00C9A5  2  48           	pha			;save char
00C9A6  2  A0 01        	ldy	#1		;point to count
00C9A8  2  38           	sec			;set carry
00C9A9  2  B1 02        	lda	(addinp),y	;get count
00C9AB  2  E9 01        	sbc	#1		;decrement
00C9AD  2  91 02        	sta	(addinp),y	;then save
00C9AF  2  68           	pla			;restore char
00C9B0  2  CE 97 CB     	dec	bufpsn		;backup pointer
00C9B3  2  C9 20        	cmp	#' '		;if space or more
00C9B5  2  B0 40        	bcs	nrmbs		;just backspace
00C9B7  2  C9 09        	cmp	#ctli		;see if tab
00C9B9  2  D0 30        	bne	ctlbs		;if not is control
00C9BB  2  38           	sec			;set flag
00C9BC  2  6E B6 CB     	ror	outflg
00C9BF  2  AD 90 CB     	lda	positn		;get position and save
00C9C2  2  8D B7 CB     	sta	lstcol
00C9C5  2  20 64 C9     	jsr	spcovr		;else go back
00C9C8  2  20 6B CA     	jsr	rptlne		;and retype
00C9CB  2  AD 90 CB     	lda	positn		;get new last position
00C9CE  2  48           	pha			;save on stack
00C9CF  2  38           	sec			;subtract to get delta
00C9D0  2  AD B7 CB     	lda	lstcol
00C9D3  2  ED 90 CB     	sbc	positn
00C9D6  2  8D B7 CB     	sta	lstcol		;and save
00C9D9  2  0E B6 CB     	asl	outflg		;clear flag
00C9DC  2  20 8B CA     bstab:	jsr	dobs		;do one
00C9DF  2  CE B7 CB     	dec	lstcol		;drop count
00C9E2  2  D0 F8        	bne	bstab		;loop if more
00C9E4  2  68           	pla			;get position
00C9E5  2  8D 90 CB     	sta	positn		;and set
00C9E8  2  4C 8E C9     	jmp	nxtinp		;then loop
00C9EB  2  AD 89 CC     ctlbs:	lda	sysdef+3	;get normal
00C9EE  2  20 87 CA     	jsr	chkbs		;bs if printing
00C9F1  2  AD 8A CC     	lda	sysdef+4	;same for invert
00C9F4  2  20 87 CA     	jsr	chkbs		;then delete char itself
00C9F7  2  20 8B CA     nrmbs:	jsr	dobs		;do a backspace
00C9FA  2  4C 8E C9     	jmp	nxtinp		;and loop
00C9FD  2  C9 10        ntdelt:	cmp	#ctlp		;if not ctl-p
00C9FF  2  D0 0B        	bne	ntctlp		;then jump
00CA01  2  AD 8F CB     	lda	lstflg		;else get printer flag
00CA04  2  49 FF        	eor	#$ff		;complement
00CA06  2  8D 8F CB     	sta	lstflg		;save
00CA09  2  4C 8E C9     	jmp	nxtinp		;and loop
00CA0C  2  C9 18        ntctlp:	cmp	#ctlx		;if not ctl-x
00CA0E  2  D0 0C        	bne	ntctlx		;then jump
00CA10  2  20 64 C9     	jsr	spcovr		;restart
00CA13  2  AD 87 CC     	lda	sysdef+1	;get clear to eol
00CA16  2  20 2C C9     	jsr	nolist		;send it
00CA19  2  4C 7F C9     	jmp	bufinp		;and start over
00CA1C  2  C9 12        ntctlx:	cmp	#ctlr		;if not ctl-r
00CA1E  2  D0 09        	bne	ntctlr		;then jump
00CA20  2  20 64 C9     	jsr	spcovr		;restart
00CA23  2  20 6B CA     	jsr	rptlne		;retype line
00CA26  2  4C 8E C9     	jmp	nxtinp		;and start over
00CA29  2  C8           ntctlr:	iny			;next position
00CA2A  2  91 02        	sta	(addinp),y	;store char
00CA2C  2  48           	pha			;and save
00CA2D  2  8C 97 CB     	sty	bufpsn		;index
00CA30  2  A0 01        	ldy	#1		;point to count
00CA32  2  98           	tya			;set a to 1
00CA33  2  18           	clc			;then
00CA34  2  71 02        	adc	(addinp),y	;add count
00CA36  2  91 02        	sta	(addinp),y	;and save
00CA38  2  68           	pla			;restore char
00CA39  2  20 F6 C8     dontsv:	jsr	output		;send char
00CA3C  2  AC 97 CB     	ldy	bufpsn		;get index
00CA3F  2  B1 02        	lda	(addinp),y	;get char
00CA41  2  C9 03        	cmp	#ctlc		;if not ctl-c
00CA43  2  D0 0B        	bne	ignrcc		;ignore
00CA45  2  A0 01        	ldy	#1		;get count
00CA47  2  B1 02        	lda	(addinp),y	;from buffer
00CA49  2  C9 01        	cmp	#1		;if not at start
00CA4B  2  D0 03        	bne	ignrcc		;ignore
00CA4D  2  4C EA C0     	jmp	xwboot		;else do warm boot
00CA50  2  A0 01        ignrcc:	ldy	#1		;get
00CA52  2  B1 02        	lda	(addinp),y	;count
00CA54  2  88           	dey			;point to max
00CA55  2  D1 02        	cmp	(addinp),y	;if length
00CA57  2  B0 03        	bcs	lineen		;at max jump
00CA59  2  4C 8E C9     	jmp	nxtinp		;else loop
00CA5C  2  A9 0D        lineen:	lda	#cr		;get a cr
00CA5E  2  4C 24 C9     endlin:	jmp	pchrot		;and send
00CA61  2               ;cr and lf
00CA61  2  A9 0D        pcrlf:	lda	#cr		;then a
00CA63  2  20 24 C9     	jsr	pchrot		;cr
00CA66  2  A9 0A        	lda	#lf		;and a
00CA68  2  4C 24 C9     	jmp	pchrot		;lf
00CA6B  2               ;retype line
00CA6B  2  AD 97 CB     rptlne:	lda	bufpsn		;save point
00CA6E  2  8D B5 CB     	sta	numcnt		;as count
00CA71  2  A9 01        	lda	#1		;start position
00CA73  2  48           	pha			;save
00CA74  2  68           mrerpt:	pla			;get position
00CA75  2  CE B5 CB     	dec	numcnt		;count down
00CA78  2  D0 01        	bne	*+3		;continue if more
00CA7A  2  60           	rts			;else done
00CA7B  2  A8           	tay			;else make index
00CA7C  2  C8           	iny			;and bump
00CA7D  2  98           	tya			;save
00CA7E  2  48           	pha			;on stack
00CA7F  2  B1 02        	lda	(addinp),y	;get char
00CA81  2  20 F6 C8     	jsr	output		;send
00CA84  2  4C 74 CA     	jmp	mrerpt		;and loop
00CA87  2               ;check for printing and backspace if needed
00CA87  2  C9 20        chkbs:	cmp	#' '		;compare to space
00CA89  2  90 19        	bcc	extdec		;not printing so done
00CA8B  2               ;do a backspace
00CA8B  2  AD 86 CC     dobs:	lda	sysdef+0	;get backspace
00CA8E  2  48           	pha			;save it
00CA8F  2  20 2C C9     	jsr	nolist		;send
00CA92  2  A9 20        	lda	#' '		;get space
00CA94  2  20 2C C9     	jsr	nolist		;send
00CA97  2  68           	pla			;get backspace
00CA98  2  4C 2C C9     	jmp	nolist		;send it
00CA9B  2               ;test for decimal digit
00CA9B  2               ;if decimal then c=0 else c=1
00CA9B  2  C9 30        tstdec:	cmp	#'0'		;if under 0
00CA9D  2  90 04        	bcc	notdec		;then not decimal
00CA9F  2  C9 3A        	cmp	#'9'+1		;if 9 or under is ok
00CAA1  2  90 01        	bcc	extdec
00CAA3  2  38           notdec:	sec			;else not a match
00CAA4  2  60           extdec:	rts
00CAA5  2               ;test for hexadecimal digit
00CAA5  2               ;if hex then c=0 else c=1
00CAA5  2  20 9B CA     tsthex:	jsr	tstdec		;first try decimal
00CAA8  2  90 FA        	bcc	extdec		;ok if dec
00CAAA  2  C9 41        	cmp	#'A'		;if under A
00CAAC  2  90 F5        	bcc	notdec		;then not hex
00CAAE  2  C9 47        	cmp	#'F'+1		;set c in F compare
00CAB0  2  60           	rts
00CAB1  2               ;bump load address by 128 and return in ay
00CAB1  2  AD F3 BF     adjdb:	lda	dskbuf		;get old
00CAB4  2  AC F4 BF     	ldy	dskbuf+1	;address
00CAB7  2  18           	clc			;and bump
00CAB8  2  69 80        	adc	#128		;by 128
00CABA  2  8D F3 BF     	sta	dskbuf		;save low
00CABD  2  90 04        	bcc	*+6		;then bump
00CABF  2  C8           	iny			;and save
00CAC0  2  8C F4 BF     	sty	dskbuf+1	;high as needed
00CAC3  2  60           	rts
00CAC4  2               ;move record from disk buffer to default buffer
00CAC4  2  AD F3 BF     mv128:	lda	dskbuf		;get address
00CAC7  2  AC F4 BF     	ldy	dskbuf+1
00CACA  2  8D D3 CA     	sta	mvfrom+1	;and set pointer
00CACD  2  8C D4 CA     	sty	mvfrom+2
00CAD0  2  A2 00        	ldx	#0		;clear index
00CAD2  2  BD FF FF     mvfrom:	lda	$ffff,x		;get byte
00CAD5  2  9D 28 01     	sta	dflbuf,x	;move it
00CAD8  2  E8           	inx
00CAD9  2  10 F7        	bpl	mvfrom		;loop until done
00CADB  2  60           	rts
00CADC  2               
00CADC  2               ;relocatable vectors
00CADC  2  4C           	.byte	$4c
00CADD  2  49 C0        extevc:	.word	extexq-1
00CADF  2  4C           	.byte	$4c
00CAE0  2  3C CB        sltmvc:	.word	sltmsg
00CAE2  2  4C           	.byte	$4c
00CAE3  2  4D CB        empdvc:	.word	empty
00CAE5  2  4C           	.byte	$4c
00CAE6  2  F2 CA        rommvc:	.word	romsg
00CAE8  2  4C           	.byte	$4c
00CAE9  2  F9 CA        bdsmvc:	.word	bdsmsg
00CAEB  2  4C           	.byte	$4c
00CAEC  2  2C CB        pemmvc:	.word	pemmsg
00CAEE  2  4C           	.byte	$4c
00CAEF  2  C5 CB        dcbevc:	.word	dcb
00CAF1  2               ;relocation stopper
00CAF1  2  FF           	.byte	$ff
00CAF2  2               ;messages
00CAF2  2  20 2D 20 52  romsg:	.byte	" - R/O$"
00CAF6  2  2F 4F 24     
00CAF9  2  20 2D 20 42  bdsmsg:	.byte	" - BAD SECTOR"
00CAFD  2  41 44 20 53  
00CB01  2  45 43 54 4F  
00CB06  2  0D 0A 3C 52  	.byte	cr,lf,"<RET> TO IGNORE -- <OTHER> "
00CB0A  2  45 54 3E 20  
00CB0E  2  54 4F 20 49  
00CB23  2  54 4F 20 41  	.byte	"TO ABORT$"
00CB27  2  42 4F 52 54  
00CB2B  2  24           
00CB2C  2  0D 0A 50 45  pemmsg:	.byte	cr,lf,"PEM ERROR ON $"
00CB30  2  4D 20 45 52  
00CB34  2  52 4F 52 20  
00CB3C  2  20 2D 20 49  sltmsg:	.byte	" - INVALID DRIVE$"
00CB40  2  4E 56 41 4C  
00CB44  2  49 44 20 44  
00CB4D  2               
00CB4D  2               ;dummy fcb
00CB4D  2  E5           empty:	.byte	$e5
00CB4E  2               ;zero page switch enable table
00CB4E  2  00 00 00 00  swctbl:	.byte	0,0,0,0,0,0,0,0
00CB52  2  00 00 00 00  
00CB56  2  00 00 01 00  	.byte	0,0,1,0,0,1,1,1
00CB5A  2  00 01 01 01  
00CB5E  2  01 01 01 01  	.byte	1,1,1,1,1,1,1,1
00CB62  2  01 01 01 01  
00CB66  2  00 00 01 00  	.byte	0,0,1,0,0,0,0,0
00CB6A  2  00 00 00 00  
00CB6E  2  00 00 00 00  	.byte	0,0,0,0
00CB72  2               ;bit mask table
00CB72  2  80 40 20 10  bitmsk:	.byte	128,64,32,16,8,4,2,1
00CB76  2  08 04 02 01  
00CB7A  2               ;bit map table
00CB7A  2  01 02 04 08  bitmap:	.byte	1,2,4,8,16,32,64,128
00CB7E  2  10 20 40 80  
00CB82  2               ;extent mask table (also uses 3 bytes in sabtbl
00CB82  2  00 01 03     exmtbl:	.byte	0,1,3
00CB85  2               ;sab table
00CB85  2  07 0F 1F 3F  sabtbl:	.byte	7,15,31,63,127
00CB89  2  7F           
00CB8A  2               ;variable storage
00CB8A  2  00           skpdir:	.byte	0		;positive if no change
00CB8B  2  00           fcbind:	.byte	0		;index to block number
00CB8C  2  00           savext:	.byte	0		;save extent
00CB8D  2  00           frscol:	.byte	0		;first col
00CB8E  2  00           pndkey:	.byte	0		;pending input
00CB8F  2  00           lstflg:	.byte	0		;printer flag
00CB90  2  00           positn:	.byte	0		;print position
00CB91  2  00           swcflg:	.byte	0		;zero page switch flag
00CB92  2  00 00        bytinp:	.word	0		;input value
00CB94  2  00           cmdinp:	.byte	0		;input command
00CB95  2  00 00        addout:	.word	0		;output address
00CB97  2               bytout	=	addout		;output value
00CB97  2  00           bufpsn:	.byte	0		;input buffer position
00CB98  2  00           exrwfl:	.byte	0		;extend flag
00CB99  2  00           tmpdrv:	.byte	0		;temporary drive number
00CB9A  2               ;align xqtvec on word boundary
00CB9A  2               	.align 2
00CB9A  2  00 00        xqtvec:	.word	0		;command vector
00CB9C  2  00 00        countr:	.word	0		;record counter
00CB9E  2  00           	.byte	0		;overflow
00CB9F  2  00 00        lkdown:	.word	0		;down pnt. for block search
00CBA1  2  00 00        lookup:	.word	0		;up pnt. for block search
00CBA3  2  00           olddrv:	.byte	0		;old drive number
00CBA4  2  00           curdrv:	.byte	0		;current drive
00CBA5  2  00           lginvc:	.byte	0		;log in status
00CBA6  2  00           ronlst:	.byte	0		;read write status
00CBA7  2  00 00        dirnum:	.word	0		;directory number
00CBA9  2  00           subrec:	.byte	0		;directory offset
00CBAA  2  00 00        recnum:	.word	0		;record number
00CBAC  2               blknum	=	recnum		;block number
00CBAC  2  00           	.byte	0		;overflow
00CBAD  2  00           chrcnt:	.byte	0		;character count
00CBAE  2  00           cmppnt:	.byte	0		;comparison pointer
00CBAF  2  00           nxtrec:	.byte	0		;next record
00CBB0  2  00           numrec:	.byte	0		;number records
00CBB1  2  00 00        dirrec:	.word	0		;directory record
00CBB3  2  00           dirmod:	.byte	0		;directory mod 4
00CBB4  2  00           index:	.byte	0		;buffer index
00CBB5  2  00           numcnt:	.byte	0		;counter
00CBB6  2  00           outflg:	.byte	0		;output enable flag
00CBB7  2  00           lstcol:	.byte	0		;last column
00CBB8  2  00           mpdrsy:	.byte	0		;save for y in mapdir
00CBB9  2  00           mpdrtm:	.byte	0		;temp in mapdir
00CBBA  2  00           blmode:	.byte	0		;<128 if byte else word
00CBBB  2  00 00        maxdrc:	.word	0		;max directory record
00CBBD  2  00           sab:	.byte	0		;mask for block
00CBBE  2  00           sxb:	.byte	0		;shift for block
00CBBF  2  00 00 00     rtclk:	.byte	0,0,0		;real time clock
00CBC2  2  00 00        gpcnt:	.word	0		;gp counter
00CBC4  2  00           trkctr:	.byte	0		;track counter
00CBC5  2               ;following region is used to capture dcb
00CBC5  2               dcb:
00CBC5  2  00 00        maxblk:	.word	0		;maximum block number
00CBC7  2  00 00        sectrk:	.word	0		;sectors per track
00CBC9  2  00 00        nsystr:	.word	0		;number system tracks
00CBCB  2  00           blkscd:	.byte	0		;block size code
00CBCC  2  00 00        maxdir:	.word	0		;maximum directory number
00CBCE  2  00 00        alcmap:	.word	0		;address of allocation map
00CBD0  2  00           chkflg:	.byte	0		;check flag
00CBD1  2  00 00        chkmap:	.word	0		;address of checksum map
00CBD3  2  00           pemwrtype:	.byte	0		;write type 0=norm,1=dir,2=unalloc
00CBD4  2  00           exm:	.byte	0		;extent mask
00CBD5  2  00           cexm1f:	.byte	0		;exm complemented and 1f
00CBD6  2               ;zero page save block
00CBD6  2               varblk:
00CBD6  2  00 00        lowin:	.word	0
00CBD8  2  00 00        	.word	0		;save bufadd
00CBDA  2  00 00        	.word	0		;save alcpnt
00CBDC  2  00 00        	.word	0		;save chkpnt
00CBDE  2               
00CBDE  1               		.include "simnhy.asm"
00CBDE  2               ;________________________________________________________________________________________________________________________________
00CBDE  2               ;
00CBDE  2               ;	Nhyodyne dos/65 system interface module (sim)
00CBDE  2               ;
00CBDE  2               ;  DWERNER 12/20/2021 	ported to Nhyodyne
00CBDE  2               ;________________________________________________________________________________________________________________________________
00CBDE  2               
00CBDE  2               		.include "macro.asm"
00CBDE  3               ;__MACRO___________________________________________________________________________________________________________________
00CBDE  3               ;
00CBDE  3               ; 	Macros for the betterment of Mankind
00CBDE  3               ;________________________________________________________________________________________________________________________________
00CBDE  3               ;
00CBDE  3               
00CBDE  3               .macro          PRTDBG      message
00CBDE  3               .LOCAL p1
00CBDE  3               .LOCAL p2
00CBDE  3               .LOCAL p3
00CBDE  3               .LOCAL p4
00CBDE  3               .LOCAL p5
00CBDE  3                 .if     .paramcount <> 1
00CBDE  3                       .error  "Too few parameters for macro PRTDBG"
00CBDE  3                       .endif
00CBDE  3                       .if DEBUG=1
00CBDE  3                       PHA
00CBDE  3                       PHX
00CBDE  3                       PHY
00CBDE  3                       LDX #$00
00CBDE  3               p1:
00CBDE  3                       LDA p4,x
00CBDE  3                       INX
00CBDE  3                       CMP #'$'
00CBDE  3                       BEQ p2
00CBDE  3                       JSR conwrt
00CBDE  3                       JMP p1
00CBDE  3               p2:
00CBDE  3                       LDA #13
00CBDE  3                       jsr conwrt
00CBDE  3                       LDA #10
00CBDE  3                       jsr conwrt
00CBDE  3                       PLY
00CBDE  3                       plx
00CBDE  3                       pla
00CBDE  3                       JMP p5
00CBDE  3               p4:
00CBDE  3                       .BYTE message
00CBDE  3               p5:
00CBDE  3                       .endif
00CBDE  3               .endmacro
00CBDE  3               
00CBDE  3               .macro          PRTS      message
00CBDE  3               .LOCAL p1
00CBDE  3               .LOCAL p2
00CBDE  3               .LOCAL p3
00CBDE  3               .LOCAL p4
00CBDE  3               .LOCAL p5
00CBDE  3                 .if     .paramcount <> 1
00CBDE  3                       .error  "Too few parameters for macro PRTS"
00CBDE  3                       .endif
00CBDE  3                       PHA
00CBDE  3                       PHX
00CBDE  3                       PHY
00CBDE  3                       LDX #$00
00CBDE  3               p1:
00CBDE  3                       LDA p4,x
00CBDE  3                       INX
00CBDE  3                       CMP #'$'
00CBDE  3                       BEQ p2
00CBDE  3                       JSR conwrt
00CBDE  3                       JMP p1
00CBDE  3               p2:
00CBDE  3                       PLY
00CBDE  3                       plx
00CBDE  3                       pla
00CBDE  3                       JMP p5
00CBDE  3               p4:
00CBDE  3                       .BYTE message
00CBDE  3               p5:
00CBDE  3               .endmacro
00CBDE  3               
00CBDE  3               
00CBDE  3               
00CBDE  3               
00CBDE  3               ;__PRTHEXBYTE__________________________________________________
00CBDE  3               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
00CBDE  3               ;______________________________________________________________
00CBDE  3               PRTHEXBYTE:
00CBDE  3  48                   PHA
00CBDF  3  DA                   PHX
00CBE0  3  5A                   PHY
00CBE1  3  AA                   TAX				; SAVE A REGISTER
00CBE2  3  4A                   LSR 				; SHIFT HIGH NIBBLE TO LOW NIBBLE
00CBE3  3  4A                   LSR 				;
00CBE4  3  4A                   LSR 				;
00CBE5  3  4A                   LSR 				;
00CBE6  3  18                   CLC               		; CLEAR CARRY
00CBE7  3  20 F2 CB             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
00CBEA  3  8A                   TXA				; RESTORE ACCUMULATOR
00CBEB  3  20 F2 CB             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
00CBEE  3  7A                   PLY
00CBEF  3  FA                   plx
00CBF0  3  68                   PLA
00CBF1  3  60                   RTS
00CBF2  3               
00CBF2  3               ;__PRINT_DIGIT_________________________________________________
00CBF2  3               ;
00CBF2  3               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
00CBF2  3               ;
00CBF2  3               ;______________________________________________________________
00CBF2  3               PRINT_DIGIT:
00CBF2  3  29 0F                       AND #$0F				; STRIP OFF HIGH NIBBLE
00CBF4  3  09 30                       ORA #$30				; ADD $30 TO PRODUCE ASCII
00CBF6  3  C9 3A                       CMP #$3A               		; IS GREATER THAN 9
00CBF8  3  30 03                       BMI PRINT_DIGIT_OUT		; NO, SKIP ADD
00CBFA  3  18                          CLC				; CLEAR CARRY
00CBFB  3  69 07                       ADC #$07				; ADD ON FOR LETTER VALUES
00CBFD  3               PRINT_DIGIT_OUT:					;
00CBFD  3  4C DF CE                    JMP conwrt              		; PRINT OUT CHAR
00CC00  3               
00CC00  3               NEWLINE:
00CC00  3  48                           pha
00CC01  3  DA                           PHX
00CC02  3  5A                           phy
00CC03  3  A9 0D                        LDA #$0D
00CC05  3  20 DF CE                     JSR conwrt
00CC08  3  A9 0A                        LDA #$0A
00CC0A  3  20 DF CE                     Jsr conwrt
00CC0D  3  7A                           ply
00CC0E  3  FA                           plx
00CC0F  3  68                           pla
00CC10  3  60                           rts
00CC11  3               
00CC11  3               PRTDEC:
00CC11  3  5A                           phy
00CC12  3  DA                           PHX
00CC13  3  48                           PHA
00CC14  3  A0 00                        ldy #00
00CC16  3  A2 FF                        LDX #$FF
00CC18  3  38                           SEC
00CC19  3               PrDec100:
00CC19  3  E8                           INX
00CC1A  3  E9 64                        SBC #100
00CC1C  3  B0 FB                        BCS PrDec100            ;Count how many 100s
00CC1E  3  69 64                        ADC #100
00CC20  3  20 3A CC                     JSR PrDecDigit          ;Print the 100s
00CC23  3  A2 FF                        LDX #$FF
00CC25  3  38                           SEC                     ;Prepare for subtraction
00CC26  3               PrDec10:
00CC26  3  E8                           INX
00CC27  3  E9 0A                        SBC #10
00CC29  3  B0 FB                        BCS PrDec10             ;Count how many 10s
00CC2B  3  69 0A                        ADC #10
00CC2D  3  20 3A CC                     JSR PrDecDigit          ;Print the 10s
00CC30  3  AA                           TAX                     ;Pass 1s into X
00CC31  3  A0 01                        ldy #1
00CC33  3  20 3A CC                     JSR PrDecDigit          ;Print the 1s
00CC36  3  68                           PLA
00CC37  3  FA                           PLX
00CC38  3  7A                           ply
00CC39  3  60                           RTS
00CC3A  3               PrDecDigit:
00CC3A  3  48                           PHA
00CC3B  3  C0 00                        cpy #$00
00CC3D  3  D0 09                        bne PrDecDigit1
00CC3F  3  8A                           txa
00CC40  3  A8                           tay
00CC41  3  C0 00                        cpy #$00
00CC43  3  D0 03                        bne PrDecDigit1
00CC45  3  4C 4E CC                     jmp PrDecDigit2
00CC48  3               PrDecDigit1:
00CC48  3  8A                           TXA                     ;Save A, pass digit to A
00CC49  3  09 30                        ORA #'0'
00CC4B  3  20 DF CE                     JSR  conwrt             ;Convert to character and print it
00CC4E  3               PrDecDigit2:
00CC4E  3  68                           PLA
00CC4F  3  60                           RTS                     ;Restore A and return
00CC50  3               
00CC50  2               DO_FARCALL =    farcall-md_pagecode+$0200
00CC50  2               
00CC50  2               ;dos/65 system interface module (sim)
00CC50  2               ;version 3.00
00CC50  2               ;this version is designed to work with the N8VEM Host Processor
00CC50  2               
00CC50  2               ;fixed parameters
00CC50  2               simstart:
00CC50  2               
00CC50  2               ;my system i/o routines in rom
00CC50  2               nsects	=	(simstart-ccm)/128	;number sectors
00CC50  2               
00CC50  2               ;main program
00CC50  2               ;jump vector used by pem
00CC50  2  4C A8 CD     sim:	jmp	boot		;from cold start
00CC53  2  4C 44 CE     wboote:	jmp	wboot		;from warm boot
00CC56  2  4C D1 CE     	jmp	consts		;check for input
00CC59  2  4C D8 CE     	jmp	conrde		;get input
00CC5C  2  4C DF CE     	jmp	conwrt		;send to terminal
00CC5F  2  4C E8 CE     	jmp	prnwrt		;printer output
00CC62  2  4C E9 CE     	jmp	punwrt		;punch output
00CC65  2  4C EA CE     	jmp	rdrinp		;reader input
00CC68  2  4C 6D CE     	jmp	home		;home drive
00CC6B  2  4C 4C CE     	jmp	seldsk		;select disk
00CC6E  2  4C 71 CE     	jmp	seltrk		;set track
00CC71  2  4C 79 CE     	jmp	selsec		;set sector
00CC74  2  4C CC CE     	jmp	setdma		;set buffer address
00CC77  2  4C 80 CE     	jmp	read		;read sector
00CC7A  2  4C A6 CE     	jmp	write		;write sector
00CC7D  2  A9 01        	lda	#1		;printer always ready
00CC7F  2  60           	rts
00CC80  2  4C EB CE     	jmp	rdtime		;clock entry
00CC83  2  4C EC CE     	jmp	xlate		;translate
00CC86  2               
00CC86  2               ;console definition block
00CC86  2               sysdef:
00CC86  2  08           	.byte	8		;backspace
00CC87  2  01           	.byte	1		;clear to end of line
00CC88  2  0C           	.byte	$c		;forward space
00CC89  2  00           	.byte	0		;normal video
00CC8A  2  5E           	.byte	'^'		;invert video
00CC8B  2  18           	.byte	24		;lines per screen
00CC8C  2  50           	.byte	80		;char per line
00CC8D  2  0C           	.byte	$c		;formfeed
00CC8E  2  1E           	.byte	$1e		;home
00CC8F  2  02           	.byte	2		;clear to end of screen
00CC90  2               
00CC90  2               ;opening id message
00CC90  2  0D 0A        opnmsg:	.byte	cr,lf
00CC92  2               
00CC92  2  64 38 38 38      	.BYTE "d8888b.  .d88b.  .d8888.    dD     ooooo",cr,lf
00CC96  2  38 62 2E 20  
00CC9A  2  20 2E 64 38  
00CCBC  2  38 38 20 20      	.BYTE "88  `8D .8P  Y8. 88   YP   d8     8P~~~~",cr,lf
00CCC0  2  60 38 44 20  
00CCC4  2  2E 38 50 20  
00CCE6  2  38 38 20 20      	.BYTE "88   88 88    88 `8bo.    d8     dP",cr,lf
00CCEA  2  20 38 38 20  
00CCEE  2  38 38 20 20  
00CD0B  2  38 38 20 20      	.BYTE "88   88 88    88   `Y8b. d8888b. V8888b.",cr,lf,0
00CD0F  2  20 38 38 20  
00CD13  2  38 38 20 20  
00CD36  2               opnmsg1:
00CD36  2  38 38 20 20      	.BYTE "88  .8D `8b  d8' db   8D 88  `8D     `8D",cr,lf
00CD3A  2  2E 38 44 20  
00CD3E  2  60 38 62 20  
00CD60  2  59 38 38 38      	.BYTE "Y8888D   `Y88P   `8888Y  `8888P  88oobY",cr,lf
00CD64  2  38 44 20 20  
00CD68  2  20 60 59 38  
00CD89  2  11 44 4F 53  	.byte 17,"DOS/65 ON THE NHYODYNE 3.00",cr,lf,0
00CD8D  2  2F 36 35 20  
00CD91  2  4F 4E 20 54  
00CDA8  2               
00CDA8  2               
00CDA8  2               ;cold entry from loader
00CDA8  2               boot:
00CDA8  2  78           	SEI 			; DISABLE INTERRUPTS
00CDA9  2  A2 FF        	ldx	#$ff		;set stack
00CDAB  2  9A           	txs			;pointer
00CDAC  2  D8           	cld			;set binary mode
00CDAD  2               
00CDAD  2  20 45 D0     	JSR	PAGER_INIT		;setup paging for device drivers
00CDB0  2               
00CDB0  2               	PRTDBG "OS Starting$"
00CDB0  2               
00CDB0  2  A9 90         	lda	#<opnmsg	;point to message
00CDB2  2  A0 CC        	ldy	#>opnmsg
00CDB4  2  20 ED CE     	jsr	outmsg		;send it
00CDB7  2  A9 36         	lda	#<opnmsg1
00CDB9  2  A0 CD        	ldy	#>opnmsg1
00CDBB  2  20 ED CE     	jsr	outmsg		;send it
00CDBE  2               
00CDBE  2  20 00 CC     	JSR 	NEWLINE
00CDC1  2               
00CDC1  2               ; 	setup diskconfig table
00CDC1  2  A2 00        	ldx 	#0
00CDC3  2               @2:
00CDC3  2  BD B9 D9     	lda 	dftdskcfg,x
00CDC6  2  9D 14 03     	sta 	dskcfg,x
00CDC9  2  E8           	inx
00CDCA  2  E0 10        	cpx 	#$10
00CDCC  2  D0 F5        	bne 	@2
00CDCE  2               
00CDCE  2               
00CDCE  2                 .IF USEFLOPPYA=1
00CDCE  2               ;  	PRTDBG "Init floppy A$"
00CDCE  2               ;  	lda	#0			;set zero
00CDCE  2               ;	jsr	seldsk		;and select drive zero
00CDCE  2               ;	JSR	SETUPDRIVE
00CDCE  2                 .ENDIF
00CDCE  2               
00CDCE  2  A9 16        	lda 	#22            		;MD_SHOW
00CDD0  2  85 32        	sta 	farfunct
00CDD2  2  4C 65 02     	jmp 	DO_FARCALL
00CDD5  2               
00CDD5  2               
00CDD5  2                   .IF USEIDEC=1
00CDD5  2  A9 04            	lda 	#04            ;PPIDE_INIT
00CDD7  2  85 32        	sta 	farfunct
00CDD9  2  20 65 02     	JSR 	DO_FARCALL
00CDDC  2                 .ENDIF
00CDDC  2               
00CDDC  2               
00CDDC  2                  .IF USEDSKYNG=1 || USEDSKY=1
00CDDC  2  A9 08        	lda 	#08            ;DSKY_INIT
00CDDE  2  85 32        	sta 	farfunct
00CDE0  2  20 65 02     	JSR 	DO_FARCALL
00CDE3  2               
00CDE3  2  A2 00        	LDX 	#$00
00CDE5  2               @1:
00CDE5  2  BD CC D0     	LDA 	DOS65DSKYINIT,X
00CDE8  2  9D 00 03     	STA	DSKY_BUF,X
00CDEB  2  E8           	INX
00CDEC  2  E0 08        	CPX 	#8
00CDEE  2  D0 F5        	BNE	@1
00CDF0  2  A9 12        	lda 	#18            ;DSKY_PUTLED
00CDF2  2  85 32        	sta 	farfunct
00CDF4  2  20 65 02     	JSR 	DO_FARCALL
00CDF7  2               
00CDF7  2  A9 0D        	lda 	#13            ;DSKY_BEEP
00CDF9  2  85 32        	sta 	farfunct
00CDFB  2  20 65 02     	JSR 	DO_FARCALL
00CDFE  2                 .ENDIF
00CDFE  2               
00CDFE  2               
00CDFE  2  A9 44        	LDA 	#<cnstxt	; STORE POINTER TO COMMAND LINE
00CE00  2  85 30        	STA 	cmdlnp
00CE02  2  A9 BF        	LDA 	#>cnstxt
00CE04  2  85 31        	STA 	cmdlnp+1
00CE06  2               
00CE06  2               
00CE06  2               
00CE06  2  A9 14        	LDA 	#<dskcfg	; STORE POINTER TO DISK CONFIG TABLE FOR APPS
00CE08  2  85 2E        	STA 	dskcfpc
00CE0A  2  A9 03        	LDA 	#>dskcfg
00CE0C  2  85 2F        	STA 	dskcfpc+1
00CE0E  2  20 0E CF     	JSR 	DSPL_DSK_CFG	; DISPLAY DISK CONFIG TO USERS
00CE11  2               
00CE11  2               
00CE11  2               				;set up jumps into dos/65 in page one
00CE11  2               setup:
00CE11  2  20 45 D0     	JSR	PAGER_INIT
00CE14  2  A2 00        	ldx	#0		;clear index
00CE16  2               				;first clear key dba variables
00CE16  2  8E 47 D1     	stx	hstact		;host buffer inactive
00CE19  2  8E 48 D1     	stx	unacnt		;clear unalloc count
00CE1C  2  BD 3E CE     setupl:	lda	inttbl,x	;get byte
00CE1F  2  9D 00 01     	sta	$100,x		;insert at start
00CE22  2  E8           	inx
00CE23  2  E0 06        	cpx	#6
00CE25  2  D0 F5        	bne	setupl		;loop until done
00CE27  2  A9 28        	lda	#<dflbuf	;get low buffer
00CE29  2  A0 01        	ldy	#>dflbuf	;and high
00CE2B  2  20 CC CE     	jsr	setdma		;and set
00CE2E  2  AD 13 03     	lda	sekdsk		;get disk
00CE31  2               
00CE31  2  A9 02        	lda	#DEFDRV		;set zero
00CE33  2  20 4C CE     	jsr	seldsk		;and select drive zero
00CE36  2  20 6D CE     	jsr	home		;home that drive
00CE39  2               
00CE39  2               	PRTDBG "Start CCM$"
00CE39  2  A9 02        	lda	#DEFDRV		;set zero
00CE3B  2  4C 03 B8     	jmp	ccm		;and go to ccm
00CE3E  2               ;initialization table
00CE3E  2  4C 53 CC 4C  inttbl:	.byte	$4c,<wboote,>wboote,$4c,<pem,>pem
00CE42  2  FE BF        
00CE44  2               ;warm boot-read dos/65 back except sim and then
00CE44  2               ; jump to ccm.
00CE44  2               
00CE44  2               
00CE44  2               wboot:
00CE44  2  78           	SEI 			; DISABLE INTERRUPTS
00CE45  2  A2 FF        	ldx	#$ff		;set stack
00CE47  2  9A           	txs			;pointer
00CE48  2  D8           	cld			;set binary mode
00CE49  2               
00CE49  2  4C 11 CE     	jmp	setup		;go setup
00CE4C  2               
00CE4C  2               
00CE4C  2               
00CE4C  2               ;__SELDSK_________________________________________________________________________________________________
00CE4C  2               ;
00CE4C  2               ; 	PERFORM DOS/65 DISK DRIVE SELECT
00CE4C  2               ;________________________________________________________________________________________________________
00CE4C  2               ;select disk
00CE4C  2               seldsk:
00CE4C  2  29 07        	and	#7		;three lsbs only
00CE4E  2  8D 13 03     	sta	sekdsk		;save for later
00CE51  2                .IF (USEFLOPPYA=1 | USEFLOPPYB=1)
00CE51  2               	jsr	MOTOROFF	; TURN OFF ALL FLOPPY MOTORS
00CE51  2                .ENDIF
00CE51  2  AD 13 03     	LDA	sekdsk		;save for later
00CE54  2  0A           	asl	a		;multiply by two
00CE55  2  AA           	tax			;make an Index
00CE56  2  BD 5D CE     	lda	dcbtbl,x	;get address
00CE59  2  BC 5E CE     	ldy	dcbtbl+1,x
00CE5C  2  60           	rts
00CE5D  2               
00CE5D  2               ;table of dcb addresses
00CE5D  2  D4 D0        dcbtbl:	.word	dcba		; A
00CE5F  2  E2 D0        	.word	dcbb		; B
00CE61  2  F0 D0        	.word	dcbc		; C
00CE63  2  FE D0        	.word	dcbd		; D
00CE65  2  0C D1        	.word	dcbe		; E
00CE67  2  1A D1        	.word	dcbf		; F
00CE69  2  28 D1        	.word	dcbg		; G
00CE6B  2  36 D1        	.word	dcbh		; H
00CE6D  2               
00CE6D  2               ;__HOME__________________________________________________________________________________________________
00CE6D  2               ;
00CE6D  2               ; 	PERFORM DOS/65 HEAD HOME
00CE6D  2               ;________________________________________________________________________________________________________
00CE6D  2               home:
00CE6D  2  A9 00        	lda	#$00
00CE6F  2  A0 00        	ldy	#$00
00CE71  2               
00CE71  2               ;__SELTRK________________________________________________________________________________________________
00CE71  2               ;
00CE71  2               ; 	PERFORM DOS/65 SELECT TRACK
00CE71  2               ;
00CE71  2               ;	A=TRACK LOW BYTE
00CE71  2               ;	Y=TRACK HIGH BYTE
00CE71  2               ;________________________________________________________________________________________________________
00CE71  2               seltrk:
00CE71  2  18           	CLC
00CE72  2  8D 0C 03     	sta	sektrk		;save number
00CE75  2  8C 0D 03     	sty	sektrk+1
00CE78  2  60           	rts
00CE79  2               
00CE79  2               ;__SELSEC________________________________________________________________________________________________
00CE79  2               ;
00CE79  2               ; 	PERFORM DOS/65 SECTOR SELECT
00CE79  2               ;
00CE79  2               ;	A=SECTOR LOW BYTE
00CE79  2               ;	Y=SECTOR HIGH BYTE
00CE79  2               ;________________________________________________________________________________________________________
00CE79  2               selsec:
00CE79  2  8D 0E 03     	sta	seksec		;save low and high
00CE7C  2  8C 0F 03     	sty	seksec+1
00CE7F  2  60           	rts
00CE80  2               
00CE80  2               ;__READ__________________________________________________________________________________________________
00CE80  2               ;
00CE80  2               ; 	PERFORM DOS/65 SECTOR READ
00CE80  2               ;________________________________________________________________________________________________________
00CE80  2               read:
00CE80  2  20 01 CF     	JSR 	GET_DRIVE_DEVICE	;
00CE83  2  29 F0        	and 	#$F0			; only want first nybble
00CE85  2  C9 00        	CMP 	#$00
00CE87  2  D0 08        	BNE 	:+			; not MD drive
00CE89  2               	;RAM
00CE89  2  A9 14        	lda 	#20            		;MD_READ_SECTOR
00CE8B  2  85 32        	sta 	farfunct
00CE8D  2  4C 65 02     	jmp 	DO_FARCALL
00CE90  2               
00CE90  2  60           	RTS				;
00CE91  2               :
00CE91  2  C9 20        	CMP 	#$20
00CE93  2  D0 03        	BNE 	:+			; not floppy drive
00CE95  2               	;FD
00CE95  2                 	.IF USEFLOPPYA=1 || USEFLOPPYB=1
00CE95  2                 	JMP	READFL			;
00CE95  2                 	.else
00CE95  2  A9 FF          	LDA	#$FF			;
00CE97  2  60           	RTS				;
00CE98  2                 	.ENDIF
00CE98  2               :
00CE98  2  C9 30        	CMP 	#$30
00CE9A  2  D0 07        	BNE 	:+			; invalid drive
00CE9C  2               	;PPIDE
00CE9C  2                 	.IF USEIDEC=1
00CE9C  2  A9 05        	lda 	#05            		;IDE_READ_SECTOR
00CE9E  2  85 32        	sta 	farfunct
00CEA0  2  4C 65 02     	jmp 	DO_FARCALL
00CEA3  2                 	.ENDIF
00CEA3  2               :
00CEA3  2  A9 FF        	LDA	#$FF			; signal error
00CEA5  2  60           	RTS				;
00CEA6  2               
00CEA6  2               
00CEA6  2               ;__WRITE_________________________________________________________________________________________________
00CEA6  2               ;
00CEA6  2               ; 	PERFORM DOS/65 SECTOR WRITE
00CEA6  2               ;________________________________________________________________________________________________________
00CEA6  2               write:
00CEA6  2  20 01 CF     	JSR 	GET_DRIVE_DEVICE	;
00CEA9  2  29 F0        	and 	#$F0			; only want first nybble
00CEAB  2               
00CEAB  2  C9 00        	CMP 	#$00
00CEAD  2  D0 08        	BNE 	:+			; not MD Drive
00CEAF  2               	;MD
00CEAF  2  A9 15        	lda 	#21            		;MD_WRITE_SECTOR
00CEB1  2  85 32        	sta 	farfunct
00CEB3  2  4C 65 02     	jmp 	DO_FARCALL
00CEB6  2               
00CEB6  2               
00CEB6  2  60           	RTS				;
00CEB7  2               :
00CEB7  2  C9 20        	CMP 	#$20
00CEB9  2  D0 03        	BNE 	:+			; not floppy drive
00CEBB  2               	;FD
00CEBB  2                 	.IF USEFLOPPYA=1 || USEFLOPPYB=1
00CEBB  2                 	Jsr	WRITEFL			;
00CEBB  2               	RTS				;
00CEBB  2                 	.else
00CEBB  2  A9 FF          	LDA	#$FF			;
00CEBD  2  60           	RTS				;
00CEBE  2                 	.ENDIF
00CEBE  2               :
00CEBE  2  C9 30        	CMP 	#$30
00CEC0  2  D0 07        	BNE 	writex			; not ppide
00CEC2  2               	;PPIDE
00CEC2  2                 	.IF USEIDEC=1
00CEC2  2  A9 06        	lda 	#06            		;IDE_WRITE_SECTOR
00CEC4  2  85 32        	sta 	farfunct
00CEC6  2  4C 65 02     	jmp 	DO_FARCALL
00CEC9  2                 	.else
00CEC9  2                 	LDA	#$FF			;
00CEC9  2               	RTS				;
00CEC9  2                 	.ENDIF
00CEC9  2               writex:
00CEC9  2  A9 FF        	LDA	#$FF			; signal error
00CECB  2  60           	RTS				;
00CECC  2               
00CECC  2               
00CECC  2               ;__SETDMA________________________________________________________________________________________________
00CECC  2               ;
00CECC  2               ; 	PERFORM DOS/65 BUFFER ADDRESS SELECTION
00CECC  2               ;
00CECC  2               ;	A=BUFFER LOW BYTE
00CECC  2               ;	Y=BUFFER HIGH BYTE
00CECC  2               ;________________________________________________________________________________________________________
00CECC  2               setdma:
00CECC  2  85 F4        	sta	dmaadr		;store low
00CECE  2  84 F5        	sty	dmaadr+1	;and high
00CED0  2  60           	rts
00CED1  2               
00CED1  2               
00CED1  2               ;__CONSTS________________________________________________________________________________________________
00CED1  2               ;
00CED1  2               ; 	GET DOS/65 CONSOLE STATUS
00CED1  2               ;________________________________________________________________________________________________________
00CED1  2               consts:
00CED1  2  A9 03        	lda 	#03
00CED3  2  85 32        	sta 	farfunct
00CED5  2  4C 65 02     	jmp 	DO_FARCALL
00CED8  2               
00CED8  2               ;__CONRDE________________________________________________________________________________________________
00CED8  2               ;
00CED8  2               ; 	PERFORM DOS/65 CONSOLE READ
00CED8  2               ;________________________________________________________________________________________________________
00CED8  2               conrde:
00CED8  2  A9 02        	lda 	#02
00CEDA  2  85 32        	sta 	farfunct
00CEDC  2  4C 65 02     	jmp 	DO_FARCALL
00CEDF  2               
00CEDF  2               
00CEDF  2               ;__CONWRT________________________________________________________________________________________________
00CEDF  2               ;
00CEDF  2               ; 	PERFORM DOS/65 CONSOLE WRITE
00CEDF  2               ;________________________________________________________________________________________________________
00CEDF  2               conwrt:
00CEDF  2  48           	pha
00CEE0  2  A9 00        	lda 	#00
00CEE2  2  85 32        	sta 	farfunct
00CEE4  2  68           	pla
00CEE5  2  4C 65 02     	jmp 	DO_FARCALL
00CEE8  2               
00CEE8  2               prnwrt:
00CEE8  2  60           	rts			;printer
00CEE9  2               punwrt:
00CEE9  2  60           	rts			;punch output
00CEEA  2               rdrinp:
00CEEA  2  60           	rts			;reader input
00CEEB  2               rdtime:
00CEEB  2  60           	rts			;read clock
00CEEC  2               xlate:
00CEEC  2  60           	rts			;sector translate
00CEED  2               
00CEED  2               
00CEED  2               ;__OUTMSG________________________________________________________________________________________________
00CEED  2               ;
00CEED  2               ; 	WRITE A NULL TERMINATED STRING TO THE CONSOLE
00CEED  2               ;
00CEED  2               ;	A=POINTER LOW BYTE
00CEED  2               ;	Y=POINTER HIGH BYTE
00CEED  2               ;________________________________________________________________________________________________________
00CEED  2               outmsg:				;output message
00CEED  2  85 F0        	STA OUTMSG_W
00CEEF  2  84 F1        	STY OUTMSG_W+1
00CEF1  2  A0 00        	LDY #$00
00CEF3  2               OUTSTRLP:
00CEF3  2  B1 F0               	LDA (OUTMSG_W),Y 	; LOAD NEXT CHAR FROM STRING INTO ACC
00CEF5  2  C9 00               	CMP #$00		; IS NULL?
00CEF7  2  F0 07               	BEQ ENDOUTSTR		; YES, END PRINT OUT
00CEF9  2  20 DF CE            	JSR conwrt  		; PRINT CHAR IN ACC
00CEFC  2  C8                  	INY      		; Y=Y+1 (BUMP INDEX)
00CEFD  2  4C F3 CE            	JMP OUTSTRLP		; DO NEXT CHAR
00CF00  2               ENDOUTSTR:
00CF00  2  60                  	RTS			; RETURN
00CF01  2               
00CF01  2               ;___GET_DRIVE_DEVICE_____________________________________________________________________________________
00CF01  2               ;
00CF01  2               ;	GET SELECTED DEVICE TYPE AND UNIT, RETURN IN "A"
00CF01  2               ;
00CF01  2               ;________________________________________________________________________________________________________
00CF01  2               GET_DRIVE_DEVICE:
00CF01  2  DA           	PHX
00CF02  2  AD 13 03     	LDA	sekdsk			; GET DRIVE
00CF05  2  29 07        	AND 	#7			; ONLY FIRST 8 DEVICES SUPPORTED
00CF07  2  0A           	asl	a			; DOUBLE NUMBER FOR TABLE LOOKUP
00CF08  2  AA           	TAX 				; MOVE TO X REGISTER
00CF09  2  BD 14 03     	LDA 	dskcfg,X 		; GET device
00CF0C  2  FA           	PLX
00CF0D  2  60           	RTS
00CF0E  2               
00CF0E  2               ;___DSPL_DSK_CFG_________________________________________________________________________________________
00CF0E  2               ;
00CF0E  2               ;	DISPLAY THE DISK CONFIGURATION FOR THE USER
00CF0E  2               ;
00CF0E  2               ;________________________________________________________________________________________________________
00CF0E  2               DSPL_DSK_CFG:
00CF0E  2  20 00 CC     	JSR 	NEWLINE
00CF11  2  48 DA 5A A2  	PRTS "Disk Configuration:$"
00CF15  2  00 BD 2A CF  
00CF19  2  E8 C9 24 F0  
00CF3E  2  20 00 CC     	JSR 	NEWLINE
00CF41  2  A2 00        	ldx 	#0
00CF43  2               DSPL_DSK_CFG_1:
00CF43  2  48 DA 5A A2  	PRTS "    $"		; MAKE IT PRETTY :)
00CF47  2  00 BD 5C CF  
00CF4B  2  E8 C9 24 F0  
00CF61  2  8A           	TXA
00CF62  2  4A           	LSR	A
00CF63  2  18           	CLC
00CF64  2  69 41        	ADC 	#'A'
00CF66  2  20 DF CE     	JSR 	conwrt
00CF69  2  A9 3A        	LDA 	#':'
00CF6B  2  20 DF CE     	JSR 	conwrt
00CF6E  2  A9 3D        	LDA 	#'='
00CF70  2  20 DF CE     	JSR 	conwrt
00CF73  2  20 8B CF     	JSR 	prtdevice	; PRINT DEVICE NAME FROM TABLE (X)
00CF76  2  A9 3A        	LDA 	#':'
00CF78  2  20 DF CE     	JSR 	conwrt
00CF7B  2  E8           	INX				; WANT SECOND BYTE OF ENTRY
00CF7C  2  BD 14 03     	LDA 	dskcfg,x 		; GET SLICE
00CF7F  2  20 11 CC     	JSR 	PRTDEC 			; PRINT SLICE IN DECIMAL (A)
00CF82  2  E8           	INX
00CF83  2  20 00 CC     	JSR 	NEWLINE
00CF86  2  E0 10        	CPX 	#16
00CF88  2  D0 B9        	BNE 	DSPL_DSK_CFG_1
00CF8A  2  60           	RTS
00CF8B  2               
00CF8B  2               ; 	DEVICE TABLE:
00CF8B  2               ;	$00	MD
00CF8B  2               ;	$2x	FLOPPY
00CF8B  2               ;	$3x	IDE
00CF8B  2               prtdevice:
00CF8B  2  BD 14 03     	LDA 	dskcfg,X 		; GET DEVICE TYPE
00CF8E  2  48           	PHA
00CF8F  2  29 F0        	AND 	#$F0 			; FILTER OUT UNIT
00CF91  2  C9 00        	CMP 	#$00
00CF93  2  D0 1F        	BNE 	prtdevice1
00CF95  2  48 DA 5A A2  	PRTS "MD$"
00CF99  2  00 BD AE CF  
00CF9D  2  E8 C9 24 F0  
00CFB1  2  4C 3E D0     	jmp 	prtdevice_done
00CFB4  2               prtdevice1:
00CFB4  2  C9 10        	CMP 	#$10
00CFB6  2  D0 20        	BNE 	prtdevice2
00CFB8  2  48 DA 5A A2  	PRTS "UNK$"
00CFBC  2  00 BD D1 CF  
00CFC0  2  E8 C9 24 F0  
00CFD5  2  4C 3E D0     	jmp 	prtdevice_done
00CFD8  2               prtdevice2:
00CFD8  2  C9 20        	CMP 	#$20
00CFDA  2  D0 1F        	BNE 	prtdevice3
00CFDC  2  48 DA 5A A2  	PRTS "FD$"
00CFE0  2  00 BD F5 CF  
00CFE4  2  E8 C9 24 F0  
00CFF8  2  4C 3E D0     	jmp 	prtdevice_done
00CFFB  2               prtdevice3:
00CFFB  2  C9 30        	CMP 	#$30
00CFFD  2  D0 22        	BNE 	prtdevicex
00CFFF  2  48 DA 5A A2  	PRTS "PPIDE$"
00D003  2  00 BD 18 D0  
00D007  2  E8 C9 24 F0  
00D01E  2  4C 3E D0     	jmp 	prtdevice_done
00D021  2               prtdevicex:
00D021  2  48 DA 5A A2  	PRTS "UNK$"
00D025  2  00 BD 3A D0  
00D029  2  E8 C9 24 F0  
00D03E  2               prtdevice_done:
00D03E  2  68           	PLA
00D03F  2  29 0F        	AND 	#$0F 			; FILTER OUT DEVICE
00D041  2  20 11 CC     	JSR 	PRTDEC
00D044  2  60           	RTS
00D045  2               
00D045  2               	.INCLUDE "dospager.asm"
00D045  3               ;__pager_________________________________________________________________________________________________________________________
00D045  3               ;
00D045  3               ; 	Nhyodyne Memory page management code
00D045  3               ;
00D045  3               ;	Entry points:
00D045  3               ;		PAGER_INIT          - called during OS init
00D045  3               ;________________________________________________________________________________________________________________________________
00D045  3               ;
00D045  3               ; RAM BANK $0C is RAM area for Drivers
00D045  3               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
00D045  3               ; RAM BANK $0F is fixed bank $0000-$7FFF
00D045  3               ;
00D045  3               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
00D045  3               ;
00D045  3               ; ROM MEMORY PAGE CONFIGURATION LATCH CONTROL PORT
00D045  3               ;       A15 IS INVERTED FOR THE NYHODYNE 65C02 CPU . . .
00D045  3               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
00D045  3               ;	^ ^ ^ ^  ^ ^ ^ ^
00D045  3               ;	: : : :  : : : :--0 = A15 ROM ONLY ADDRESS LINE DEFAULT IS 0
00D045  3               ;	: : : :  : : :----0 = A16 ROM ONLY ADDRESS LINE DEFAULT IS 0
00D045  3               ;	: : : :  : :------0 = A17 ROM ONLY ADDRESS LINE DEFAULT IS 0
00D045  3               ;	: : : :  :--------0 = A18 ROM ONLY ADDRESS LINE DEFAULT IS 0
00D045  3               ;	: : : :-----------0 = A19 ROM ONLY ADDRESS LINE DEFAULT IS 0
00D045  3               ;	: : :-------------0 = A20 ROM ONLY ADDRESS LINE DEFAULT IS 0
00D045  3               ;	: :---------------0 = ROM BOOT OVERRIDE DEFAULT IS 0
00D045  3               ;	:-----------------0 = LOWER PAGE ROM SELECT (0=ROM, 1=NOTHING) DEFAULT IS 0
00D045  3               ;
00D045  3               ; RAM PAGE CONFIGURATION LATCH CONTROL PORT
00D045  3               ;
00D045  3               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
00D045  3               ;	^ ^ ^ ^  ^ ^ ^ ^
00D045  3               ;	: : : :  : : : :--0 = A15 RAM ONLY ADDRESS LINE DEFAULT IS 0
00D045  3               ;	: : : :  : : :----0 = A16 RAM ONLY ADDRESS LINE DEFAULT IS 0
00D045  3               ;	: : : :  : :------0 = A17 RAM ONLY ADDRESS LINE DEFAULT IS 0
00D045  3               ;	: : : :  :--------0 = A18 RAM ONLY ADDRESS LINE DEFAULT IS 0
00D045  3               ;	: : : :-----------0 = A19 RAM ONLY ADDRESS LINE DEFAULT IS 0
00D045  3               ;	: : :-------------0 = UNDEFINED DEFAULT IS 0
00D045  3               ;	: :---------------0 = RAM BOOT OVERRIDE DEFAULT IS 0
00D045  3               ;	:-----------------0 = LOWER PAGE RAM SELECT (0=NOTHING, 1=RAM) DEFAULT IS 0;
00D045  3               
00D045  3               
00D045  3               ;__PAGER_INIT___________________________________________________________________________________________
00D045  3               ;
00D045  3               ;  INIT -- Copy code into $0200-$02FF for controling banking and copying
00D045  3               ;____________________________________________________________________________________________________
00D045  3               PAGER_INIT:
00D045  3  A2 00                LDX     #$00
00D047  3               :
00D047  3  BD 53 D0             LDA     md_pagecode,X
00D04A  3  9D 00 02             STA     MD_PAGERA,X
00D04D  3  E8                   INX
00D04E  3  E0 00                CPX     #$00
00D050  3  D0 F5                BNE     :-
00D052  3  60                   RTS
00D053  3               
00D053  3               ;       X=Control Word
00D053  3               ;	7 6 5 4  3 2 1 0
00D053  3               ;	^ ^ ^ ^  ^ ^ ^ ^
00D053  3               ;       : : X X  X X X X    = UNUSED
00D053  3               ;	: :---------------0 = RAM=0, ROM=1
00D053  3               ;	:-----------------0 = Read=0, Write=1
00D053  3               ;       A= bank
00D053  3               ;       Y= page
00D053  3               ;
00D053  3               md_pagecode:
00D053  3  48                   PHA
00D054  3  84 15                STY     MD_PAGESE+1     ; setup copy from pointer
00D056  3  A0 00                LDY     #$00
00D058  3  84 14                STY     MD_PAGESE
00D05A  3  8A                   TXA
00D05B  3  29 80                AND     #%10000000
00D05D  3  C9 00                CMP     #$00
00D05F  3  D0 38                BNE     MD_PAGE_WRITE
00D061  3               ; PERFORM READ HERE
00D061  3  8A                   TXA
00D062  3  29 40                AND     #%01000000
00D064  3  C9 00                CMP     #$00
00D066  3  D0 0D                BNE     MD_PAGE_ROREAD
00D068  3               ; DO RAM READ
00D068  3  A9 80                LDA     #$80
00D06A  3  8D 7C 03             STA     MPCL_ROM
00D06D  3  68                   PLA
00D06E  3  09 80                ORA     #$80
00D070  3  8D 78 03             STA     MPCL_RAM
00D073  3  D0 0B                BNE     MD_PAGE_COPYFRM
00D075  3               MD_PAGE_ROREAD:
00D075  3  A9 00                LDA     #$00
00D077  3  8D 78 03             STA     MPCL_RAM
00D07A  3  68                   PLA
00D07B  3  29 7F                AND     #$7F
00D07D  3  8D 7C 03             STA     MPCL_ROM
00D080  3               MD_PAGE_COPYFRM:
00D080  3               ; DO THE COPY
00D080  3  A2 00                LDX     #$00
00D082  3               :
00D082  3  DA                   PHX
00D083  3  7A                   PLY
00D084  3  B1 14                LDA     (MD_PAGESE),Y
00D086  3  9D 00 04             STA     MD_PAGEBU,X
00D089  3  E8                   INX
00D08A  3  E0 00                CPX     #$00
00D08C  3  D0 F4                BNE     :-
00D08E  3  A9 80                LDA     #$80
00D090  3  8D 7C 03             STA     MPCL_ROM
00D093  3  A9 8E                LDA     #$8E
00D095  3  8D 78 03             STA     MPCL_RAM
00D098  3  60                   RTS
00D099  3               MD_PAGE_WRITE:
00D099  3  68                   PLA
00D09A  3  09 80                ORA     #%10000000
00D09C  3  8D 78 03             STA     MPCL_RAM
00D09F  3               ; DO THE COPY
00D09F  3  A2 00                LDX     #$00
00D0A1  3               :
00D0A1  3  DA                   PHX
00D0A2  3  7A                   PLY
00D0A3  3  BD 00 04             LDA     MD_PAGEBU,X
00D0A6  3  91 14                STA     (MD_PAGESE),Y
00D0A8  3  E8                   INX
00D0A9  3  E0 00                CPX     #$00
00D0AB  3  D0 F4                BNE     :-
00D0AD  3  A9 80                LDA     #$80
00D0AF  3  8D 7C 03             STA     MPCL_ROM
00D0B2  3  A9 8E                LDA     #$8E
00D0B4  3  8D 78 03             STA     MPCL_RAM
00D0B7  3  60                   RTS
00D0B8  3               md_pagecodeend:
00D0B8  3               farcall:
00D0B8  3  48                   PHA
00D0B9  3  A9 8C                LDA     #$8C
00D0BB  3  8D 78 03             STA     MPCL_RAM
00D0BE  3  EA                   nop
00D0BF  3  EA                   nop
00D0C0  3  68                   PLA
00D0C1  3  20 00 88             JSR     BANKED_DRIVER_DISPATCHER
00D0C4  3  48                   pha
00D0C5  3  A9 8E                LDA     #$8E
00D0C7  3  8D 78 03             STA     MPCL_RAM
00D0CA  3  68                   pla
00D0CB  3  60                   RTS
00D0CC  3               
00D0CC  2               ;------------------------------------------------------------------------------------
00D0CC  2               
00D0CC  2               DOS65DSKYINIT:
00D0CC  2  54 6E 5C 5E  	.BYTE 	$54,$6E,$5C,$5E,$6E,$54,$79,$40
00D0D0  2  6E 54 79 40  
00D0D4  2               
00D0D4  2               ;disk control blocks
00D0D4  2  7F 00        dcba:	.word	127		;max block number
00D0D6  2  40 00        	.word	64		;sectors per track
00D0D8  2  00 00        	.word	0		;number system tracks
00D0DA  2  01           	.byte	1		;block size = 2048
00D0DB  2  FF 00        	.word	255		;max directory number
00D0DD  2  49 D1        	.word	almpa		;address of map for a
00D0DF  2  00           	.byte	00		;do checksums
00D0E0  2  39 D9        	.word	ckmp		;checksum map
00D0E2  2  BF 00        dcbb:	.word	191		;max block number
00D0E4  2  40 00        	.word	64		;sectors per track
00D0E6  2  00 00        	.word	0		;number system tracks
00D0E8  2  01           	.byte	1		;block size = 2048
00D0E9  2  9B 00        	.word	155		;max directory number
00D0EB  2  47 D2        	.word	almpb		;address of map for b
00D0ED  2  00           	.byte	00		;do checksums
00D0EE  2  39 D9        	.word	ckmp		;checksum map
00D0F0  2  FF 07        dcbc:	.word	2047		;max block number
00D0F2  2  40 00        	.word	64		;sectors per track
00D0F4  2  10 00        	.word	16		;number system tracks
00D0F6  2  02           	.byte	2		;block size = 4096
00D0F7  2  FF 01        	.word	511		;max directory number
00D0F9  2  45 D3        	.word	almpc		;address of map for C
00D0FB  2  00           	.byte	0		;do checksums
00D0FC  2  39 D9        	.word	ckmp		;checksum map
00D0FE  2  FF 07        dcbd:	.word	2047		;max block number
00D100  2  40 00        	.word	64		;sectors per track
00D102  2  10 00        	.word	16		;number system tracks
00D104  2  02           	.byte	2		;block size = 4096
00D105  2  FF 01        	.word	511		;max directory number
00D107  2  43 D4        	.word	almpd		;address of map for d
00D109  2  00           	.byte	0		;do checksums
00D10A  2  39 D9        	.word	ckmp		;checksum map
00D10C  2  FF 07        dcbe:	.word	2047		;max block number
00D10E  2  40 00        	.word	64		;sectors per track
00D110  2  10 00        	.word	16		;number system tracks
00D112  2  02           	.byte	2		;block size = 4096
00D113  2  FF 01        	.word	511		;max directory number
00D115  2  41 D5        	.word	almpe		;address of map for e
00D117  2  00           	.byte	0		;do checksums
00D118  2  39 D9        	.word	ckmp		;checksum map
00D11A  2  FF 07        dcbf:	.word	2047		;max block number
00D11C  2  40 00        	.word	64		;sectors per track
00D11E  2  10 00        	.word	16		;number system tracks
00D120  2  02           	.byte	2		;block size = 4096
00D121  2  FF 01        	.word	511		;max directory number
00D123  2  3F D6        	.word	almpf		;address of map for f
00D125  2  00           	.byte	0		;do checksums
00D126  2  39 D9        	.word	ckmp		;checksum map
00D128  2  FF 07        dcbg:	.word	2047		;max block number
00D12A  2  40 00        	.word	64		;sectors per track
00D12C  2  10 00        	.word	16		;number system tracks
00D12E  2  02           	.byte	2		;block size = 4096
00D12F  2  FF 01        	.word	511		;max directory number
00D131  2  3D D7        	.word	almpg		;address of map for g
00D133  2  00           	.byte	0		;do checksums
00D134  2  39 D9        	.word	ckmp		;checksum map
00D136  2  FF 07        dcbh:	.word	2047		;max block number
00D138  2  40 00        	.word	64		;sectors per track
00D13A  2  10 00        	.word	16		;number system tracks
00D13C  2  02           	.byte	2		;block size = 4096
00D13D  2  FF 01        	.word	511		;max directory number
00D13F  2  3B D8        	.word	almph		;address of map for h
00D141  2  00           	.byte	0		;do checksums
00D142  2  39 D9        	.word	ckmp		;checksum map
00D144  2               
00D144  2               ;data area
00D144  2               
00D144  2  00           hstwrt:		.byte	0	;0=written,1=pending host write
00D145  2  00 00        debtmp:		.word 0		; DEBLOCK TEMP VAR
00D147  2  00           hstact:		.byte 0		;host active flag
00D148  2  00           unacnt:		.byte 0		;unalloc rec cnt
00D149  2               
00D149  2               
00D149  2               ;allocation maps
00D149  2  xx xx xx xx  almpa:		.res	254
00D14D  2  xx xx xx xx  
00D151  2  xx xx xx xx  
00D247  2  xx xx xx xx  almpb:		.res	254
00D24B  2  xx xx xx xx  
00D24F  2  xx xx xx xx  
00D345  2  xx xx xx xx  almpc:		.res	254
00D349  2  xx xx xx xx  
00D34D  2  xx xx xx xx  
00D443  2  xx xx xx xx  almpd:		.res	254
00D447  2  xx xx xx xx  
00D44B  2  xx xx xx xx  
00D541  2  xx xx xx xx  almpe:		.res	254
00D545  2  xx xx xx xx  
00D549  2  xx xx xx xx  
00D63F  2  xx xx xx xx  almpf:		.res	254
00D643  2  xx xx xx xx  
00D647  2  xx xx xx xx  
00D73D  2  xx xx xx xx  almpg:		.res	254
00D741  2  xx xx xx xx  
00D745  2  xx xx xx xx  
00D83B  2  xx xx xx xx  almph:		.res	254
00D83F  2  xx xx xx xx  
00D843  2  xx xx xx xx  
00D939  2               ;checksum maps - not used
00D939  2  xx xx xx xx  ckmp:		.res	128
00D93D  2  xx xx xx xx  
00D941  2  xx xx xx xx  
00D9B9  2               
00D9B9  2               dftdskcfg:
00D9B9  2  00 00        	.byte $00,$00		;  disk A: unit,slice  (invalid for floppy and RAM disks)
00D9BB  2  01 00        	.byte $01,$00		;  disk B: unit,slice  (invalid for floppy and RAM disks)
00D9BD  2  30 00        	.byte $30,$00		;  disk C: unit,slice
00D9BF  2  30 01        	.byte $30,$01		;  disk D: unit,slice
00D9C1  2  30 02        	.byte $30,$02		;  disk E: unit,slice
00D9C3  2  30 03        	.byte $30,$03		;  disk F: unit,slice
00D9C5  2  30 04        	.byte $30,$04		;  disk G: unit,slice
00D9C7  2  30 06        	.byte $30,$06		;  disk H: unit,slice
00D9C9  2               
00D9C9  1               
00D9C9  1               	.end
