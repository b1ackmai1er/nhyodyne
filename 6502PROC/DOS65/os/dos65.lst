ca65 V2.18 - Ubuntu 2.19-1
Main file   : dos65.asm
Current file: dos65.asm

000000r 1               ;sysgen
000000r 1               ;version 2.15-a
000000r 1               ;released:	30 november 1985 (2.10)
000000r 1               ;last revised:	2 may 1996 (2.11)
000000r 1               ;			eliminated word mode for 1024 blocks
000000r 1               ;			made extent a single byte
000000r 1               ;		3 may 1996 (2.12)
000000r 1               ;			added initial exm related code
000000r 1               ;		11 may 1996 (2.13)
000000r 1               ;			added use of exm in getblk
000000r 1               ;			added code to set exm & cexm1f
000000r 1               ;			corrected errors
000000r 1               ;		19 may 1996 (2.14)
000000r 1               ;			changed ccm ren to "to from" syntax
000000r 1               ;			allowed _ in file names
000000r 1               ;		13 march 2008 (2.15)
000000r 1               ;			reformatted for TASM & ASM210+
000000r 1               ;			eliminated dependence on "IBM" format
000000r 1               ;			  by reading first sector # using SIM+51
000000r 1               ;			  TRANSLATE code. If translate
000000r 1               ;			  does not have first physical sector in first
000000r 1               ;			  position this approach may not work.
000000r 1               ;			  SIM can also perform no translation at all.
000000r 1               ;			  Also assumes BOOT & SIM both know correct
000000r 1               ;			  starting sector for cold & warm boot. It
000000r 1               ;			  should work regardless of physical sector
000000r 1               ;			  size as long as existing SIM is configured
000000r 1               ;			  correctly for destination drive. BOOT
000000r 1               ;			  must correctly handle sectors > 128 bytes
000000r 1               ;			  as must WARM BOOT in SIM.
000000r 1               ;			  In any case BOOT and WARM BOOT must
000000r 1               ;			  read sectors in sequential order, i.e.,
000000r 1               ;			  no interleave.
000000r 1               ;this program contains the complete dos/65 operating
000000r 1               ;system except for the boot and sim.
000000r 1               ;when used by the system operator this program
000000r 1               ;provides the capability to construct a new
000000r 1               ;operating system including the users boot and sim.
000000r 1               ;the system is relocated to fit the memory size
000000r 1               ;specified by the user and is written onto
000000r 1               ;the system tracks of the specified drive.
000000r 1               ;improvements over version 2.0 include:
000000r 1               ;	use of "from to" syntax for ren
000000r 1               ;	addition of go command
000000r 1               ;	addition of load command
000000r 1               ;	ability to enter numbers as decimal or hex
000000r 1               ;	address parameter added to save
000000r 1               ;	error checking in sysgen (write)
000000r 1               ;	write type for deblocking added
000000r 1               ;	page zero 0 & 1 not used
000000r 1               ;	allow _ in file names
000000r 1               
000000r 1                       .INCLUDE "DOSDEFN.ASM"  ; base addresses and definitions
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               ;
000000r 2               ;	Nhyodyne dos/65 base addresses and definitions
000000r 2               ;
000000r 2               ;  DWERNER 04/24/2022 	Initial
000000r 2               ;________________________________________________________________________________________________________________________________
000000r 2               
000000r 2               ;base addresses and definitions
000000r 2               btejmp          = $0100         ; warm boot jump
000000r 2               pemjmp          = $0103         ; jump to pem
000000r 2               iostat          = $0106         ; i/o status
000000r 2               dflfcb          = $0107         ; default fcb
000000r 2               dflbuf          = $0128         ; default buffer
000000r 2               memmovr         = $0200         ; 0200-02ff subr to move data from ram/rom disks
000000r 2               MD_PAGERA       = $0200         ; PAGE DRIVER ADDRESS
000000r 2               
000000r 2               IO              = $0300         ; 0300-03FF Memory mapped IO
000000r 2               MPCL_ROM        = $037C         ; ROM MAPPER
000000r 2               MPCL_RAM        = $0378         ; RAM MAPPER
000000r 2               
000000r 2               MD_PAGEBU       = $0400         ; 0400-04FF PAGE BUFFER ADDRESS
000000r 2               MD_PAGESE       = pointr        ; PAGE SECTOR STORAGE
000000r 2               
000000r 2               ;
000000r 2               ; DRIVER WORKING STORAGE
000000r 2               ;
000000r 2               DSKY_BUF        = $0500         ; Eight Bytes DSKY display buffer
000000r 2               DSKY_BUFLEN     = 8             ;
000000r 2               DSKY_HEXBUF     = $0508         ; Four Bytes DSKY hex buffer
000000r 2               DSKY_HEXBUFLEN  = 4             ;
000000r 2               sektrk          = $050C         ; seek track number
000000r 2               seksec          = $050E         ; seek sector number
000000r 2               debcyll         = $0510         ; DEBLOCKED CYLINDER LSB
000000r 2               debcylm         = $0511         ; DEBLOCKED CYLINDER MSB
000000r 2               debsehd         = $0512         ; DEBLOCKED SECTOR AND HEAD (HS)
000000r 2               sekdsk          = $0513         ; seek disk number
000000r 2               dskcfg          = $0514         ; 16 bytes disk configuration table
000000r 2               DSKUNIT         = $0525         ; seek disk number
000000r 2               
000000r 2               
000000r 2               tea             = $800          ;tea start
000000r 2               
000000r 2               ;zero page for setup
000000r 2               trknum          = $02           ;current track
000000r 2               dcbadd          = $04           ;dcb address
000000r 2               nmsstr          = $06           ;number system tracks
000000r 2               nsectr          = $08           ;number sectors per track
000000r 2               ttlsec          = $0A           ;total sectors to write
000000r 2               trkcnt          = ttlsec
000000r 2               size            = $0B           ;ascii size
000000r 2               lokim           = $0D           ;low kim limit
000000r 2               hikim           = $0F           ;high kim limit
000000r 2               offset          = $11           ;relocation offset
000000r 2               kimcnt          = $13           ;kim counter
000000r 2               pointr          = $14           ;pointer
000000r 2               lengt           = $16           ;inst length
000000r 2               point           = $17           ;relocate pointer
000000r 2               adjust          = $19           ;relocate distance
000000r 2               kimpnt          = $1B           ;kim file index
000000r 2               savex           = $1C           ;save for x
000000r 2               savey           = $1D           ;save for y
000000r 2               number          = $1E           ;input pack buffer
000000r 2               dstdrv          = $20           ;destination drive
000000r 2               defalt          = $21           ;default drive
000000r 2               seccnt          = $22           ;sector count
000000r 2               secnum          = $24           ;sector number
000000r 2               curccm          = $26           ;start of current ccm
000000r 2               simlng          = $28           ;length of sim
000000r 2               room            = $2A           ;memory needed for sysgen
000000r 2               stksav          = $2C           ;save stack register
000000r 2               frstsc          = $2D           ;first sector number of disk
000000r 2               dskcfpc         = $2E           ;pointer to disk configuration table
000000r 2               cmdlnp          = $30           ;pointer to command line buffer
000000r 2               farfunct        = $32           ;function to call in driver area
000000r 2               farpointer      = $33           ;WORD POINTER to call in driver area
000000r 2               IRQVECTOR       = $35           ; VECTOR FOR USER IRQ RTN
000000r 2               NMIVECTOR       = $37           ; VECTOR FOR USER NMI RTN
000000r 2               zptemp          = $39
000000r 2               STACKA          = $3A           ; TEMP VAR FOR STACK MANIPULATION
000000r 2               lastzp          = $3B
000000r 2               ;pem constants on entry to write
000000r 2               wrall           = 0             ;write to allocated
000000r 2               wrdir           = 1             ;write to directory
000000r 2               wrual           = 2             ;write to unallocated
000000r 2               
000000r 2               ;page zero and system ram assignments
000000r 2               DEST            = $EC           ;pointer for OutMsg
000000r 2               SRC             = $EE           ;pointer for OutMsg
000000r 2               OUTMSG_W        = $F0           ;pointer for OutMsg
000000r 2               mvepnt          = $f2           ;host buffer location
000000r 2               dmaadr          = $f4           ;pointer for r/w
000000r 2               
000000r 2               ;fixed parameters
000000r 2               lf              = $a            ;linefeeed
000000r 2               cr              = $d            ;return
000000r 2               eof             = $1a           ;end of file
000000r 2               null            = 0             ;null
000000r 2               ctlc            = 3             ;abort
000000r 2               ctle            = 5             ;physical cr lf
000000r 2               ctli            = 9             ;tab character
000000r 2               ctlp            = $10           ;toggle printer
000000r 2               ctlr            = $12           ;repeat line
000000r 2               ctls            = $13           ;freeze
000000r 2               ctlx            = $18           ;cancel
000000r 2               semico          = $3b           ;semicolon
000000r 2               delete          = $08           ;delete character
000000r 2               numcmd          = 36            ;number commands
000000r 2               
000000r 2               BANKED_DRIVER_DISPATCHER=$8800  ; LOCATION OF DRIVER DISPATCHER
000000r 2               DEBUG           = 0             ; assemble with debug information on
000000r 2               
000000r 2               
000000r 2               USESERIAL       = 1             ; SET TO ONE SERIAL CONSOLE IO
000000r 2               USEFLOPPYA      = 0             ; SET TO ONE FOR FLOPPY = "A"
000000r 2               USEFLOPPYB      = 0             ; SET TO ONE FOR FLOPPY = "B"
000000r 2               USEIDEC         = 1             ; SET TO ONE FOR IDE HDD="C"
000000r 2               USEDSKY         = 0             ; SEND INFO TO DSKY
000000r 2               USEDSKYNG       = 1             ; SEND INFO TO DSKYNG
000000r 2               DSKY_KBD        = 1             ; USE DSKY KEYBOARD?
000000r 2               DEFDRV          = 2             ; SET TO DEFAULT DRIVE LETTER
000000r 2               USEDISKIOV1     = 0             ; Floppy and IDE card is  DISK IO V1
000000r 2               USEDISKIOV3     = 0             ; Floppy and IDE card is  DISK IO V3
000000r 2               
000000r 2               FLPA35          = 0             ; set to 1 if floppy a is A 3.5" 80 track drive (0= 5.25" 40 track drive)
000000r 2               FLPB35          = 0             ; set to 1 if floppy a is B 3.5" 80 track drive (0= 5.25" 40 track drive)
000000r 2               
000000r 2               DSKYOSC         = 1000000
000000r 2               USEROM          = 0
000000r 2               
000000r 1               
000000r 1               ; for Nhyodyne:
000000r 1               ; RAM BANK $0C is RAM area for Drivers
000000r 1               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
000000r 1               ; RAM BANK $0F is fixed bank $0000-$7FFF
000000r 1               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
000000r 1               
000000r 1               
000000r 1                       .SEGMENT "OS"
000000r 1                       .ORG    $D000
00D000  1                       .INCLUDE "ccmnhy.asm"
00D000  2               ;________________________________________________________________________________________________________________________________
00D000  2               ;
00D000  2               ;	Nhyodyne dos/65 dos/65 console command module (ccm)
00D000  2               ;
00D000  2               ;  DWERNER 12/20/2021 	ported to Nhyodyne
00D000  2               ;  DWERNER 12/30/2021   changed .COM files to .CO6 files to reduce confusion when
00D000  2               ;                       sharing CP/M file system images
00D000  2               ;  DWERNER 02/19/2022   Strip off Most significant bit of file name in dir to
00D000  2               ;			make filesystem compatible with ROMWBW
00D000  2               ;________________________________________________________________________________________________________________________________
00D000  2               
00D000  2               ;ccm unique definitions
00D000  2               nbuilt          = 7             ;number built in commands
00D000  2               ;main program
00D000  2               ; warm boot vector
00D000  2  4C C8 E5             JMP     boot
00D003  2  4C 6B 02             JMP     DO_FARCALL
00D006  2               ccm:
00D006  2  D8                   CLD                     ;set binary mode
00D007  2  48                   PHA                     ;save drive number
00D008  2  20 FF D3             JSR     rstdsk          ;initialize system
00D00B  2  68                   PLA                     ;restore drive num
00D00C  2  20 03 D4             JSR     slctds          ;select drive
00D00F  2  AD A8 E4             LDA     sysdef+6        ;get line length
00D012  2  4A                   LSR     a               ;divide
00D013  2  4A                   LSR     a               ;by
00D014  2  4A                   LSR     a               ;16
00D015  2  4A                   LSR     a               ;for dir
00D016  2  8D FA D7             STA     sixten          ;and save
00D019  2  AD 46 D7             LDA     cnslng          ;get buffer length
00D01C  2  D0 3C                BNE     mrecmd          ;if more handle it
00D01E  2               ccmlpe:
00D01E  2  A2 FF                LDX     #$ff            ;set
00D020  2  9A                   TXS                     ;stack
00D021  2  D8                   CLD                     ;set binary mode
00D022  2  A9 11                LDA     #17             ; SEND A XON
00D024  2  20 F3 D3             JSR     chrout          ; ----------
00D027  2  20 6C D4             JSR     hdrout          ;send header
00D02A  2  A9 3E                LDA     #'>'            ;then print
00D02C  2  20 F3 D3             JSR     chrout          ;prompt
00D02F  2  AD 8E D6             LDA     cnsbvc          ;point to start
00D032  2  AC 8F D6             LDY     cnsbvc+1        ;of buffer
00D035  2  20 F7 D3             JSR     rdebuf          ;do buffer read
00D038  2  A0 00                LDY     #0              ;clear index
00D03A  2  AE 46 D7             LDX     cnslng          ;get length
00D03D  2  F0 DF                BEQ     ccmlpe          ;loop if empty
00D03F  2               lwrupr:
00D03F  2  B9 47 D7             LDA     cnstxt,y        ;else get char
00D042  2  C9 61                CMP     #'a'            ;if less than a
00D044  2  90 09                BCC     nxtchg          ;skip convert
00D046  2  C9 7B                CMP     #'z'+1          ;if over z
00D048  2  B0 05                BCS     nxtchg          ;skip convert
00D04A  2  29 5F                AND     #%01011111      ;else convert
00D04C  2  99 47 D7             STA     cnstxt,y        ;put back in buffer
00D04F  2               nxtchg:
00D04F  2  C8                   INY                     ;bump index
00D050  2  CA                   DEX                     ;count down
00D051  2  D0 EC                BNE     lwrupr          ;loop if more
00D053  2  8A                   TXA                     ;set a to zero
00D054  2  99 47 D7             STA     cnstxt,y        ;insert stopper
00D057  2  8D EA D7             STA     cnbfpt          ;initialize pointer
00D05A  2               mrecmd:
00D05A  2  20 A7 D5             JSR     stdflb          ;set default buffer
00D05D  2  20 2E D4             JSR     intdsk          ;get drive number
00D060  2  8D EB D7             STA     dfldsk          ;store as default
00D063  2  20 A8 D4             JSR     prslin          ;parse command
00D066  2  D0 64                BNE     cmderr          ;error if afn
00D068  2  AD EC D7             LDA     tmpdsk          ;get temporary
00D06B  2  F0 04                BEQ     nodrch          ;if zero ok
00D06D  2  A9 15                LDA     #nbuilt*3       ;else set and
00D06F  2  D0 2E                BNE     dotrns          ;do transient
00D071  2               nodrch:
00D071  2  A9 00                LDA     #0              ;clear
00D073  2  AA                   TAX                     ;table index
00D074  2  8D F0 D7             STA     ccmcount        ;and count
00D077  2               tsnxfn:
00D077  2  A0 01                LDY     #1              ;set fcb index
00D079  2               tsnxch:
00D079  2  BD 20 D7             LDA     fnctbl,x        ;get table entry
00D07C  2  F0 1A                BEQ     gotcmd          ;if zero got it
00D07E  2  D9 C6 D7             CMP     fcbone,y        ;else test
00D081  2  D0 04                BNE     nocmpr          ;no good if not =
00D083  2  E8                   INX                     ;bump
00D084  2  C8                   INY                     ;pointers
00D085  2  D0 F2                BNE     tsnxch          ;and loop
00D087  2               nocmpr:
00D087  2  E8                   INX                     ;go to end
00D088  2  BD 20 D7             LDA     fnctbl,x        ;of table
00D08B  2  D0 FA                BNE     nocmpr          ;entry
00D08D  2  E8                   INX                     ;point to next
00D08E  2  EE F0 D7             INC     ccmcount        ;bump count
00D091  2  AD F0 D7             LDA     ccmcount        ;and if not
00D094  2  C9 07                CMP     #nbuilt         ;limit then
00D096  2  D0 DF                BNE     tsnxfn          ;try next
00D098  2               gotcmd:
00D098  2  AD F0 D7             LDA     ccmcount        ;get count
00D09B  2  0A                   ASL     a               ;multiply by two
00D09C  2  6D F0 D7             ADC     ccmcount        ;then add for x3
00D09F  2               dotrns:
00D09F  2  AA                   TAX                     ;use as index
00D0A0  2  E8                   INX                     ;bump to pass jmp
00D0A1  2  BD 99 D6             LDA     xqfntb,x        ;to get
00D0A4  2  BC 9A D6             LDY     xqfntb+1,x      ;entry address
00D0A7  2  8D EE D7             STA     vector          ;then set
00D0AA  2  8C EF D7             STY     vector+1        ;vector
00D0AD  2  AD 92 D6             LDA     extcvc+1        ;save
00D0B0  2  48                   PHA                     ;return
00D0B1  2  AD 91 D6             LDA     extcvc          ;address
00D0B4  2  48                   PHA                     ;on stack
00D0B5  2  6C EE D7             JMP     (vector)        ;execute
00D0B8  2               extcmd:
00D0B8  2  20 37 D4             JSR     rstddr          ;restore default
00D0BB  2               extwod:
00D0BB  2  20 A8 D4             JSR     prslin          ;parse more
00D0BE  2  AD C7 D7             LDA     fcbone+1        ;if first
00D0C1  2  38                   SEC                     ;character
00D0C2  2  E9 20                SBC     #' '            ;not a space
00D0C4  2  0D EC D7             ORA     tmpdsk          ;or if temporary
00D0C7  2  D0 03                BNE     cmderr          ;then an error
00D0C9  2  4C 1E D0             JMP     ccmlpe          ;else loop
00D0CC  2               ;command error syntax handler
00D0CC  2               cmderr:
00D0CC  2  20 E4 D3             JSR     ccrlf           ;do a cr lf
00D0CF  2  AC F1 D7             LDY     curpnt          ;get command pointer
00D0D2  2               cmerlp:
00D0D2  2  B9 47 D7             LDA     cnstxt,y        ;get char
00D0D5  2  F0 0A                BEQ     cmerex          ;if null then done
00D0D7  2  C9 20                CMP     #' '            ;if space
00D0D9  2  F0 06                BEQ     cmerex          ;then done
00D0DB  2  20 75 D4             JSR     cotsxy          ;output with save
00D0DE  2  C8                   INY                     ;point to next
00D0DF  2  D0 F1                BNE     cmerlp          ;and loop
00D0E1  2               cmerex:
00D0E1  2  A9 3F                LDA     #'?'            ;send a
00D0E3  2  20 F3 D3             JSR     chrout          ;question mark
00D0E6  2  4C 1E D0             JMP     ccmlpe          ;and start over
00D0E9  2               ;execute dir command
00D0E9  2               ; dir <afn>
00D0E9  2               dir:
00D0E9  2  20 A8 D4             JSR     prslin          ;find object file
00D0EC  2  20 AE D5             JSR     clrslt          ;clear auto and select
00D0EF  2  A9 20                LDA     #' '            ;if name
00D0F1  2  CD C7 D7             CMP     fcbone+1        ;and
00D0F4  2  D0 0F                BNE     findfr          ;type are
00D0F6  2  CD CF D7             CMP     fcbone+9        ;not empty
00D0F9  2  D0 0A                BNE     findfr          ;then use it
00D0FB  2  A9 3F                LDA     #'?'            ;else
00D0FD  2  A0 0B                LDY     #11             ;fill
00D0FF  2               fillqu:
00D0FF  2  99 C6 D7             STA     fcbone,y        ;fcb
00D102  2  88                   DEY                     ;with
00D103  2  D0 FA                BNE     fillqu          ;question marks
00D105  2               findfr:
00D105  2  20 62 D4             JSR     srchf1          ;search for first match
00D108  2  30 58                BMI     notfnd          ;error if none
00D10A  2               fnddir:
00D10A  2  AD FA D7             LDA     sixten          ;set across
00D10D  2  8D F9 D7             STA     across          ;to four
00D110  2  20 E4 D3             JSR     ccrlf           ;do a crlf
00D113  2               dirl:
00D113  2  20 6F D4             JSR     hdr             ;do header
00D116  2  A9 3A                LDA     #':'            ;then a
00D118  2  20 F3 D3             JSR     chrout          ;colon
00D11B  2  AD F2 D7             LDA     diradd          ;get number
00D11E  2  0A                   ASL     a               ;and
00D11F  2  0A                   ASL     a               ;multiply
00D120  2  0A                   ASL     a               ;by
00D121  2  0A                   ASL     a               ;thirty two
00D122  2  0A                   ASL     a               ;then
00D123  2  29 60                AND     #%01100000      ;mask out insignificant
00D125  2  A8                   TAY                     ;make a pointer
00D126  2  C8                   INY                     ;and bump
00D127  2  A2 01                LDX     #1              ;set counter
00D129  2               nmelpe:
00D129  2  B9 28 01             LDA     dflbuf,y        ;get name
00D12C  2  29 7F                AND     #$7F            ;mask out read only bit
00D12E  2  20 75 D4             JSR     cotsxy          ;else send to console
00D131  2               noname:
00D131  2  C8                   INY                     ;bump index
00D132  2  E8                   INX                     ;and count
00D133  2  E0 0C                CPX     #12             ;if count is 12
00D135  2  F0 0C                BEQ     endnme          ;then done
00D137  2  E0 09                CPX     #9              ;or if not 9
00D139  2  D0 EE                BNE     nmelpe          ;then loop
00D13B  2  A9 2E                LDA     #'.'            ;else send
00D13D  2  20 75 D4             JSR     cotsxy          ;a period
00D140  2  4C 29 D1             JMP     nmelpe          ;and loop
00D143  2               endnme:
00D143  2  20 FB D3             JSR     chkcst          ;check console status
00D146  2  D0 19                BNE     extdir          ;if key down quit
00D148  2  20 9A D4             JSR     setone          ;else point to fcb
00D14B  2  20 13 D4             JSR     srchnx          ;else search for next
00D14E  2  8D F2 D7             STA     diradd          ;save number
00D151  2  30 0E                BMI     extdir          ;quit if not found
00D153  2  CE F9 D7             DEC     across          ;drop count
00D156  2  F0 B2                BEQ     fnddir          ;new line if 0
00D158  2  20 F1 D3             JSR     spcout          ;send
00D15B  2  20 F1 D3             JSR     spcout          ;two spaces
00D15E  2  4C 13 D1             JMP     dirl            ;and stay
00D161  2               extdir:
00D161  2  60                   RTS                     ;else done
00D162  2               ;not found error handler
00D162  2               notfnd:
00D162  2  A0 34                LDY     #ntfnms         ;point to message
00D164  2  4C C3 D5             JMP     sndmsg          ;send and exit
00D167  2               ;execute ren command
00D167  2               ; ren <ufn> <ufn>
00D167  2               ;where first ufn is from name and second is to name
00D167  2               ren:
00D167  2  20 A8 D4             JSR     prslin          ;get old name
00D16A  2  D0 57                BNE     renerr          ;error if afn
00D16C  2  20 A1 D4             JSR     tmpold          ;save drive
00D16F  2  20 AE D5             JSR     clrslt          ;clear auto and select
00D172  2  20 62 D4             JSR     srchf1          ;if file does not exist
00D175  2  30 4F                BMI     fntfnd          ;then an error
00D177  2  20 E3 D5             JSR     frssec          ;move name to second half
00D17A  2  AC EA D7             LDY     cnbfpt          ;get pointer
00D17D  2  B9 47 D7             LDA     cnstxt,y        ;and then char
00D180  2  C9 20                CMP     #' '            ;if not a space
00D182  2  D0 3C                BNE     rensyn          ;then error
00D184  2  20 A8 D4             JSR     prslin          ;get new name
00D187  2  D0 37                BNE     rensyn          ;error if afn
00D189  2  AD EC D7             LDA     tmpdsk          ;get new drive
00D18C  2  F0 12                BEQ     nonwdr          ;if zero ok
00D18E  2  CD F6 D7             CMP     oldtmp          ;compare to old
00D191  2  F0 0D                BEQ     nonwdr          ;ok if same
00D193  2  38                   SEC                     ;drop for default check
00D194  2  E9 01                SBC     #1
00D196  2  CD EB D7             CMP     dfldsk          ;if not default
00D199  2  D0 25                BNE     rensyn          ;is error
00D19B  2  AD F6 D7             LDA     oldtmp          ;and then if from not
00D19E  2  D0 20                BNE     rensyn          ;default is error
00D1A0  2               nonwdr:
00D1A0  2  AD F6 D7             LDA     oldtmp          ;else get old
00D1A3  2  8D EC D7             STA     tmpdsk          ;and save
00D1A6  2  A9 00                LDA     #0              ;clear
00D1A8  2  8D D6 D7             STA     fcbone+16
00D1AB  2  20 AE D5             JSR     clrslt          ;reselect
00D1AE  2  20 62 D4             JSR     srchf1          ;search for old
00D1B1  2  10 09                BPL     filexs          ;error if found
00D1B3  2  20 E3 D5             JSR     frssec          ;swap names
00D1B6  2  20 9A D4             JSR     setone          ;point to fcb
00D1B9  2  4C 2A D4             JMP     renmfl          ;and do it
00D1BC  2               ;ren file exists error handler
00D1BC  2               filexs:
00D1BC  2  A0 3E                LDY     #flexms         ;point to
00D1BE  2  D0 08                BNE     remsg           ;and send
00D1C0  2               ;ren syntax error handler
00D1C0  2               rensyn:
00D1C0  2  20 37 D4             JSR     rstddr          ;restore default
00D1C3  2               renerr:
00D1C3  2  4C CC D0             JMP     cmderr          ;do error
00D1C6  2               ;ren source file not found error handler
00D1C6  2               fntfnd:
00D1C6  2  A0 34                LDY     #ntfnms         ;point to
00D1C8  2               remsg:
00D1C8  2  4C C3 D5             JMP     sndmsg          ;and send
00D1CB  2               ;execute save command
00D1CB  2               ; save <length> <drive:>ufn (<address>)
00D1CB  2               save:
00D1CB  2  A9 00                LDA     #<tea           ;set start address to tea start
00D1CD  2  A0 08                LDY     #>tea
00D1CF  2  8D 00 D8             STA     sadr
00D1D2  2  8C 01 D8             STY     sadr+1
00D1D5  2  20 08 D6             JSR     bldnum          ;calculate length
00D1D8  2  D0 7A                BNE     saverr          ;error if > 255 pages
00D1DA  2  8D F5 D7             STA     length          ;else save low
00D1DD  2  0D F5 D7             ORA     length          ;test for zero length
00D1E0  2  F0 72                BEQ     saverr          ;error if is
00D1E2  2  20 A8 D4             JSR     prslin          ;get file name
00D1E5  2  D0 6D                BNE     saverr          ;error if afn
00D1E7  2  20 E3 D5             JSR     frssec          ;move name to second half
00D1EA  2  20 A1 D4             JSR     tmpold          ;save drive
00D1ED  2  20 08 D6             JSR     bldnum          ;it is so find value
00D1F0  2  AE C7 D7             LDX     fcbone+1        ;see if there
00D1F3  2  E0 20                CPX     #' '
00D1F5  2  F0 0A                BEQ     nosadr          ;it is not
00D1F7  2  8D 00 D8             STA     sadr            ;and set address
00D1FA  2  8C 01 D8             STY     sadr+1
00D1FD  2  C0 02                CPY     #2              ;make sure is high enough
00D1FF  2  90 53                BCC     saverr          ;error if not
00D201  2               nosadr:
00D201  2  20 F6 D5             JSR     secfrs          ;move name back
00D204  2  20 AE D5             JSR     clrslt          ;clear auto and select
00D207  2  20 17 D4             JSR     dlt1            ;delete
00D20A  2  20 9A D4             JSR     setone          ;then create
00D20D  2  20 26 D4             JSR     cratfl          ;new file
00D210  2  30 45                BMI     noroom          ;say no room if error
00D212  2  20 4D D4             JSR     open1           ;open file
00D215  2  30 44                BMI     noopen          ;if error
00D217  2  18                   CLC                     ;now find end page
00D218  2  AD 01 D8             LDA     sadr+1
00D21B  2  6D F5 D7             ADC     length
00D21E  2  8D F5 D7             STA     length
00D221  2  AD 00 D8             LDA     sadr            ;get start address
00D224  2  AC 01 D8             LDY     sadr+1
00D227  2               wrtmre:
00D227  2  8D F7 D7             STA     dskbuf          ;set
00D22A  2  8C F8 D7             STY     dskbuf+1        ;buffer
00D22D  2  20 C8 E2             JSR     mv128           ;move data to buffer
00D230  2  20 9A D4             JSR     setone          ;point to fcb
00D233  2  20 22 D4             JSR     wrrcrd          ;write record
00D236  2  D0 27                BNE     wrterr          ;exit if error
00D238  2  18                   CLC                     ;else
00D239  2  AD F7 D7             LDA     dskbuf          ;get old
00D23C  2  AC F8 D7             LDY     dskbuf+1        ;buffer
00D23F  2  69 80                ADC     #128            ;add 128
00D241  2  90 03                BCC     donotc          ;if carry
00D243  2  C8                   INY                     ;bump upper
00D244  2  F0 05                BEQ     clssav          ;done if page zero
00D246  2               donotc:
00D246  2  CC F5 D7             CPY     length          ;loop if upper
00D249  2  D0 DC                BNE     wrtmre          ;not at limit
00D24B  2               clssav:
00D24B  2  20 9A D4             JSR     setone          ;else point to
00D24E  2  20 0B D4             JSR     clsefl          ;and close file
00D251  2  30 10                BMI     cantcl          ;say so if error
00D253  2               extera:
00D253  2  60                   RTS
00D254  2               ;save error handler
00D254  2               saverr:
00D254  2  4C CC D0             JMP     cmderr          ;do error
00D257  2               ;save no room error handler
00D257  2               noroom:
00D257  2  A0 01                LDY     #nospms         ;point to
00D259  2  D0 0A                BNE     semsg           ;and send
00D25B  2               ;save can not open error handler
00D25B  2               noopen:
00D25B  2  A0 55                LDY     #cnnoms         ;point to
00D25D  2  D0 06                BNE     semsg           ;and send
00D25F  2               ;save write error handler
00D25F  2               wrterr:
00D25F  2  A0 62                LDY     #wrerms         ;point
00D261  2  D0 02                BNE     semsg           ;to and send
00D263  2               ;save can not close error
00D263  2               cantcl:
00D263  2  A0 0A                LDY     #ntclms         ;point to
00D265  2               semsg:
00D265  2  4C C3 D5             JMP     sndmsg          ;and send
00D268  2               ;execute era command
00D268  2               ; era <afn>
00D268  2               era:
00D268  2  20 A8 D4             JSR     prslin          ;get file name
00D26B  2  C9 0B                CMP     #11             ;if not all ?
00D26D  2  D0 13                BNE     nteral          ;then skip verify
00D26F  2  A0 18                LDY     #alflms         ;else point to
00D271  2  20 C3 D5             JSR     sndmsg          ;and send all files
00D274  2  20 ED D3             JSR     cnsrde          ;get an input
00D277  2  48                   PHA                     ;and save
00D278  2  20 E4 D3             JSR     ccrlf           ;do a cr lf
00D27B  2  68                   PLA                     ;restore char
00D27C  2  29 5F                AND     #$5f            ;convert to upper case
00D27E  2  C9 59                CMP     #'Y'            ;if not y
00D280  2  D0 D1                BNE     extera          ;then quit
00D282  2               nteral:
00D282  2  20 AE D5             JSR     clrslt          ;clear auto and select
00D285  2  4C 17 D4             JMP     dlt1            ;delete first
00D288  2               ;execute type command
00D288  2               ; type d:ufn
00D288  2               type:
00D288  2  20 A8 D4             JSR     prslin          ;get file
00D28B  2  D0 30                BNE     typafn          ;error if afn
00D28D  2  20 4A D4             JSR     casdo1          ;clear - select - open file 1
00D290  2  30 32                BMI     notype          ;error if not found
00D292  2  20 E4 D3             JSR     ccrlf           ;else do cr lf
00D295  2               typmre:
00D295  2  20 5C D4             JSR     read1           ;read record
00D298  2  F0 04                BEQ     okread          ;if ok continue
00D29A  2  10 20                BPL     exttyp          ;exit if just end
00D29C  2  30 22                BMI     typerr          ;else error
00D29E  2               okread:
00D29E  2  A2 00                LDX     #0              ;clear index
00D2A0  2               typlpe:
00D2A0  2  BD 28 01             LDA     dflbuf,x        ;get char
00D2A3  2  C9 1A                CMP     #eof            ;if eof
00D2A5  2  F0 15                BEQ     exttyp          ;then exit
00D2A7  2  20 75 D4             JSR     cotsxy          ;else send
00D2AA  2  20 FB D3             JSR     chkcst          ;if key down
00D2AD  2  D0 08                BNE     exttok          ;then exit
00D2AF  2  AE F3 D7             LDX     savx            ;else get index
00D2B2  2  E8                   INX                     ;bump it
00D2B3  2  10 EB                BPL     typlpe          ;and loop if < 128
00D2B5  2  30 DE                BMI     typmre          ;else read more
00D2B7  2               exttok:
00D2B7  2  A2 06                LDX     #6              ;clear console
00D2B9  2  20 03 01             JSR     pemjmp          ;with no echo
00D2BC  2               exttyp:
00D2BC  2  60                   RTS
00D2BD  2               ;type syntax error handler
00D2BD  2               typafn:
00D2BD  2  4C CC D0             JMP     cmderr          ;error return
00D2C0  2               ;type read error handler
00D2C0  2               typerr:
00D2C0  2  A0 29                LDY     #rderms         ;point to
00D2C2  2  D0 02                BNE     temsg           ;and send
00D2C4  2               ;type not found error handler
00D2C4  2               notype:
00D2C4  2  A0 34                LDY     #ntfnms         ;point to
00D2C6  2               temsg:
00D2C6  2  4C C3 D5             JMP     sndmsg          ;and send
00D2C9  2               ;execute load command
00D2C9  2               ; load <ufn> (<address>)
00D2C9  2               load:
00D2C9  2  20 D8 D5             JSR     setddb          ;set load start to tea start
00D2CC  2  20 A8 D4             JSR     prslin          ;build fcb
00D2CF  2  D0 EC                BNE     typafn          ;error if afn
00D2D1  2  20 E3 D5             JSR     frssec          ;save in second half
00D2D4  2  20 A1 D4             JSR     tmpold          ;save file
00D2D7  2  20 08 D6             JSR     bldnum          ;find start address
00D2DA  2  AE C7 D7             LDX     fcbone+1        ;see if number
00D2DD  2  E0 20                CPX     #' '
00D2DF  2  F0 03                BEQ     usedfl          ;if none use default
00D2E1  2  20 DC D5             JSR     setdb           ;and set
00D2E4  2               usedfl:
00D2E4  2  20 F6 D5             JSR     secfrs          ;move name back
00D2E7  2  20 4A D4             JSR     casdo1          ;clear - select - open file 1
00D2EA  2  30 D8                BMI     notype          ;exit if not found
00D2EC  2  AD F7 D7             LDA     dskbuf          ;get load start
00D2EF  2  AC F8 D7             LDY     dskbuf+1
00D2F2  2               lcmdlp:
00D2F2  2  20 32 D4             JSR     setbuf          ;set as disk buffer
00D2F5  2  20 5C D4             JSR     read1           ;read record
00D2F8  2  D0 06                BNE     loadnd          ;done if not zero
00D2FA  2  20 B5 E2             JSR     adjdb           ;bump address
00D2FD  2  4C F2 D2             JMP     lcmdlp          ;and loop
00D300  2               loadnd:
00D300  2  30 BE                BMI     typerr          ;if error say so
00D302  2  4C A7 D5             JMP     stdflb          ;back to default buffer
00D305  2               ;execute go command
00D305  2               ; go (<address>)
00D305  2               go:
00D305  2  20 08 D6             JSR     bldnum          ;get address
00D308  2  AE C7 D7             LDX     fcbone+1        ;get first char
00D30B  2  E0 20                CPX     #' '            ;see if nothing
00D30D  2  F0 03                BEQ     nolnum          ;nothing so use tea
00D30F  2  4C 79 D3             JMP     godoit          ;then execute
00D312  2               nolnum:
00D312  2  4C 75 D3             JMP     gotea
00D315  2               ;execute trns (transient) command
00D315  2               ; <ufn> (<fn>) (<fn>)
00D315  2               trns:
00D315  2  AD C7 D7             LDA     fcbone+1        ;get first char
00D318  2  C9 20                CMP     #' '            ;if not space
00D31A  2  D0 11                BNE     chktyp          ;check type
00D31C  2  AD EC D7             LDA     tmpdsk          ;else test temp
00D31F  2  F0 09                BEQ     skpdrv          ;if none skip
00D321  2  38                   SEC                     ;else convert
00D322  2  E9 01                SBC     #1              ;to number
00D324  2  8D EB D7             STA     dfldsk          ;set default
00D327  2  20 03 D4             JSR     slctds          ;and select
00D32A  2               skpdrv:
00D32A  2  4C BB D0             JMP     extwod          ;return
00D32D  2               chktyp:
00D32D  2  AD CF D7             LDA     fcbone+9        ;get type
00D330  2  C9 20                CMP     #' '            ;if space
00D332  2  F0 03                BEQ     typemp          ;then ok
00D334  2  4C DC D3             JMP     trnerr          ;else error
00D337  2               typemp:
00D337  2  A2 02                LDX     #2              ;make
00D339  2               setcom:
00D339  2  BD E7 D7             LDA     typcom,x        ;type
00D33C  2  9D CF D7             STA     fcbone+9,x      ;com
00D33F  2  CA                   DEX                     ;then
00D340  2  10 F7                BPL     setcom          ;continue
00D342  2  20 4A D4             JSR     casdo1          ;clear - select - open file one
00D345  2  10 03                BPL     gottrn          ;jump if ok
00D347  2  4C D9 D3             JMP     topner          ;else do error
00D34A  2               gottrn:
00D34A  2  20 D8 D5             JSR     setddb          ;set start to tea
00D34D  2               nxtrcr:
00D34D  2  20 32 D4             JSR     setbuf          ;set address
00D350  2  20 5C D4             JSR     read1           ;read fcb 1
00D353  2  D0 1E                BNE     endlde          ;branch if error or eof
00D355  2  20 B5 E2             JSR     adjdb           ;adjust address up by 128
00D358  2  CD 94 D6             CMP     ccmvc           ;if new low
00D35B  2  90 07                BCC     tryhig          ;ok try high
00D35D  2  CC 95 D6             CPY     ccmvc+1         ;else if high
00D360  2  90 EB                BCC     nxtrcr          ;ok do more
00D362  2  B0 07                BCS     chklnd          ;else check for end
00D364  2               tryhig:
00D364  2  CC 95 D6             CPY     ccmvc+1         ;if high less
00D367  2  90 E4                BCC     nxtrcr          ;then ok
00D369  2  F0 E2                BEQ     nxtrcr          ;or ok if same
00D36B  2               chklnd:
00D36B  2  20 A7 D5             JSR     stdflb          ;set buffer to default
00D36E  2  20 5C D4             JSR     read1           ;read (should be eof)
00D371  2  F0 6C                BEQ     tlderr          ;error if more
00D373  2               endlde:
00D373  2  30 6A                BMI     tlderr          ;do error
00D375  2               gotea:
00D375  2  A9 00                LDA     #<tea           ;set go address to tea start
00D377  2  A0 08                LDY     #>tea
00D379  2               godoit:
00D379  2  8D CE D3             STA     do+1            ;set to ay
00D37C  2  8C CF D3             STY     do+2
00D37F  2  20 37 D4             JSR     rstddr          ;else restore default
00D382  2  20 A8 D4             JSR     prslin          ;parse file
00D385  2  AD EC D7             LDA     tmpdsk          ;set auto
00D388  2  8D C6 D7             STA     fcbone          ;select position
00D38B  2  A2 10                LDX     #16             ;do a second
00D38D  2  20 AA D4             JSR     prsmre          ;fcb if there
00D390  2  AD EC D7             LDA     tmpdsk          ;set auto select
00D393  2  8D D6 D7             STA     fcbone+16       ;again
00D396  2  A0 00                LDY     #0              ;clear record
00D398  2  8C E6 D7             STY     fcbone+32       ;counter
00D39B  2  A2 20                LDX     #32             ;move
00D39D  2               movfcb:
00D39D  2  BD C6 D7             LDA     fcbone,x        ;all
00D3A0  2  9D 07 01             STA     dflfcb,x        ;to
00D3A3  2  CA                   DEX                     ;default
00D3A4  2  10 F7                BPL     movfcb          ;fcb
00D3A6  2  E8                   INX                     ;set x to zero
00D3A7  2               tstbuf:
00D3A7  2  B9 47 D7             LDA     cnstxt,y        ;get char
00D3AA  2  F0 07                BEQ     isnull          ;if null jump
00D3AC  2  C9 20                CMP     #' '            ;or if space
00D3AE  2  F0 03                BEQ     isnull          ;jump
00D3B0  2  C8                   INY                     ;else bump pointer
00D3B1  2  D0 F4                BNE     tstbuf          ;and loop
00D3B3  2               isnull:
00D3B3  2  A9 00                LDA     #0              ;clear
00D3B5  2  8D 28 01             STA     dflbuf          ;count
00D3B8  2               movbuf:
00D3B8  2  B9 47 D7             LDA     cnstxt,y        ;get char
00D3BB  2  9D 29 01             STA     dflbuf+1,x      ;and move
00D3BE  2  F0 07                BEQ     fillov          ;exit if null
00D3C0  2  E8                   INX                     ;increment
00D3C1  2  C8                   INY                     ;counters
00D3C2  2  EE 28 01             INC     dflbuf          ;and length
00D3C5  2  D0 F1                BNE     movbuf          ;and loop
00D3C7  2               fillov:
00D3C7  2  20 E4 D3             JSR     ccrlf           ;do a cr lf
00D3CA  2  20 A7 D5             JSR     stdflb          ;set default
00D3CD  2               do:
00D3CD  2  20 00 08             JSR     tea             ;execute
00D3D0  2  AD EB D7             LDA     dfldsk          ;get default
00D3D3  2  20 03 D4             JSR     slctds          ;and set
00D3D6  2  4C 1E D0             JMP     ccmlpe          ;then loop
00D3D9  2               ;trns syntax error handler
00D3D9  2               topner:
00D3D9  2  20 37 D4             JSR     rstddr          ;restore default
00D3DC  2               trnerr:
00D3DC  2  4C CC D0             JMP     cmderr          ;do error
00D3DF  2               ;trns load error
00D3DF  2               tlderr:
00D3DF  2  A0 4A                LDY     #lderms         ;point to
00D3E1  2  4C C3 D5             JMP     sndmsg          ;and send
00D3E4  2               ;carriage return and linefeed
00D3E4  2               ccrlf:
00D3E4  2  A9 0D                LDA     #cr             ;get a cr
00D3E6  2  20 F3 D3             JSR     chrout          ;send
00D3E9  2  A9 0A                LDA     #lf             ;get a lf
00D3EB  2  D0 06                BNE     chrout          ;and send
00D3ED  2               ;pem entry routines
00D3ED  2               cnsrde:
00D3ED  2  A2 01                LDX     #1              ;console read
00D3EF  2  D0 43                BNE     pemgo
00D3F1  2               spcout:
00D3F1  2  A9 20                LDA     #' '            ;output space
00D3F3  2               chrout:
00D3F3  2  A2 02                LDX     #2              ;console output
00D3F5  2  D0 3D                BNE     pemgo
00D3F7  2               rdebuf:
00D3F7  2  A2 0A                LDX     #10             ;buffered input
00D3F9  2  D0 39                BNE     pemgo
00D3FB  2               chkcst:
00D3FB  2  A2 0B                LDX     #11             ;check console
00D3FD  2  D0 35                BNE     pemgo
00D3FF  2               rstdsk:
00D3FF  2  A2 0D                LDX     #13             ;initialize system
00D401  2  D0 31                BNE     pemgo
00D403  2               slctds:
00D403  2  A2 0E                LDX     #14             ;select drive
00D405  2  D0 2D                BNE     pemgo
00D407  2               openfl:
00D407  2  A2 0F                LDX     #15             ;open file
00D409  2  D0 29                BNE     pemgo
00D40B  2               clsefl:
00D40B  2  A2 10                LDX     #16             ;close file
00D40D  2  D0 25                BNE     pemgo
00D40F  2               srchfr:
00D40F  2  A2 11                LDX     #17             ;first match
00D411  2  D0 21                BNE     pemgo
00D413  2               srchnx:
00D413  2  A2 12                LDX     #18             ;next match
00D415  2  D0 1D                BNE     pemgo
00D417  2               ;delete file one
00D417  2               dlt1:
00D417  2  20 9A D4             JSR     setone          ;point to fcb
00D41A  2               dltfil:
00D41A  2  A2 13                LDX     #19             ;delete file
00D41C  2  D0 16                BNE     pemgo
00D41E  2               rdrcrd:
00D41E  2  A2 14                LDX     #20             ;read record
00D420  2  D0 12                BNE     pemgo
00D422  2               wrrcrd:
00D422  2  A2 15                LDX     #21             ;write record
00D424  2  D0 0E                BNE     pemgo
00D426  2               cratfl:
00D426  2  A2 16                LDX     #22             ;create file
00D428  2  D0 0A                BNE     pemgo
00D42A  2               renmfl:
00D42A  2  A2 17                LDX     #23             ;rename file
00D42C  2  D0 06                BNE     pemgo
00D42E  2               intdsk:
00D42E  2  A2 19                LDX     #25             ;read drive num
00D430  2  D0 02                BNE     pemgo
00D432  2               setbuf:
00D432  2  A2 1A                LDX     #26             ;set buffer add
00D434  2               pemgo:
00D434  2  4C 03 01             JMP     pemjmp          ;go to pem
00D437  2               ;restore default drive
00D437  2               rstddr:
00D437  2  AD EC D7             LDA     tmpdsk          ;if temp drive
00D43A  2  F0 1F                BEQ     extddr          ;zero then exit
00D43C  2  38                   SEC                     ;else
00D43D  2  E9 01                SBC     #1              ;subtract one
00D43F  2  CD EB D7             CMP     dfldsk          ;compare to default
00D442  2  F0 17                BEQ     extddr          ;exit if same
00D444  2               seldfl:
00D444  2  AD EB D7             LDA     dfldsk          ;else get default
00D447  2  4C 03 D4             JMP     slctds          ;select
00D44A  2               ;clear auto - select disk - open file at fcbone
00D44A  2               casdo1:
00D44A  2  20 AE D5             JSR     clrslt          ;clear auto and select
00D44D  2               ;open file one
00D44D  2               ; returns:n=1 if not found
00D44D  2               open1:
00D44D  2  A9 00                LDA     #0              ;clear
00D44F  2  8D E6 D7             STA     fcbone+32       ;record number
00D452  2  20 9A D4             JSR     setone          ;point to fcb
00D455  2  20 07 D4             JSR     openfl          ;open it
00D458  2  8D F2 D7             STA     diradd          ;save number
00D45B  2               extddr:
00D45B  2  60                   RTS
00D45C  2               ;read file one
00D45C  2               read1:
00D45C  2  20 9A D4             JSR     setone          ;point to fcb
00D45F  2  4C 1E D4             JMP     rdrcrd          ;do read
00D462  2               ;search for first file one
00D462  2               ; returns:n=1 if not found
00D462  2               srchf1:
00D462  2  20 9A D4             JSR     setone          ;point to fcb
00D465  2  20 0F D4             JSR     srchfr          ;search for first
00D468  2  8D F2 D7             STA     diradd          ;save number
00D46B  2  60                   RTS
00D46C  2               ;header output
00D46C  2               hdrout:
00D46C  2  20 E4 D3             JSR     ccrlf           ;do cr lf
00D46F  2               hdr:
00D46F  2  20 2E D4             JSR     intdsk          ;get drive number
00D472  2  18                   CLC                     ;make
00D473  2  69 41                ADC     #'A'            ;a letter
00D475  2               ;output with save of x and y
00D475  2               ;this routine calls the pem resident routine
00D475  2               ;tstchr to see if a char is a printing char.
00D475  2               ;if it is then c=1 upon return from tstchr.
00D475  2               cotsxy:
00D475  2  8E F3 D7             STX     savx            ;save x
00D478  2  8C F4 D7             STY     savy            ;and y
00D47B  2  20 BF E0             JSR     tstchr          ;see if printing
00D47E  2  B0 10                BCS     isprnt          ;jump if is
00D480  2  48                   PHA                     ;else save
00D481  2  AD A6 E4             LDA     sysdef+4        ;get invert
00D484  2  20 F3 D3             JSR     chrout          ;send it
00D487  2  68                   PLA                     ;get char
00D488  2  09 40                ORA     #'@'            ;make printing
00D48A  2  20 F3 D3             JSR     chrout          ;send it
00D48D  2  AD A5 E4             LDA     sysdef+3        ;get normal
00D490  2               isprnt:
00D490  2  20 F3 D3             JSR     chrout          ;do output
00D493  2  AC F4 D7             LDY     savy            ;get y
00D496  2  AE F3 D7             LDX     savx            ;and x
00D499  2  60                   RTS
00D49A  2               ;set up fcb one pointer
00D49A  2               setone:
00D49A  2  AD 97 D6             LDA     fcb1vc          ;low
00D49D  2  AC 98 D6             LDY     fcb1vc+1        ;and high
00D4A0  2  60                   RTS
00D4A1  2               ;save tmpdsk in oldtmp
00D4A1  2               tmpold:
00D4A1  2  AD EC D7             LDA     tmpdsk
00D4A4  2  8D F6 D7             STA     oldtmp
00D4A7  2  60                   RTS
00D4A8  2               ;parse command line
00D4A8  2               prslin:
00D4A8  2  A2 00                LDX     #0              ;clear index
00D4AA  2               prsmre:
00D4AA  2  8A                   TXA                     ;save
00D4AB  2  48                   PHA                     ;index
00D4AC  2  A9 00                LDA     #0              ;clear temp
00D4AE  2  8D EC D7             STA     tmpdsk          ;drive flag
00D4B1  2  AC EA D7             LDY     cnbfpt          ;get buffer pointer
00D4B4  2  20 75 D5             JSR     skpspc          ;find first non-space
00D4B7  2  8C F1 D7             STY     curpnt          ;save index
00D4BA  2  F0 0D                BEQ     nulchr          ;jump if null
00D4BC  2  29 0F                AND     #%00001111      ;else look at 4 lsbs
00D4BE  2  48                   PHA                     ;and save
00D4BF  2  C8                   INY                     ;point to next char
00D4C0  2  B9 47 D7             LDA     cnstxt,y        ;and get it
00D4C3  2  C9 3A                CMP     #':'            ;if a colon
00D4C5  2  F0 0A                BEQ     drvinp          ;jump and set drive
00D4C7  2  68                   PLA                     ;else clear stack
00D4C8  2  88                   DEY                     ;backup index
00D4C9  2               nulchr:
00D4C9  2  AD EB D7             LDA     dfldsk          ;set automatic
00D4CC  2  9D C6 D7             STA     fcbone,x        ;to default
00D4CF  2  10 08                BPL     trynme          ;then parse name
00D4D1  2               drvinp:
00D4D1  2  68                   PLA                     ;get number
00D4D2  2  8D EC D7             STA     tmpdsk          ;set temp flag
00D4D5  2  9D C6 D7             STA     fcbone,x        ;and fcb
00D4D8  2  C8                   INY                     ;point past colon
00D4D9  2               trynme:
00D4D9  2  A9 08                LDA     #8              ;set name count
00D4DB  2  8D F0 D7             STA     ccmcount        ;to eight
00D4DE  2               tstnme:
00D4DE  2  20 82 D5             JSR     tstlgl          ;test for illegal
00D4E1  2  F0 1D                BEQ     flnmsp          ;if illegal jump
00D4E3  2  E8                   INX                     ;bump pointer
00D4E4  2  C9 2A                CMP     #'*'            ;if not *
00D4E6  2  D0 07                BNE     notafn          ;skip ? fill
00D4E8  2  A9 3F                LDA     #'?'            ;get a ?
00D4EA  2  9D C6 D7             STA     fcbone,x        ;store
00D4ED  2  D0 04                BNE     nxtout          ;and jump
00D4EF  2               notafn:
00D4EF  2  9D C6 D7             STA     fcbone,x        ;store char
00D4F2  2  C8                   INY                     ;bump source
00D4F3  2               nxtout:
00D4F3  2  CE F0 D7             DEC     ccmcount        ;drop counter down
00D4F6  2  D0 E6                BNE     tstnme          ;and loop
00D4F8  2               skpmre:
00D4F8  2  20 82 D5             JSR     tstlgl          ;if illegal
00D4FB  2  F0 11                BEQ     trytyp          ;try type
00D4FD  2  C8                   INY                     ;else bump index
00D4FE  2  D0 F8                BNE     skpmre          ;and loop
00D500  2               flnmsp:
00D500  2  E8                   INX                     ;next position
00D501  2  A9 20                LDA     #' '            ;get a space
00D503  2  9D C6 D7             STA     fcbone,x        ;store
00D506  2  CE F0 D7             DEC     ccmcount        ;count down
00D509  2  D0 F5                BNE     flnmsp          ;and loop
00D50B  2  B9 47 D7             LDA     cnstxt,y        ;get char again
00D50E  2               trytyp:
00D50E  2  48                   PHA                     ;save char
00D50F  2  A9 03                LDA     #3              ;set count
00D511  2  8D F0 D7             STA     ccmcount        ;to three
00D514  2  68                   PLA                     ;get char
00D515  2  C9 2E                CMP     #'.'            ;if not .
00D517  2  D0 23                BNE     fltysp          ;then fill spaces
00D519  2  C8                   INY                     ;else bump source
00D51A  2               tsttyp:
00D51A  2  20 82 D5             JSR     tstlgl          ;if not legal
00D51D  2  F0 1D                BEQ     fltysp          ;then fill spaces
00D51F  2  E8                   INX                     ;else bump index
00D520  2  C9 2A                CMP     #'*'            ;if not *
00D522  2  D0 07                BNE     notaft          ;then skip fill
00D524  2  A9 3F                LDA     #'?'            ;else get ?
00D526  2  9D C6 D7             STA     fcbone,x        ;move to fcb
00D529  2  D0 04                BNE     mrtyfl          ;and loop
00D52B  2               notaft:
00D52B  2  9D C6 D7             STA     fcbone,x        ;move char to fcb
00D52E  2  C8                   INY                     ;bump source
00D52F  2               mrtyfl:
00D52F  2  CE F0 D7             DEC     ccmcount        ;count down
00D532  2  D0 E6                BNE     tsttyp          ;and loop
00D534  2               nttype:
00D534  2  20 82 D5             JSR     tstlgl          ;if illegal
00D537  2  F0 0E                BEQ     filnul          ;fill out nulls
00D539  2  C8                   INY                     ;else bump source
00D53A  2  D0 F8                BNE     nttype          ;and loop
00D53C  2               fltysp:
00D53C  2  E8                   INX                     ;bump fcb pointer
00D53D  2  A9 20                LDA     #' '            ;get space
00D53F  2  9D C6 D7             STA     fcbone,x        ;put in fcb
00D542  2  CE F0 D7             DEC     ccmcount        ;count down
00D545  2  D0 F5                BNE     fltysp          ;and continue
00D547  2               filnul:
00D547  2  A9 03                LDA     #3              ;clear
00D549  2  8D F0 D7             STA     ccmcount        ;three
00D54C  2               mrnlty:
00D54C  2  E8                   INX                     ;bump fcb pointer
00D54D  2  A9 00                LDA     #0              ;get a zero
00D54F  2  9D C6 D7             STA     fcbone,x        ;move to fcb
00D552  2  CE F0 D7             DEC     ccmcount        ;count down
00D555  2  D0 F5                BNE     mrnlty          ;loop until done
00D557  2  8C EA D7             STY     cnbfpt          ;update start pointer
00D55A  2  A9 00                LDA     #0              ;clear
00D55C  2  8D F0 D7             STA     ccmcount        ;count
00D55F  2  68                   PLA                     ;restore stack
00D560  2  A8                   TAY                     ;move to index
00D561  2  A2 0B                LDX     #11             ;counter to 11
00D563  2               tstqus:
00D563  2  C8                   INY                     ;point to
00D564  2  B9 C6 D7             LDA     fcbone,y        ;and get char
00D567  2  C9 3F                CMP     #'?'            ;if not a ?
00D569  2  D0 03                BNE     nxtqus          ;then jump
00D56B  2  EE F0 D7             INC     ccmcount        ;else bump count
00D56E  2               nxtqus:
00D56E  2  CA                   DEX                     ;loop until
00D56F  2  D0 F2                BNE     tstqus          ;11 tested
00D571  2  AD F0 D7             LDA     ccmcount        ;get count
00D574  2  60                   RTS                     ;and return
00D575  2               ;skip space
00D575  2               skpspc:
00D575  2  B9 47 D7             LDA     cnstxt,y        ;get char
00D578  2  F0 07                BEQ     extskp          ;jump if null
00D57A  2  C9 20                CMP     #' '            ;if not space
00D57C  2  D0 03                BNE     extskp          ;then exit
00D57E  2  C8                   INY                     ;else go to next
00D57F  2  D0 F4                BNE     skpspc          ;and test
00D581  2               extskp:
00D581  2  60                   RTS
00D582  2               ;test legal
00D582  2               tstlgl:
00D582  2  B9 47 D7             LDA     cnstxt,y        ;get char
00D585  2  F0 1C                BEQ     extlgl
00D587  2  C9 20                CMP     #' '            ;if space
00D589  2  90 19                BCC     badinp          ;ok - less is error
00D58B  2  F0 16                BEQ     extlgl
00D58D  2  C9 3D                CMP     #'='
00D58F  2  F0 12                BEQ     extlgl
00D591  2  C9 2E                CMP     #'.'
00D593  2  F0 0E                BEQ     extlgl
00D595  2  C9 3A                CMP     #':'
00D597  2  F0 0A                BEQ     extlgl
00D599  2  C9 3B                CMP     #semico
00D59B  2  F0 06                BEQ     extlgl
00D59D  2  C9 3C                CMP     #'<'
00D59F  2  F0 02                BEQ     extlgl
00D5A1  2  C9 3E                CMP     #'>'
00D5A3  2               extlgl:
00D5A3  2  60                   RTS
00D5A4  2               badinp:
00D5A4  2  4C CC D0             JMP     cmderr
00D5A7  2               ;set default buffer address
00D5A7  2               stdflb:
00D5A7  2  A9 28                LDA     #<dflbuf        ;point to
00D5A9  2  A0 01                LDY     #>dflbuf        ;location
00D5AB  2  4C 32 D4             JMP     setbuf          ;and set
00D5AE  2               ;clear automatic and select
00D5AE  2               clrslt:
00D5AE  2  A9 00                LDA     #0              ;clear auto
00D5B0  2  8D C6 D7             STA     fcbone          ;select
00D5B3  2               slttmp:
00D5B3  2  AD EC D7             LDA     tmpdsk          ;get temp
00D5B6  2  F0 1F                BEQ     extsnd          ;if zero exit
00D5B8  2  38                   SEC                     ;else subtract
00D5B9  2  E9 01                SBC     #1              ;one
00D5BB  2  CD EB D7             CMP     dfldsk          ;if same as default
00D5BE  2  F0 17                BEQ     extsnd          ;then quit
00D5C0  2  4C 03 D4             JMP     slctds          ;else set
00D5C3  2               ;send message
00D5C3  2               sndmsg:
00D5C3  2  8C F4 D7             STY     savy            ;save index
00D5C6  2  20 E4 D3             JSR     ccrlf           ;do cr and lf
00D5C9  2  AC F4 D7             LDY     savy            ;get index
00D5CC  2               lpesnd:
00D5CC  2  B9 B2 D6             LDA     msgtbl,y        ;get char
00D5CF  2  F0 06                BEQ     extsnd          ;if null quit
00D5D1  2  20 75 D4             JSR     cotsxy          ;else send
00D5D4  2  C8                   INY                     ;point to next
00D5D5  2  D0 F5                BNE     lpesnd          ;and loop
00D5D7  2               extsnd:
00D5D7  2  60                   RTS
00D5D8  2               ;set load start address
00D5D8  2               setddb:
00D5D8  2  A9 00                LDA     #<tea           ;to tea start
00D5DA  2  A0 08                LDY     #>tea
00D5DC  2               setdb:
00D5DC  2  8D F7 D7             STA     dskbuf          ;to ay
00D5DF  2  8C F8 D7             STY     dskbuf+1
00D5E2  2  60                   RTS
00D5E3  2               ;move first part of fcb to second half
00D5E3  2               ;and move second part to first part.
00D5E3  2               ;only ren depends upon this routine to actually
00D5E3  2               ;swap fcb halves.
00D5E3  2               ;alters:a,x,p
00D5E3  2               ;returns:x=$ff
00D5E3  2               frssec:
00D5E3  2  A2 0F                LDX     #15             ;set index to last
00D5E5  2               frsclp:
00D5E5  2  BD C6 D7             LDA     fcbone,x        ;get byte
00D5E8  2  BC D6 D7             LDY     fcbone+16,x
00D5EB  2  9D D6 D7             STA     fcbone+16,x     ;move it
00D5EE  2  98                   TYA
00D5EF  2  9D C6 D7             STA     fcbone,x
00D5F2  2  CA                   DEX
00D5F3  2  10 F0                BPL     frsclp          ;until 16 moved
00D5F5  2  60                   RTS
00D5F6  2               ;move second part of fcb to first half
00D5F6  2               ;restore tmpdsk from save location
00D5F6  2               ;alters:a,x,p
00D5F6  2               ;returns:x=$ff
00D5F6  2               secfrs:
00D5F6  2  A2 0F                LDX     #15             ;set index to last
00D5F8  2               scfrlp:
00D5F8  2  BD D6 D7             LDA     fcbone+16,x     ;get byte
00D5FB  2  9D C6 D7             STA     fcbone,x        ;move it
00D5FE  2  CA                   DEX
00D5FF  2  10 F7                BPL     scfrlp          ;loop until done
00D601  2  AD F6 D7             LDA     oldtmp          ;get old flag
00D604  2  8D EC D7             STA     tmpdsk          ;and set
00D607  2  60                   RTS
00D608  2               ;build a number from command line and leave in num
00D608  2               ;will handle either decimal (e.g., 578) or hexadecimal (e.g., $3f2)
00D608  2               ;move parse index past number
00D608  2               ;modifies:all
00D608  2               ;returns:a,y set to low and high of number
00D608  2               ;	 flags set according to y which is high part of number
00D608  2               bldnum:
00D608  2  A9 09                LDA     #9              ;preset to decimal
00D60A  2  8D FB D7             STA     moduls
00D60D  2  20 A8 D4             JSR     prslin          ;put in fcb
00D610  2  AD EC D7             LDA     tmpdsk          ;if temp
00D613  2  D0 67                BNE     numerr          ;is error
00D615  2  8D FC D7             STA     num             ;else clear num
00D618  2  8D FD D7             STA     num+1
00D61B  2  A8                   TAY                     ;and index
00D61C  2  B9 C7 D7             LDA     fcbone+1,y      ;get first char
00D61F  2  C9 24                CMP     #'$'            ;see if hex signal
00D621  2  D0 06                BNE     bnumlp          ;skip if not
00D623  2  A9 0F                LDA     #15             ;set for modulus
00D625  2  8D FB D7             STA     moduls
00D628  2  C8                   INY                     ;bump past $
00D629  2               bnumlp:
00D629  2  C8                   INY                     ;next char
00D62A  2  B9 C6 D7             LDA     fcbone,y        ;get digit
00D62D  2  C9 20                CMP     #' '            ;see if space
00D62F  2  F0 4E                BEQ     endnlp          ;done if is
00D631  2  20 9F E2             JSR     tstdec          ;see if decimal
00D634  2  90 0E                BCC     usedig          ;use if is
00D636  2  20 A9 E2             JSR     tsthex          ;see if hex
00D639  2  B0 41                BCS     numerr          ;error if not
00D63B  2  E9 06                SBC     #6              ;remove offset
00D63D  2  A2 0F                LDX     #15             ;test for hex modulus
00D63F  2  EC FB D7             CPX     moduls
00D642  2  D0 38                BNE     numerr          ;error if not
00D644  2               usedig:
00D644  2  29 0F                AND     #%00001111      ;eliminate ascii bias
00D646  2  48                   PHA                     ;save result
00D647  2  AD FC D7             LDA     num             ;move number to temp
00D64A  2  8D FE D7             STA     tnum
00D64D  2  AD FD D7             LDA     num+1
00D650  2  8D FF D7             STA     tnum+1
00D653  2  AE FB D7             LDX     moduls          ;get modulus
00D656  2  18                   CLC
00D657  2               addlpe:
00D657  2  AD FC D7             LDA     num             ;add number to itself
00D65A  2  6D FE D7             ADC     tnum
00D65D  2  8D FC D7             STA     num
00D660  2  AD FD D7             LDA     num+1           ;modulus times
00D663  2  6D FF D7             ADC     tnum+1
00D666  2  8D FD D7             STA     num+1
00D669  2  B0 11                BCS     numerr          ;error if carry out
00D66B  2  CA                   DEX
00D66C  2  D0 E9                BNE     addlpe          ;loop if more
00D66E  2  68                   PLA                     ;get input back
00D66F  2  6D FC D7             ADC     num             ;add in
00D672  2  8D FC D7             STA     num
00D675  2  90 B2                BCC     bnumlp          ;loop if no carry
00D677  2  EE FD D7             INC     num+1           ;else bump high
00D67A  2  D0 AD                BNE     bnumlp          ;and loop for more
00D67C  2               ;error in bldnum - handle and quit
00D67C  2               numerr:
00D67C  2  4C CC D0             JMP     cmderr          ;do general error
00D67F  2               ;end of use of name part - check type
00D67F  2               endnlp:
00D67F  2  AD CF D7             LDA     fcbone+9        ;get first
00D682  2  C9 20                CMP     #' '            ;see if space
00D684  2  D0 F6                BNE     numerr          ;error if not
00D686  2  AD FC D7             LDA     num             ;return with result
00D689  2  AC FD D7             LDY     num+1
00D68C  2  60                   RTS
00D68D  2               ;relocatable vectors
00D68D  2  4C                   .BYTE   $4c
00D68E  2               cnsbvc:
00D68E  2  45 D7                .WORD   cnsbuf
00D690  2  4C                   .BYTE   $4c
00D691  2               extcvc:
00D691  2  B7 D0                .WORD   extcmd-1
00D693  2  4C                   .BYTE   $4c
00D694  2               ccmvc:
00D694  2  06 D0                .WORD   ccm
00D696  2  4C                   .BYTE   $4c
00D697  2               fcb1vc:
00D697  2  C6 D7                .WORD   fcbone
00D699  2               ;function entry vector
00D699  2               xqfntb:
00D699  2  4C E9 D0             JMP     dir
00D69C  2  4C CB D1             JMP     save
00D69F  2  4C 68 D2             JMP     era
00D6A2  2  4C 88 D2             JMP     type
00D6A5  2  4C 67 D1             JMP     ren
00D6A8  2  4C 05 D3             JMP     go
00D6AB  2  4C C9 D2             JMP     load
00D6AE  2  4C 15 D3             JMP     trns
00D6B1  2               ;terminator for relocation
00D6B1  2  FF                   .BYTE   $ff
00D6B2  2               ;messages
00D6B2  2               msgtbl:
00D6B2  2  00                   .BYTE   0
00D6B3  2               nospms          = *-msgtbl
00D6B3  2  4E 4F 20 53          .BYTE   "NO SPACE",0
00D6B7  2  50 41 43 45  
00D6BB  2  00           
00D6BC  2               ntclms          = *-msgtbl
00D6BC  2  43 41 4E 20          .BYTE   "CAN NOT CLOSE",0
00D6C0  2  4E 4F 54 20  
00D6C4  2  43 4C 4F 53  
00D6CA  2               alflms          = *-msgtbl
00D6CA  2  41 4C 4C 20          .BYTE   "ALL FILES (Y/N)?",0
00D6CE  2  46 49 4C 45  
00D6D2  2  53 20 28 59  
00D6DB  2               rderms          = *-msgtbl
00D6DB  2  52 45 41 44          .BYTE   "READ ERROR",0
00D6DF  2  20 45 52 52  
00D6E3  2  4F 52 00     
00D6E6  2               ntfnms          = *-msgtbl
00D6E6  2  4E 4F 54 20          .BYTE   "NOT FOUND",0
00D6EA  2  46 4F 55 4E  
00D6EE  2  44 00        
00D6F0  2               flexms          = *-msgtbl
00D6F0  2  46 49 4C 45          .BYTE   "FILE EXISTS",0
00D6F4  2  20 45 58 49  
00D6F8  2  53 54 53 00  
00D6FC  2               lderms          = *-msgtbl
00D6FC  2  4C 4F 41 44          .BYTE   "LOAD ERROR",0
00D700  2  20 45 52 52  
00D704  2  4F 52 00     
00D707  2               cnnoms          = *-msgtbl
00D707  2  43 41 4E 20          .BYTE   "CAN NOT OPEN",0
00D70B  2  4E 4F 54 20  
00D70F  2  4F 50 45 4E  
00D714  2               wrerms          = *-msgtbl
00D714  2  57 52 49 54          .BYTE   "WRITE ERROR",0
00D718  2  45 20 45 52  
00D71C  2  52 4F 52 00  
00D720  2               ;function name table
00D720  2               fnctbl:
00D720  2  44 49 52 20          .BYTE   "DIR ",0
00D724  2  00           
00D725  2  53 41 56 45          .BYTE   "SAVE ",0
00D729  2  20 00        
00D72B  2  45 52 41 20          .BYTE   "ERA ",0
00D72F  2  00           
00D730  2  54 59 50 45          .BYTE   "TYPE ",0
00D734  2  20 00        
00D736  2  52 45 4E 20          .BYTE   "REN ",0
00D73A  2  00           
00D73B  2  47 4F 20 00          .BYTE   "GO ",0
00D73F  2  4C 4F 41 44          .BYTE   "LOAD ",0
00D743  2  20 00        
00D745  2               ;input buffer
00D745  2               cnsbuf:
00D745  2               cnsmax:
00D745  2  7F                   .BYTE   127
00D746  2               cnslng:
00D746  2  00                   .BYTE   0
00D747  2               cnstxt:
00D747  2  xx xx xx xx          .RES    127
00D74B  2  xx xx xx xx  
00D74F  2  xx xx xx xx  
00D7C6  2               ;fcb one
00D7C6  2               fcbone:
00D7C6  2  xx xx xx xx          .RES    33
00D7CA  2  xx xx xx xx  
00D7CE  2  xx xx xx xx  
00D7E7  2               ;com type field
00D7E7  2               typcom:
00D7E7  2  43 4F 36             .BYTE   "CO6"
00D7EA  2               ;variable storage
00D7EA  2               cnbfpt:
00D7EA  2  00                   .BYTE   0               ;buffer index
00D7EB  2               dfldsk:
00D7EB  2  00                   .BYTE   0               ;default drive
00D7EC  2               tmpdsk:
00D7EC  2  00                   .BYTE   0               ;temporary dvive
00D7ED  2               ;align vector on word boundary
00D7ED  2  xx                   .ALIGN  2
00D7EE  2               vector:
00D7EE  2  00 00                .WORD   0               ;execution vector
00D7F0  2               ccmcount:
00D7F0  2  00                   .BYTE   0               ;counter
00D7F1  2               curpnt:
00D7F1  2  00                   .BYTE   0               ;input parse start
00D7F2  2               diradd:
00D7F2  2  00                   .BYTE   0               ;directory number
00D7F3  2               savx:
00D7F3  2  00                   .BYTE   0               ;save x location
00D7F4  2               savy:
00D7F4  2  00                   .BYTE   0               ;save y location
00D7F5  2               length:
00D7F5  2  00                   .BYTE   0               ;number tages to save
00D7F6  2               oldtmp:
00D7F6  2  00                   .BYTE   0               ;temp drive in ren
00D7F7  2               dskbuf:
00D7F7  2  00 08                .WORD   tea             ;disk buffer start
00D7F9  2               across:
00D7F9  2  00                   .BYTE   0               ;dir count on line
00D7FA  2               sixten:
00D7FA  2  00                   .BYTE   0               ;line length div 16
00D7FB  2               moduls:
00D7FB  2  09                   .BYTE   9               ;modulus-1 for number input
00D7FC  2               num:
00D7FC  2  00 00                .WORD   0               ;input number
00D7FE  2               tnum:
00D7FE  2  00 00                .WORD   0               ;temp in bldnum
00D800  2               sadr:
00D800  2  00 08                .WORD   tea             ;save start address
00D802  2               
00D802  1                       .INCLUDE "pemnhy.asm"
00D802  2               ;________________________________________________________________________________________________________________________________
00D802  2               ;
00D802  2               ;	Nhyodyne dos/65 primitive execution module (pem)
00D802  2               ;
00D802  2               ;  DWERNER 02/19/2022   Strip off Most significant bit of file name in dir to
00D802  2               ;			make filesystem compatible with ROMWBW
00D802  2               ;________________________________________________________________________________________________________________________________
00D802  2               
00D802  2               ;zero page data storage
00D802  2               addinp          = $02           ;initialized to a,y
00D802  2               bufadd          = $04           ;buffer address
00D802  2               alcpnt          = $06           ;allocation map pointer
00D802  2               chkpnt          = $08           ;checksum map pointer
00D802  2               numvar          = 8             ;eight bytes
00D802  2               ;main program
00D802  2               ; input:x=command,a=value,a&y=address
00D802  2               ; returns:a=value,a&y=address
00D802  2               ; alters:all
00D802  2               pem:
00D802  2  D8                   CLD                     ;set binary mode
00D803  2  8D 96 E3             STA     bytinp          ;save input
00D806  2  8D DA E3             STA     lowin           ;value and
00D809  2  8C 97 E3             STY     bytinp+1        ;save high
00D80C  2  8C DB E3             STY     lowin+1         ;address
00D80F  2  8E 98 E3             STX     cmdinp          ;and command
00D812  2  E0 24                CPX     #numcmd         ;if invalid
00D814  2  B0 50                BCS     extpem          ;then exit
00D816  2  BD 52 E3             LDA     swctbl,x        ;if flag zero
00D819  2  F0 08                BEQ     noswin          ;skip switch
00D81B  2  A9 FF                LDA     #255            ;else set
00D81D  2  8D 95 E3             STA     swcflg          ;memory switch flag
00D820  2  20 ED DA             JSR     switch          ;move data to page zero
00D823  2               noswin:
00D823  2  A9 00                LDA     #0              ;clear drive
00D825  2  8D 9D E3             STA     tmpdrv          ;switch flag
00D828  2  AD 98 E3             LDA     cmdinp          ;get command
00D82B  2  0A                   ASL     a               ;multiply by two
00D82C  2  6D 98 E3             ADC     cmdinp          ;then add to get x3
00D82F  2  AA                   TAX                     ;and make a pointer
00D830  2  E8                   INX                     ;bump to pass jmp
00D831  2  BD 7A D8             LDA     cmdtbl,x        ;get command
00D834  2  BC 7B D8             LDY     cmdtbl+1,x      ;address
00D837  2  8D 9E E3             STA     xqtvec          ;and put
00D83A  2  8C 9F E3             STY     xqtvec+1        ;in vector
00D83D  2  AD E2 E2             LDA     extevc+1        ;get return
00D840  2  48                   PHA                     ;address
00D841  2  AD E1 E2             LDA     extevc          ;and push
00D844  2  48                   PHA                     ;as return
00D845  2  AD 96 E3             LDA     bytinp          ;get input value
00D848  2  AC 97 E3             LDY     bytinp+1
00D84B  2  6C 9E E3             JMP     (xqtvec)        ;then execute
00D84E  2               extexq:
00D84E  2  8D 99 E3             STA     bytout          ;save value
00D851  2  8C 9A E3             STY     addout+1        ;and address
00D854  2  AD 9D E3             LDA     tmpdrv          ;get temp drive
00D857  2  F0 0D                BEQ     extpem          ;if zero skip switch
00D859  2  A0 00                LDY     #0              ;else
00D85B  2  91 02                STA     (addinp),y      ;put back in fcb
00D85D  2  AD A7 E3             LDA     olddrv          ;get old drive number
00D860  2  8D 96 E3             STA     bytinp          ;set input value
00D863  2  20 08 DB             JSR     chgdrv          ;then switch back
00D866  2               extpem:
00D866  2  2C 95 E3             BIT     swcflg          ;test memory switch
00D869  2  10 08                BPL     noswot          ;if not set skip
00D86B  2  20 ED DA             JSR     switch          ;else do memory switch
00D86E  2  A9 00                LDA     #0              ;clear
00D870  2  8D 95 E3             STA     swcflg          ;flag
00D873  2               noswot:
00D873  2  AC 9A E3             LDY     addout+1        ;get address
00D876  2  AD 99 E3             LDA     bytout          ;and value (address low)
00D879  2  60                   RTS
00D87A  2               ;command vector table
00D87A  2               cmdtbl:
00D87A  2  4C EE D8             JMP     xwboot          ;warm boot
00D87D  2  4C DF DA             JMP     xcnsin          ;console input with echo
00D880  2  4C 17 E1             JMP     sndchr          ;console output
00D883  2  4C 81 E4             JMP     sim+21          ;tape reader
00D886  2  4C 7E E4             JMP     sim+18          ;tape punch
00D889  2  4C 7B E4             JMP     sim+15          ;printer output
00D88C  2  4C 89 E0             JMP     getcon          ;console input w/o echo
00D88F  2  4C 23 D9             JMP     xgtios          ;read i/o status
00D892  2  4C 2E D9             JMP     xstios          ;set i/o status
00D895  2  4C CE E0             JMP     sndstr          ;print buffer
00D898  2  4C 83 E1             JMP     bufinp          ;read buffer
00D89B  2  4C 99 E0             JMP     kbdsts          ;test console ready
00D89E  2  4C 99 E4             JMP     sim+45          ;read list status
00D8A1  2  4C 36 DB             JMP     xintds          ;initialize system
00D8A4  2  4C 08 DB             JMP     chgdrv          ;log in drive
00D8A7  2  4C B3 DD             JMP     xopen           ;open file
00D8AA  2  4C EE DD             JMP     xclose          ;close file
00D8AD  2  4C 12 DE             JMP     xfndfr          ;find first match
00D8B0  2  4C 3E D9             JMP     xfndnx          ;find next match
00D8B3  2  4C A6 D9             JMP     xdltfl          ;delete file
00D8B6  2  4C 46 D9             JMP     xread           ;read record
00D8B9  2  4C CB D9             JMP     xwrite          ;write record
00D8BC  2  4C B5 DE             JMP     xmake           ;create file
00D8BF  2  4C 84 D9             JMP     xrenme          ;rename file
00D8C2  2  4C 36 D9             JMP     xintlg          ;interrogate log in status
00D8C5  2  4C 32 D9             JMP     xintdr          ;interrogate current drive
00D8C8  2  4C FD DA             JMP     chgdma          ;set buffer address
00D8CB  2  4C 27 D9             JMP     xrdalv          ;read allocation map start
00D8CE  2  4C 71 DD             JMP     setron          ;set r/w status
00D8D1  2  4C 3A D9             JMP     xrdros          ;read r/w status
00D8D4  2  4C E6 D8             JMP     setlst          ;set list echo status
00D8D7  2  4C EA D8             JMP     lststs          ;read list echo status
00D8DA  2  4C FE D8             JMP     xrtclo          ;read low clock
00D8DD  2  4C 12 D9             JMP     xrtchi          ;read high clock
00D8E0  2  4C 1C D9             JMP     xrddcb          ;read dcb address
00D8E3  2  4C 9F E4             JMP     sim+51          ;translate sector
00D8E6  2               ;set list echo status
00D8E6  2               setlst:
00D8E6  2  8D 93 E3             STA     lstflg          ;set flag
00D8E9  2  60                   RTS
00D8EA  2               ;read list echo status
00D8EA  2               lststs:
00D8EA  2  AD 93 E3             LDA     lstflg          ;read flag
00D8ED  2  60                   RTS
00D8EE  2               ;execute warm boot
00D8EE  2               ; ***this command does not return to pem***
00D8EE  2               ; ***instead it jumps to sim, resets	***
00D8EE  2               ; ***system and stack and jumps to ccm. ***
00D8EE  2               xwboot:
00D8EE  2  2C 95 E3             BIT     swcflg          ;test memory switch flag
00D8F1  2  10 08                BPL     dowmbt          ;if clear do not
00D8F3  2  20 ED DA             JSR     switch          ;switch memory
00D8F6  2  A9 00                LDA     #0              ;clear
00D8F8  2  8D 95 E3             STA     swcflg          ;flag
00D8FB  2               dowmbt:
00D8FB  2  4C 6F E4             JMP     sim+3           ;go to sim
00D8FE  2               
00D8FE  2               ;execute read real time clock
00D8FE  2               xrtclo:
00D8FE  2  20 9C E4             JSR     sim+48          ;read clock
00D901  2               
00D901  2  8D C3 E3             STA     rtclk           ;save low
00D904  2  8C C4 E3             STY     rtclk+1         ;middle
00D907  2  8E C5 E3             STX     rtclk+2         ;high
00D90A  2  8A                   TXA
00D90B  2  29 80                AND     #%10000000      ;test for valid
00D90D  2  A8                   TAY
00D90E  2  AD C3 E3             LDA     rtclk           ;get low
00D911  2  60                   RTS
00D912  2               ;execute read real time clock high
00D912  2               xrtchi:
00D912  2  AD C5 E3             LDA     rtclk+2         ;get high
00D915  2  29 7F                AND     #%01111111      ;clear status
00D917  2  A8                   TAY
00D918  2  AD C4 E3             LDA     rtclk+1         ;get middle
00D91B  2  60                   RTS
00D91C  2               ;execute read dcb address
00D91C  2               xrddcb:
00D91C  2  AD 70 DB             LDA     cptdcb+1        ;get address
00D91F  2  AC 71 DB             LDY     cptdcb+2
00D922  2  60                   RTS
00D923  2               ;execute read i/o status
00D923  2               xgtios:
00D923  2  AD 06 01             LDA     iostat          ;get status byte
00D926  2  60                   RTS
00D927  2               ;execute read allocation map starting address
00D927  2               xrdalv:
00D927  2  AD D2 E3             LDA     alcmap          ;get
00D92A  2  AC D3 E3             LDY     alcmap+1        ;starting address
00D92D  2  60                   RTS                     ;then return
00D92E  2               ;execute set i/o status
00D92E  2               xstios:
00D92E  2  8D 06 01             STA     iostat          ;set status
00D931  2  60                   RTS
00D932  2               ;execute interrogate current drive
00D932  2               xintdr:
00D932  2  AD A8 E3             LDA     curdrv          ;get number
00D935  2  60                   RTS
00D936  2               ;execute read log in status
00D936  2               xintlg:
00D936  2  AD A9 E3             LDA     lginvc          ;get status
00D939  2  60                   RTS
00D93A  2               ;execute read read/write status
00D93A  2               xrdros:
00D93A  2  AD AA E3             LDA     ronlst          ;get status
00D93D  2  60                   RTS
00D93E  2               ;execute find next match
00D93E  2               xfndnx:
00D93E  2  20 16 DB             JSR     autodr          ;auto drive select
00D941  2  A9 0D                LDA     #13             ;match including
00D943  2  4C 1F DE             JMP     search          ;extent
00D946  2               ;execute read next record
00D946  2               xread:
00D946  2  20 16 DB             JSR     autodr          ;auto drive select
00D949  2  20 93 DD             JSR     inrcct          ;initialize record counters
00D94C  2  AD B3 E3             LDA     nxtrec          ;if next record less
00D94F  2  CD B4 E3             CMP     numrec          ;then number records
00D952  2  90 13                BCC     tryrde          ;then try to read
00D954  2  C9 80                CMP     #128            ;but if not and
00D956  2  F0 03                BEQ     tryext          ;is max try to extend
00D958  2               rdeeof:
00D958  2  A9 01                LDA     #1              ;else set eof
00D95A  2  60                   RTS                     ;code and return
00D95B  2               tryext:
00D95B  2  A2 01                LDX     #1              ;try for a read
00D95D  2  20 F1 DE             JSR     extend          ;file extension
00D960  2  C9 00                CMP     #0              ;if not ok exit eof
00D962  2  D0 F4                BNE     rdeeof          ;with jump back
00D964  2  8D B3 E3             STA     nxtrec          ;clear next record
00D967  2               tryrde:
00D967  2  20 82 DF             JSR     getblk          ;and get block
00D96A  2  AD AE E3             LDA     blknum          ;if block not zero
00D96D  2  0D AF E3             ORA     blknum+1
00D970  2  D0 03                BNE     dorde           ;do the read
00D972  2  A9 02                LDA     #2              ;else set unwritten
00D974  2  60                   RTS                     ;code and exit
00D975  2               dorde:
00D975  2  20 64 DE             JSR     calrcn          ;calculate record number
00D978  2  20 B0 DC             JSR     sttrsc          ;set track and sector
00D97B  2  20 3B E0             JSR     rdesec          ;do sector read
00D97E  2  20 A2 DD             JSR     updtrc          ;update counters
00D981  2  A9 00                LDA     #0              ;return w/o error
00D983  2               extrde:
00D983  2  60                   RTS
00D984  2               ;execute file rename
00D984  2               xrenme:
00D984  2  20 16 DB             JSR     autodr          ;automatic drive select
00D987  2  20 18 E0             JSR     tstron          ;test for r/o
00D98A  2  A9 0C                LDA     #12             ;match name
00D98C  2  20 17 DE             JSR     frstsr          ;and type
00D98F  2  30 14                BMI     extren          ;exit if not found
00D991  2               doren:
00D991  2  A9 00                LDA     #0              ;clear drive select
00D993  2  A0 10                LDY     #16             ;in new name
00D995  2  91 02                STA     (addinp),y      ;part of fcb
00D997  2  A9 0C                LDA     #12             ;then move
00D999  2  A2 10                LDX     #16             ;new name
00D99B  2  20 84 DE             JSR     dirchg          ;to directory
00D99E  2  A9 0C                LDA     #12             ;see if
00D9A0  2  20 1F DE             JSR     search          ;another match
00D9A3  2  10 EC                BPL     doren           ;loop if found
00D9A5  2               extren:
00D9A5  2  60                   RTS                     ;number
00D9A6  2               ;execute delete file
00D9A6  2               xdltfl:
00D9A6  2  20 16 DB             JSR     autodr          ;automatic drive select
00D9A9  2  20 18 E0             JSR     tstron          ;test for r/o
00D9AC  2  A9 0C                LDA     #12             ;match name
00D9AE  2  20 17 DE             JSR     frstsr          ;and type
00D9B1  2  30 17                BMI     extdlt          ;done if not found
00D9B3  2               dodlt:
00D9B3  2  A2 00                LDX     #0              ;else do a
00D9B5  2  20 E8 DF             JSR     mapdir          ;delete
00D9B8  2  AC AD E3             LDY     subrec          ;then change
00D9BB  2  AD 51 E3             LDA     empty           ;byte zero to
00D9BE  2  91 04                STA     (bufadd),y      ;empty code
00D9C0  2  20 41 E0             JSR     updtck          ;then update directory
00D9C3  2  A9 0C                LDA     #12             ;search
00D9C5  2  20 1F DE             JSR     search          ;for next
00D9C8  2  10 E9                BPL     dodlt           ;loop if found
00D9CA  2               extdlt:
00D9CA  2  60                   RTS                     ;exit
00D9CB  2               ;execute write next record
00D9CB  2               xwrite:
00D9CB  2  20 16 DB             JSR     autodr          ;automatic drive select
00D9CE  2  20 18 E0             JSR     tstron          ;test for r/o
00D9D1  2  20 93 DD             JSR     inrcct          ;initialize counters
00D9D4  2  AD B3 E3             LDA     nxtrec          ;get next record
00D9D7  2  C9 80                CMP     #128            ;compare to max
00D9D9  2  90 03                BCC     ntexte          ;continue if less
00D9DB  2  A9 01                LDA     #1              ;else flag as extend
00D9DD  2  60                   RTS                     ;error and exit
00D9DE  2               ntexte:
00D9DE  2  20 82 DF             JSR     getblk          ;calculate block num
00D9E1  2  A9 00                LDA     #0              ;say normal write
00D9E3  2  8D D7 E3             STA     pemwrtype       ;for now
00D9E6  2  AD AE E3             LDA     blknum          ;get it and if
00D9E9  2  0D AF E3             ORA     blknum+1
00D9EC  2  F0 03                BEQ     *+5             ;zero then get number
00D9EE  2  4C AE DA             JMP     blkopn          ;else go write
00D9F1  2  A9 02                LDA     #2              ;say unalloc write
00D9F3  2  8D D7 E3             STA     pemwrtype
00D9F6  2  AD 8F E3             LDA     fcbind          ;get index from prior
00D9F9  2  48                   PHA                     ;and save
00D9FA  2  C9 10                CMP     #16             ;if first block
00D9FC  2  F0 1A                BEQ     isfrst          ;then don't change
00D9FE  2  A8                   TAY                     ;else make an index
00D9FF  2  88                   DEY                     ;point to last
00DA00  2  2C BE E3             BIT     blmode          ;test mode
00DA03  2  10 01                BPL     *+3             ;done if byte
00DA05  2  88                   DEY                     ;else drop for word
00DA06  2  B1 02                LDA     (addinp),y      ;and get that number
00DA08  2  8D AE E3             STA     blknum          ;store as starting
00DA0B  2  C8                   INY                     ;bump for word
00DA0C  2  A9 00                LDA     #0              ;preset for byte
00DA0E  2  2C BE E3             BIT     blmode          ;test mode
00DA11  2  10 02                BPL     *+4             ;done if byte
00DA13  2  B1 02                LDA     (addinp),y      ;else get high
00DA15  2  8D AF E3             STA     blknum+1        ;then set high
00DA18  2               isfrst:
00DA18  2  AD AE E3             LDA     blknum          ;get block
00DA1B  2  8D A3 E3             STA     lkdown          ;set lower and
00DA1E  2  8D A5 E3             STA     lookup          ;upper pointers
00DA21  2  AD AF E3             LDA     blknum+1        ;now set high part
00DA24  2  8D A4 E3             STA     lkdown+1
00DA27  2  8D A6 E3             STA     lookup+1
00DA2A  2               srblag:
00DA2A  2  AD A5 E3             LDA     lookup          ;if upper pointer
00DA2D  2  CD C9 E3             CMP     maxblk          ;not at max
00DA30  2  D0 08                BNE     upnemx          ;then keep going
00DA32  2  AC A6 E3             LDY     lookup+1        ;now check high
00DA35  2  CC CA E3             CPY     maxblk+1
00DA38  2  F0 12                BEQ     tstdwn          ;go test down
00DA3A  2               upnemx:
00DA3A  2  EE A5 E3             INC     lookup          ;else bump upper
00DA3D  2  D0 03                BNE     *+5
00DA3F  2  EE A6 E3             INC     lookup+1
00DA42  2  AD A3 E3             LDA     lkdown          ;then if lower
00DA45  2  0D A4 E3             ORA     lkdown+1
00DA48  2  F0 18                BEQ     dotest          ;is zero start test
00DA4A  2  D0 0B                BNE     dcdown          ;else drop lower
00DA4C  2               tstdwn:
00DA4C  2  AD A3 E3             LDA     lkdown          ;if upper & lower at
00DA4F  2  0D A4 E3             ORA     lkdown+1
00DA52  2  D0 03                BNE     dcdown          ;drop if not zero
00DA54  2  A8                   TAY                     ;also set y
00DA55  2  F0 30                BEQ     extsbl          ;then exit
00DA57  2               dcdown:
00DA57  2  AD A3 E3             LDA     lkdown          ;drop lower
00DA5A  2  D0 03                BNE     *+5
00DA5C  2  CE A4 E3             DEC     lkdown+1
00DA5F  2  CE A3 E3             DEC     lkdown
00DA62  2               dotest:
00DA62  2  AD A3 E3             LDA     lkdown          ;get lower
00DA65  2  AC A4 E3             LDY     lkdown+1
00DA68  2  20 55 DD             JSR     tstblk          ;and test
00DA6B  2  D0 09                BNE     trylup          ;if full try upper
00DA6D  2  AD A3 E3             LDA     lkdown          ;else use lower
00DA70  2  AC A4 E3             LDY     lkdown+1
00DA73  2  4C 87 DA             JMP     extsbl          ;as result
00DA76  2               trylup:
00DA76  2  AD A5 E3             LDA     lookup          ;get upper
00DA79  2  AC A6 E3             LDY     lookup+1
00DA7C  2  20 55 DD             JSR     tstblk          ;if full
00DA7F  2  D0 A9                BNE     srblag          ;then loop
00DA81  2  AD A5 E3             LDA     lookup          ;else use upper
00DA84  2  AC A6 E3             LDY     lookup+1
00DA87  2               extsbl:
00DA87  2  8D AE E3             STA     blknum          ;then save number
00DA8A  2  8C AF E3             STY     blknum+1
00DA8D  2  0D AF E3             ORA     blknum+1        ;see if zero
00DA90  2  D0 04                BNE     gtgood          ;then proceed
00DA92  2  68                   PLA                     ;clear stack
00DA93  2  A9 02                LDA     #2              ;set end
00DA95  2  60                   RTS                     ;of data return
00DA96  2               gtgood:
00DA96  2  AD AE E3             LDA     blknum          ;get low again
00DA99  2  20 69 DD             JSR     setblk          ;set allocation map
00DA9C  2  68                   PLA                     ;get block
00DA9D  2  A8                   TAY                     ;pointer back
00DA9E  2  AD AE E3             LDA     blknum          ;get number
00DAA1  2  91 02                STA     (addinp),y      ;and put in fcb
00DAA3  2  AD AF E3             LDA     blknum+1        ;get high
00DAA6  2  C8                   INY
00DAA7  2  2C BE E3             BIT     blmode          ;test mode
00DAAA  2  10 02                BPL     *+4             ;done if byte
00DAAC  2  91 02                STA     (addinp),y      ;else set high
00DAAE  2               blkopn:
00DAAE  2  20 64 DE             JSR     calrcn          ;calculate record num
00DAB1  2  20 B0 DC             JSR     sttrsc          ;set track and sector
00DAB4  2  20 47 E0             JSR     wrtsec          ;do write
00DAB7  2  AE B3 E3             LDX     nxtrec          ;get next record
00DABA  2  EC B4 E3             CPX     numrec          ;if less than max
00DABD  2  90 05                BCC     notful          ;then ok
00DABF  2  E8                   INX                     ;else bump count
00DAC0  2  8E B4 E3             STX     numrec          ;and save
00DAC3  2  CA                   DEX                     ;back down
00DAC4  2               notful:
00DAC4  2  E0 7F                CPX     #127            ;if not at max
00DAC6  2  D0 11                BNE     noawex          ;skip extending
00DAC8  2  20 A2 DD             JSR     updtrc          ;update record counters
00DACB  2  A2 00                LDX     #0              ;do write
00DACD  2  20 F1 DE             JSR     extend          ;file extension
00DAD0  2  C9 00                CMP     #0              ;if not ok
00DAD2  2  D0 0A                BNE     extwrt          ;exit
00DAD4  2  A9 FF                LDA     #255            ;else start counter
00DAD6  2  8D B3 E3             STA     nxtrec          ;at one short
00DAD9  2               noawex:
00DAD9  2  20 A2 DD             JSR     updtrc          ;then update counters
00DADC  2  A9 00                LDA     #0              ;good return
00DADE  2               extwrt:
00DADE  2  60                   RTS                     ;exit
00DADF  2               ;execute console input
00DADF  2               xcnsin:
00DADF  2  20 89 E0             JSR     getcon          ;get input
00DAE2  2  20 BF E0             JSR     tstchr          ;test it and
00DAE5  2  90 05                BCC     extxci          ;if control exit
00DAE7  2  48                   PHA                     ;else save
00DAE8  2  20 17 E1             JSR     sndchr          ;echo
00DAEB  2  68                   PLA                     ;restore
00DAEC  2               extxci:
00DAEC  2  60                   RTS                     ;return
00DAED  2               ;switch memory
00DAED  2               ;page zero block begins at $02 and is numvar bytes long.
00DAED  2               switch:
00DAED  2  A2 07                LDX     #numvar-1       ;get number to switch
00DAEF  2               nxtswh:
00DAEF  2  B5 02                LDA     2,x             ;get zero page
00DAF1  2  BC DA E3             LDY     varblk,x        ;and save area
00DAF4  2  9D DA E3             STA     varblk,x        ;save zero
00DAF7  2  94 02                STY     2,x             ;and high
00DAF9  2  CA                   DEX                     ;count down
00DAFA  2  10 F3                BPL     nxtswh          ;and loop until done
00DAFC  2               drvsme:
00DAFC  2  60                   RTS                     ;then return
00DAFD  2               ;change dma address
00DAFD  2               ; input:addinp=address
00DAFD  2               ; returns:none
00DAFD  2               ; alters:all
00DAFD  2               chgdma:
00DAFD  2  A5 02                LDA     addinp          ;get low
00DAFF  2  A4 03                LDY     addinp+1        ;and high address
00DB01  2  85 04                STA     bufadd          ;then store
00DB03  2  84 05                STY     bufadd+1        ;in address
00DB05  2  4C 90 E4             JMP     sim+36          ;then go to sim
00DB08  2               
00DB08  2               ;change drive
00DB08  2               ; input:bytinp
00DB08  2               ; returns:none
00DB08  2               ; alters:all
00DB08  2               chgdrv:
00DB08  2  AD 96 E3             LDA     bytinp          ;get input
00DB0B  2  CD A8 E3             CMP     curdrv          ;if same as current
00DB0E  2  F0 EC                BEQ     drvsme          ;do nothing
00DB10  2  8D A8 E3             STA     curdrv          ;else change current
00DB13  2  4C 49 DB             JMP     mapdrv          ;then log it in
00DB16  2               ;automatic drive select
00DB16  2               ; input:(addinp) 0=no change
00DB16  2               ; 1-8 or 'A'-'H' = change
00DB16  2               ; returns:none
00DB16  2               ; alters:all
00DB16  2               autodr:
00DB16  2  A0 00                LDY     #0              ;get
00DB18  2  B1 02                LDA     (addinp),y      ;first byte of fcb
00DB1A  2  F0 19                BEQ     qtatdr          ;if zero quit
00DB1C  2  38                   SEC                     ;set carry for
00DB1D  2  E9 01                SBC     #1              ;subtract one
00DB1F  2  29 07                AND     #%00000111      ;look at three lsbs
00DB21  2  8D 96 E3             STA     bytinp          ;make parameter
00DB24  2  AD A8 E3             LDA     curdrv          ;get current
00DB27  2  8D A7 E3             STA     olddrv          ;and save
00DB2A  2  B1 02                LDA     (addinp),y      ;get fcb entry
00DB2C  2  8D 9D E3             STA     tmpdrv          ;and save as flag
00DB2F  2  98                   TYA                     ;set a to 0
00DB30  2  91 02                STA     (addinp),y      ;clear byte zero in fcb
00DB32  2  20 08 DB             JSR     chgdrv          ;then select new drive
00DB35  2               qtatdr:
00DB35  2  60                   RTS                     ;and return
00DB36  2               ;execute initialize system
00DB36  2               ; input:none
00DB36  2               ; returns:none
00DB36  2               ; alters:all,curdrv,lginvc,bufadd
00DB36  2               xintds:
00DB36  2  A9 02                LDA     #DEFDRV         ;set current
00DB38  2  8D A8 E3             STA     curdrv          ;drive to a
00DB3B  2  8D A9 E3             STA     lginvc          ;clear log in status
00DB3E  2  A9 28                LDA     #<dflbuf        ;get default buffer
00DB40  2  A0 01                LDY     #>dflbuf        ;address
00DB42  2  85 02                STA     addinp          ;and set up
00DB44  2  84 03                STY     addinp+1        ;parameters
00DB46  2  20 FD DA             JSR     chgdma          ;change address
00DB49  2               
00DB49  2               ;log in drive and set pointers and maps
00DB49  2               ; input:curdrv
00DB49  2               ; returns:none
00DB49  2               ; alters:all
00DB49  2               mapdrv:
00DB49  2  AD A8 E3             LDA     curdrv          ;if current drive
00DB4C  2  C9 08                CMP     #8              ;is 0 to 7
00DB4E  2  90 0F                BCC     vlddrv          ;then log it in
00DB50  2               drserr:
00DB50  2  20 6A E0             JSR     errout          ;send error message
00DB53  2  AD E4 E2             LDA     sltmvc          ;point to
00DB56  2  AC E5 E2             LDY     sltmvc+1        ;select message
00DB59  2  20 CE E0             JSR     sndstr          ;and send it
00DB5C  2               
00DB5C  2  4C EE D8             JMP     xwboot          ;and abort
00DB5F  2               
00DB5F  2               vlddrv:
00DB5F  2  20 87 E4             JSR     sim+27          ;go to sim to set
00DB62  2  8D 70 DB             STA     cptdcb+1        ;save
00DB65  2  8C 71 DB             STY     cptdcb+2
00DB68  2  0D 71 DB             ORA     cptdcb+2        ;see if invalid
00DB6B  2  F0 E3                BEQ     drserr          ;error if is
00DB6D  2               ;capture dcb
00DB6D  2  A0 0D                LDY     #14-1           ;do 14 bytes
00DB6F  2               cptdcb:
00DB6F  2  B9 FF FF             LDA     $ffff,y         ;get value from sim
00DB72  2  99 C9 E3             STA     dcb,y           ;store it
00DB75  2  88                   DEY
00DB76  2  10 F7                BPL     cptdcb          ;loop for more
00DB78  2  AD CF E3             LDA     blkscd          ;get block size code
00DB7B  2  A8                   TAY                     ;save in y
00DB7C  2  18                   CLC
00DB7D  2  69 03                ADC     #3              ;convert to sxb
00DB7F  2  8D C2 E3             STA     sxb             ;and save
00DB82  2  B9 89 E3             LDA     sabtbl,y        ;get sab
00DB85  2  8D C1 E3             STA     sab             ;and set
00DB88  2  AD D0 E3             LDA     maxdir          ;get max dir
00DB8B  2  8D BF E3             STA     maxdrc          ;set max dir record
00DB8E  2  AD D1 E3             LDA     maxdir+1
00DB91  2  4A                   LSR     a               ;divide by 4
00DB92  2  6E BF E3             ROR     maxdrc
00DB95  2  4A                   LSR     a
00DB96  2  6E BF E3             ROR     maxdrc
00DB99  2  8D C0 E3             STA     maxdrc+1        ;then save high
00DB9C  2  A9 00                LDA     #0              ;set mode to byte
00DB9E  2  8D BE E3             STA     blmode
00DBA1  2  AD CA E3             LDA     maxblk+1        ;branch if max block
00DBA4  2  F0 05                BEQ     ntm255          ;not over 255
00DBA6  2               ;if y=0 when the following line is executed it means
00DBA6  2               ;that the user has put an illegal combination into
00DBA6  2               ;the disk definition table. may want to consider
00DBA6  2               ;putting some error checking here in the future if
00DBA6  2               ;there is space in pem.
00DBA6  2  88                   DEY                     ;back up index
00DBA7  2  38                   SEC                     ;else set mode to word
00DBA8  2  6E BE E3             ROR     blmode
00DBAB  2               ntm255:
00DBAB  2  B9 86 E3             LDA     exmtbl,y        ;get extent mask
00DBAE  2  8D D8 E3             STA     exm
00DBB1  2               
00DBB1  2  38                   SEC                     ;now calculate cexm1f
00DBB2  2  A9 1F                LDA     #31
00DBB4  2  F9 86 E3             SBC     exmtbl,y
00DBB7  2  8D D9 E3             STA     cexm1f
00DBBA  2  AE A8 E3             LDX     curdrv          ;get drive as pointer
00DBBD  2  BD 7E E3             LDA     bitmap,x        ;get bit
00DBC0  2  2D A9 E3             AND     lginvc          ;if logged in
00DBC3  2  D0 0C                BNE     extstm          ;then exit
00DBC5  2  BD 7E E3             LDA     bitmap,x        ;get bit back
00DBC8  2  0D A9 E3             ORA     lginvc          ;set in log-in
00DBCB  2  8D A9 E3             STA     lginvc          ;and update
00DBCE  2  4C D2 DB             JMP     flinal          ;then fill in maps
00DBD1  2               
00DBD1  2               extstm:
00DBD1  2  60                   RTS                     ;and return
00DBD2  2               ;fill in allocation map
00DBD2  2               flinal:
00DBD2  2  20 2C E0             JSR     setrw           ;set to read/write
00DBD5  2  AD C9 E3             LDA     maxblk          ;divide max block by
00DBD8  2  8D C6 E3             STA     gpcnt           ;eight to get max
00DBDB  2  AD CA E3             LDA     maxblk+1
00DBDE  2  A2 03                LDX     #3
00DBE0  2               clcnab:
00DBE0  2  4A                   LSR     a               ;use a for speed
00DBE1  2  6E C6 E3             ROR     gpcnt
00DBE4  2  CA                   DEX
00DBE5  2  D0 F9                BNE     clcnab          ;loop if more
00DBE7  2  8D C7 E3             STA     gpcnt+1         ;save high
00DBEA  2  EE C6 E3             INC     gpcnt           ;bump by one
00DBED  2  D0 03                BNE     *+5
00DBEF  2  EE C7 E3             INC     gpcnt+1         ;with carry
00DBF2  2  AD D2 E3             LDA     alcmap          ;get map start
00DBF5  2  AC D3 E3             LDY     alcmap+1
00DBF8  2  85 06                STA     alcpnt          ;set pointer to start
00DBFA  2  84 07                STY     alcpnt+1
00DBFC  2  A0 00                LDY     #0              ;clear index
00DBFE  2               clraml:
00DBFE  2  A9 00                LDA     #0              ;clear byte
00DC00  2  91 06                STA     (alcpnt),y      ;put in map
00DC02  2  E6 06                INC     alcpnt          ;bump pointer
00DC04  2  D0 02                BNE     *+4
00DC06  2  E6 07                INC     alcpnt+1        ;with carry
00DC08  2  AD C6 E3             LDA     gpcnt           ;get low of count
00DC0B  2  D0 03                BNE     *+5             ;skip if not zero
00DC0D  2  CE C7 E3             DEC     gpcnt+1         ;else drop high
00DC10  2  CE C6 E3             DEC     gpcnt           ;always drop low
00DC13  2  AD C6 E3             LDA     gpcnt           ;test for zero
00DC16  2  0D C7 E3             ORA     gpcnt+1
00DC19  2  D0 E3                BNE     clraml          ;loop if more
00DC1B  2               ;at this point complete map is cleared
00DC1B  2  AD BF E3             LDA     maxdrc          ;get low of max dir record
00DC1E  2  8D C6 E3             STA     gpcnt
00DC21  2  AD C0 E3             LDA     maxdrc+1        ;high in a
00DC24  2  AE C2 E3             LDX     sxb             ;set x according to block size
00DC27  2               clcmdb:
00DC27  2  4A                   LSR     a               ;do division
00DC28  2  6E C6 E3             ROR     gpcnt
00DC2B  2  CA                   DEX
00DC2C  2  D0 F9                BNE     clcmdb          ;until x is zero
00DC2E  2  8D C7 E3             STA     gpcnt+1         ;set high
00DC31  2  EE C6 E3             INC     gpcnt           ;then bump by one
00DC34  2  D0 03                BNE     *+5
00DC36  2  EE C7 E3             INC     gpcnt+1
00DC39  2  8E AE E3             STX     blknum          ;clear block number
00DC3C  2  8E AF E3             STX     blknum+1
00DC3F  2               fildal:
00DC3F  2  AD AE E3             LDA     blknum          ;get block number
00DC42  2  AC AF E3             LDY     blknum+1
00DC45  2  20 69 DD             JSR     setblk          ;set bit
00DC48  2  EE AE E3             INC     blknum          ;bump block number
00DC4B  2  D0 03                BNE     *+5
00DC4D  2  EE AF E3             INC     blknum+1
00DC50  2  AD C6 E3             LDA     gpcnt           ;get low of count
00DC53  2  D0 03                BNE     *+5             ;skip if not zero
00DC55  2  CE C7 E3             DEC     gpcnt+1         ;else drop high
00DC58  2  CE C6 E3             DEC     gpcnt           ;always do low
00DC5B  2  AD C6 E3             LDA     gpcnt           ;test for zero
00DC5E  2  0D C7 E3             ORA     gpcnt+1
00DC61  2  D0 DC                BNE     fildal          ;loop if more
00DC63  2               ;at this point directory space is mapped
00DC63  2  20 82 DC             JSR     intdrv          ;initialize drive
00DC66  2  20 DC DF             JSR     cldrnm          ;clear directory number
00DC69  2               fillpe:
00DC69  2  A2 01                LDX     #1              ;parameter for fill
00DC6B  2  20 24 DF             JSR     nxtdir          ;execute for next directory
00DC6E  2  30 11                BMI     extfil          ;done if invalid
00DC70  2  AC AD E3             LDY     subrec          ;get offset
00DC73  2  B1 04                LDA     (bufadd),y      ;get empty/valid flag
00DC75  2  C9 E5                CMP     #$e5            ;if empty
00DC77  2  F0 F0                BEQ     fillpe          ;try next
00DC79  2  A2 01                LDX     #1              ;parameter for fill in
00DC7B  2  20 E8 DF             JSR     mapdir          ;do directory map
00DC7E  2  4C 69 DC             JMP     fillpe          ;then loop
00DC81  2               extfil:
00DC81  2  60                   RTS                     ;return
00DC82  2               ;initialize drive
00DC82  2               ; input:nsystr
00DC82  2               ; returns:none
00DC82  2               ; alters:all
00DC82  2               intdrv:
00DC82  2  20 84 E4             JSR     sim+24          ;home then
00DC85  2               
00DC85  2  AD CD E3             LDA     nsystr          ;get number of system tracks
00DC88  2  AC CE E3             LDY     nsystr+1
00DC8B  2  4C 8A E4             JMP     sim+30          ;and set in sim
00DC8E  2               
00DC8E  2               ;directory record set up
00DC8E  2               ; input:dirnum
00DC8E  2               ; returns:none
00DC8E  2               ; alters:all,recnum,dirrec
00DC8E  2               drrcsu:
00DC8E  2  AD AC E3             LDA     dirnum+1        ;move high dir number
00DC91  2  8D AF E3             STA     recnum+1        ;to record number
00DC94  2  AD AB E3             LDA     dirnum          ;divide
00DC97  2  4E AF E3             LSR     recnum+1        ;directory by four
00DC9A  2  6A                   ROR     a
00DC9B  2  4E AF E3             LSR     recnum+1
00DC9E  2  6A                   ROR     a
00DC9F  2  8D B5 E3             STA     dirrec          ;and save
00DCA2  2  8D AE E3             STA     recnum          ;set low record number
00DCA5  2  AD AF E3             LDA     recnum+1        ;get high
00DCA8  2  8D B6 E3             STA     dirrec+1        ;and set
00DCAB  2  A9 00                LDA     #0              ;clear top byte
00DCAD  2  8D B0 E3             STA     recnum+2
00DCB0  2               ;set track and sector
00DCB0  2               ; input:recnum
00DCB0  2               ; returns:none
00DCB0  2               ; alters:all,countr,trkctr
00DCB0  2               sttrsc:
00DCB0  2  A2 00                LDX     #0              ;clear track counter
00DCB2  2  8E C8 E3             STX     trkctr
00DCB5  2  8E A0 E3             STX     countr          ;and record
00DCB8  2  8E A1 E3             STX     countr+1        ;counter
00DCBB  2  8E A2 E3             STX     countr+2
00DCBE  2               trnxtr:
00DCBE  2  AD AE E3             LDA     recnum          ;from
00DCC1  2  CD A0 E3             CMP     countr          ;record number
00DCC4  2  AD AF E3             LDA     recnum+1        ;and if a
00DCC7  2  ED A1 E3             SBC     countr+1        ;borrow then
00DCCA  2  AD B0 E3             LDA     recnum+2
00DCCD  2  ED A2 E3             SBC     countr+2
00DCD0  2  90 21                BCC     higher          ;gone too far
00DCD2  2  18                   CLC                     ;else
00DCD3  2  AD A0 E3             LDA     countr          ;get counter
00DCD6  2  6D CB E3             ADC     sectrk          ;add sectors per track
00DCD9  2  8D A0 E3             STA     countr          ;sectors per track
00DCDC  2  AD A1 E3             LDA     countr+1
00DCDF  2  6D CC E3             ADC     sectrk+1
00DCE2  2  8D A1 E3             STA     countr+1
00DCE5  2  90 03                BCC     bumptr          ;done if no carry
00DCE7  2  EE A2 E3             INC     countr+2        ;else bump high
00DCEA  2               bumptr:
00DCEA  2  E8                   INX                     ;increase track count
00DCEB  2  D0 D1                BNE     trnxtr          ;with carry
00DCED  2  EE C8 E3             INC     trkctr
00DCF0  2  4C BE DC             JMP     trnxtr          ;then loop
00DCF3  2               higher:
00DCF3  2  CA                   DEX                     ;back up track
00DCF4  2  E0 FF                CPX     #$ff            ;see if wrap around
00DCF6  2  D0 03                BNE     *+5             ;wasn't
00DCF8  2  CE C8 E3             DEC     trkctr          ;else drop high
00DCFB  2  8A                   TXA                     ;move to a
00DCFC  2  18                   CLC                     ;add starting track
00DCFD  2  6D CD E3             ADC     nsystr
00DD00  2  AA                   TAX                     ;save in x
00DD01  2  AD C8 E3             LDA     trkctr
00DD04  2  6D CE E3             ADC     nsystr+1
00DD07  2  A8                   TAY                     ;move to correct registers
00DD08  2  8A                   TXA
00DD09  2  20 8A E4             JSR     sim+30          ;then set in sim
00DD0C  2               
00DD0C  2  38                   SEC                     ;back
00DD0D  2  AD A0 E3             LDA     countr          ;counter down
00DD10  2  ED CB E3             SBC     sectrk          ;by sectors per track
00DD13  2  8D A0 E3             STA     countr          ;and save
00DD16  2  AD A1 E3             LDA     countr+1
00DD19  2  ED CC E3             SBC     sectrk+1
00DD1C  2  8D A1 E3             STA     countr+1
00DD1F  2  38                   SEC                     ;now
00DD20  2  AD AE E3             LDA     recnum          ;find difference
00DD23  2  ED A0 E3             SBC     countr          ;as sector
00DD26  2  AA                   TAX                     ;save in x
00DD27  2  AD AF E3             LDA     recnum+1
00DD2A  2  ED A1 E3             SBC     countr+1
00DD2D  2  A8                   TAY                     ;move to correct registers
00DD2E  2  8A                   TXA
00DD2F  2  20 9F E4             JSR     sim+51          ;translate
00DD32  2               
00DD32  2  4C 8D E4             JMP     sim+33          ;and set through sim
00DD35  2               
00DD35  2               ;get block bit mask and index
00DD35  2               ; input:a&y=block number
00DD35  2               ; returns:a=bit mask and y=0
00DD35  2               ; alters:all and alcpnt
00DD35  2               blkmsk:
00DD35  2  48                   PHA                     ;save block number
00DD36  2  84 07                STY     alcpnt+1        ;including high
00DD38  2  A0 03                LDY     #3              ;divide by eight
00DD3A  2               blkmlp:
00DD3A  2  46 07                LSR     alcpnt+1        ;shift high
00DD3C  2  6A                   ROR     a
00DD3D  2  88                   DEY                     ;loop until done
00DD3E  2  D0 FA                BNE     blkmlp
00DD40  2  18                   CLC                     ;now add map start
00DD41  2  6D D2 E3             ADC     alcmap
00DD44  2  85 06                STA     alcpnt
00DD46  2  A5 07                LDA     alcpnt+1
00DD48  2  6D D3 E3             ADC     alcmap+1
00DD4B  2  85 07                STA     alcpnt+1
00DD4D  2  68                   PLA                     ;get number back
00DD4E  2  29 07                AND     #%00000111      ;look at 3 lsbs
00DD50  2  AA                   TAX                     ;get
00DD51  2  BD 76 E3             LDA     bitmsk,x        ;mask
00DD54  2  60                   RTS                     ;and return
00DD55  2               ;test block
00DD55  2               ; input:a&y=block number
00DD55  2               ; returns:z=1 if unassigned
00DD55  2               ; 	   =0 if assigned and bit in a is set
00DD55  2               ; alters:all
00DD55  2               tstblk:
00DD55  2  20 35 DD             JSR     blkmsk          ;get mask and index
00DD58  2  31 06                AND     (alcpnt),y      ;mask with map entry
00DD5A  2  60                   RTS                     ;then return
00DD5B  2               ;alter block status
00DD5B  2               ; input:a&y=block number,x=1 if set
00DD5B  2               ;		   	  =0 if reset
00DD5B  2               ; returns:none
00DD5B  2               ; alters:all and allocation map
00DD5B  2               altalc:
00DD5B  2  E0 01                CPX     #1              ;if set
00DD5D  2  F0 0A                BEQ     setblk          ;go do it
00DD5F  2               clrblk:
00DD5F  2  20 35 DD             JSR     blkmsk          ;else get mask
00DD62  2  49 FF                EOR     #$ff            ;and complement
00DD64  2  31 06                AND     (alcpnt),y      ;preserve others
00DD66  2  91 06                STA     (alcpnt),y      ;and save
00DD68  2  60                   RTS                     ;then return
00DD69  2               setblk:
00DD69  2  20 35 DD             JSR     blkmsk          ;get mask
00DD6C  2  11 06                ORA     (alcpnt),y      ;set bit
00DD6E  2  91 06                STA     (alcpnt),y      ;and put back
00DD70  2  60                   RTS                     ;then return
00DD71  2               ;set current drive to read only
00DD71  2               ; input:curdrv,ronlst,bitmap
00DD71  2               ; returns:none
00DD71  2               ; alters:a,x,p and ronlst
00DD71  2               setron:
00DD71  2  AE A8 E3             LDX     curdrv          ;get number
00DD74  2  BD 7E E3             LDA     bitmap,x        ;and get mask
00DD77  2  0D AA E3             ORA     ronlst          ;or with status
00DD7A  2  8D AA E3             STA     ronlst          ;and put back
00DD7D  2  60                   RTS                     ;then return
00DD7E  2               ;calculate checksum of buffer @ bufadd
00DD7E  2               ; input: buffer@(bufadd)
00DD7E  2               ; returns:a=checksum
00DD7E  2               ; alters:a,y,p
00DD7E  2               clcchk:
00DD7E  2  A9 00                LDA     #0              ;clear accumulator
00DD80  2  A0 7F                LDY     #127            ;start at end
00DD82  2               chkmre:
00DD82  2  18                   CLC                     ;no carry
00DD83  2  71 04                ADC     (bufadd),y      ;add byte
00DD85  2  88                   DEY                     ;count down
00DD86  2  10 FA                BPL     chkmre          ;and loop until done
00DD88  2  60                   RTS                     ;then return
00DD89  2               ;check read/write status
00DD89  2               ; input:curdrv,ronlst
00DD89  2               ; returns:z=0 if r/o or z=1 if r/w
00DD89  2               ; alters:a,x,p
00DD89  2               chkron:
00DD89  2  AE A8 E3             LDX     curdrv          ;get current drive
00DD8C  2  BD 7E E3             LDA     bitmap,x        ;get mask
00DD8F  2  2D AA E3             AND     ronlst          ;and test status
00DD92  2  60                   RTS
00DD93  2               ;initialize record counters from fcb
00DD93  2               ; input:fcb@(addinp)
00DD93  2               ; returns:none
00DD93  2               ; alters:a,y,p,nxtrec,numrec
00DD93  2               inrcct:
00DD93  2  A0 20                LDY     #32             ;next record offset
00DD95  2  B1 02                LDA     (addinp),y      ;get next record
00DD97  2  8D B3 E3             STA     nxtrec          ;and save
00DD9A  2  A0 0F                LDY     #15             ;number records offset
00DD9C  2  B1 02                LDA     (addinp),y      ;get number
00DD9E  2  8D B4 E3             STA     numrec          ;and save
00DDA1  2  60                   RTS                     ;and return
00DDA2  2               ;update record counters in fcb
00DDA2  2               ; input:nxtrec,numrec
00DDA2  2               ; returns:none
00DDA2  2               ; alters:all,fcb@(addinp)
00DDA2  2               updtrc:
00DDA2  2  AE B3 E3             LDX     nxtrec          ;get next record
00DDA5  2  E8                   INX                     ;bump it
00DDA6  2  8A                   TXA                     ;transfer
00DDA7  2  A0 20                LDY     #32             ;set offset
00DDA9  2  91 02                STA     (addinp),y      ;and store in fcb
00DDAB  2  AD B4 E3             LDA     numrec          ;get number
00DDAE  2  A0 0F                LDY     #15             ;and its offset
00DDB0  2  91 02                STA     (addinp),y      ;and store
00DDB2  2  60                   RTS                     ;then return
00DDB3  2               ;execute open file
00DDB3  2               xopen:
00DDB3  2  20 16 DB             JSR     autodr          ;auto drive select
00DDB6  2               ;open file
00DDB6  2               ; input:fcb @ (addinp)
00DDB6  2               ; returns:n=1 if not found,a=dirmod (255 if not found)
00DDB6  2               ; alters:all
00DDB6  2               opnfle:
00DDB6  2  20 15 DE             JSR     fndf13          ;match all including extent
00DDB9  2  30 32                BMI     extopn          ;done if not found
00DDBB  2  A9 0C                LDA     #12             ;point to first char
00DDBD  2  0D AD E3             ORA     subrec          ;add offset
00DDC0  2  A8                   TAY                     ;make it a pointer
00DDC1  2               nxopmv:
00DDC1  2  B1 04                LDA     (bufadd),y      ;get buffer contents
00DDC3  2  AA                   TAX                     ;and save
00DDC4  2  98                   TYA                     ;save index
00DDC5  2  29 1F                AND     #%00011111      ;remove offset
00DDC7  2  A8                   TAY                     ;back to index
00DDC8  2  8A                   TXA                     ;get byte back
00DDC9  2  91 02                STA     (addinp),y      ;and store in fcb
00DDCB  2  98                   TYA                     ;get index
00DDCC  2  0D AD E3             ORA     subrec          ;add offset back
00DDCF  2  A8                   TAY                     ;and make index again
00DDD0  2  C8                   INY                     ;next position
00DDD1  2  98                   TYA                     ;if index
00DDD2  2  29 1F                AND     #%00011111      ;not gone past
00DDD4  2  D0 EB                BNE     nxopmv          ;end then loop
00DDD6  2               ;now correct extent and max records
00DDD6  2  A0 0C                LDY     #12             ;point at extent in fcb
00DDD8  2  AD 90 E3             LDA     savext          ;get save from search
00DDDB  2  D1 02                CMP     (addinp),y      ;compare
00DDDD  2  F0 0B                BEQ     extsme          ;jump ahead if same
00DDDF  2  91 02                STA     (addinp),y      ;else change extent
00DDE1  2  A9 80                LDA     #128            ;assume fcb ext < dir ext
00DDE3  2  90 01                BCC     fcbxls          ;jump ahead if true
00DDE5  2  0A                   ASL     a               ;clear a
00DDE6  2               fcbxls:
00DDE6  2  A0 0F                LDY     #15             ;point to max
00DDE8  2  91 02                STA     (addinp),y      ;and set
00DDEA  2               extsme:
00DDEA  2  AD B7 E3             LDA     dirmod          ;else get number
00DDED  2               extopn:
00DDED  2  60                   RTS                     ;and return
00DDEE  2               ;execute close file
00DDEE  2               xclose:
00DDEE  2  20 16 DB             JSR     autodr          ;auto drive select
00DDF1  2               ;close file
00DDF1  2               ;if file is r/o then no actual close
00DDF1  2               ;operation is performed.
00DDF1  2               ; input:fcb @ (addinp)
00DDF1  2               ; returns:n=1 if not valid,a=dirmod (255 if invalid)
00DDF1  2               ; alters:all
00DDF1  2               clsfle:
00DDF1  2  20 15 DE             JSR     fndf13          ;match including extent
00DDF4  2  30 1B                BMI     extcls          ;exit if not found
00DDF6  2  20 89 DD             JSR     chkron          ;see if r/o
00DDF9  2  D0 13                BNE     noclse          ;branch if is
00DDFB  2               ;now set flag to ensure directory extent and number of
00DDFB  2               ;records fields are only changed if necessary.
00DDFB  2               ;The decision to change is determined by whether or
00DDFB  2               ;not the system is closing an extent less than the
00DDFB  2               ;maximum extent in the directory entry. If that is
00DDFB  2               ;the case, the directory extent and number of record
00DDFB  2               ;fields are not changed.
00DDFB  2  A0 0C                LDY     #12             ;get extent
00DDFD  2  B1 02                LDA     (addinp),y
00DDFF  2  48                   PHA                     ;save it
00DE00  2  98                   TYA                     ;now look in directory
00DE01  2  0D AD E3             ORA     subrec
00DE04  2  A8                   TAY
00DE05  2  68                   PLA                     ;get extent back
00DE06  2  D1 04                CMP     (bufadd),y
00DE08  2  6E 8E E3             ROR     skpdir          ;save result
00DE0B  2               ;now go do it
00DE0B  2  20 80 DE             JSR     updtdr          ;update directory
00DE0E  2               noclse:
00DE0E  2  AD B7 E3             LDA     dirmod          ;get directory number
00DE11  2               extcls:
00DE11  2  60                   RTS                     ;and return
00DE12  2               ;execute find first match
00DE12  2               xfndfr:
00DE12  2  20 16 DB             JSR     autodr          ;auto drive select
00DE15  2               fndf13:
00DE15  2  A9 0D                LDA     #13             ;match including extent
00DE17  2               ;search for first match
00DE17  2               ; input:a=number char to match
00DE17  2               ; returns:n=1 if invalid,a=dirmod (255 if invalid)
00DE17  2               ; alters:all
00DE17  2               frstsr:
00DE17  2  48                   PHA                     ;save number to match
00DE18  2  20 DC DF             JSR     cldrnm          ;clear directory number to -1
00DE1B  2  20 82 DC             JSR     intdrv          ;and drive
00DE1E  2  68                   PLA                     ;get number to match
00DE1F  2               ;search for directory match
00DE1F  2               ; input:a=number char to match
00DE1F  2               ; returns:n=1 if not found,a=dirmod (255 if invalid)
00DE1F  2               ; alters:all
00DE1F  2               search:
00DE1F  2  8D B1 E3             STA     chrcnt          ;save number
00DE22  2               newtry:
00DE22  2  A2 00                LDX     #0              ;set for search
00DE24  2  8E B2 E3             STX     cmppnt          ;clear pointer
00DE27  2  20 24 DF             JSR     nxtdir          ;get next entry
00DE2A  2  30 37                BMI     exitsr          ;exit if not found
00DE2C  2  AE B1 E3             LDX     chrcnt          ;get count
00DE2F  2               mremch:
00DE2F  2  AC B2 E3             LDY     cmppnt          ;get pointer
00DE32  2  EE B2 E3             INC     cmppnt          ;and bump
00DE35  2  B1 02                LDA     (addinp),y      ;get fcb entry
00DE37  2  C0 0C                CPY     #12             ;see if at extent
00DE39  2  D0 13                BNE     notaex          ;jump if not
00DE3B  2  8D 90 E3             STA     savext          ;save for later use
00DE3E  2  48                   PHA                     ;save extent
00DE3F  2  98                   TYA                     ;change to directory
00DE40  2  0D AD E3             ORA     subrec          ;coordinates
00DE43  2  A8                   TAY
00DE44  2  68                   PLA                     ;get extent back
00DE45  2  51 04                EOR     (bufadd),y      ;exclusive or with dir
00DE47  2  2D D9 E3             AND     cexm1f          ;and with exm complement + 1f
00DE4A  2  F0 11                BEQ     trynxt          ;ok if zero
00DE4C  2  D0 D4                BNE     newtry          ;else get next directory
00DE4E  2               notaex:
00DE4E  2  C9 3F                CMP     #'?'            ;if a ? then
00DE50  2  F0 0B                BEQ     trynxt          ;is a match
00DE52  2  48                   PHA                     ;save char
00DE53  2  98                   TYA                     ;then add
00DE54  2  0D AD E3             ORA     subrec          ;offset to
00DE57  2  A8                   TAY                     ;make pointer
00DE58  2  68                   PLA                     ;get char back
00DE59  2               ;        sta     savex
00DE59  2               ;        lda	(bufadd),y	;if not same
00DE59  2               ;        and     #$7F            ; strip off high bit for ROMWBW Read only filesystem
00DE59  2               ;	cmp	savex	        ;if not same
00DE59  2  D1 04                CMP     (bufadd),y      ;if not same
00DE5B  2  D0 C5                BNE     newtry          ;try next directory
00DE5D  2               trynxt:
00DE5D  2  CA                   DEX                     ;else count number down
00DE5E  2  D0 CF                BNE     mremch          ;and loop if more
00DE60  2  AD B7 E3             LDA     dirmod          ;return with directory
00DE63  2               exitsr:
00DE63  2  60                   RTS                     ;number mod 4
00DE64  2               ;calculate logical record number
00DE64  2               ; input:blknum
00DE64  2               ; returns:none
00DE64  2               ; alters:a,x,p,recnum
00DE64  2               calrcn:
00DE64  2  AE C2 E3             LDX     sxb             ;set x according to blkscd
00DE67  2               mulmre:
00DE67  2  0E AE E3             ASL     blknum          ;multiply block
00DE6A  2  2E AF E3             ROL     blknum+1        ;number
00DE6D  2  2E B0 E3             ROL     blknum+2
00DE70  2  CA                   DEX                     ;by code
00DE71  2  D0 F4                BNE     mulmre
00DE73  2  AD C1 E3             LDA     sab             ;set mask in a
00DE76  2  2D B3 E3             AND     nxtrec          ;and with next record
00DE79  2  0D AE E3             ORA     recnum          ;or with number
00DE7C  2  8D AE E3             STA     recnum          ;and save
00DE7F  2  60                   RTS
00DE80  2               ;update directory
00DE80  2               updtdr:
00DE80  2  A9 20                LDA     #32             ;change all
00DE82  2  A2 00                LDX     #0              ;from start
00DE84  2               ;change directory entry
00DE84  2               ; input:a=number char to change,x=starting position,fcb@(addinp)
00DE84  2               ; returns:none
00DE84  2               ; alters:all,directory,checksums
00DE84  2               dirchg:
00DE84  2  8D B1 E3             STA     chrcnt          ;save count
00DE87  2  CE B1 E3             DEC     chrcnt          ;back up
00DE8A  2               mrechg:
00DE8A  2  18                   CLC                     ;clear carry
00DE8B  2  8A                   TXA                     ;get offset
00DE8C  2  6D B1 E3             ADC     chrcnt          ;compute index
00DE8F  2  A8                   TAY                     ;and set
00DE90  2  C0 0C                CPY     #12             ;see if at extent
00DE92  2  F0 04                BEQ     docare          ;if so do special
00DE94  2  C0 0F                CPY     #15             ;see if at number rec
00DE96  2  D0 05                BNE     dntcar          ;if not skip
00DE98  2               docare:
00DE98  2  2C 8E E3             BIT     skpdir          ;check flag
00DE9B  2  10 0D                BPL     nochng          ;skip if ok
00DE9D  2               dntcar:
00DE9D  2  B1 02                LDA     (addinp),y      ;get char
00DE9F  2  48                   PHA                     ;save it
00DEA0  2  AD B1 E3             LDA     chrcnt          ;get count
00DEA3  2  0D AD E3             ORA     subrec          ;add offset
00DEA6  2  A8                   TAY                     ;make an index
00DEA7  2  68                   PLA                     ;get char back
00DEA8  2  91 04                STA     (bufadd),y      ;and put in buffer
00DEAA  2               nochng:
00DEAA  2  CE B1 E3             DEC     chrcnt          ;count down
00DEAD  2  10 DB                BPL     mrechg          ;and loop
00DEAF  2  20 8E DC             JSR     drrcsu          ;set it up
00DEB2  2  4C 41 E0             JMP     updtck          ;and do change
00DEB5  2               ;execute create file
00DEB5  2               xmake:
00DEB5  2  20 16 DB             JSR     autodr          ;auto drive select
00DEB8  2               ;create file
00DEB8  2               ; input:fcb@(addinp)
00DEB8  2               ; returns:n=1 if not valid,a=dirmod (255 if not valid)
00DEB8  2               ; alters:dirnum,dirmod,fcb@(addinp)
00DEB8  2               mkefle:
00DEB8  2  20 18 E0             JSR     tstron          ;test for r/o
00DEBB  2  A5 02                LDA     addinp          ;save fcb
00DEBD  2  48                   PHA                     ;address
00DEBE  2  A5 03                LDA     addinp+1        ;on
00DEC0  2  48                   PHA                     ;stack
00DEC1  2  AD E7 E2             LDA     empdvc          ;then point
00DEC4  2  AC E8 E2             LDY     empdvc+1        ;to empty
00DEC7  2  85 02                STA     addinp          ;dummy
00DEC9  2  84 03                STY     addinp+1        ;fcb
00DECB  2  A9 01                LDA     #1              ;match only
00DECD  2  20 17 DE             JSR     frstsr          ;first char
00DED0  2  68                   PLA                     ;restore
00DED1  2  85 03                STA     addinp+1        ;fcb
00DED3  2  68                   PLA                     ;address
00DED4  2  85 02                STA     addinp          ;from stack
00DED6  2  AD B7 E3             LDA     dirmod          ;get number mod 4
00DED9  2  30 15                BMI     extmke          ;quit if not found
00DEDB  2  A0 0D                LDY     #13             ;else set up
00DEDD  2  A9 00                LDA     #0              ;to clear
00DEDF  2               mkeagn:
00DEDF  2  91 02                STA     (addinp),y      ;rest of
00DEE1  2  C8                   INY                     ;fcb
00DEE2  2  C0 21                CPY     #33             ;including next
00DEE4  2  D0 F9                BNE     mkeagn          ;record
00DEE6  2               ;the next two lines ensure that the extent and
00DEE6  2               ;number of records fields are updated
00DEE6  2  38                   SEC
00DEE7  2  6E 8E E3             ROR     skpdir
00DEEA  2  20 80 DE             JSR     updtdr          ;update directory
00DEED  2  AD B7 E3             LDA     dirmod          ;get number
00DEF0  2               extmke:
00DEF0  2  60                   RTS                     ;and quit
00DEF1  2               ;extend file
00DEF1  2               ; input:fcb@(addinp), x=1 read
00DEF1  2               ;		        0 write
00DEF1  2               extend:
00DEF1  2  8E 9C E3             STX     exrwfl          ;save parameter
00DEF4  2  20 F1 DD             JSR     clsfle          ;close current extent
00DEF7  2  30 2A                BMI     extext          ;exit if not found
00DEF9  2  A0 0C                LDY     #12             ;else
00DEFB  2  B1 02                LDA     (addinp),y      ;get extent
00DEFD  2  18                   CLC                     ;and
00DEFE  2  69 01                ADC     #1              ;add one
00DF00  2  29 1F                AND     #%00011111      ;see if overflow
00DF02  2  F0 17                BEQ     exteof          ;eof if so
00DF04  2  91 02                STA     (addinp),y      ;and save
00DF06  2  20 15 DE             JSR     fndf13          ;see if next extent exists
00DF09  2  10 0B                BPL     opnext          ;if so open
00DF0B  2  AD 9C E3             LDA     exrwfl          ;if not and is write then create
00DF0E  2  D0 13                BNE     extext          ;else return as eof
00DF10  2               dwrtex:
00DF10  2  20 B8 DE             JSR     mkefle          ;create file
00DF13  2  4C 19 DF             JMP     tstext          ;and test
00DF16  2               opnext:
00DF16  2  20 B6 DD             JSR     opnfle          ;open
00DF19  2               tstext:
00DF19  2  10 03                BPL     extnok          ;continue if ok
00DF1B  2               exteof:
00DF1B  2  A9 01                LDA     #1              ;else set eof
00DF1D  2  60                   RTS                     ;and return
00DF1E  2               extnok:
00DF1E  2  20 93 DD             JSR     inrcct          ;initialize counters
00DF21  2  A9 00                LDA     #0              ;good
00DF23  2               extext:
00DF23  2  60                   RTS                     ;return
00DF24  2               ;set up next directory block
00DF24  2               ; input:dirnum,x=1 for update checksum
00DF24  2               ; returns:a=dirmod (255 if invalid),n=1 if invalid
00DF24  2               ; alters:alll,dirnum,dirmod
00DF24  2               nxtdir:
00DF24  2  8A                   TXA                     ;save operation
00DF25  2  48                   PHA                     ;on stack
00DF26  2  EE AB E3             INC     dirnum          ;bump directory
00DF29  2  D0 03                BNE     *+5
00DF2B  2  EE AC E3             INC     dirnum+1
00DF2E  2  AD D0 E3             LDA     maxdir          ;if not at limit continue
00DF31  2  CD AB E3             CMP     dirnum
00DF34  2  AD D1 E3             LDA     maxdir+1
00DF37  2  ED AC E3             SBC     dirnum+1
00DF3A  2  B0 05                BCS     gtnxdr          ;then continue
00DF3C  2  68                   PLA                     ;else clear stack
00DF3D  2  AA                   TAX                     ;and set x
00DF3E  2  4C DC DF             JMP     cldrnm          ;set to invalid
00DF41  2               gtnxdr:
00DF41  2  AD AB E3             LDA     dirnum          ;get low again
00DF44  2  29 03                AND     #%00000011      ;look at 2 lsbs
00DF46  2  8D B7 E3             STA     dirmod          ;save mod 4
00DF49  2  0A                   ASL     a               ;multiply
00DF4A  2  0A                   ASL     a               ;by
00DF4B  2  0A                   ASL     a               ;32 to
00DF4C  2  0A                   ASL     a               ;get pointer
00DF4D  2  0A                   ASL     a               ;offset
00DF4E  2  8D AD E3             STA     subrec          ;and save
00DF51  2  F0 05                BEQ     getdir          ;if zero read new
00DF53  2  68                   PLA                     ;else clear stack
00DF54  2  AA                   TAX                     ;set x
00DF55  2  4C 60 DF             JMP     gotdir          ;and exit
00DF58  2               getdir:
00DF58  2  20 8E DC             JSR     drrcsu          ;set up to read
00DF5B  2  20 3B E0             JSR     rdesec          ;do read
00DF5E  2  68                   PLA                     ;get operation
00DF5F  2  AA                   TAX                     ;code
00DF60  2               ;;;;;;	jsr	chksop		;do it
00DF60  2               gotdir:
00DF60  2  AD B7 E3             LDA     dirmod          ;and return
00DF63  2               exnxdr:
00DF63  2  60                   RTS                     ;with number
00DF64  2               ;checksum operation
00DF64  2               ;this routine assumes calling routine has checked for
00DF64  2               ;valid dirnum and hence valid dirrec
00DF64  2               ; input:chkflg,dirrec,x (1=update else check)
00DF64  2               ; returns:none
00DF64  2               ; alters:map@(chkmap)
00DF64  2               chksop:
00DF64  2  2C D4 E3             BIT     chkflg          ;check flag
00DF67  2  30 FA                BMI     exnxdr          ;done if set
00DF69  2  CA                   DEX                     ;dec code
00DF6A  2  D0 09                BNE     tstchk          ;if not zero test
00DF6C  2  20 7E DD             JSR     clcchk          ;else calculate
00DF6F  2  20 C6 DF             JSR     clcckp          ;calculate pointer
00DF72  2  91 08                STA     (chkpnt),y      ;and save
00DF74  2  60                   RTS                     ;then return
00DF75  2               tstchk:
00DF75  2  20 7E DD             JSR     clcchk          ;do calculation
00DF78  2  20 C6 DF             JSR     clcckp          ;calculate pointer
00DF7B  2  D1 08                CMP     (chkpnt),y      ;compare to old
00DF7D  2  F0 E4                BEQ     exnxdr          ;if equal ok
00DF7F  2  4C 71 DD             JMP     setron          ;else set to r/o
00DF82  2               ;get block number
00DF82  2               ; input:nxtrec,blmode,fcb@(addinp),sxb,exm
00DF82  2               ; returns:none
00DF82  2               ; alters:all,blknum
00DF82  2               getblk:
00DF82  2  AE C2 E3             LDX     sxb             ;set x according to blkscd
00DF85  2  AD B3 E3             LDA     nxtrec          ;get next record
00DF88  2               gblp:
00DF88  2  4A                   LSR     a               ;divide by 2 x times
00DF89  2  CA                   DEX
00DF8A  2  D0 FC                BNE     gblp
00DF8C  2  8D AE E3             STA     blknum          ;save previous as temp
00DF8F  2               ;use extent as offset but first use sxb to create param
00DF8F  2  38                   SEC
00DF90  2  A9 08                LDA     #8
00DF92  2  ED C2 E3             SBC     sxb
00DF95  2  AA                   TAX
00DF96  2               ;now get extent from fcb
00DF96  2  A0 0C                LDY     #12
00DF98  2  B1 02                LDA     (addinp),y
00DF9A  2  2D D8 E3             AND     exm             ;and with mask
00DF9D  2  4A                   LSR     a               ;shift with lsb to c
00DF9E  2               gbxlp:
00DF9E  2  2A                   ROL     a               ;now go other way
00DF9F  2  CA                   DEX
00DFA0  2  D0 FC                BNE     gbxlp
00DFA2  2  18                   CLC                     ;now add saved value
00DFA3  2  6D AE E3             ADC     blknum          ;back
00DFA6  2  2C BE E3             BIT     blmode          ;test mode
00DFA9  2  10 01                BPL     *+3             ;skip if byte
00DFAB  2  0A                   ASL     a               ;else times two
00DFAC  2  18                   CLC                     ;then add
00DFAD  2  69 10                ADC     #16             ;offset into fcb
00DFAF  2  8D 8F E3             STA     fcbind          ;save for later
00DFB2  2  A8                   TAY                     ;set index
00DFB3  2  B1 02                LDA     (addinp),y      ;get number
00DFB5  2  8D AE E3             STA     blknum          ;store
00DFB8  2  C8                   INY
00DFB9  2  A9 00                LDA     #0              ;clear
00DFBB  2  2C BE E3             BIT     blmode          ;test mode
00DFBE  2  10 02                BPL     *+4             ;skip if byte
00DFC0  2  B1 02                LDA     (addinp),y      ;else get high
00DFC2  2  8D AF E3             STA     blknum+1        ;high byte
00DFC5  2  60                   RTS                     ;and return
00DFC6  2               ;calculate chkpnt as function of dirrec and chkmap
00DFC6  2               ; input:dirrec,chkmap
00DFC6  2               ; returns:y=0
00DFC6  2               ; alters:y,p,chkpnt
00DFC6  2               clcckp:
00DFC6  2  48                   PHA                     ;save a
00DFC7  2  18                   CLC
00DFC8  2  AD B5 E3             LDA     dirrec          ;add record number
00DFCB  2  6D D5 E3             ADC     chkmap          ;to start
00DFCE  2  85 08                STA     chkpnt
00DFD0  2  AD B6 E3             LDA     dirrec+1
00DFD3  2  6D D6 E3             ADC     chkmap+1
00DFD6  2  85 09                STA     chkpnt+1
00DFD8  2  A0 00                LDY     #0
00DFDA  2  68                   PLA                     ;get a back
00DFDB  2  60                   RTS
00DFDC  2               ;clear directory number to $ffff
00DFDC  2               ; input:none
00DFDC  2               ; returns:a=$ff,n=1,z=0
00DFDC  2               ; alters:a,p,dirnum,dirmod
00DFDC  2               cldrnm:
00DFDC  2  A9 FF                LDA     #$ff            ;set to $ff
00DFDE  2  8D AB E3             STA     dirnum
00DFE1  2  8D AC E3             STA     dirnum+1
00DFE4  2  8D B7 E3             STA     dirmod
00DFE7  2  60                   RTS
00DFE8  2               ;change allocation map
00DFE8  2               ; input:subrec,directory record @ (bufadd)
00DFE8  2               ; returns:none
00DFE8  2               ; alters:all,allocation map
00DFE8  2               mapdir:
00DFE8  2  18                   CLC                     ;add 16 to
00DFE9  2  AD AD E3             LDA     subrec          ;to subrec to point
00DFEC  2  69 10                ADC     #16             ;to block number field
00DFEE  2  A8                   TAY                     ;make index
00DFEF  2               lpmpdr:
00DFEF  2  8C BC E3             STY     mpdrsy          ;save index
00DFF2  2  8A                   TXA                     ;save x
00DFF3  2  48                   PHA                     ;operation
00DFF4  2  B1 04                LDA     (bufadd),y      ;get block number
00DFF6  2  8D BD E3             STA     mpdrtm          ;save in temp
00DFF9  2  C8                   INY                     ;bump index for word
00DFFA  2  20 7C E0             JSR     gthibn          ;get high part of number
00DFFD  2               mpdrnw:
00DFFD  2  0D BD E3             ORA     mpdrtm          ;see if zero
00E000  2  F0 0A                BEQ     skpedr          ;skip if zero
00E002  2  20 7C E0             JSR     gthibn          ;get high again
00E005  2  A8                   TAY                     ;move to y
00E006  2  AD BD E3             LDA     mpdrtm          ;get low again
00E009  2  20 5B DD             JSR     altalc          ;else alter map
00E00C  2               skpedr:
00E00C  2  68                   PLA                     ;get operation
00E00D  2  AA                   TAX                     ;back
00E00E  2  AC BC E3             LDY     mpdrsy          ;get index back
00E011  2  C8                   INY                     ;bump it
00E012  2  98                   TYA                     ;if still
00E013  2  29 0F                AND     #%00001111      ;in field
00E015  2  D0 D8                BNE     lpmpdr          ;then loop
00E017  2  60                   RTS                     ;else quit
00E018  2               ;test r/w status
00E018  2               ;does warm boot if r/o
00E018  2               ; input:curdrv,ronlst
00E018  2               ; returns:none
00E018  2               ; alters:a,x,p
00E018  2               tstron:
00E018  2  20 89 DD             JSR     chkron          ;test bit
00E01B  2  F0 1D                BEQ     exttro          ;exit if r/w
00E01D  2  20 6A E0             JSR     errout          ;else send error
00E020  2  AD EA E2             LDA     rommvc          ;point to r/o
00E023  2  AC EB E2             LDY     rommvc+1        ;message
00E026  2  20 CE E0             JSR     sndstr          ;send it
00E029  2  4C EE D8             JMP     xwboot          ;then abort
00E02C  2               ;set current drive to r/w
00E02C  2               ; input:curdrv,ronlst
00E02C  2               ; returns:ronlst
00E02C  2               ; alters:a,x,p,ronlst
00E02C  2               setrw:
00E02C  2  AE A8 E3             LDX     curdrv          ;get drive
00E02F  2  BD 7E E3             LDA     bitmap,x        ;and mask
00E032  2  49 FF                EOR     #$ff            ;complement
00E034  2  2D AA E3             AND     ronlst          ;and with status
00E037  2  8D AA E3             STA     ronlst          ;save
00E03A  2               exttro:
00E03A  2  60                   RTS                     ;return
00E03B  2               ;read sector
00E03B  2               rdesec:
00E03B  2  20 93 E4             JSR     sim+39          ;do read
00E03E  2               
00E03E  2  4C 4D E0             JMP     chkrwe          ;check for error
00E041  2               ;update checksum and directory
00E041  2               updtck:
00E041  2  A2 01                LDX     #1              ;set for update
00E043  2               ;;;;;	jsr	chksop		;do it
00E043  2  A9 01                LDA     #1              ;say is directory op
00E045  2  D0 03                BNE     secwrt          ;do it
00E047  2               ;write sector
00E047  2               wrtsec:
00E047  2  AD D7 E3             LDA     pemwrtype       ;get write type
00E04A  2               secwrt:
00E04A  2  20 96 E4             JSR     sim+42          ;do write
00E04D  2               
00E04D  2               chkrwe:
00E04D  2  C9 00                CMP     #0              ;if not ok
00E04F  2  F0 E9                BEQ     exttro          ;done if zero
00E051  2               ;read/write error
00E051  2               rwerrt:
00E051  2  20 6A E0             JSR     errout          ;send error message
00E054  2  AD ED E2             LDA     bdsmvc          ;point to
00E057  2  AC EE E2             LDY     bdsmvc+1        ;bad sector message
00E05A  2  20 CE E0             JSR     sndstr          ;and send
00E05D  2  20 89 E0             JSR     getcon          ;get input
00E060  2  C9 0D                CMP     #cr             ;if a cr
00E062  2  F0 03                BEQ     ignerr          ;then continue
00E064  2  4C EE D8             JMP     xwboot          ;else abort
00E067  2               ignerr:
00E067  2  4C 65 E2             JMP     pcrlf           ;crlf and return
00E06A  2               ;error output routine
00E06A  2               ; input:curdrv,pemmvc
00E06A  2               ; returns:none
00E06A  2               ; alters:all
00E06A  2               errout:
00E06A  2  AD F0 E2             LDA     pemmvc          ;point to
00E06D  2  AC F1 E2             LDY     pemmvc+1        ;error message
00E070  2  20 CE E0             JSR     sndstr          ;send it
00E073  2  AD A8 E3             LDA     curdrv          ;get drive number
00E076  2  18                   CLC                     ;add
00E077  2  69 41                ADC     #'A'            ;ascii a
00E079  2  4C 17 E1             JMP     sndchr          ;and send it
00E07C  2               ;get high part of block number if word (zero if byte)
00E07C  2               ; input:y=index to high,blmode,directory@(bufadd)+subrec
00E07C  2               ; returns:a=high part of block number
00E07C  2               ; alters:a,p,mpdrsy iff word
00E07C  2               gthibn:
00E07C  2  A9 00                LDA     #0              ;preset for byte
00E07E  2  2C BE E3             BIT     blmode          ;test mode
00E081  2  10 05                BPL     gthiex          ;done if byte
00E083  2  B1 04                LDA     (bufadd),y      ;get high
00E085  2  8C BC E3             STY     mpdrsy          ;alter y
00E088  2               gthiex:
00E088  2  60                   RTS
00E089  2               ;get console input
00E089  2               ; input:pndkey
00E089  2               ; returns:a=character
00E089  2               ; alters:all,pndkey
00E089  2               getcon:
00E089  2  AD 92 E3             LDA     pndkey          ;get pending
00E08C  2  48                   PHA                     ;save it
00E08D  2  A9 00                LDA     #0              ;clear
00E08F  2  8D 92 E3             STA     pndkey          ;pending
00E092  2  68                   PLA                     ;restore
00E093  2  D0 03                BNE     extget          ;exit if not null
00E095  2  20 75 E4             JSR     sim+9           ;else get new
00E098  2               
00E098  2               extget:
00E098  2  60                   RTS                     ;and return
00E099  2               ;check keyboard status
00E099  2               ;handles <ctl-s> for freeze and <ctl-c> for boot
00E099  2               ; input:pndkey
00E099  2               ; returns:a=0 if no input or <>0 if input
00E099  2               ; alters:all,pndkey
00E099  2               kbdsts:
00E099  2  AD 92 E3             LDA     pndkey          ;get pending
00E09C  2  D0 20                BNE     extkbd          ;if there quit
00E09E  2  20 72 E4             JSR     sim+6           ;else test
00E0A1  2  C9 00                CMP     #$00            ;if zero
00E0A3  2  F0 19                BEQ     extkbd          ;exit
00E0A5  2  20 75 E4             JSR     sim+9           ;else get input
00E0A8  2  C9 13                CMP     #ctls           ;if not freeze
00E0AA  2  D0 0D                BNE     newpnd          ;save input
00E0AC  2  20 75 E4             JSR     sim+9           ;else wait for more
00E0AF  2  C9 03                CMP     #ctlc           ;if not abort
00E0B1  2  D0 03                BNE     nowarm          ;then jump
00E0B3  2  4C EE D8             JMP     xwboot          ;else do warm boot
00E0B6  2               nowarm:
00E0B6  2  A9 00                LDA     #0              ;clear
00E0B8  2  60                   RTS                     ;and return
00E0B9  2               newpnd:
00E0B9  2  8D 92 E3             STA     pndkey          ;save
00E0BC  2  A9 FF                LDA     #$ff            ;set ready
00E0BE  2               extkbd:
00E0BE  2  60                   RTS                     ;and return
00E0BF  2               ;test character
00E0BF  2               ; input:a=character
00E0BF  2               ; returns:c=0 if control or c=1 if printing
00E0BF  2               ; alters:p
00E0BF  2               tstchr:
00E0BF  2  C9 0D                CMP     #cr             ;if cr
00E0C1  2  F0 0A                BEQ     chtext          ;quit
00E0C3  2  C9 0A                CMP     #lf             ;if linefeed
00E0C5  2  F0 06                BEQ     chtext          ;quit
00E0C7  2  C9 09                CMP     #ctli           ;if tab
00E0C9  2  F0 02                BEQ     chtext          ;quit
00E0CB  2  C9 20                CMP     #' '            ;see if control
00E0CD  2               chtext:
00E0CD  2  60                   RTS                     ;and return
00E0CE  2               ;send string ending in $
00E0CE  2               ; input:ay=string address
00E0CE  2               ; returns:none
00E0CE  2               ; alters:all,index,sndlpe+1 and +2
00E0CE  2               sndstr:
00E0CE  2  8D D7 E0             STA     sndlpe+1        ;set pointer
00E0D1  2  8C D8 E0             STY     sndlpe+2
00E0D4  2  A0 00                LDY     #0
00E0D6  2               sndlpe:
00E0D6  2  B9 FF FF             LDA     $ffff,y         ;get char
00E0D9  2  C9 24                CMP     #'$'            ;if terminator
00E0DB  2  F0 0C                BEQ     sndext          ;then exit
00E0DD  2  C8                   INY                     ;else bump
00E0DE  2  8C B8 E3             STY     index           ;and save
00E0E1  2  20 17 E1             JSR     sndchr          ;send char
00E0E4  2  AC B8 E3             LDY     index           ;get index
00E0E7  2  D0 ED                BNE     sndlpe          ;and loop
00E0E9  2               sndext:
00E0E9  2  60                   RTS                     ;return
00E0EA  2               ;send char to printer if enabled
00E0EA  2               ; input:a=character,lstflg
00E0EA  2               ; returns:a=character
00E0EA  2               ; alters:x,y,p
00E0EA  2               lstout:
00E0EA  2  2C 93 E3             BIT     lstflg          ;test flag
00E0ED  2  10 0A                BPL     extlst          ;exit if off
00E0EF  2  2C BA E3             BIT     outflg          ;test output flag
00E0F2  2  30 05                BMI     extlst          ;done if set
00E0F4  2  48                   PHA                     ;save char
00E0F5  2  20 7B E4             JSR     sim+15          ;send
00E0F8  2  68                   PLA                     ;get char
00E0F9  2               extlst:
00E0F9  2  60                   RTS                     ;and done
00E0FA  2               ;output a character
00E0FA  2               ; input:a=character,console definition block in sim
00E0FA  2               ; returns:none
00E0FA  2               ; alters:all,positn
00E0FA  2               output:
00E0FA  2  20 BF E0             JSR     tstchr          ;test it
00E0FD  2  B0 18                BCS     sndchr          ;if not control jump
00E0FF  2  48                   PHA                     ;else save
00E100  2  AD A6 E4             LDA     sysdef+4        ;get invert
00E103  2  20 30 E1             JSR     nolist          ;send to console
00E106  2  A9 5E                LDA     #'^'            ;get arrow
00E108  2  20 EA E0             JSR     lstout          ;send to printer
00E10B  2  68                   PLA                     ;get character
00E10C  2  09 40                ORA     #'A'-1          ;convert to ascii
00E10E  2  20 28 E1             JSR     pchrot          ;send to all
00E111  2  AD A5 E4             LDA     sysdef+3        ;get normal
00E114  2  4C 30 E1             JMP     nolist          ;to console
00E117  2               sndchr:
00E117  2  C9 09                CMP     #ctli           ;if not tab
00E119  2  D0 0D                BNE     pchrot          ;send
00E11B  2               tabspc:
00E11B  2  A9 20                LDA     #' '            ;else get space
00E11D  2  20 28 E1             JSR     pchrot          ;send
00E120  2  AD 94 E3             LDA     positn          ;get count
00E123  2  29 07                AND     #7              ;if not mod 8
00E125  2  D0 F4                BNE     tabspc          ;loop
00E127  2  60                   RTS                     ;else exit
00E128  2               pchrot:
00E128  2  48                   PHA                     ;save char
00E129  2  20 99 E0             JSR     kbdsts          ;test input
00E12C  2  68                   PLA                     ;restore
00E12D  2  20 EA E0             JSR     lstout          ;to printer if on
00E130  2               nolist:
00E130  2  48                   PHA                     ;save again
00E131  2  2C BA E3             BIT     outflg          ;test flag
00E134  2  30 03                BMI     *+5             ;done if set
00E136  2  20 78 E4             JSR     sim+12          ;to console
00E139  2  68                   PLA                     ;restore
00E13A  2  EE 94 E3             INC     positn          ;bump col
00E13D  2  C9 20                CMP     #' '            ;if space or more
00E13F  2  B0 26                BCS     extchr          ;is ok
00E141  2  CD A4 E4             CMP     sysdef+2        ;also ok
00E144  2  F0 21                BEQ     extchr          ;if forward
00E146  2  CE 94 E3             DEC     positn          ;else drop back
00E149  2  CD A2 E4             CMP     sysdef+0        ;see if bs
00E14C  2  D0 06                BNE     tryotr          ;branch if not
00E14E  2  CE 94 E3             DEC     positn          ;else drop again
00E151  2  30 0F                BMI     zrocol          ;zero if <0
00E153  2  60                   RTS                     ;else ok
00E154  2               tryotr:
00E154  2  C9 0D                CMP     #cr             ;if a cr
00E156  2  F0 0A                BEQ     zrocol          ;clear col
00E158  2  CD A9 E4             CMP     sysdef+7        ;if a formfeed
00E15B  2  F0 05                BEQ     zrocol          ;also clear
00E15D  2  CD AA E4             CMP     sysdef+8        ;if not home
00E160  2  D0 05                BNE     extchr          ;then done
00E162  2               zrocol:
00E162  2  A9 00                LDA     #0              ;clear
00E164  2  8D 94 E3             STA     positn          ;column
00E167  2               extchr:
00E167  2  60                   RTS                     ;and exit
00E168  2               ;go to left and space past prompt
00E168  2               ; input:frscol,positn
00E168  2               ; returns:none
00E168  2               ; alters:positn
00E168  2               spcovr:
00E168  2  A9 0D                LDA     #cr             ;get cr
00E16A  2  20 28 E1             JSR     pchrot          ;send to all
00E16D  2  A9 0A                LDA     #lf             ;send lf
00E16F  2  20 EA E0             JSR     lstout          ;only to printer
00E172  2               mreovr:
00E172  2  AD 91 E3             LDA     frscol          ;get first
00E175  2  CD 94 E3             CMP     positn          ;see if there
00E178  2  F0 ED                BEQ     extchr          ;done if is
00E17A  2  AD A4 E4             LDA     sysdef+2        ;get forward
00E17D  2  20 30 E1             JSR     nolist          ;send it
00E180  2  4C 72 E1             JMP     mreovr          ;and loop
00E183  2               ;buffered read
00E183  2               ; input:buffer@(addinp)
00E183  2               ; returns:none
00E183  2               ; alters:all,buffer@(addinp)
00E183  2               bufinp:
00E183  2  A9 00                LDA     #0              ;clear
00E185  2  A0 01                LDY     #1              ;length
00E187  2  91 02                STA     (addinp),y      ;position in buffer
00E189  2  8C 9B E3             STY     bufpsn          ;set point to 1
00E18C  2  AD 94 E3             LDA     positn          ;get current
00E18F  2  8D 91 E3             STA     frscol          ;and save
00E192  2               nxtinp:
00E192  2  20 89 E0             JSR     getcon          ;get input
00E195  2  AC 9B E3             LDY     bufpsn          ;get index
00E198  2  C9 0D                CMP     #cr             ;if not a cr
00E19A  2  D0 03                BNE     notcr           ;then jump
00E19C  2  4C 62 E2             JMP     endlin          ;else done
00E19F  2               notcr:
00E19F  2  C9 08                CMP     #delete         ;if not delete
00E1A1  2  D0 5E                BNE     ntdelt          ;then jump
00E1A3  2  C0 01                CPY     #1              ;else if start
00E1A5  2  F0 EB                BEQ     nxtinp          ;then loop
00E1A7  2  B1 02                LDA     (addinp),y      ;get last
00E1A9  2  48                   PHA                     ;save char
00E1AA  2  A0 01                LDY     #1              ;point to count
00E1AC  2  38                   SEC                     ;set carry
00E1AD  2  B1 02                LDA     (addinp),y      ;get count
00E1AF  2  E9 01                SBC     #1              ;decrement
00E1B1  2  91 02                STA     (addinp),y      ;then save
00E1B3  2  68                   PLA                     ;restore char
00E1B4  2  CE 9B E3             DEC     bufpsn          ;backup pointer
00E1B7  2  C9 20                CMP     #' '            ;if space or more
00E1B9  2  B0 40                BCS     nrmbs           ;just backspace
00E1BB  2  C9 09                CMP     #ctli           ;see if tab
00E1BD  2  D0 30                BNE     ctlbs           ;if not is control
00E1BF  2  38                   SEC                     ;set flag
00E1C0  2  6E BA E3             ROR     outflg
00E1C3  2  AD 94 E3             LDA     positn          ;get position and save
00E1C6  2  8D BB E3             STA     lstcol
00E1C9  2  20 68 E1             JSR     spcovr          ;else go back
00E1CC  2  20 6F E2             JSR     rptlne          ;and retype
00E1CF  2  AD 94 E3             LDA     positn          ;get new last position
00E1D2  2  48                   PHA                     ;save on stack
00E1D3  2  38                   SEC                     ;subtract to get delta
00E1D4  2  AD BB E3             LDA     lstcol
00E1D7  2  ED 94 E3             SBC     positn
00E1DA  2  8D BB E3             STA     lstcol          ;and save
00E1DD  2  0E BA E3             ASL     outflg          ;clear flag
00E1E0  2               bstab:
00E1E0  2  20 8F E2             JSR     dobs            ;do one
00E1E3  2  CE BB E3             DEC     lstcol          ;drop count
00E1E6  2  D0 F8                BNE     bstab           ;loop if more
00E1E8  2  68                   PLA                     ;get position
00E1E9  2  8D 94 E3             STA     positn          ;and set
00E1EC  2  4C 92 E1             JMP     nxtinp          ;then loop
00E1EF  2               ctlbs:
00E1EF  2  AD A5 E4             LDA     sysdef+3        ;get normal
00E1F2  2  20 8B E2             JSR     chkbs           ;bs if printing
00E1F5  2  AD A6 E4             LDA     sysdef+4        ;same for invert
00E1F8  2  20 8B E2             JSR     chkbs           ;then delete char itself
00E1FB  2               nrmbs:
00E1FB  2  20 8F E2             JSR     dobs            ;do a backspace
00E1FE  2  4C 92 E1             JMP     nxtinp          ;and loop
00E201  2               ntdelt:
00E201  2  C9 10                CMP     #ctlp           ;if not ctl-p
00E203  2  D0 0B                BNE     ntctlp          ;then jump
00E205  2  AD 93 E3             LDA     lstflg          ;else get printer flag
00E208  2  49 FF                EOR     #$ff            ;complement
00E20A  2  8D 93 E3             STA     lstflg          ;save
00E20D  2  4C 92 E1             JMP     nxtinp          ;and loop
00E210  2               ntctlp:
00E210  2  C9 18                CMP     #ctlx           ;if not ctl-x
00E212  2  D0 0C                BNE     ntctlx          ;then jump
00E214  2  20 68 E1             JSR     spcovr          ;restart
00E217  2  AD A3 E4             LDA     sysdef+1        ;get clear to eol
00E21A  2  20 30 E1             JSR     nolist          ;send it
00E21D  2  4C 83 E1             JMP     bufinp          ;and start over
00E220  2               ntctlx:
00E220  2  C9 12                CMP     #ctlr           ;if not ctl-r
00E222  2  D0 09                BNE     ntctlr          ;then jump
00E224  2  20 68 E1             JSR     spcovr          ;restart
00E227  2  20 6F E2             JSR     rptlne          ;retype line
00E22A  2  4C 92 E1             JMP     nxtinp          ;and start over
00E22D  2               ntctlr:
00E22D  2  C8                   INY                     ;next position
00E22E  2  91 02                STA     (addinp),y      ;store char
00E230  2  48                   PHA                     ;and save
00E231  2  8C 9B E3             STY     bufpsn          ;index
00E234  2  A0 01                LDY     #1              ;point to count
00E236  2  98                   TYA                     ;set a to 1
00E237  2  18                   CLC                     ;then
00E238  2  71 02                ADC     (addinp),y      ;add count
00E23A  2  91 02                STA     (addinp),y      ;and save
00E23C  2  68                   PLA                     ;restore char
00E23D  2               dontsv:
00E23D  2  20 FA E0             JSR     output          ;send char
00E240  2  AC 9B E3             LDY     bufpsn          ;get index
00E243  2  B1 02                LDA     (addinp),y      ;get char
00E245  2  C9 03                CMP     #ctlc           ;if not ctl-c
00E247  2  D0 0B                BNE     ignrcc          ;ignore
00E249  2  A0 01                LDY     #1              ;get count
00E24B  2  B1 02                LDA     (addinp),y      ;from buffer
00E24D  2  C9 01                CMP     #1              ;if not at start
00E24F  2  D0 03                BNE     ignrcc          ;ignore
00E251  2  4C EE D8             JMP     xwboot          ;else do warm boot
00E254  2               ignrcc:
00E254  2  A0 01                LDY     #1              ;get
00E256  2  B1 02                LDA     (addinp),y      ;count
00E258  2  88                   DEY                     ;point to max
00E259  2  D1 02                CMP     (addinp),y      ;if length
00E25B  2  B0 03                BCS     lineen          ;at max jump
00E25D  2  4C 92 E1             JMP     nxtinp          ;else loop
00E260  2               lineen:
00E260  2  A9 0D                LDA     #cr             ;get a cr
00E262  2               endlin:
00E262  2  4C 28 E1             JMP     pchrot          ;and send
00E265  2               ;cr and lf
00E265  2               pcrlf:
00E265  2  A9 0D                LDA     #cr             ;then a
00E267  2  20 28 E1             JSR     pchrot          ;cr
00E26A  2  A9 0A                LDA     #lf             ;and a
00E26C  2  4C 28 E1             JMP     pchrot          ;lf
00E26F  2               ;retype line
00E26F  2               rptlne:
00E26F  2  AD 9B E3             LDA     bufpsn          ;save point
00E272  2  8D B9 E3             STA     numcnt          ;as count
00E275  2  A9 01                LDA     #1              ;start position
00E277  2  48                   PHA                     ;save
00E278  2               mrerpt:
00E278  2  68                   PLA                     ;get position
00E279  2  CE B9 E3             DEC     numcnt          ;count down
00E27C  2  D0 01                BNE     *+3             ;continue if more
00E27E  2  60                   RTS                     ;else done
00E27F  2  A8                   TAY                     ;else make index
00E280  2  C8                   INY                     ;and bump
00E281  2  98                   TYA                     ;save
00E282  2  48                   PHA                     ;on stack
00E283  2  B1 02                LDA     (addinp),y      ;get char
00E285  2  20 FA E0             JSR     output          ;send
00E288  2  4C 78 E2             JMP     mrerpt          ;and loop
00E28B  2               ;check for printing and backspace if needed
00E28B  2               chkbs:
00E28B  2  C9 20                CMP     #' '            ;compare to space
00E28D  2  90 19                BCC     extdec          ;not printing so done
00E28F  2               ;do a backspace
00E28F  2               dobs:
00E28F  2  AD A2 E4             LDA     sysdef+0        ;get backspace
00E292  2  48                   PHA                     ;save it
00E293  2  20 30 E1             JSR     nolist          ;send
00E296  2  A9 20                LDA     #' '            ;get space
00E298  2  20 30 E1             JSR     nolist          ;send
00E29B  2  68                   PLA                     ;get backspace
00E29C  2  4C 30 E1             JMP     nolist          ;send it
00E29F  2               ;test for decimal digit
00E29F  2               ;if decimal then c=0 else c=1
00E29F  2               tstdec:
00E29F  2  C9 30                CMP     #'0'            ;if under 0
00E2A1  2  90 04                BCC     notdec          ;then not decimal
00E2A3  2  C9 3A                CMP     #'9'+1          ;if 9 or under is ok
00E2A5  2  90 01                BCC     extdec
00E2A7  2               notdec:
00E2A7  2  38                   SEC                     ;else not a match
00E2A8  2               extdec:
00E2A8  2  60                   RTS
00E2A9  2               ;test for hexadecimal digit
00E2A9  2               ;if hex then c=0 else c=1
00E2A9  2               tsthex:
00E2A9  2  20 9F E2             JSR     tstdec          ;first try decimal
00E2AC  2  90 FA                BCC     extdec          ;ok if dec
00E2AE  2  C9 41                CMP     #'A'            ;if under A
00E2B0  2  90 F5                BCC     notdec          ;then not hex
00E2B2  2  C9 47                CMP     #'F'+1          ;set c in F compare
00E2B4  2  60                   RTS
00E2B5  2               ;bump load address by 128 and return in ay
00E2B5  2               adjdb:
00E2B5  2  AD F7 D7             LDA     dskbuf          ;get old
00E2B8  2  AC F8 D7             LDY     dskbuf+1        ;address
00E2BB  2  18                   CLC                     ;and bump
00E2BC  2  69 80                ADC     #128            ;by 128
00E2BE  2  8D F7 D7             STA     dskbuf          ;save low
00E2C1  2  90 04                BCC     *+6             ;then bump
00E2C3  2  C8                   INY                     ;and save
00E2C4  2  8C F8 D7             STY     dskbuf+1        ;high as needed
00E2C7  2  60                   RTS
00E2C8  2               ;move record from disk buffer to default buffer
00E2C8  2               mv128:
00E2C8  2  AD F7 D7             LDA     dskbuf          ;get address
00E2CB  2  AC F8 D7             LDY     dskbuf+1
00E2CE  2  8D D7 E2             STA     mvfrom+1        ;and set pointer
00E2D1  2  8C D8 E2             STY     mvfrom+2
00E2D4  2  A2 00                LDX     #0              ;clear index
00E2D6  2               mvfrom:
00E2D6  2  BD FF FF             LDA     $ffff,x         ;get byte
00E2D9  2  9D 28 01             STA     dflbuf,x        ;move it
00E2DC  2  E8                   INX
00E2DD  2  10 F7                BPL     mvfrom          ;loop until done
00E2DF  2  60                   RTS
00E2E0  2               
00E2E0  2               ;relocatable vectors
00E2E0  2  4C                   .BYTE   $4c
00E2E1  2               extevc:
00E2E1  2  4D D8                .WORD   extexq-1
00E2E3  2  4C                   .BYTE   $4c
00E2E4  2               sltmvc:
00E2E4  2  40 E3                .WORD   sltmsg
00E2E6  2  4C                   .BYTE   $4c
00E2E7  2               empdvc:
00E2E7  2  51 E3                .WORD   empty
00E2E9  2  4C                   .BYTE   $4c
00E2EA  2               rommvc:
00E2EA  2  F6 E2                .WORD   romsg
00E2EC  2  4C                   .BYTE   $4c
00E2ED  2               bdsmvc:
00E2ED  2  FD E2                .WORD   bdsmsg
00E2EF  2  4C                   .BYTE   $4c
00E2F0  2               pemmvc:
00E2F0  2  30 E3                .WORD   pemmsg
00E2F2  2  4C                   .BYTE   $4c
00E2F3  2               dcbevc:
00E2F3  2  C9 E3                .WORD   dcb
00E2F5  2               ;relocation stopper
00E2F5  2  FF                   .BYTE   $ff
00E2F6  2               ;messages
00E2F6  2               romsg:
00E2F6  2  20 2D 20 52          .BYTE   " - R/O$"
00E2FA  2  2F 4F 24     
00E2FD  2               bdsmsg:
00E2FD  2  20 2D 20 42          .BYTE   " - BAD SECTOR"
00E301  2  41 44 20 53  
00E305  2  45 43 54 4F  
00E30A  2  0D 0A 3C 52          .BYTE   cr,lf,"<RET> TO IGNORE -- <OTHER> "
00E30E  2  45 54 3E 20  
00E312  2  54 4F 20 49  
00E327  2  54 4F 20 41          .BYTE   "TO ABORT$"
00E32B  2  42 4F 52 54  
00E32F  2  24           
00E330  2               pemmsg:
00E330  2  0D 0A 50 45          .BYTE   cr,lf,"PEM ERROR ON $"
00E334  2  4D 20 45 52  
00E338  2  52 4F 52 20  
00E340  2               sltmsg:
00E340  2  20 2D 20 49          .BYTE   " - INVALID DRIVE$"
00E344  2  4E 56 41 4C  
00E348  2  49 44 20 44  
00E351  2               
00E351  2               ;dummy fcb
00E351  2               empty:
00E351  2  E5                   .BYTE   $e5
00E352  2               ;zero page switch enable table
00E352  2               swctbl:
00E352  2  00 00 00 00          .BYTE   0,0,0,0,0,0,0,0
00E356  2  00 00 00 00  
00E35A  2  00 00 01 00          .BYTE   0,0,1,0,0,1,1,1
00E35E  2  00 01 01 01  
00E362  2  01 01 01 01          .BYTE   1,1,1,1,1,1,1,1
00E366  2  01 01 01 01  
00E36A  2  00 00 01 00          .BYTE   0,0,1,0,0,0,0,0
00E36E  2  00 00 00 00  
00E372  2  00 00 00 00          .BYTE   0,0,0,0
00E376  2               ;bit mask table
00E376  2               bitmsk:
00E376  2  80 40 20 10          .BYTE   128,64,32,16,8,4,2,1
00E37A  2  08 04 02 01  
00E37E  2               ;bit map table
00E37E  2               bitmap:
00E37E  2  01 02 04 08          .BYTE   1,2,4,8,16,32,64,128
00E382  2  10 20 40 80  
00E386  2               ;extent mask table (also uses 3 bytes in sabtbl
00E386  2               exmtbl:
00E386  2  00 01 03             .BYTE   0,1,3
00E389  2               ;sab table
00E389  2               sabtbl:
00E389  2  07 0F 1F 3F          .BYTE   7,15,31,63,127
00E38D  2  7F           
00E38E  2               ;variable storage
00E38E  2               skpdir:
00E38E  2  00                   .BYTE   0               ;positive if no change
00E38F  2               fcbind:
00E38F  2  00                   .BYTE   0               ;index to block number
00E390  2               savext:
00E390  2  00                   .BYTE   0               ;save extent
00E391  2               frscol:
00E391  2  00                   .BYTE   0               ;first col
00E392  2               pndkey:
00E392  2  00                   .BYTE   0               ;pending input
00E393  2               lstflg:
00E393  2  00                   .BYTE   0               ;printer flag
00E394  2               positn:
00E394  2  00                   .BYTE   0               ;print position
00E395  2               swcflg:
00E395  2  00                   .BYTE   0               ;zero page switch flag
00E396  2               bytinp:
00E396  2  00 00                .WORD   0               ;input value
00E398  2               cmdinp:
00E398  2  00                   .BYTE   0               ;input command
00E399  2               addout:
00E399  2  00 00                .WORD   0               ;output address
00E39B  2               bytout          = addout        ;output value
00E39B  2               bufpsn:
00E39B  2  00                   .BYTE   0               ;input buffer position
00E39C  2               exrwfl:
00E39C  2  00                   .BYTE   0               ;extend flag
00E39D  2               tmpdrv:
00E39D  2  00                   .BYTE   0               ;temporary drive number
00E39E  2               ;align xqtvec on word boundary
00E39E  2                       .ALIGN  2
00E39E  2               xqtvec:
00E39E  2  00 00                .WORD   0               ;command vector
00E3A0  2               countr:
00E3A0  2  00 00                .WORD   0               ;record counter
00E3A2  2  00                   .BYTE   0               ;overflow
00E3A3  2               lkdown:
00E3A3  2  00 00                .WORD   0               ;down pnt. for block search
00E3A5  2               lookup:
00E3A5  2  00 00                .WORD   0               ;up pnt. for block search
00E3A7  2               olddrv:
00E3A7  2  00                   .BYTE   0               ;old drive number
00E3A8  2               curdrv:
00E3A8  2  00                   .BYTE   0               ;current drive
00E3A9  2               lginvc:
00E3A9  2  00                   .BYTE   0               ;log in status
00E3AA  2               ronlst:
00E3AA  2  00                   .BYTE   0               ;read write status
00E3AB  2               dirnum:
00E3AB  2  00 00                .WORD   0               ;directory number
00E3AD  2               subrec:
00E3AD  2  00                   .BYTE   0               ;directory offset
00E3AE  2               recnum:
00E3AE  2  00 00                .WORD   0               ;record number
00E3B0  2               blknum          = recnum        ;block number
00E3B0  2  00                   .BYTE   0               ;overflow
00E3B1  2               chrcnt:
00E3B1  2  00                   .BYTE   0               ;character count
00E3B2  2               cmppnt:
00E3B2  2  00                   .BYTE   0               ;comparison pointer
00E3B3  2               nxtrec:
00E3B3  2  00                   .BYTE   0               ;next record
00E3B4  2               numrec:
00E3B4  2  00                   .BYTE   0               ;number records
00E3B5  2               dirrec:
00E3B5  2  00 00                .WORD   0               ;directory record
00E3B7  2               dirmod:
00E3B7  2  00                   .BYTE   0               ;directory mod 4
00E3B8  2               index:
00E3B8  2  00                   .BYTE   0               ;buffer index
00E3B9  2               numcnt:
00E3B9  2  00                   .BYTE   0               ;counter
00E3BA  2               outflg:
00E3BA  2  00                   .BYTE   0               ;output enable flag
00E3BB  2               lstcol:
00E3BB  2  00                   .BYTE   0               ;last column
00E3BC  2               mpdrsy:
00E3BC  2  00                   .BYTE   0               ;save for y in mapdir
00E3BD  2               mpdrtm:
00E3BD  2  00                   .BYTE   0               ;temp in mapdir
00E3BE  2               blmode:
00E3BE  2  00                   .BYTE   0               ;<128 if byte else word
00E3BF  2               maxdrc:
00E3BF  2  00 00                .WORD   0               ;max directory record
00E3C1  2               sab:
00E3C1  2  00                   .BYTE   0               ;mask for block
00E3C2  2               sxb:
00E3C2  2  00                   .BYTE   0               ;shift for block
00E3C3  2               rtclk:
00E3C3  2  00 00 00             .BYTE   0,0,0           ;real time clock
00E3C6  2               gpcnt:
00E3C6  2  00 00                .WORD   0               ;gp counter
00E3C8  2               trkctr:
00E3C8  2  00                   .BYTE   0               ;track counter
00E3C9  2               ;following region is used to capture dcb
00E3C9  2               dcb:
00E3C9  2               maxblk:
00E3C9  2  00 00                .WORD   0               ;maximum block number
00E3CB  2               sectrk:
00E3CB  2  00 00                .WORD   0               ;sectors per track
00E3CD  2               nsystr:
00E3CD  2  00 00                .WORD   0               ;number system tracks
00E3CF  2               blkscd:
00E3CF  2  00                   .BYTE   0               ;block size code
00E3D0  2               maxdir:
00E3D0  2  00 00                .WORD   0               ;maximum directory number
00E3D2  2               alcmap:
00E3D2  2  00 00                .WORD   0               ;address of allocation map
00E3D4  2               chkflg:
00E3D4  2  00                   .BYTE   0               ;check flag
00E3D5  2               chkmap:
00E3D5  2  00 00                .WORD   0               ;address of checksum map
00E3D7  2               pemwrtype:
00E3D7  2  00                   .BYTE   0               ;write type 0=norm,1=dir,2=unalloc
00E3D8  2               exm:
00E3D8  2  00                   .BYTE   0               ;extent mask
00E3D9  2               cexm1f:
00E3D9  2  00                   .BYTE   0               ;exm complemented and 1f
00E3DA  2               ;zero page save block
00E3DA  2               varblk:
00E3DA  2               lowin:
00E3DA  2  00 00                .WORD   0
00E3DC  2  00 00                .WORD   0               ;save bufadd
00E3DE  2  00 00                .WORD   0               ;save alcpnt
00E3E0  2  00 00                .WORD   0               ;save chkpnt
00E3E2  2               
00E3E2  1                       .INCLUDE "simnhy.asm"
00E3E2  2               ;________________________________________________________________________________________________________________________________
00E3E2  2               ;
00E3E2  2               ; Nhyodyne dos / 65 system interface module (sim)
00E3E2  2               ;
00E3E2  2               ; DWERNER 12 / 20 / 2021 ported to Nhyodyne
00E3E2  2               ;________________________________________________________________________________________________________________________________
00E3E2  2               
00E3E2  2                       .INCLUDE "MACRO.ASM"
00E3E2  3               ;__MACRO___________________________________________________________________________________________________________________
00E3E2  3               ;
00E3E2  3               ; 	Macros for the betterment of Mankind
00E3E2  3               ;________________________________________________________________________________________________________________________________
00E3E2  3               ;
00E3E2  3               
00E3E2  3               .macro          PRTDBG      message
00E3E2  3               .LOCAL p1
00E3E2  3               .LOCAL p2
00E3E2  3               .LOCAL p3
00E3E2  3               .LOCAL p4
00E3E2  3               .LOCAL p5
00E3E2  3                 .if     .paramcount <> 1
00E3E2  3                       .error  "Too few parameters for macro PRTDBG"
00E3E2  3                       .endif
00E3E2  3                       .if DEBUG=1
00E3E2  3                       PHA
00E3E2  3                       txa
00E3E2  3                       PHa
00E3E2  3                       tya
00E3E2  3                       PHa
00E3E2  3                       LDX #$00
00E3E2  3               p1:
00E3E2  3                       LDA p4,x
00E3E2  3                       INX
00E3E2  3                       CMP #'$'
00E3E2  3                       BEQ p2
00E3E2  3                       JSR conwrt
00E3E2  3                       JMP p1
00E3E2  3               p2:
00E3E2  3                       LDA #13
00E3E2  3                       jsr conwrt
00E3E2  3                       LDA #10
00E3E2  3                       jsr conwrt
00E3E2  3                       PLA
00E3E2  3                       tay
00E3E2  3                       PLA
00E3E2  3                       tax
00E3E2  3                       pla
00E3E2  3                       JMP p5
00E3E2  3               p4:
00E3E2  3                       .BYTE message
00E3E2  3               p5:
00E3E2  3                       .endif
00E3E2  3               .endmacro
00E3E2  3               
00E3E2  3               .macro          PRTS      message
00E3E2  3               .LOCAL p1
00E3E2  3               .LOCAL p2
00E3E2  3               .LOCAL p3
00E3E2  3               .LOCAL p4
00E3E2  3               .LOCAL p5
00E3E2  3                 .if     .paramcount <> 1
00E3E2  3                       .error  "Too few parameters for macro PRTS"
00E3E2  3                       .endif
00E3E2  3                       PHA
00E3E2  3                       txa
00E3E2  3                       PHa
00E3E2  3                       tya
00E3E2  3                       PHa
00E3E2  3                       LDX #$00
00E3E2  3               p1:
00E3E2  3                       LDA p4,x
00E3E2  3                       INX
00E3E2  3                       CMP #'$'
00E3E2  3                       BEQ p2
00E3E2  3                       JSR conwrt
00E3E2  3                       JMP p1
00E3E2  3               p2:
00E3E2  3                       PLa
00E3E2  3                       tay
00E3E2  3                       pla
00E3E2  3                       tax
00E3E2  3                       pla
00E3E2  3                       JMP p5
00E3E2  3               p4:
00E3E2  3                       .BYTE message
00E3E2  3               p5:
00E3E2  3               .endmacro
00E3E2  3               
00E3E2  3               
00E3E2  3               
00E3E2  3               
00E3E2  3               ;__PRTHEXBYTE__________________________________________________
00E3E2  3               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
00E3E2  3               ;______________________________________________________________
00E3E2  3               PRTHEXBYTE:
00E3E2  3  48                   PHA
00E3E3  3  85 3A                sta     STACKA
00E3E5  3  8A                   TXA
00E3E6  3  48                   PHa
00E3E7  3  98                   tya
00E3E8  3  48                   PHA
00E3E9  3  A5 3A                LDA     STACKA
00E3EB  3  AA                   TAX				; SAVE A REGISTER
00E3EC  3  4A                   LSR 				; SHIFT HIGH NIBBLE TO LOW NIBBLE
00E3ED  3  4A                   LSR 				;
00E3EE  3  4A                   LSR 				;
00E3EF  3  4A                   LSR 				;
00E3F0  3  18                   CLC               		; CLEAR CARRY
00E3F1  3  20 FE E3             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
00E3F4  3  8A                   TXA				; RESTORE ACCUMULATOR
00E3F5  3  20 FE E3             JSR PRINT_DIGIT			; PRINT LOW NIBBLE
00E3F8  3  68                   PLa
00E3F9  3  A8                   TAY
00E3FA  3  68                   plA
00E3FB  3  AA                   TAX
00E3FC  3  68                   PLA
00E3FD  3  60                   RTS
00E3FE  3               
00E3FE  3               ;__PRINT_DIGIT_________________________________________________
00E3FE  3               ;
00E3FE  3               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
00E3FE  3               ;
00E3FE  3               ;______________________________________________________________
00E3FE  3               PRINT_DIGIT:
00E3FE  3  29 0F                       AND #$0F				; STRIP OFF HIGH NIBBLE
00E400  3  09 30                       ORA #$30				; ADD $30 TO PRODUCE ASCII
00E402  3  C9 3A                       CMP #$3A               		; IS GREATER THAN 9
00E404  3  30 03                       BMI PRINT_DIGIT_OUT		; NO, SKIP ADD
00E406  3  18                          CLC				; CLEAR CARRY
00E407  3  69 07                       ADC #$07				; ADD ON FOR LETTER VALUES
00E409  3               PRINT_DIGIT_OUT:					;
00E409  3  4C 1E E7                    JMP conwrt              		; PRINT OUT CHAR
00E40C  3               
00E40C  3               NEWLINE:
00E40C  3  48                           pha
00E40D  3  8A                           TXA
00E40E  3  48                           PHA
00E40F  3  98                           TYA
00E410  3  48                           phA
00E411  3  A9 0D                        LDA #$0D
00E413  3  20 1E E7                     JSR conwrt
00E416  3  A9 0A                        LDA #$0A
00E418  3  20 1E E7                     Jsr conwrt
00E41B  3  68                           pla
00E41C  3  A8                           TAY
00E41D  3  68                           pla
00E41E  3  AA                           TAX
00E41F  3  68                           pla
00E420  3  60                           rts
00E421  3               
00E421  3               PRTDEC:
00E421  3  85 3A                        STA             STACKA
00E423  3  98                           TYA
00E424  3  48                           phA
00E425  3  8A                           TXA
00E426  3  48                           PHa
00E427  3  A5 3A                        LDA             STACKA
00E429  3  48                           PHA
00E42A  3  A0 00                        ldy #00
00E42C  3  A2 FF                        LDX #$FF
00E42E  3  38                           SEC
00E42F  3               PrDec100:
00E42F  3  E8                           INX
00E430  3  E9 64                        SBC #100
00E432  3  B0 FB                        BCS PrDec100            ;Count how many 100s
00E434  3  69 64                        ADC #100
00E436  3  20 56 E4                     JSR PrDecDigit          ;Print the 100s
00E439  3  A2 FF                        LDX #$FF
00E43B  3  38                           SEC                     ;Prepare for subtraction
00E43C  3               PrDec10:
00E43C  3  E8                           INX
00E43D  3  E9 0A                        SBC #10
00E43F  3  B0 FB                        BCS PrDec10             ;Count how many 10s
00E441  3  69 0A                        ADC #10
00E443  3  20 56 E4                     JSR PrDecDigit          ;Print the 10s
00E446  3  AA                           TAX                     ;Pass 1s into X
00E447  3  A0 01                        ldy #1
00E449  3  20 56 E4                     JSR PrDecDigit          ;Print the 1s
00E44C  3  68                           PLA
00E44D  3  85 3A                        STA STACKA
00E44F  3  68                           PLa
00E450  3  AA                           TAX
00E451  3  68                           pla
00E452  3  A8                           TAY
00E453  3  A5 3A                        LDA     STACKA
00E455  3  60                           RTS
00E456  3               PrDecDigit:
00E456  3  48                           PHA
00E457  3  C0 00                        cpy #$00
00E459  3  D0 09                        bne PrDecDigit1
00E45B  3  8A                           txa
00E45C  3  A8                           tay
00E45D  3  C0 00                        cpy #$00
00E45F  3  D0 03                        bne PrDecDigit1
00E461  3  4C 6A E4                     jmp PrDecDigit2
00E464  3               PrDecDigit1:
00E464  3  8A                           TXA                     ;Save A, pass digit to A
00E465  3  09 30                        ORA #'0'
00E467  3  20 1E E7                     JSR  conwrt             ;Convert to character and print it
00E46A  3               PrDecDigit2:
00E46A  3  68                           PLA
00E46B  3  60                           RTS                     ;Restore A and return
00E46C  3               
00E46C  2               DO_FARCALL      = farcall - md_pagecode + $0200
00E46C  2               
00E46C  2               ;dos / 65 system interface module (sim)
00E46C  2               ;version 3.00
00E46C  2               ;this version is designed to work with the N8VEM Host Processor
00E46C  2               
00E46C  2               ;fixed parameters
00E46C  2               simstart:
00E46C  2               
00E46C  2               ;my system i / o routines in rom
00E46C  2               nsects          = (simstart - ccm) / 128;number sectors
00E46C  2               
00E46C  2               ;main program
00E46C  2               ;jump vector used by pem
00E46C  2               sim:
00E46C  2  4C C8 E5             JMP     boot            ;from cold start
00E46F  2               wboote:
00E46F  2  4C 70 E6             JMP     wboot           ;from warm boot
00E472  2  4C 10 E7             JMP     consts          ;check for input
00E475  2  4C 17 E7             JMP     conrde          ;get input
00E478  2  4C 1E E7             JMP     conwrt          ;send to terminal
00E47B  2  4C 27 E7             JMP     prnwrt          ;printer output
00E47E  2  4C 28 E7             JMP     punwrt          ;punch output
00E481  2  4C 29 E7             JMP     rdrinp          ;reader input
00E484  2  4C 99 E6             JMP     home            ;home drive
00E487  2  4C 78 E6             JMP     seldsk          ;select disk
00E48A  2  4C 9D E6             JMP     seltrk          ;set track
00E48D  2  4C A5 E6             JMP     selsec          ;set sector
00E490  2  4C 0B E7             JMP     setdma          ;set buffer address
00E493  2  4C AC E6             JMP     read            ;read sector
00E496  2  4C DF E6             JMP     write           ;write sector
00E499  2  A9 01                LDA     #1              ;printer always ready
00E49B  2  60                   RTS
00E49C  2  4C 2A E7             JMP     rdtime          ;clock entry
00E49F  2  4C 2B E7             JMP     xlate           ;translate
00E4A2  2               
00E4A2  2               ;console definition block
00E4A2  2               sysdef:
00E4A2  2  08                   .BYTE   8               ;backspace
00E4A3  2  01                   .BYTE   1               ;clear to end of line
00E4A4  2  0C                   .BYTE   $c              ;forward space
00E4A5  2  00                   .BYTE   0               ;normal video
00E4A6  2  5E                   .BYTE   '^'             ;invert video
00E4A7  2  18                   .BYTE   24              ;lines per screen
00E4A8  2  50                   .BYTE   80              ;char per line
00E4A9  2  0C                   .BYTE   $c              ;formfeed
00E4AA  2  1E                   .BYTE   $1e             ;home
00E4AB  2  02                   .BYTE   2               ;clear to end of screen
00E4AC  2               
00E4AC  2               ;opening id message
00E4AC  2               opnmsg:
00E4AC  2  0D 0A                .BYTE   cr, lf
00E4AE  2               
00E4AE  2  64 38 38 38          .BYTE   "d8888b.  .d88b.  .d8888.    dD     ooooo", cr, lf
00E4B2  2  38 62 2E 20  
00E4B6  2  20 2E 64 38  
00E4D8  2  38 38 20 20          .BYTE   "88  `8D .8P  Y8. 88'  YP   d8'    8P~~~~", cr, lf
00E4DC  2  60 38 44 20  
00E4E0  2  2E 38 50 20  
00E502  2  38 38 20 20          .BYTE   "88   88 88    88 `8bo.    d8'    dP", cr, lf
00E506  2  20 38 38 20  
00E50A  2  38 38 20 20  
00E527  2  38 38 20 20          .BYTE   "88   88 88    88   `Y8b. d8888b. V8888b.", cr, lf,0
00E52B  2  20 38 38 20  
00E52F  2  38 38 20 20  
00E552  2               opnmsg1:
00E552  2  38 38 20 20          .BYTE   "88  .8D `8b  d8' db   8D 88' `8D     `8D ", cr, lf
00E556  2  2E 38 44 20  
00E55A  2  60 38 62 20  
00E57D  2  59 38 38 38          .BYTE   "Y8888D'  `Y88P'  `8888Y' `8888P  88oobY'", cr, lf
00E581  2  38 44 27 20  
00E585  2  20 60 59 38  
00E5A7  2  11 44 4F 53          .BYTE   17, "DOS / 65 ON THE NHYODYNE 3.00", cr, lf, 0
00E5AB  2  20 2F 20 36  
00E5AF  2  35 20 4F 4E  
00E5C8  2               
00E5C8  2               
00E5C8  2               ;cold entry from loader
00E5C8  2               boot:
00E5C8  2  78                   SEI                     ; DISABLE INTERRUPTS
00E5C9  2  A2 FF                LDX     #$ff            ;set stack
00E5CB  2  9A                   TXS                     ;pointer
00E5CC  2  D8                   CLD                     ;set binary mode
00E5CD  2               
00E5CD  2  20 BB E8             JSR     PAGER_INIT      ;setup paging for device drivers
00E5D0  2               
00E5D0  2                       PRTDBG  "OS Starting$"
00E5D0  2               
00E5D0  2  A9 AC                LDA     #<opnmsg        ;point to message
00E5D2  2  A0 E4                LDY     #>opnmsg
00E5D4  2  20 2C E7             JSR     outmsg          ;send it
00E5D7  2  A9 52                LDA     #<opnmsg1
00E5D9  2  A0 E5                LDY     #>opnmsg1
00E5DB  2  20 2C E7             JSR     outmsg          ;send it
00E5DE  2               
00E5DE  2  20 0C E4             JSR     NEWLINE
00E5E1  2               
00E5E1  2               ; setup diskconfig table
00E5E1  2  A2 00                LDX     #0
00E5E3  2               @2:
00E5E3  2  BD 74 F2             LDA     dftdskcfg, x
00E5E6  2  9D 14 05             STA     dskcfg, x
00E5E9  2  E8                   INX
00E5EA  2  E0 10                CPX     #$10
00E5EC  2  D0 F5                BNE     @2
00E5EE  2               
00E5EE  2                       PRTDBG  "DISK CFG TABLE COPIED$"
00E5EE  2               
00E5EE  2  A9 00                LDA     #0              ;set zero
00E5F0  2  20 78 E6             JSR     seldsk          ;and select drive zero
00E5F3  2               
00E5F3  2  A9 16                LDA     #22             ;MD_SHOW
00E5F5  2  85 32                STA     farfunct
00E5F7  2  20 6B 02             JSR     DO_FARCALL
00E5FA  2               
00E5FA  2  A9 19                LDA     #25             ;FD_INIT
00E5FC  2  85 32                STA     farfunct
00E5FE  2  20 6B 02             JSR     DO_FARCALL
00E601  2               
00E601  2  A9 04                LDA     #04             ;PPIDE_INIT
00E603  2  85 32                STA     farfunct
00E605  2  20 6B 02             JSR     DO_FARCALL
00E608  2               
00E608  2                       .IF     USEDSKYNG=1 || USEDSKY=1
00E608  2  A9 07                    LDA     #07             ;DSKY_INIT
00E60A  2  85 32                    STA     farfunct
00E60C  2  20 6B 02                 JSR     DO_FARCALL
00E60F  2               
00E60F  2  A2 00                    LDX     #$00
00E611  2               @1:
00E611  2  BD 87 E9                 LDA     DOS65DSKYINIT, X
00E614  2  9D 00 05                 STA     DSKY_BUF, X
00E617  2  E8                       INX
00E618  2  E0 08                    CPX     #8
00E61A  2  D0 F5                    BNE     @1
00E61C  2  A9 08                    LDA     #08             ;DSKY_SHOW
00E61E  2  85 32                    STA     farfunct
00E620  2  20 6B 02                 JSR     DO_FARCALL
00E623  2               
00E623  2  A9 0D                    LDA     #13             ;DSKY_BEEP
00E625  2  85 32                    STA     farfunct
00E627  2  20 6B 02                 JSR     DO_FARCALL
00E62A  2               .ENDIF
00E62A  2               
00E62A  2  A9 47                    LDA     #<cnstxt        ; STORE POINTER TO COMMAND LINE
00E62C  2  85 30                    STA     cmdlnp
00E62E  2  A9 D7                    LDA     #>cnstxt
00E630  2  85 31                    STA     cmdlnp + 1
00E632  2               
00E632  2  A9 14                    LDA     #<dskcfg        ; STORE POINTER TO DISK CONFIG TABLE FOR APPS
00E634  2  85 2E                    STA     dskcfpc
00E636  2  A9 05                    LDA     #>dskcfg
00E638  2  85 2F                    STA     dskcfpc + 1
00E63A  2  20 69 E7                 JSR     DSPL_DSK_CFG    ; DISPLAY DISK CONFIG TO USERS
00E63D  2               
00E63D  2               
00E63D  2               ;set up jumps into dos / 65 in page one
00E63D  2               setup:
00E63D  2  20 BB E8                 JSR     PAGER_INIT
00E640  2  A2 00                    LDX     #0              ;clear index
00E642  2               ;first clear key dba variables
00E642  2  8E 02 EA                 STX     hstact          ;host buffer inactive
00E645  2  8E 03 EA                 STX     unacnt          ;clear unalloc count
00E648  2               setupl:
00E648  2  BD 6A E6                 LDA     inttbl, x       ;get byte
00E64B  2  9D 00 01                 STA     $100, x         ;insert at start
00E64E  2  E8                       INX
00E64F  2  E0 06                    CPX     #6
00E651  2  D0 F5                    BNE     setupl          ;loop until done
00E653  2  A9 28                    LDA     #<dflbuf        ;get low buffer
00E655  2  A0 01                    LDY     #>dflbuf        ;and high
00E657  2  20 0B E7                 JSR     setdma          ;and set
00E65A  2  AD 13 05                 LDA     sekdsk          ;get disk
00E65D  2               
00E65D  2  A9 02                    LDA     #DEFDRV         ;set zero
00E65F  2  20 78 E6                 JSR     seldsk          ;and select drive zero
00E662  2  20 99 E6                 JSR     home            ;home that drive
00E665  2               
00E665  2                           PRTDBG  "Start CCM$"
00E665  2  A9 02                    LDA     #DEFDRV         ;set zero
00E667  2  4C 06 D0                 JMP     ccm             ;and go to ccm
00E66A  2               ;initialization table
00E66A  2               inttbl:
00E66A  2  4C 6F E4 4C              .BYTE   $4c, <wboote, >wboote, $4c, <pem, >pem
00E66E  2  02 D8        
00E670  2               ;warm boot - read dos / 65 back except sim and then
00E670  2               ; jump to ccm.
00E670  2               
00E670  2               
00E670  2               wboot:
00E670  2  78                       SEI                     ; DISABLE INTERRUPTS
00E671  2  A2 FF                    LDX     #$ff            ;set stack
00E673  2  9A                       TXS                     ;pointer
00E674  2  D8                       CLD                     ;set binary mode
00E675  2               
00E675  2  4C 3D E6                 JMP     setup           ;go setup
00E678  2               
00E678  2               
00E678  2               
00E678  2               ;__SELDSK_________________________________________________________________________________________________
00E678  2               ;
00E678  2               ; PERFORM DOS / 65 DISK DRIVE SELECT
00E678  2               ;________________________________________________________________________________________________________
00E678  2               ;select disk
00E678  2               seldsk:
00E678  2  29 07                    AND     #7              ;three lsbs only
00E67A  2  8D 13 05                 STA     sekdsk          ;save for later
00E67D  2  AD 13 05                 LDA     sekdsk          ;save for later
00E680  2  0A                       ASL     a               ;multiply by two
00E681  2  AA                       TAX                     ;make an Index
00E682  2  BD 89 E6                 LDA     dcbtbl, x       ;get address
00E685  2  BC 8A E6                 LDY     dcbtbl + 1, x
00E688  2  60                       RTS
00E689  2               
00E689  2               ;table of dcb addresses
00E689  2               dcbtbl:
00E689  2  8F E9                    .WORD   dcba            ; A
00E68B  2  9D E9                    .WORD   dcbb            ; B
00E68D  2  AB E9                    .WORD   dcbc            ; C
00E68F  2  B9 E9                    .WORD   dcbd            ; D
00E691  2  C7 E9                    .WORD   dcbe            ; E
00E693  2  D5 E9                    .WORD   dcbf            ; F
00E695  2  E3 E9                    .WORD   dcbg            ; G
00E697  2  F1 E9                    .WORD   dcbh            ; H
00E699  2               
00E699  2               ;__HOME__________________________________________________________________________________________________
00E699  2               ;
00E699  2               ; PERFORM DOS / 65 HEAD HOME
00E699  2               ;________________________________________________________________________________________________________
00E699  2               home:
00E699  2  A9 00                    LDA     #$00
00E69B  2  A0 00                    LDY     #$00
00E69D  2               
00E69D  2               ;__SELTRK________________________________________________________________________________________________
00E69D  2               ;
00E69D  2               ; PERFORM DOS / 65 SELECT TRACK
00E69D  2               ;
00E69D  2               ; A=TRACK LOW BYTE
00E69D  2               ; Y=TRACK HIGH BYTE
00E69D  2               ;________________________________________________________________________________________________________
00E69D  2               seltrk:
00E69D  2  18                       CLC
00E69E  2  8D 0C 05                 STA     sektrk          ;save number
00E6A1  2  8C 0D 05                 STY     sektrk + 1
00E6A4  2  60                       RTS
00E6A5  2               
00E6A5  2               ;__SELSEC________________________________________________________________________________________________
00E6A5  2               ;
00E6A5  2               ; PERFORM DOS / 65 SECTOR SELECT
00E6A5  2               ;
00E6A5  2               ; A=SECTOR LOW BYTE
00E6A5  2               ; Y=SECTOR HIGH BYTE
00E6A5  2               ;________________________________________________________________________________________________________
00E6A5  2               selsec:
00E6A5  2  8D 0E 05                 STA     seksec          ;save low and high
00E6A8  2  8C 0F 05                 STY     seksec + 1
00E6AB  2  60                       RTS
00E6AC  2               
00E6AC  2               ;__READ__________________________________________________________________________________________________
00E6AC  2               ;
00E6AC  2               ; PERFORM DOS / 65 SECTOR READ
00E6AC  2               ;________________________________________________________________________________________________________
00E6AC  2               read:
00E6AC  2  20 40 E7                 JSR     GET_DRIVE_DEVICE;
00E6AF  2  29 F0                    AND     #$F0            ; only want first nybble
00E6B1  2  C9 00                    CMP     #$00
00E6B3  2  D0 0A                    BNE     :+              ; not MD drive
00E6B5  2               ;RAM
00E6B5  2  A9 14                    LDA     #20             ;MD_READ_SECTOR
00E6B7  2  85 32                    STA     farfunct
00E6B9  2  20 6B 02                 JSR     DO_FARCALL
00E6BC  2  4C 48 E9                 JMP     MOVEBUFTODMA
00E6BF  2               :
00E6BF  2  C9 20                    CMP     #$20
00E6C1  2  D0 0B                    BNE     :+              ; not floppy drive
00E6C3  2               ;FD
00E6C3  2  A9 17                    LDA     #23             ;FD_READ_SECTOR
00E6C5  2  85 32                    STA     farfunct
00E6C7  2  20 6B 02                 JSR     DO_FARCALL
00E6CA  2  4C 48 E9                 JMP     MOVEBUFTODMA
00E6CD  2  60                       RTS                     ;
00E6CE  2               :
00E6CE  2  C9 30                    CMP     #$30
00E6D0  2  D0 0A                    BNE     :+              ; invalid drive
00E6D2  2               ;PPIDE
00E6D2  2  A9 05                    LDA     #05             ;IDE_READ_SECTOR
00E6D4  2  85 32                    STA     farfunct
00E6D6  2  20 6B 02                 JSR     DO_FARCALL
00E6D9  2  4C 48 E9                 JMP     MOVEBUFTODMA
00E6DC  2               :
00E6DC  2  A9 FF                    LDA     #$FF            ; signal error
00E6DE  2  60                       RTS                     ;
00E6DF  2               
00E6DF  2               
00E6DF  2               ;__WRITE_________________________________________________________________________________________________
00E6DF  2               ;
00E6DF  2               ; PERFORM DOS / 65 SECTOR WRITE
00E6DF  2               ;________________________________________________________________________________________________________
00E6DF  2               write:
00E6DF  2  20 40 E7                 JSR     GET_DRIVE_DEVICE;
00E6E2  2  20 5E E9                 JSR     MOVEDMATOBUF
00E6E5  2               
00E6E5  2  29 F0                    AND     #$F0            ; only want first nybble
00E6E7  2               
00E6E7  2  C9 00                    CMP     #$00
00E6E9  2  D0 07                    BNE     :+              ; not MD Drive
00E6EB  2               ;MD
00E6EB  2  A9 15                    LDA     #21             ;MD_WRITE_SECTOR
00E6ED  2  85 32                    STA     farfunct
00E6EF  2  4C 6B 02                 JMP     DO_FARCALL
00E6F2  2               :
00E6F2  2  C9 20                    CMP     #$20
00E6F4  2  D0 07                    BNE     :+              ; not floppy drive
00E6F6  2               ;FD
00E6F6  2  A9 18                    LDA     #24             ;FD_WRITE_SECTOR
00E6F8  2  85 32                    STA     farfunct
00E6FA  2  4C 6B 02                 JMP     DO_FARCALL
00E6FD  2               :
00E6FD  2  C9 30                    CMP     #$30
00E6FF  2  D0 07                    BNE     writex          ; not ppide
00E701  2               ;PPIDE
00E701  2  A9 06                    LDA     #06             ;IDE_WRITE_SECTOR
00E703  2  85 32                    STA     farfunct
00E705  2  4C 6B 02                 JMP     DO_FARCALL
00E708  2               writex:
00E708  2  A9 FF                    LDA     #$FF            ; signal error
00E70A  2  60                       RTS                     ;
00E70B  2               
00E70B  2               
00E70B  2               ;__SETDMA________________________________________________________________________________________________
00E70B  2               ;
00E70B  2               ; PERFORM DOS / 65 BUFFER ADDRESS SELECTION
00E70B  2               ;
00E70B  2               ; A=BUFFER LOW BYTE
00E70B  2               ; Y=BUFFER HIGH BYTE
00E70B  2               ;________________________________________________________________________________________________________
00E70B  2               setdma:
00E70B  2  85 F4                    STA     dmaadr          ;store low
00E70D  2  84 F5                    STY     dmaadr + 1      ;and high
00E70F  2  60                       RTS
00E710  2               
00E710  2               
00E710  2               ;__CONSTS________________________________________________________________________________________________
00E710  2               ;
00E710  2               ; GET DOS / 65 CONSOLE STATUS
00E710  2               ;________________________________________________________________________________________________________
00E710  2               consts:
00E710  2  A9 03                    LDA     #03
00E712  2  85 32                    STA     farfunct
00E714  2  4C 6B 02                 JMP     DO_FARCALL
00E717  2               
00E717  2               ;__CONRDE________________________________________________________________________________________________
00E717  2               ;
00E717  2               ; PERFORM DOS / 65 CONSOLE READ
00E717  2               ;________________________________________________________________________________________________________
00E717  2               conrde:
00E717  2  A9 02                    LDA     #02
00E719  2  85 32                    STA     farfunct
00E71B  2  4C 6B 02                 JMP     DO_FARCALL
00E71E  2               
00E71E  2               
00E71E  2               ;__CONWRT________________________________________________________________________________________________
00E71E  2               ;
00E71E  2               ; PERFORM DOS / 65 CONSOLE WRITE
00E71E  2               ;________________________________________________________________________________________________________
00E71E  2               conwrt:
00E71E  2  48                       PHA
00E71F  2  A9 00                    LDA     #00
00E721  2  85 32                    STA     farfunct
00E723  2  68                       PLA
00E724  2  4C 6B 02                 JMP     DO_FARCALL
00E727  2               
00E727  2               prnwrt:
00E727  2  60                       RTS                     ;printer
00E728  2               punwrt:
00E728  2  60                       RTS                     ;punch output
00E729  2               rdrinp:
00E729  2  60                       RTS                     ;reader input
00E72A  2               rdtime:
00E72A  2  60                       RTS                     ;read clock
00E72B  2               xlate:
00E72B  2  60                       RTS                     ;sector translate
00E72C  2               
00E72C  2               
00E72C  2               ;__OUTMSG________________________________________________________________________________________________
00E72C  2               ;
00E72C  2               ; WRITE A NULL TERMINATED STRING TO THE CONSOLE
00E72C  2               ;
00E72C  2               ; A=POINTER LOW BYTE
00E72C  2               ; Y=POINTER HIGH BYTE
00E72C  2               ;________________________________________________________________________________________________________
00E72C  2               outmsg:     ;output message
00E72C  2  85 F0                    STA     OUTMSG_W
00E72E  2  84 F1                    STY     OUTMSG_W + 1
00E730  2  A0 00                    LDY     #$00
00E732  2               OUTSTRLP:
00E732  2  B1 F0                    LDA     (OUTMSG_W), Y   ; LOAD NEXT CHAR FROM STRING INTO ACC
00E734  2  C9 00                    CMP     #$00            ; IS NULL?
00E736  2  F0 07                    BEQ     ENDOUTSTR       ; YES, END PRINT OUT
00E738  2  20 1E E7                 JSR     conwrt          ; PRINT CHAR IN ACC
00E73B  2  C8                       INY                     ; Y=Y + 1 (BUMP INDEX)
00E73C  2  4C 32 E7                 JMP     OUTSTRLP        ; DO NEXT CHAR
00E73F  2               ENDOUTSTR:
00E73F  2  60                       RTS                     ; RETURN
00E740  2               
00E740  2               ;___GET_DRIVE_DEVICE_____________________________________________________________________________________
00E740  2               ;
00E740  2               ; GET SELECTED DEVICE TYPE AND UNIT, RETURN IN "A"
00E740  2               ;
00E740  2               ;________________________________________________________________________________________________________
00E740  2               GET_DRIVE_DEVICE:
00E740  2  8A                       TXA
00E741  2  48                       PHA
00E742  2  AD 13 05                 LDA     sekdsk          ; GET DRIVE
00E745  2  29 07                    AND     #7              ; ONLY FIRST 8 DEVICES SUPPORTED
00E747  2  0A                       ASL     a               ; DOUBLE NUMBER FOR TABLE LOOKUP
00E748  2  AA                       TAX                     ; MOVE TO X REGISTER
00E749  2  BD 14 05                 LDA     dskcfg, X       ; GET device
00E74C  2               ; SETUP FLOPPY CONTROL WHILE WE ARE HERE
00E74C  2  29 01                    AND     #$01
00E74E  2  C9 00                    CMP     #$00
00E750  2  D0 08                    BNE     :+
00E752  2  A9 10                    LDA     #%00010000
00E754  2  8D 25 05                 STA     DSKUNIT
00E757  2  4C 5F E7                 JMP     GET_DRIVE_DEVICE_1
00E75A  2               :
00E75A  2  A9 21                    LDA     #%00100001
00E75C  2  8D 25 05                 STA     DSKUNIT
00E75F  2               GET_DRIVE_DEVICE_1:
00E75F  2  BD 14 05                 LDA     dskcfg, X       ; GET device
00E762  2  85 3A                    STA     STACKA
00E764  2  68                       PLA
00E765  2  AA                       TAX
00E766  2  A5 3A                    LDA     STACKA
00E768  2  60                       RTS
00E769  2               
00E769  2               ;___DSPL_DSK_CFG_________________________________________________________________________________________
00E769  2               ;
00E769  2               ; DISPLAY THE DISK CONFIGURATION FOR THE USER
00E769  2               ;
00E769  2               ;________________________________________________________________________________________________________
00E769  2               DSPL_DSK_CFG:
00E769  2  20 0C E4                 JSR     NEWLINE
00E76C  2  48 8A 48 98              PRTS    "DISK   Configuration:$"
00E770  2  48 A2 00 BD  
00E774  2  89 E7 E8 C9  
00E79F  2  20 0C E4                 JSR     NEWLINE
00E7A2  2  A2 00                    LDX     #0
00E7A4  2               DSPL_DSK_CFG_1:
00E7A4  2  48 8A 48 98              PRTS    " $"            ; MAKE IT PRETTY :)
00E7A8  2  48 A2 00 BD  
00E7AC  2  C1 E7 E8 C9  
00E7C3  2  8A                       TXA
00E7C4  2  4A                       LSR     A
00E7C5  2  18                       CLC
00E7C6  2  69 41                    ADC     #'A'
00E7C8  2  20 1E E7                 JSR     conwrt
00E7CB  2  A9 3A                    LDA     #':'
00E7CD  2  20 1E E7                 JSR     conwrt
00E7D0  2  A9 3D                    LDA     #'='
00E7D2  2  20 1E E7                 JSR     conwrt
00E7D5  2  20 ED E7                 JSR     prtdevice       ; PRINT DEVICE NAME FROM TABLE (X)
00E7D8  2  A9 3A                    LDA     #':'
00E7DA  2  20 1E E7                 JSR     conwrt
00E7DD  2  E8                       INX                     ; WANT SECOND BYTE OF ENTRY
00E7DE  2  BD 14 05                 LDA     dskcfg, x       ; GET SLICE
00E7E1  2  20 21 E4                 JSR     PRTDEC          ; PRINT SLICE IN DECIMAL (A)
00E7E4  2  E8                       INX
00E7E5  2  20 0C E4                 JSR     NEWLINE
00E7E8  2  E0 10                    CPX     #16
00E7EA  2  D0 B8                    BNE     DSPL_DSK_CFG_1
00E7EC  2  60                       RTS
00E7ED  2               
00E7ED  2               ; DEVICE TABLE:
00E7ED  2               ; $00 MD
00E7ED  2               ; $2x FLOPPY
00E7ED  2               ; $3x IDE
00E7ED  2               prtdevice:
00E7ED  2  BD 14 05                 LDA     dskcfg, X       ; GET DEVICE TYPE
00E7F0  2  48                       PHA
00E7F1  2  29 F0                    AND     #$F0            ; FILTER OUT UNIT
00E7F3  2  C9 00                    CMP     #$00
00E7F5  2  D0 23                    BNE     prtdevice1
00E7F7  2  48 8A 48 98              PRTS    "MD$"
00E7FB  2  48 A2 00 BD  
00E7FF  2  14 E8 E8 C9  
00E817  2  4C B4 E8                 JMP     prtdevice_done
00E81A  2               prtdevice1:
00E81A  2  C9 10                    CMP     #$10
00E81C  2  D0 24                    BNE     prtdevice2
00E81E  2  48 8A 48 98              PRTS    "UNK$"
00E822  2  48 A2 00 BD  
00E826  2  3B E8 E8 C9  
00E83F  2  4C B4 E8                 JMP     prtdevice_done
00E842  2               prtdevice2:
00E842  2  C9 20                    CMP     #$20
00E844  2  D0 23                    BNE     prtdevice3
00E846  2  48 8A 48 98              PRTS    "FD$"
00E84A  2  48 A2 00 BD  
00E84E  2  63 E8 E8 C9  
00E866  2  4C B4 E8                 JMP     prtdevice_done
00E869  2               prtdevice3:
00E869  2  C9 30                    CMP     #$30
00E86B  2  D0 26                    BNE     prtdevicex
00E86D  2  48 8A 48 98              PRTS    "PPIDE$"
00E871  2  48 A2 00 BD  
00E875  2  8A E8 E8 C9  
00E890  2  4C B4 E8                 JMP     prtdevice_done
00E893  2               prtdevicex:
00E893  2  48 8A 48 98              PRTS    "UNK$"
00E897  2  48 A2 00 BD  
00E89B  2  B0 E8 E8 C9  
00E8B4  2               prtdevice_done:
00E8B4  2  68                       PLA
00E8B5  2  29 0F                    AND     #$0F            ; FILTER OUT DEVICE
00E8B7  2  20 21 E4                 JSR     PRTDEC
00E8BA  2  60                       RTS
00E8BB  2               
00E8BB  2                           .INCLUDE "dospager.asm"
00E8BB  3               ;__pager_________________________________________________________________________________________________________________________
00E8BB  3               ;
00E8BB  3               ; 	Nhyodyne Memory page management code
00E8BB  3               ;
00E8BB  3               ;	Entry points:
00E8BB  3               ;		PAGER_INIT          - called during OS init
00E8BB  3               ;________________________________________________________________________________________________________________________________
00E8BB  3               ;
00E8BB  3               ; RAM BANK $0C is RAM area for Drivers
00E8BB  3               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
00E8BB  3               ; RAM BANK $0F is fixed bank $0000-$7FFF
00E8BB  3               ;
00E8BB  3               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
00E8BB  3               ;
00E8BB  3               ; ROM MEMORY PAGE CONFIGURATION LATCH CONTROL PORT
00E8BB  3               ;       A15 IS INVERTED FOR THE NYHODYNE 65C02 CPU . . .
00E8BB  3               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
00E8BB  3               ;	^ ^ ^ ^  ^ ^ ^ ^
00E8BB  3               ;	: : : :  : : : :--0 = A15 ROM ONLY ADDRESS LINE DEFAULT IS 0 x
00E8BB  3               ;	: : : :  : : :----0 = A16 ROM ONLY ADDRESS LINE DEFAULT IS 0
00E8BB  3               ;	: : : :  : :------0 = A17 ROM ONLY ADDRESS LINE DEFAULT IS 0
00E8BB  3               ;	: : : :  :--------0 = A18 ROM ONLY ADDRESS LINE DEFAULT IS 0 X
00E8BB  3               ;	: : : :-----------0 = A19 ROM ONLY ADDRESS LINE DEFAULT IS 0
00E8BB  3               ;	: : :-------------0 = A20 ROM ONLY ADDRESS LINE DEFAULT IS 0
00E8BB  3               ;	: :---------------0 = ROM BOOT OVERRIDE DEFAULT IS 0
00E8BB  3               ;	:-----------------0 = LOWER PAGE ROM SELECT (0=ROM, 1=NOTHING) DEFAULT IS 0
00E8BB  3               ;
00E8BB  3               ; RAM PAGE CONFIGURATION LATCH CONTROL PORT
00E8BB  3               ;
00E8BB  3               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
00E8BB  3               ;	^ ^ ^ ^  ^ ^ ^ ^
00E8BB  3               ;	: : : :  : : : :--0 = A15 RAM ONLY ADDRESS LINE DEFAULT IS 0
00E8BB  3               ;	: : : :  : : :----0 = A16 RAM ONLY ADDRESS LINE DEFAULT IS 0
00E8BB  3               ;	: : : :  : :------0 = A17 RAM ONLY ADDRESS LINE DEFAULT IS 0
00E8BB  3               ;	: : : :  :--------0 = A18 RAM ONLY ADDRESS LINE DEFAULT IS 0
00E8BB  3               ;	: : : :-----------0 = A19 RAM ONLY ADDRESS LINE DEFAULT IS 0
00E8BB  3               ;	: : :-------------0 = UNDEFINED DEFAULT IS 0
00E8BB  3               ;	: :---------------0 = RAM BOOT OVERRIDE DEFAULT IS 0
00E8BB  3               ;	:-----------------0 = LOWER PAGE RAM SELECT (0=NOTHING, 1=RAM) DEFAULT IS 0;
00E8BB  3               
00E8BB  3               
00E8BB  3               ;__PAGER_INIT___________________________________________________________________________________________
00E8BB  3               ;
00E8BB  3               ;  INIT -- Copy code into $0200-$02FF for controling banking and copying
00E8BB  3               ;____________________________________________________________________________________________________
00E8BB  3               PAGER_INIT:
00E8BB  3  A2 00                LDX     #$00
00E8BD  3               :
00E8BD  3  BD C9 E8             LDA     md_pagecode,X
00E8C0  3  9D 00 02             STA     MD_PAGERA,X
00E8C3  3  E8                   INX
00E8C4  3  E0 00                CPX     #$00
00E8C6  3  D0 F5                BNE     :-
00E8C8  3  60                   RTS
00E8C9  3               
00E8C9  3               ;       X=Control Word
00E8C9  3               ;	7 6 5 4  3 2 1 0
00E8C9  3               ;	^ ^ ^ ^  ^ ^ ^ ^
00E8C9  3               ;       : : : X  X X X X    = UNUSED
00E8C9  3               ;	: : :-------------0 = Read=0, Write=1
00E8C9  3               ;	: :---------------0 = RAM=0, ROM=1
00E8C9  3               ;	:-----------------0 = LOW=0, HIGH=1
00E8C9  3               ;       A= bank
00E8C9  3               ;       Y= page
00E8C9  3               ;
00E8C9  3               md_pagecode:
00E8C9  3  48                   PHA
00E8CA  3  84 15                STY     MD_PAGESE+1     ; setup copy from pointer
00E8CC  3  8A                   TXA
00E8CD  3  29 80                AND     #$80
00E8CF  3  A8                   TAY
00E8D0  3  84 14                STY     MD_PAGESE
00E8D2  3  8A                   TXA
00E8D3  3  29 20                AND     #%00100000
00E8D5  3  C9 00                CMP     #$00
00E8D7  3  D0 3E                BNE     MD_PAGE_WRITE
00E8D9  3               ; PERFORM READ HERE
00E8D9  3  8A                   TXA
00E8DA  3  29 40                AND     #%01000000
00E8DC  3  C9 00                CMP     #$00
00E8DE  3  D0 0E                BNE     MD_PAGE_ROREAD
00E8E0  3               ; DO RAM READ
00E8E0  3  A9 80                LDA     #$80
00E8E2  3  8D 7C 03             STA     MPCL_ROM
00E8E5  3  68                   PLA
00E8E6  3  09 80                ORA     #$80
00E8E8  3  8D 78 03             STA     MPCL_RAM
00E8EB  3  4C F9 E8             JMP     MD_PAGE_COPYFRM
00E8EE  3               MD_PAGE_ROREAD:
00E8EE  3  A9 00                LDA     #$00
00E8F0  3  8D 78 03             STA     MPCL_RAM
00E8F3  3  68                   PLA
00E8F4  3  29 7F                AND     #$7F
00E8F6  3  8D 7C 03             STA     MPCL_ROM
00E8F9  3               MD_PAGE_COPYFRM:
00E8F9  3               ; DO THE COPY
00E8F9  3  A2 00                LDX     #$00
00E8FB  3  A0 00                LDY     #$00
00E8FD  3               :
00E8FD  3  B1 14                LDA     (MD_PAGESE),Y
00E8FF  3  9D 00 04             STA     MD_PAGEBU,X
00E902  3  E8                   INX
00E903  3  C8                   INY
00E904  3  E0 80                CPX     #$80
00E906  3  D0 F5                BNE     :-
00E908  3  A9 80                LDA     #$80
00E90A  3  8D 7C 03             STA     MPCL_ROM
00E90D  3  EA                   NOP
00E90E  3  EA                   NOP
00E90F  3  A9 8C                LDA     #$8C
00E911  3  8D 78 03             STA     MPCL_RAM
00E914  3  EA                   NOP
00E915  3  EA                   NOP
00E916  3  60                   RTS
00E917  3               MD_PAGE_WRITE:
00E917  3  68                   PLA
00E918  3  09 80                ORA     #%10000000
00E91A  3  8D 78 03             STA     MPCL_RAM
00E91D  3               ; DO THE COPY
00E91D  3  A2 00                LDX     #$00
00E91F  3  A0 00                LDY     #$00
00E921  3               :
00E921  3  BD 00 04             LDA     MD_PAGEBU,X
00E924  3  91 14                STA     (MD_PAGESE),Y
00E926  3  E8                   INX
00E927  3  C8                   INY
00E928  3  E0 80                CPX     #$80
00E92A  3  D0 F5                BNE     :-
00E92C  3  A9 8C                LDA     #$8C
00E92E  3  8D 78 03             STA     MPCL_RAM
00E931  3  EA                   NOP
00E932  3  EA                   NOP
00E933  3  60                   RTS
00E934  3               md_pagecodeend:
00E934  3               farcall:
00E934  3                       .IF     USEROM=1
00E934  3                           PHA
00E934  3                           LDA     #$80
00E934  3                           STA     MPCL_ROM
00E934  3                           NOP
00E934  3                           NOP
00E934  3                           LDA     #$8C
00E934  3                           STA     MPCL_RAM
00E934  3                           NOP
00E934  3                           NOP
00E934  3                           PLA
00E934  3                           JSR     BANKED_DRIVER_DISPATCHER
00E934  3                           PHA
00E934  3                           LDA     #$00
00E934  3                           STA     MPCL_RAM
00E934  3                           NOP
00E934  3                           NOP
00E934  3                           STA     MPCL_ROM
00E934  3                           NOP
00E934  3                           NOP
00E934  3                           PLA
00E934  3                           RTS
00E934  3               md_farrun:
00E934  3                           LDA     #$80
00E934  3                           STA     MPCL_ROM
00E934  3                           NOP
00E934  3                           NOP
00E934  3                           LDA     $00
00E934  3                           STA     MPCL_RAM
00E934  3                           NOP
00E934  3                           NOP
00E934  3                           JMP     ($0001)
00E934  3                       .ELSE
00E934  3  48                       PHA
00E935  3  A9 8C                    LDA     #$8C
00E937  3  8D 78 03                 STA     MPCL_RAM
00E93A  3  EA                       NOP
00E93B  3  EA                       NOP
00E93C  3  68                       PLA
00E93D  3  20 00 88                 JSR     BANKED_DRIVER_DISPATCHER
00E940  3  48                       PHA
00E941  3  A9 8E                    LDA     #$8E
00E943  3  8D 78 03                 STA     MPCL_RAM
00E946  3  68                       PLA
00E947  3  60                       RTS
00E948  3                       .ENDIF
00E948  3               
00E948  2               ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
00E948  2               ;___MOVEBUFTODMA_________________________________________________________________________________________
00E948  2               ;
00E948  2               ; MOVE BUFFER TO DMA
00E948  2               ;
00E948  2               ;________________________________________________________________________________________________________
00E948  2               MOVEBUFTODMA:
00E948  2  48                       PHA
00E949  2  A9 00                    LDA     #$00            ;
00E94B  2  85 EE                    STA     SRC
00E94D  2  A9 04                    LDA     #>MD_PAGEBU     ;
00E94F  2  85 EF                    STA     SRC + 1         ;
00E951  2  A5 F4                    LDA     dmaadr          ;
00E953  2  85 EC                    STA     DEST            ;
00E955  2  A5 F5                    LDA     dmaadr + 1      ;
00E957  2  85 ED                    STA     DEST + 1        ;
00E959  2  20 74 E9                 JSR     COPY_DOS_SECTOR ;
00E95C  2  68                       PLA
00E95D  2  60                       RTS
00E95E  2               
00E95E  2               ;___MOVEDMATOBUF_________________________________________________________________________________________
00E95E  2               ;
00E95E  2               ; MOVE DMA TO BUFFER
00E95E  2               ;
00E95E  2               ;________________________________________________________________________________________________________
00E95E  2               MOVEDMATOBUF:
00E95E  2  48                       PHA
00E95F  2  A9 00                    LDA     #$00            ;
00E961  2  85 EC                    STA     DEST
00E963  2  A9 04                    LDA     #>MD_PAGEBU     ;
00E965  2  85 ED                    STA     DEST + 1        ;
00E967  2  A5 F4                    LDA     dmaadr          ;
00E969  2  85 EE                    STA     SRC             ;
00E96B  2  A5 F5                    LDA     dmaadr + 1      ;
00E96D  2  85 EF                    STA     SRC + 1         ;
00E96F  2  20 74 E9                 JSR     COPY_DOS_SECTOR ;
00E972  2  68                       PLA
00E973  2  60                       RTS
00E974  2               
00E974  2               
00E974  2               
00E974  2               ;___COPY_DOS_SECTOR______________________________________________________________________________________
00E974  2               ;
00E974  2               ; COPY 128 BYTE SECTOR FOR DOS / 65
00E974  2               ;
00E974  2               ;________________________________________________________________________________________________________
00E974  2               COPY_DOS_SECTOR:
00E974  2  48                       PHA
00E975  2  98                       TYA
00E976  2  48                       PHA
00E977  2  A0 00                    LDY     #$00            ;
00E979  2               COPY_DOS_SECTOR1:
00E979  2  B1 EE                    LDA     (SRC), Y        ;
00E97B  2  91 EC                    STA     (DEST), Y       ;
00E97D  2  C8                       INY                     ;
00E97E  2  98                       TYA                     ;
00E97F  2  C9 80                    CMP     #$80            ;
00E981  2  D0 F6                    BNE     COPY_DOS_SECTOR1;
00E983  2  68                       PLA
00E984  2  A8                       TAY
00E985  2  68                       PLA
00E986  2  60                       RTS
00E987  2               
00E987  2               DOS65DSKYINIT:
00E987  2  54 6E 5C 5E              .BYTE   $54, $6E, $5C, $5E, $6E, $54, $79, $40
00E98B  2  6E 54 79 40  
00E98F  2               
00E98F  2               ;disk control blocks
00E98F  2               dcba:
00E98F  2  7F 00                    .WORD   127             ;max block number
00E991  2  40 00                    .WORD   64              ;sectors per track
00E993  2  00 00                    .WORD   0               ;number system tracks
00E995  2  01                       .BYTE   1               ;block size = 2048
00E996  2  FF 00                    .WORD   255             ;max directory number
00E998  2  04 EA                    .WORD   almpa           ;address of map for a
00E99A  2  00                       .BYTE   00              ;do checksums
00E99B  2  F4 F1                    .WORD   ckmp            ;checksum map
00E99D  2               dcbb:
00E99D  2  BF 00                    .WORD   191             ;max block number
00E99F  2  40 00                    .WORD   64              ;sectors per track
00E9A1  2  00 00                    .WORD   0               ;number system tracks
00E9A3  2  01                       .BYTE   1               ;block size = 2048
00E9A4  2  9B 00                    .WORD   155             ;max directory number
00E9A6  2  02 EB                    .WORD   almpb           ;address of map for b
00E9A8  2  00                       .BYTE   00              ;do checksums
00E9A9  2  F4 F1                    .WORD   ckmp            ;checksum map
00E9AB  2               dcbc:
00E9AB  2  FF 07                    .WORD   2047            ;max block number
00E9AD  2  40 00                    .WORD   64              ;sectors per track
00E9AF  2  10 00                    .WORD   16              ;number system tracks
00E9B1  2  02                       .BYTE   2               ;block size = 4096
00E9B2  2  FF 01                    .WORD   511             ;max directory number
00E9B4  2  00 EC                    .WORD   almpc           ;address of map for C
00E9B6  2  00                       .BYTE   0               ;do checksums
00E9B7  2  F4 F1                    .WORD   ckmp            ;checksum map
00E9B9  2               dcbd:
00E9B9  2  5E 01                    .WORD   350             ;max block number
00E9BB  2  24 00                    .WORD   36              ;sectors per track
00E9BD  2  04 00                    .WORD   4               ;number system tracks
00E9BF  2  01                       .BYTE   1               ;block size = 2048
00E9C0  2  7F 00                    .WORD   127             ;max directory number
00E9C2  2  FE EC                    .WORD   almpd           ;address of map for d
00E9C4  2  00                       .BYTE   0               ;do checksums
00E9C5  2  F4 F1                    .WORD   ckmp            ;checksum map
00E9C7  2               dcbe:
00E9C7  2  5E 01                    .WORD   350             ;max block number
00E9C9  2  24 00                    .WORD   36              ;sectors per track
00E9CB  2  04 00                    .WORD   4               ;number system tracks
00E9CD  2  01                       .BYTE   1               ;block size = 2048
00E9CE  2  7F 00                    .WORD   127             ;max directory number
00E9D0  2  FC ED                    .WORD   almpe           ;address of map for e
00E9D2  2  00                       .BYTE   0               ;do checksums
00E9D3  2  F4 F1                    .WORD   ckmp            ;checksum map
00E9D5  2               dcbf:
00E9D5  2  FF 07                    .WORD   2047            ;max block number
00E9D7  2  40 00                    .WORD   64              ;sectors per track
00E9D9  2  10 00                    .WORD   16              ;number system tracks
00E9DB  2  02                       .BYTE   2               ;block size = 4096
00E9DC  2  FF 01                    .WORD   511             ;max directory number
00E9DE  2  FA EE                    .WORD   almpf           ;address of map for f
00E9E0  2  00                       .BYTE   0               ;do checksums
00E9E1  2  F4 F1                    .WORD   ckmp            ;checksum map
00E9E3  2               dcbg:
00E9E3  2  FF 07                    .WORD   2047            ;max block number
00E9E5  2  40 00                    .WORD   64              ;sectors per track
00E9E7  2  10 00                    .WORD   16              ;number system tracks
00E9E9  2  02                       .BYTE   2               ;block size = 4096
00E9EA  2  FF 01                    .WORD   511             ;max directory number
00E9EC  2  F8 EF                    .WORD   almpg           ;address of map for g
00E9EE  2  00                       .BYTE   0               ;do checksums
00E9EF  2  F4 F1                    .WORD   ckmp            ;checksum map
00E9F1  2               dcbh:
00E9F1  2  FF 07                    .WORD   2047            ;max block number
00E9F3  2  40 00                    .WORD   64              ;sectors per track
00E9F5  2  10 00                    .WORD   16              ;number system tracks
00E9F7  2  02                       .BYTE   2               ;block size = 4096
00E9F8  2  FF 01                    .WORD   511             ;max directory number
00E9FA  2  F6 F0                    .WORD   almph           ;address of map for h
00E9FC  2  00                       .BYTE   0               ;do checksums
00E9FD  2  F4 F1                    .WORD   ckmp            ;checksum map
00E9FF  2               
00E9FF  2               ;data area
00E9FF  2               
00E9FF  2               hstwrt:
00E9FF  2  00                       .BYTE   0               ;0=written, 1=pending host write
00EA00  2               debtmp:
00EA00  2  00 00                    .WORD   0               ; DEBLOCK TEMP VAR
00EA02  2               hstact:
00EA02  2  00                       .BYTE   0               ;host active flag
00EA03  2               unacnt:
00EA03  2  00                       .BYTE   0               ;unalloc rec cnt
00EA04  2               
00EA04  2               
00EA04  2               ;allocation maps
00EA04  2               almpa:
00EA04  2  xx xx xx xx              .RES    254
00EA08  2  xx xx xx xx  
00EA0C  2  xx xx xx xx  
00EB02  2               almpb:
00EB02  2  xx xx xx xx              .RES    254
00EB06  2  xx xx xx xx  
00EB0A  2  xx xx xx xx  
00EC00  2               almpc:
00EC00  2  xx xx xx xx              .RES    254
00EC04  2  xx xx xx xx  
00EC08  2  xx xx xx xx  
00ECFE  2               almpd:
00ECFE  2  xx xx xx xx              .RES    254
00ED02  2  xx xx xx xx  
00ED06  2  xx xx xx xx  
00EDFC  2               almpe:
00EDFC  2  xx xx xx xx              .RES    254
00EE00  2  xx xx xx xx  
00EE04  2  xx xx xx xx  
00EEFA  2               almpf:
00EEFA  2  xx xx xx xx              .RES    254
00EEFE  2  xx xx xx xx  
00EF02  2  xx xx xx xx  
00EFF8  2               almpg:
00EFF8  2  xx xx xx xx              .RES    254
00EFFC  2  xx xx xx xx  
00F000  2  xx xx xx xx  
00F0F6  2               almph:
00F0F6  2  xx xx xx xx              .RES    254
00F0FA  2  xx xx xx xx  
00F0FE  2  xx xx xx xx  
00F1F4  2               ;checksum maps - not used
00F1F4  2               ckmp:
00F1F4  2  xx xx xx xx              .RES    128
00F1F8  2  xx xx xx xx  
00F1FC  2  xx xx xx xx  
00F274  2               
00F274  2               dftdskcfg:
00F274  2  00 00                    .BYTE   $00, $00        ; disk A: unit, slice (invalid for floppy and RAM disks)
00F276  2  01 00                    .BYTE   $01, $00        ; disk B: unit, slice (invalid for floppy and RAM disks)
00F278  2  30 06                    .BYTE   $30, $06        ; disk C: unit, slice
00F27A  2  20 00                    .BYTE   $20, $00        ; disk D: unit, slice
00F27C  2  21 00                    .BYTE   $21, $00        ; disk E: unit, slice
00F27E  2  30 03                    .BYTE   $30, $03        ; disk F: unit, slice
00F280  2  30 04                    .BYTE   $30, $04        ; disk G: unit, slice
00F282  2  30 00                    .BYTE   $30, $00        ; disk H: unit, slice
00F284  2               
00F284  1               
00F284  1                       .END
