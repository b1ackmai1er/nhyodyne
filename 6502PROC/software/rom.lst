ca65 V2.18 - Ubuntu 2.19-1
Main file   : rom.asm
Current file: rom.asm

000000r 1               
000000r 1               ;__MONITOR_______________________________________________________
000000r 1               ; This is a simple monitor program that can be uploaded to the MBC
000000r 1               ; from Z80 mode.
000000r 1               ;
000000r 1               ; It assumes that the 65C02 board is set for IOPage 03.
000000r 1               ; remember that bit A15 is inverted on the board so the dip switch is set to $83.
000000r 1               ;
000000r 1               ; If the SBC is the only CPU in the system, ensure that jumpers
000000r 1               ; J1 and J2 are set for 1&2.   Then burn ROM.BIN into EPROM.
000000r 1               ;
000000r 1               ; If the SBC is secondary to a Z80, the monitor.com file can be run from CP/M or the
000000r 1               ; monitor.hex file can be loaded from the monitor. Ensure that jumpers J1 and J4
000000r 1               ; are set for 2&3, the 6502 toggle IO address is set for $FF and
000000r 1               ; the 65C02 board is set for IOPage 03.
000000r 1               ; remember that bit A15 is inverted on the board so the dip switch is set to $83.
000000r 1               ;
000000r 1               ;
000000r 1               ; to run from the MBC Z80 monitor
000000r 1               ;
000000r 1               ; first set the MPCL to allow RAM in the low bank
000000r 1               ; >O 7C 80
000000r 1               ; >O 78 80
000000r 1               ;
000000r 1               ; then load the .HEX file.
000000r 1               ; >L
000000r 1               ;
000000r 1               ;
000000r 1               ; Finally transfer control to the 65C02 by reading the toggle register
000000r 1               ; >I FF
000000r 1               ;
000000r 1               ; The '02 should reset and run this program
000000r 1               ;
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;
000000r 1               ; DATA CONSTANTS
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;REGISTER		IO PORT		; FUNCTION
000000r 1               farfunct        = $32           ;function to call in driver area
000000r 1               IRQVECTOR       = $35           ; VECTOR FOR USER IRQ RTN
000000r 1               NMIVECTOR       = $37           ; VECTOR FOR USER IRQ RTN
000000r 1               TEMPWORD        = $39           ;
000000r 1               STRPTR          = $3B
000000r 1               
000000r 1               IO              = $0300         ; 0300-03FF Memory mapped IO
000000r 1               MPCL_ROM        = $037C         ; ROM MAPPER
000000r 1               MPCL_RAM        = $0378         ; RAM MAPPER
000000r 1               
000000r 1               MD_PAGEBU       = $0400         ; 0400-04FF PAGE BUFFER ADDRESS
000000r 1               memmovr         = $0500         ; 0200-02ff subr to move data from ram/rom disks
000000r 1               MD_PAGERA       = $0500         ; PAGE DRIVER ADDRESS
000000r 1               MD_PAGESE       = $14           ; PAGE SECTOR STORAGE
000000r 1               BANKED_DRIVER_DISPATCHER=$8800  ; LOCATION OF DRIVER DISPATCHER
000000r 1               USEROM          = 1
000000r 1               
000000r 1               ; UART 16C550 SERIAL -- Assumes IO is in page $03 -- DIP Switch settings $83
000000r 1               UART0           = $0368         ; DATA IN/OUT
000000r 1               UART1           = $0369         ; CHECK RX
000000r 1               UART2           = $036A         ; INTERRUPTS
000000r 1               UART3           = $036B         ; LINE CONTROL
000000r 1               UART4           = $036C         ; MODEM CONTROL
000000r 1               UART5           = $036D         ; LINE STATUS
000000r 1               UART6           = $036E         ; MODEM STATUS
000000r 1               UART7           = $036F         ; SCRATCH REG.
000000r 1               
000000r 1               
000000r 1                       .SEGMENT "TROM"
000000r 1                       .ORG    $F000
00F000  1               
00F000  1               ;__COLD_START___________________________________________________
00F000  1               ;
00F000  1               ; PERFORM SYSTEM COLD INIT
00F000  1               ;
00F000  1               ;_______________________________________________________________
00F000  1               COLD_START:
00F000  1  78                   SEI                     ; DISABLE INTERRUPTS
00F001  1  D8                   CLD                     ;  VERIFY DECIMAL MODE IS OFF
00F002  1  A2 FF                LDX     #$FF            ;
00F004  1  9A                   TXS                     ; CLEAR STACK
00F005  1               
00F005  1  A9 26                LDA     #<IRQROUTINE
00F007  1  85 35                STA     IRQVECTOR
00F009  1  85 37                STA     NMIVECTOR
00F00B  1  A9 F0                LDA     #>IRQROUTINE
00F00D  1  85 36                STA     IRQVECTOR+1
00F00F  1  85 38                STA     NMIVECTOR+1
00F011  1               
00F011  1  20 41 F0             JSR     INIT_SERIAL
00F014  1  20 DC FA             JSR     PAGER_INIT
00F017  1               
00F017  1  20 88 FB             JSR     RELOCATE_DRIVERS
00F01A  1               
00F01A  1  A9 DF                LDA     #<STARTUP       ; OUTPUT STARTUP STRING
00F01C  1  85 3B                STA     STRPTR          ;
00F01E  1  A9 FB                LDA     #>STARTUP       ;
00F020  1  85 3C                STA     STRPTR+1        ;
00F022  1  20 74 F0             JSR     OUTSTR          ;
00F025  1               
00F025  1               ;
00F025  1  00                   BRK                     ; PERFORM BRK (START MONITOR)
00F026  1               
00F026  1               
00F026  1               ;__IRQROUTINE___________________________________________________
00F026  1               ;
00F026  1               ; HANDLE INTERRUPT PROCESING
00F026  1               ;
00F026  1               ;_______________________________________________________________
00F026  1               IRQROUTINE:
00F026  1  58                   CLI                     ; ENABLE INTERRUPTS AGAIN
00F027  1  40                   RTI
00F028  1               
00F028  1               ;__INTERRUPT____________________________________________________
00F028  1               ;
00F028  1               ; HANDLE IRQ INTERRUPT AND DETERMINE IF IT IS A BRK OR AN IRQ
00F028  1               ;
00F028  1               ;_______________________________________________________________
00F028  1               INTERRUPT:
00F028  1  78                   SEI                     ; DISABLE INTERRUPTS
00F029  1  85 39                STA     TEMPWORD
00F02B  1  68                   PLA                     ; GET STATUS REGISTER
00F02C  1  48                   PHA                     ; SAVE STATUS REGISTER
00F02D  1  29 10                AND     #$10            ; MASK BRK
00F02F  1  D0 03                BNE     BRKCMD          ; BRK CMD
00F031  1  6C 35 00             JMP     (IRQVECTOR)     ; LET USER ROUTINE HAVE IT (USER DEFINED IRQ)
00F034  1               BRKCMD:
00F034  1  A5 39                LDA     TEMPWORD
00F036  1  48                   PHA
00F037  1  8A                   TXA
00F038  1  48                   PHA
00F039  1  98                   TYA
00F03A  1  48                   PHA
00F03B  1  4C 89 F0             JMP     BRKROUTINE      ; MONITOR BRK ROUTINE
00F03E  1               
00F03E  1               NINTERRUPT:
00F03E  1  6C 37 00             JMP     (NMIVECTOR)     ; LET USER ROUTINE HAVE IT (USER DEFINED NMI)
00F041  1               
00F041  1               ;__________________________________________________________________________________________________________
00F041  1               ;
00F041  1               ;  AT SOME POINT, REPLACE THIS WITH 6502HBIOS CALLS
00F041  1               ;
00F041  1               
00F041  1               INIT_SERIAL:
00F041  1  A9 80                LDA     #$80            ;
00F043  1  8D 6B 03             STA     UART3           ; SET DLAB FLAG
00F046  1  A9 0C                LDA     #12             ; SET TO 12 = 9600 BAUD
00F048  1  8D 68 03             STA     UART0           ; save baud rate
00F04B  1  A9 00                LDA     #00             ;
00F04D  1  8D 69 03             STA     UART1           ;
00F050  1  A9 03                LDA     #03             ;
00F052  1  8D 6B 03             STA     UART3           ; SET 8 BIT DATA, 1 STOPBIT
00F055  1  8D 6C 03             STA     UART4           ;
00F058  1  60                   RTS
00F059  1               
00F059  1               ;__IOF_CONINW____________________________________________________________________________________________
00F059  1               ;
00F059  1               ; PERFORM BLOCKING CONSOLE READ
00F059  1               ;________________________________________________________________________________________________________
00F059  1               IOF_CONINW:
00F059  1  A9 02                LDA     #02
00F05B  1  85 32                STA     farfunct
00F05D  1  4C 6B 05             JMP     DO_FARCALL
00F060  1               
00F060  1               ;__IOF_CONIN_____________________________________________________________________________________________
00F060  1               ;
00F060  1               ; PERFORM NON-BLOCKING CONSOLE READ
00F060  1               ;________________________________________________________________________________________________________
00F060  1               IOF_CONIN:
00F060  1  A9 01                LDA     #01
00F062  1  85 32                STA     farfunct
00F064  1  4C 6B 05             JMP     DO_FARCALL
00F067  1               
00F067  1               ;__OUTCH_________________________________________________________________________________________________
00F067  1               ;
00F067  1               ; PERFORM CONSOLE WRITE
00F067  1               ;________________________________________________________________________________________________________
00F067  1               OUTCH:
00F067  1  48                   PHA
00F068  1  A9 00                LDA     #00
00F06A  1  85 32                STA     farfunct
00F06C  1  68                   PLA
00F06D  1  4C 6B 05             JMP     DO_FARCALL
00F070  1               
00F070  1               
00F070  1               Z80:
00F070  1  00                   BRK
00F071  1  00 00 00             .BYTE   00,00,00
00F074  1               
00F074  1               ;__OUTSTR______________________________________________________
00F074  1               ;
00F074  1               ; OUTPUT THE STRING POINTED TO BY OUTSTR TO THE SCREEN
00F074  1               ;
00F074  1               ;______________________________________________________________
00F074  1               OUTSTR:
00F074  1  A0 00                LDY     #$00            ; LOAD $00 INTO Y
00F076  1               OUTSTRLP:
00F076  1  B1 3B                LDA     (STRPTR),Y      ; LOAD NEXT CHAR FROM STRING INTO ACC
00F078  1  C9 00                CMP     #$00            ; IS NULL?
00F07A  1  F0 0C                BEQ     ENDOUTSTR       ; YES, END PRINT OUT
00F07C  1  20 67 F0             JSR     OUTCH           ; PRINT CHAR IN ACC
00F07F  1  E6 3B                INC     STRPTR
00F081  1  D0 F3                BNE     OUTSTRLP
00F083  1  E6 3C                INC     STRPTR+1
00F085  1  4C 76 F0             JMP     OUTSTRLP        ; DO NEXT CHAR
00F088  1               ENDOUTSTR:
00F088  1  60                   RTS                     ; RETURN
00F089  1               
00F089  1                       .INCLUDE"SUPERMON.ASM"
00F089  2               ; ********************************
00F089  2               ; * SUPERMON+ 64 JIM BUTTERFIELD *
00F089  2               ; * V1.2   AUGUST 20 1985        *
00F089  2               ; ********************************
00F089  2               
00F089  2               ; Reformatted and annotated in late 2016/early 2017 by J.B. Langston.
00F089  2               ; Modified for Nhyodyne 3/12/2023 D. Werner
00F089  2               ;
00F089  2               ; Mr. Butterfield . . you inspired many of us, thank you.
00F089  2               ;
00F089  2               ; -----------------------------------------------------------------------------
00F089  2               ; temporary pointers
00F089  2               TMP0            = $C1           ; used to return input, often holds end address
00F089  2               TMP2            = $C3           ; usually holds start address
00F089  2               
00F089  2               ; these 7 locations are used to store the registers when
00F089  2               ; entering the monitor and restore them when exiting.
00F089  2               
00F089  2               PCH             = $B0           ; program counter high byte
00F089  2               PCL             = $B1           ; program counter low byte
00F089  2               SR              = $B2           ; status register
00F089  2               ACC             = $B3           ; accumulator
00F089  2               XR              = $B4           ; X register
00F089  2               YR              = $B5           ; Y register
00F089  2               SP              = $B6           ; stack pointer
00F089  2               STORE           = $B7           ; 2-byte temp storage
00F089  2               CHRPNT          = $B9           ; current position in input buffer
00F089  2               SAVY            = $BA           ; temp storage, often to save Y register
00F089  2               U9F             = $BB           ; index into assembler work buffer
00F089  2               CKSM            = $BC           ; S19 loader checksum store
00F089  2               LOADADR         = $BD           ; S19 load address
00F089  2               LOADWRK         = $BF           ; S19 load work
00F089  2               
00F089  2               ;-----------------------------------------------------------------------------
00F089  2               ; variables
00F089  2               ACMD            = $C5           ; addressing command
00F089  2               LENGTH          = $C6           ; length of operand
00F089  2               MNEMW           = $C7           ; 3 letter mnemonic buffer
00F089  2               SAVX            = $CA           ; 1 byte temp storage, often to save X register
00F089  2               OPCODE          = $CB           ; current opcode for assembler/disassembler
00F089  2               UPFLG           = $CC           ; flag: count up (bit 7 clear) or down (bit 7 set)
00F089  2               DIGCNT          = $CB           ; digit count
00F089  2               INDIG           = $CC           ; numeric value of single digit
00F089  2               NUMBIT          = $CD           ; numeric base of input
00F089  2               STASH           = $CE           ; 2-byte temp storage
00F089  2               U0AA0           = $D0           ; 10 byte work buffer
00F089  2               U0AAE           = $D0+10        ; end of 10 byte work buffer
00F089  2               STAGE           = $DA           ; 30 byte staging buffer for filename, search, etc.
00F089  2               ESTAGE          = $DA+30        ; end of 30 byte staging buffer for filename, search, etc.
00F089  2               INBUFF          = $0200
00F089  2               CHROUT          = OUTCH
00F089  2               
00F089  2               
00F089  2               ; -----------------------------------------------------------------------------
00F089  2               ; BRK handler
00F089  2               BRKROUTINE:
00F089  2               BREAK:
00F089  2  A2 05                LDX     #$05            ; pull registers off the stack
00F08B  2               BSTACK:
00F08B  2  68                   PLA                     ; order: Y,X,A,SR,PCL,PCH
00F08C  2  95 B0                STA     PCH,X           ; store in memory
00F08E  2  CA                   DEX
00F08F  2  10 FA                BPL     BSTACK
00F091  2  D8                   CLD                     ; disable bcd mode
00F092  2  BA                   TSX                     ; store stack pointer in memory
00F093  2  86 B6                STX     SP
00F095  2  58                   CLI                     ; enable interupts
00F096  2               
00F096  2               ; -----------------------------------------------------------------------------
00F096  2               ; display registers [R]
00F096  2               DSPLYR:
00F096  2  A0 00                LDY     #MSG2-MSGBAS    ; display headers
00F098  2  20 DA F8             JSR     SNDCLR
00F09B  2  A9 3B                LDA     #$3B            ; prefix registers with "; " to allow editing
00F09D  2  20 67 F0             JSR     CHROUT
00F0A0  2  A9 20                LDA     #$20
00F0A2  2  20 67 F0             JSR     CHROUT
00F0A5  2  A5 B0                LDA     PCH             ; print 2-byte program counter
00F0A7  2  20 74 F7             JSR     WRTWO
00F0AA  2  A0 01                LDY     #1              ; start 1 byte after PC high byte
00F0AC  2               DISJ:
00F0AC  2  B9 B0 00             LDA     PCH,Y           ; loop through rest of the registers
00F0AF  2  20 50 F7             JSR     WRBYTE          ; print 1-byte register value
00F0B2  2  C8                   INY
00F0B3  2  C0 07                CPY     #7              ; there are a total of 5 registers to print
00F0B5  2  90 F5                BCC     DISJ
00F0B7  2               
00F0B7  2               ; -----------------------------------------------------------------------------
00F0B7  2               ; main loop
00F0B7  2               STRT:
00F0B7  2  20 5B F7             JSR     CRLF            ; new line
00F0BA  2  A2 00                LDX     #0              ; point at start of input buffer
00F0BC  2  86 B9                STX     CHRPNT
00F0BE  2               SMOVE:
00F0BE  2  20 59 F0             JSR     IOF_CONINW      ; CHRIN kernal call to input a character
00F0C1  2               
00F0C1  2  C9 08                CMP     #$08            ; IS BACKSPACE?
00F0C3  2  D0 1A                BNE     :+              ; NO, SKUP BACKSPACE RTN
00F0C5  2  E0 00                CPX     #$00            ; IS INDEX =0 ?
00F0C7  2  F0 F5                BEQ     SMOVE           ; YES, SKIP BACKSPACE
00F0C9  2  20 67 F0             JSR     OUTCH           ; BACK UP CURSOR
00F0CC  2  A9 20                LDA     #$20
00F0CE  2  20 67 F0             JSR     OUTCH           ; SPACE ON SCREEN
00F0D1  2  A9 08                LDA     #$08
00F0D3  2  20 67 F0             JSR     OUTCH           ; BACK UP CURSOR
00F0D6  2               
00F0D6  2  A9 00                LDA     #0
00F0D8  2  9D 00 02             STA     INBUFF,X        ; store in input buffer
00F0DB  2  CA                   DEX
00F0DC  2  4C BE F0             JMP     SMOVE
00F0DF  2               :
00F0DF  2  20 67 F0             JSR     OUTCH           ; OUTPUT CHAR TO SCREEN
00F0E2  2               
00F0E2  2  9D 00 02             STA     INBUFF,X        ; store in input buffer
00F0E5  2  E8                   INX
00F0E6  2  E0 00                CPX     #00             ; error if buffer is full
00F0E8  2  F0 1C                BEQ     ERROR
00F0EA  2  C9 0D                CMP     #$0D            ; keep reading until CR
00F0EC  2  D0 D0                BNE     SMOVE
00F0EE  2  A9 00                LDA     #0              ; null-terminate input buffer
00F0F0  2  9D FF 01             STA     INBUFF-1,X      ; (replacing the CR)
00F0F3  2               ST1:
00F0F3  2  20 99 F7             JSR     GETCHR          ; get a character from the buffer
00F0F6  2  F0 BF                BEQ     STRT            ; start over if buffer is empty
00F0F8  2  C9 20                CMP     #$20            ; skip leading spaces
00F0FA  2  F0 F7                BEQ     ST1
00F0FC  2               S0:
00F0FC  2  A2 15                LDX     #KEYTOP-KEYW    ; loop through valid command characters
00F0FE  2               S1:
00F0FE  2  DD 9D FA             CMP     KEYW,X          ; see if input character matches
00F101  2  F0 0B                BEQ     S2              ; command matched, dispatch it
00F103  2  CA                   DEX                     ; no match, check next command
00F104  2  10 F8                BPL     S1              ; keep trying until we've checked them all
00F106  2                                               ; then fall through to error handler
00F106  2               
00F106  2               ; -----------------------------------------------------------------------------
00F106  2               ; handle error
00F106  2               ERROR:
00F106  2  A0 1E                LDY     #MSG3-MSGBAS    ; display "?" to indicate error and go to new line
00F108  2  20 ED F8             JSR     SNDMSG
00F10B  2  4C B7 F0             JMP     STRT            ; back to main loop
00F10E  2               
00F10E  2               ; -----------------------------------------------------------------------------
00F10E  2               ; dispatch command
00F10E  2               S2:
00F10E  2  E0 10                CPX     #$10            ; next 4 commands are base conversions
00F110  2  B0 0E                BCS     CNVLNK          ;   which are handled by the same subroutine
00F112  2  8A                   TXA                     ; remaining commands dispatch through vector table
00F113  2  0A                   ASL     A               ; multiply index of command by 2
00F114  2  AA                   TAX                     ;   since table contains 2-byte addresses
00F115  2  BD B3 FA             LDA     KADDR+1,X       ; push address from vector table onto stack
00F118  2  48                   PHA                     ;   so that the RTS from GETPAR will jump there
00F119  2  BD B2 FA             LDA     KADDR,X
00F11C  2  48                   PHA
00F11D  2  4C 8F F6             JMP     GETPAR          ; get the first parameter for the command
00F120  2               CNVLNK:
00F120  2  4C 2E F8             JMP     CONVRT          ; handle base conversion
00F123  2               
00F123  2               
00F123  2               ; -----------------------------------------------------------------------------
00F123  2               ; display memory [M]
00F123  2               DSPLYM:
00F123  2  B0 08                BCS     DSPM11          ; start from previous end addr if no address given
00F125  2  20 AF F7             JSR     COPY12          ; save start address in TMP2
00F128  2  20 8F F6             JSR     GETPAR          ; get end address in TMP0
00F12B  2  90 06                BCC     DSMNEW          ; did user specify one?
00F12D  2               DSPM11:
00F12D  2  A9 0B                LDA     #$0B            ; if not, show 12 lines by default
00F12F  2  85 C1                STA     TMP0
00F131  2  D0 0E                BNE     DSPBYT          ; always true, but BNE uses 1 byte less than JMP
00F133  2               DSMNEW:
00F133  2  20 B8 F7             JSR     SUB12           ; end addr given, calc bytes between start and end
00F136  2  90 1E                BCC     MERROR          ; error if start is after end
00F138  2  A2 03                LDX     #3              ; divide by 8 (shift right 3 times)
00F13A  2               DSPM01:
00F13A  2  46 C2                LSR     TMP0+1
00F13C  2  66 C1                ROR     TMP0
00F13E  2  CA                   DEX
00F13F  2  D0 F9                BNE     DSPM01
00F141  2               DSPBYT:
00F141  2  20 FB F8             JSR     STOP            ; check for stop key
00F144  2  F0 0D                BEQ     DSPMX           ; exit early if pressed
00F146  2  20 BA F1             JSR     DISPMEM         ; display 1 line containing 8 bytes
00F149  2  A9 08                LDA     #8              ; increase start address by 8 bytes
00F14B  2  20 E8 F7             JSR     BUMPAD2
00F14E  2  20 C6 F7             JSR     SUBA1           ; decrement line counter
00F151  2  B0 EE                BCS     DSPBYT          ; show another line until it's < 0
00F153  2               DSPMX:
00F153  2  4C B7 F0             JMP     STRT            ; back to main loop
00F156  2               MERROR:
00F156  2  4C 06 F1             JMP     ERROR           ; handle error
00F159  2               
00F159  2               ; -----------------------------------------------------------------------------
00F159  2               ; alter registers [;]
00F159  2               ALTR:
00F159  2  20 00 F8             JSR     COPY1P          ; store first parameter in PC
00F15C  2  A0 00                LDY     #0              ; init counter
00F15E  2               ALTR1:
00F15E  2  20 8F F6             JSR     GETPAR          ; get value for next register
00F161  2  B0 0A                BCS     ALTRX           ; exit early if no more values given
00F163  2  A5 C1                LDA     TMP0            ; store in memory, offset from SR
00F165  2  99 B2 00             STA     SR,Y            ; these locations will be transferred to the
00F168  2  C8                   INY                     ;   actual registers before exiting the monitor
00F169  2  C0 05                CPY     #$05            ; have we updated all 5 yet?
00F16B  2  90 F1                BCC     ALTR1           ; if not, get next
00F16D  2               ALTRX:
00F16D  2  4C B7 F0             JMP     STRT            ; back to main loop
00F170  2               
00F170  2               ; -----------------------------------------------------------------------------
00F170  2               ; alter memory [>]
00F170  2               ALTM:
00F170  2  B0 13                BCS     ALTMX           ; exit if no parameter provided
00F172  2  20 AF F7             JSR     COPY12          ; copy parameter to start address
00F175  2  A0 00                LDY     #0
00F177  2               ALTM1:
00F177  2  20 8F F6             JSR     GETPAR          ; get value for next byte of memory
00F17A  2  B0 09                BCS     ALTMX           ; if none given, exit early
00F17C  2  A5 C1                LDA     TMP0            ; poke value into memory at start address + Y
00F17E  2  91 C3                STA     (TMP2),Y
00F180  2  C8                   INY                     ; next byte
00F181  2  C0 08                CPY     #8              ; have we read 8 bytes yet?
00F183  2  90 F2                BCC     ALTM1           ; if not, read the next one
00F185  2               ALTMX:
00F185  2  A9 91                LDA     #$91            ; move cursor up
00F187  2  20 67 F0             JSR     CHROUT
00F18A  2  20 BA F1             JSR     DISPMEM         ; re-display line to make ascii match hex
00F18D  2  4C B7 F0             JMP     STRT            ; back to main loop
00F190  2               
00F190  2               ; -----------------------------------------------------------------------------
00F190  2               ; goto (run) [G]
00F190  2               GOTO:
00F190  2  A6 B6                LDX     SP              ; load stack pointer from memory
00F192  2  9A                   TXS                     ; save in SP register
00F193  2               GOTO2:
00F193  2  20 00 F8             JSR     COPY1P          ; copy provided address to PC
00F196  2  78                   SEI                     ; disable interrupts
00F197  2  A5 B0                LDA     PCH             ; push PC high byte on stack
00F199  2  48                   PHA
00F19A  2  A5 B1                LDA     PCL             ; push PC low byte on stack
00F19C  2  48                   PHA
00F19D  2  A5 B2                LDA     SR              ; push status byte on stack
00F19F  2  48                   PHA
00F1A0  2  A5 B3                LDA     ACC             ; load accumulator from memory
00F1A2  2  A6 B4                LDX     XR              ; load X from memory
00F1A4  2  A4 B5                LDY     YR              ; load Y from memory
00F1A6  2  40                   RTI                     ; return from interrupt (pops PC and SR)
00F1A7  2               
00F1A7  2               ; jump to subroutine [J]
00F1A7  2               JSUB:
00F1A7  2  A6 B6                LDX     SP              ; load stack pointer from memory
00F1A9  2  9A                   TXS                     ; save value in SP register
00F1AA  2  20 93 F1             JSR     GOTO2           ; same as goto command
00F1AD  2  84 B5                STY     YR              ; save Y to memory
00F1AF  2  86 B4                STX     XR              ; save X to memory
00F1B1  2  85 B3                STA     ACC             ; save accumulator to memory
00F1B3  2  08                   PHP                     ; push processor status on stack
00F1B4  2  68                   PLA                     ; pull processor status into A
00F1B5  2  85 B2                STA     SR              ; save processor status to memory
00F1B7  2  4C 96 F0             JMP     DSPLYR          ; display registers
00F1BA  2               
00F1BA  2               ; -----------------------------------------------------------------------------
00F1BA  2               ; display 8 bytes of memory
00F1BA  2               DISPMEM:
00F1BA  2  20 5B F7             JSR     CRLF            ; new line
00F1BD  2  A9 3E                LDA     #'>'            ; prefix > so memory can be edited in place
00F1BF  2  20 67 F0             JSR     CHROUT
00F1C2  2  20 46 F7             JSR     SHOWAD          ; show address of first byte on line
00F1C5  2  A0 00                LDY     #0
00F1C7  2  F0 03                BEQ     DMEMGO          ; SHOWAD already printed a space after the address
00F1C9  2               DMEMLP:
00F1C9  2  20 53 F7             JSR     SPACE           ; print space between bytes
00F1CC  2               DMEMGO:
00F1CC  2  B1 C3                LDA     (TMP2),Y        ; load byte from start address + Y
00F1CE  2  20 74 F7             JSR     WRTWO           ; output hex digits for byte
00F1D1  2  C8                   INY                     ; next byte
00F1D2  2  C0 08                CPY     #8              ; have we output 8 bytes yet?
00F1D4  2  90 F3                BCC     DMEMLP          ; if not, output next byte
00F1D6  2  A0 26                LDY     #MSG5-MSGBAS    ; if so, output : and turn on reverse video
00F1D8  2  20 ED F8             JSR     SNDMSG          ;   before displaying ascii representation
00F1DB  2  A0 00                LDY     #0              ; back to first byte in line
00F1DD  2               DCHAR:
00F1DD  2  B1 C3                LDA     (TMP2),Y        ; load byte at start address + Y
00F1DF  2  AA                   TAX                     ; stash in X
00F1E0  2  29 BF                AND     #$BF            ; clear 6th bit
00F1E2  2  C9 22                CMP     #$22            ; is it a quote (")?
00F1E4  2  F0 08                BEQ     DDOT            ; if so, print . instead
00F1E6  2  8A                   TXA                     ; if not, restore character
00F1E7  2  29 7F                AND     #$7F            ; clear top bit
00F1E9  2  C9 20                CMP     #$20            ; is it a printable character (>= $20)?
00F1EB  2  8A                   TXA                     ; restore character
00F1EC  2  B0 02                BCS     DCHROK          ; if printable, output character
00F1EE  2               DDOT:
00F1EE  2  A9 2E                LDA     #$2E            ; if not, output '.' instaed
00F1F0  2               DCHROK:
00F1F0  2  20 67 F0             JSR     CHROUT
00F1F3  2  C8                   INY                     ; next byte
00F1F4  2  C0 08                CPY     #8              ; have we output 8 bytes yet?
00F1F6  2  90 E5                BCC     DCHAR           ; if not, output next byte
00F1F8  2  60                   RTS
00F1F9  2               
00F1F9  2               ; -----------------------------------------------------------------------------
00F1F9  2               ; compare memory [C]
00F1F9  2               COMPAR:
00F1F9  2  A9 00                LDA     #0              ; bit 7 clear signals compare
00F1FB  2  2C                   .BYTE   $2C             ; absolute BIT opcode consumes next word (LDA #$80)
00F1FC  2               
00F1FC  2               ; transfer memory [T]
00F1FC  2               TRANS:
00F1FC  2  A9 80                LDA     #$80            ; bit 7 set signals transfer
00F1FE  2  85 BA                STA     SAVY            ; save compare/transfer flag in SAVY
00F200  2  A9 00                LDA     #0              ; assume we're counting up (bit 7 clear)
00F202  2  85 CC                STA     UPFLG           ; save direction flag
00F204  2  20 0B F8             JSR     GETDIF          ; get two addresses and calculate difference
00F207  2                                               ;   TMP2 = source start
00F207  2                                               ;   STASH = source end
00F207  2                                               ;   STORE = length
00F207  2  B0 05                BCS     TERROR          ; carry set indicates error
00F209  2  20 8F F6             JSR     GETPAR          ; get destination address in TMP0
00F20C  2  90 03                BCC     TOKAY           ; carry set indicates error
00F20E  2               TERROR:
00F20E  2  4C 06 F1             JMP     ERROR           ; handle error
00F211  2               TOKAY:
00F211  2  24 BA                BIT     SAVY            ; transfer or compare?
00F213  2  10 23                BPL     COMPAR1         ; high bit clear indicates compare
00F215  2  A5 C3                LDA     TMP2            ; if it's a transfer, we must take steps
00F217  2  C5 C1                CMP     TMP0            ;   to avoid overwriting the source bytes before
00F219  2  A5 C4                LDA     TMP2+1          ;   they have been transferred
00F21B  2  E5 C2                SBC     TMP0+1          ; compare source (TMP2) to destination (TMP0)
00F21D  2  B0 19                BCS     COMPAR1         ; and count up if source is before than desitnation
00F21F  2  A5 B7                LDA     STORE           ; otherwise, start at end and count down...
00F221  2  65 C1                ADC     TMP0            ; add length (STORE) to desintation (TMP0)
00F223  2  85 C1                STA     TMP0            ; to calculate end of destination
00F225  2  A5 B8                LDA     STORE+1
00F227  2  65 C2                ADC     TMP0+1
00F229  2  85 C2                STA     TMP0+1
00F22B  2  A2 01                LDX     #1              ; change source pointer from beginning to end
00F22D  2               TDOWN:
00F22D  2  B5 CE                LDA     STASH,X         ; TMP2 = source end (STASH)
00F22F  2  95 C3                STA     TMP2,X
00F231  2  CA                   DEX
00F232  2  10 F9                BPL     TDOWN
00F234  2  A9 80                LDA     #$80            ; high bit set in UPFLG means count down
00F236  2  85 CC                STA     UPFLG
00F238  2               COMPAR1:
00F238  2  20 5B F7             JSR     CRLF            ; new line
00F23B  2  A0 00                LDY     #0              ; no offset from pointer
00F23D  2               TCLOOP:
00F23D  2  20 FB F8             JSR     STOP            ; check for stop key
00F240  2  F0 2F                BEQ     TEXIT           ; exit if pressed
00F242  2  B1 C3                LDA     (TMP2),Y        ; load byte from source
00F244  2  24 BA                BIT     SAVY            ; transfer or compare?
00F246  2  10 02                BPL     COMPAR2         ; skip store if comparing
00F248  2  91 C1                STA     (TMP0),Y        ; otherwise, store in destination
00F24A  2               COMPAR2:
00F24A  2  D1 C1                CMP     (TMP0),Y        ; compare to destination
00F24C  2  F0 03                BEQ     TMVAD           ; don't show address if equal
00F24E  2  20 46 F7             JSR     SHOWAD          ; show address
00F251  2               TMVAD:
00F251  2  24 CC                BIT     UPFLG           ; counting up or down?
00F253  2  30 0B                BMI     TDECAD          ; high bit set means we're counting down
00F255  2  E6 C1                INC     TMP0            ; increment destination low byte
00F257  2  D0 10                BNE     TINCOK
00F259  2  E6 C2                INC     TMP0+1          ; carry to high byte if necessary
00F25B  2  D0 0C                BNE     TINCOK
00F25D  2  4C 06 F1             JMP     ERROR           ; error if high byte overflowed
00F260  2               TDECAD:
00F260  2  20 C6 F7             JSR     SUBA1           ; decrement destination (TMP0)
00F263  2  20 F2 F7             JSR     SUB21           ; decrement source (TMP2)
00F266  2  4C 6C F2             JMP     TMOR
00F269  2               TINCOK:
00F269  2  20 E6 F7             JSR     ADDA2           ; increment source (TMP2)
00F26C  2               TMOR:
00F26C  2  20 D8 F7             JSR     SUB13           ; decrement length
00F26F  2  B0 CC                BCS     TCLOOP          ; loop until length is 0
00F271  2               TEXIT:
00F271  2  4C B7 F0             JMP     STRT            ; back to main loop
00F274  2               
00F274  2               ; -----------------------------------------------------------------------------
00F274  2               ; hunt memory [H]
00F274  2               HUNT:
00F274  2  20 0B F8             JSR     GETDIF          ; get start (TMP2) and end (TMP0) of haystack
00F277  2  B0 57                BCS     HERROR          ; carry indicates error
00F279  2  A0 00                LDY     #0
00F27B  2  20 99 F7             JSR     GETCHR          ; get a single character
00F27E  2  C9 27                CMP     #39             ; is it a single quote?
00F280  2  D0 16                BNE     NOSTRH          ; if not, input needle as hex bytes
00F282  2  20 99 F7             JSR     GETCHR          ; if so, input needle as string
00F285  2  C9 00                CMP     #0
00F287  2  F0 47                BEQ     HERROR          ; error if needle isn't at least one byte
00F289  2               HPAR:
00F289  2  99 DA 00             STA     STAGE,Y         ; save char in staging area
00F28C  2  C8                   INY
00F28D  2  20 99 F7             JSR     GETCHR          ; get another char
00F290  2  F0 18                BEQ     HTGO            ; if it's null start searching
00F292  2  C0 1E                CPY     #ESTAGE-STAGE   ; have we filled up the needle staging area?
00F294  2  D0 F3                BNE     HPAR            ; if not, get another character
00F296  2  F0 12                BEQ     HTGO            ; if so, start searching
00F298  2               NOSTRH:
00F298  2  20 8D F6             JSR     RDPAR           ; read hex bytes if string not indicated
00F29B  2               HLP:
00F29B  2  A5 C1                LDA     TMP0            ; save last read byte in staging area
00F29D  2  99 DA 00             STA     STAGE,Y
00F2A0  2  C8                   INY                     ; get another hex byte
00F2A1  2  20 8F F6             JSR     GETPAR
00F2A4  2  B0 04                BCS     HTGO            ; if there is none, start searching
00F2A6  2  C0 1E                CPY     #ESTAGE-STAGE   ; have we filled up the needle staging area?
00F2A8  2  D0 F1                BNE     HLP             ; if not, get another byte
00F2AA  2               HTGO:
00F2AA  2  84 BA                STY     SAVY            ; save length of needle
00F2AC  2  20 5B F7             JSR     CRLF            ; new line
00F2AF  2               HSCAN:
00F2AF  2  A0 00                LDY     #0
00F2B1  2               HLP3:
00F2B1  2  B1 C3                LDA     (TMP2),Y        ; get first byte in haystack
00F2B3  2  D9 DA 00             CMP     STAGE,Y         ; compare it to first byte of needle
00F2B6  2  D0 08                BNE     HNOFT           ; if it doesn't match, we haven't found anything
00F2B8  2  C8                   INY                     ; if it does, check the next byte
00F2B9  2  C4 BA                CPY     SAVY            ; have we reached the end of the needle?
00F2BB  2  D0 F4                BNE     HLP3            ; if not, keep comparing bytes
00F2BD  2  20 46 F7             JSR     SHOWAD          ; match found, show address
00F2C0  2               HNOFT:
00F2C0  2  20 FB F8             JSR     STOP            ; no match, check for stop key
00F2C3  2  F0 08                BEQ     HEXIT           ; exit prematurely if pressed
00F2C5  2  20 E6 F7             JSR     ADDA2           ; increment haystack pointer
00F2C8  2  20 D8 F7             JSR     SUB13           ; decrement haystack length
00F2CB  2  B0 E2                BCS     HSCAN           ; still more haystack? keep searching
00F2CD  2               HEXIT:
00F2CD  2  4C B7 F0             JMP     STRT            ; back to main loop
00F2D0  2               HERROR:
00F2D0  2  4C 06 F1             JMP     ERROR           ; handle error
00F2D3  2               
00F2D3  2               
00F2D3  2               ; -----------------------------------------------------------------------------
00F2D3  2               ; fill memory [F]
00F2D3  2               FILL:
00F2D3  2  20 0B F8             JSR     GETDIF          ; start in TMP2, end in STASH, length in STORE
00F2D6  2  B0 20                BCS     FERROR          ; carry set indicates error
00F2D8  2  20 8F F6             JSR     GETPAR          ; get value to fill in TMP0
00F2DB  2  B0 1B                BCS     FERROR          ; carry set indicates error
00F2DD  2  20 99 F7             JSR     GETCHR          ; any more characters triggers an error
00F2E0  2  D0 16                BNE     FERROR
00F2E2  2  A0 00                LDY     #0              ; no offset
00F2E4  2               FILLP:
00F2E4  2  A5 C1                LDA     TMP0            ; load value to fill in accumulator
00F2E6  2  91 C3                STA     (TMP2),Y        ; store fill value in current address
00F2E8  2  20 FB F8             JSR     STOP            ; check for stop key
00F2EB  2  F0 08                BEQ     FSTART          ; if pressed, back to main loop
00F2ED  2  20 E6 F7             JSR     ADDA2           ; increment address
00F2F0  2  20 D8 F7             JSR     SUB13           ; decrement length
00F2F3  2  B0 EF                BCS     FILLP           ; keep going until length reaches 0
00F2F5  2               FSTART:
00F2F5  2  4C B7 F0             JMP     STRT            ; back to main loop
00F2F8  2               FERROR:
00F2F8  2  4C 06 F1             JMP     ERROR           ; handle error
00F2FB  2               ; -----------------------------------------------------------------------------
00F2FB  2               ; Boot System [B]
00F2FB  2               BOOT:
00F2FB  2  B0 5E                BCS     BOOTX           ; exit with error if no parameter given
00F2FD  2  A5 C1                LDA     TMP0
00F2FF  2  29 0F                AND     #$0F
00F301  2  8D 00 18             STA     $1800
00F304  2  A9 8E                LDA     #$8E
00F306  2  8D 01 18             STA     $1801
00F309  2  A9 00                LDA     #$00
00F30B  2  8D 02 18             STA     $1802
00F30E  2  A9 D0                LDA     #$D0
00F310  2  8D 03 18             STA     $1803
00F313  2  A9 17                LDA     #$17
00F315  2  8D 04 18             STA     $1804
00F318  2  A5 C1                LDA     TMP0
00F31A  2  29 F0                AND     #$F0            ; filter out unit
00F31C  2  C9 00                CMP     #$00            ; is IDE?
00F31E  2  F0 07                BEQ     BOOT_IDE
00F320  2  C9 10                CMP     #$10            ; is Floppy?
00F322  2  F0 1D                BEQ     BOOT_FLOPPY
00F324  2  4C 5B F3             JMP     BOOTX
00F327  2               BOOT_IDE:
00F327  2  A9 1D                LDA     #29
00F329  2  85 32                STA     farfunct
00F32B  2  A0 18                LDY     #$18
00F32D  2  A9 00                LDA     #00
00F32F  2  20 6B 05             JSR     DO_FARCALL
00F332  2  A9 8E                LDA     #$8E
00F334  2  85 00                STA     $00
00F336  2  A9 00                LDA     #$00
00F338  2  85 01                STA     $01
00F33A  2  A9 D0                LDA     #$D0
00F33C  2  85 02                STA     $02
00F33E  2  4C 8D 05             JMP     DO_FARRUN
00F341  2               BOOT_FLOPPY:
00F341  2  A9 20                LDA     #32
00F343  2  85 32                STA     farfunct
00F345  2  A0 18                LDY     #$18
00F347  2  A9 00                LDA     #00
00F349  2  20 6B 05             JSR     DO_FARCALL
00F34C  2  A9 8E                LDA     #$8E
00F34E  2  85 00                STA     $00
00F350  2  A9 00                LDA     #$00
00F352  2  85 01                STA     $01
00F354  2  A9 D0                LDA     #$D0
00F356  2  85 02                STA     $02
00F358  2  4C 8D 05             JMP     DO_FARRUN
00F35B  2               BOOTX:
00F35B  2  4C 06 F1             JMP     ERROR           ; back to main loop
00F35E  2               
00F35E  2               ; -----------------------------------------------------------------------------
00F35E  2               ; Write OS [W]
00F35E  2               WRITEOS:
00F35E  2  B0 46                BCS     WRITEOSX        ; exit with error if no parameter given
00F360  2  A5 C1                LDA     TMP0
00F362  2  29 0F                AND     #$0F
00F364  2  8D 00 08             STA     $0800
00F367  2  A9 8E                LDA     #$8E
00F369  2  8D 01 08             STA     $0801
00F36C  2  A9 00                LDA     #$00
00F36E  2  8D 02 08             STA     $0802
00F371  2  A9 D0                LDA     #$D0
00F373  2  8D 03 08             STA     $0803
00F376  2  A9 17                LDA     #$17
00F378  2  8D 04 08             STA     $0804
00F37B  2  A5 C1                LDA     TMP0
00F37D  2  29 F0                AND     #$F0            ; filter out unit
00F37F  2  C9 00                CMP     #$00            ; is IDE?
00F381  2  F0 07                BEQ     WRITEOS_IDE
00F383  2  C9 10                CMP     #$10            ; is Floppy?
00F385  2  F0 11                BEQ     WRITEOS_FLOPPY
00F387  2  4C A6 F3             JMP     WRITEOSX
00F38A  2               WRITEOS_IDE:
00F38A  2  A9 1C                LDA     #28
00F38C  2  85 32                STA     farfunct
00F38E  2  A0 08                LDY     #08
00F390  2  A9 00                LDA     #00
00F392  2  20 6B 05             JSR     DO_FARCALL
00F395  2  4C B7 F0             JMP     STRT
00F398  2               WRITEOS_FLOPPY:
00F398  2  A9 1F                LDA     #31
00F39A  2  85 32                STA     farfunct
00F39C  2  A0 08                LDY     #08
00F39E  2  A9 00                LDA     #00
00F3A0  2  20 6B 05             JSR     DO_FARCALL
00F3A3  2  4C B7 F0             JMP     STRT
00F3A6  2               WRITEOSX:
00F3A6  2  4C 06 F1             JMP     ERROR           ; back to main loop
00F3A9  2               
00F3A9  2               ; -----------------------------------------------------------------------------
00F3A9  2               ; CLEAR DIRECTORY SECTORS [Z]
00F3A9  2               CLRDIR:
00F3A9  2  B0 2F                BCS     CLRDIRX         ; abort if no device specified
00F3AB  2  A5 C1                LDA     TMP0
00F3AD  2  8D 00 08             STA     $0800           ; save specified disk unit here
00F3B0  2  20 8F F6             JSR     GETPAR          ; get start track
00F3B3  2  B0 25                BCS     CLRDIRX         ; abort if not specified
00F3B5  2  20 AF F7             JSR     COPY12          ; save start track in TMP2
00F3B8  2  20 8F F6             JSR     GETPAR          ; get number of tracks in TMP0
00F3BB  2  B0 1D                BCS     CLRDIRX         ; abort if not specified
00F3BD  2  A5 C3                LDA     TMP2
00F3BF  2  8D 01 08             STA     $0801
00F3C2  2  A5 C4                LDA     TMP2+1
00F3C4  2  8D 02 08             STA     $0802
00F3C7  2  A5 C1                LDA     TMP0
00F3C9  2  8D 03 08             STA     $0803
00F3CC  2  A9 1E                LDA     #30
00F3CE  2  85 32                STA     farfunct
00F3D0  2  A0 08                LDY     #08
00F3D2  2  A9 00                LDA     #00
00F3D4  2  20 6B 05             JSR     DO_FARCALL
00F3D7  2  4C B7 F0             JMP     STRT            ; back to main loop
00F3DA  2               CLRDIRX:
00F3DA  2  4C 06 F1             JMP     ERROR           ; back to main loop
00F3DD  2               
00F3DD  2               ; -----------------------------------------------------------------------------
00F3DD  2               ; assemble [A.]
00F3DD  2               ; read in mnemonic
00F3DD  2               ASTART:
00F3DD  2  4C B7 F0             JMP     STRT            ; back to main loop
00F3E0  2               ASSEM:
00F3E0  2  B0 31                BCS     AERROR          ; error if no address given
00F3E2  2  20 AF F7             JSR     COPY12          ; copy address to TMP2
00F3E5  2               AGET1:
00F3E5  2  A2 00                LDX     #0
00F3E7  2  86 D1                STX     U0AA0+1         ; clear byte that mnemonic gets shifted into
00F3E9  2  86 CB                STX     DIGCNT          ; clear digit count
00F3EB  2               AGET2:
00F3EB  2  20 99 F7             JSR     GETCHR          ; get a char
00F3EE  2  D0 04                BNE     ALMOR           ; proceed if the character isn't null
00F3F0  2  E0 00                CPX     #0              ; it's null, have read a mnemonic yet?
00F3F2  2  F0 E9                BEQ     ASTART          ; if not, silently go back to main loop
00F3F4  2               ALMOR:
00F3F4  2  C9 20                CMP     #$20            ; skip leading spaces
00F3F6  2  F0 ED                BEQ     AGET1
00F3F8  2  95 C7                STA     MNEMW,X         ; put character in mnemonic buffer
00F3FA  2  E8                   INX
00F3FB  2  E0 03                CPX     #3              ; have we read 3 characters yet?
00F3FD  2  D0 EC                BNE     AGET2           ; if not, get next character
00F3FF  2               
00F3FF  2               ; compress mnemonic into two bytes
00F3FF  2               ASQEEZ:
00F3FF  2  CA                   DEX                     ; move to previous char
00F400  2  30 14                BMI     AOPRND          ; if we're done with mnemonic, look for operand
00F402  2  B5 C7                LDA     MNEMW,X         ; get current character
00F404  2  38                   SEC                     ; pack 3-letter mnemonic into 2 bytes (15 bits)
00F405  2  E9 3F                SBC     #$3F            ; subtract $3F from ascii code so A-Z = 2 to 27
00F407  2  A0 05                LDY     #$05            ; letters now fit in 5 bits; shift them out
00F409  2               ASHIFT:
00F409  2  4A                   LSR     A               ;   into the first two bytes of the inst buffer
00F40A  2  66 D1                ROR     U0AA0+1         ; catch the low bit from accumulator in right byte
00F40C  2  66 D0                ROR     U0AA0           ; catch the low bit from right byte in left byte
00F40E  2  88                   DEY                     ; count down bits
00F40F  2  D0 F8                BNE     ASHIFT          ; keep looping until we reach zero
00F411  2  F0 EC                BEQ     ASQEEZ          ; unconditional branch to handle next char
00F413  2               AERROR:
00F413  2  4C 06 F1             JMP     ERROR           ; handle error
00F416  2               
00F416  2               ; parse operand
00F416  2               AOPRND:
00F416  2  A2 02                LDX     #2              ; mnemonic is in first two bytes so start at third
00F418  2               ASCAN:
00F418  2  A5 CB                LDA     DIGCNT          ; did we find address digits last time?
00F41A  2  D0 28                BNE     AFORM1          ; if so, look for mode chars
00F41C  2  20 B4 F6             JSR     RDVAL           ; otherwise, look for an address
00F41F  2  F0 21                BEQ     AFORM0          ; we didn't find an address, look for characters
00F421  2  B0 F0                BCS     AERROR          ; carry flag indicates error
00F423  2  A9 24                LDA     #'$'
00F425  2  95 D0                STA     U0AA0,X         ; prefix addresses with $
00F427  2  E8                   INX                     ; next position in buffer
00F428  2  A0 04                LDY     #4              ; non-zero page addresses are 4 hex digits
00F42A  2  A5 CD                LDA     NUMBIT          ; check numeric base in which address was given
00F42C  2  C9 08                CMP     #8              ; for addresses given in octal or binary
00F42E  2  90 04                BCC     AADDR           ;   use only the high byte to determine page
00F430  2  C4 CB                CPY     DIGCNT          ; for decimal or hex, force non-zero page addressing
00F432  2  F0 06                BEQ     AFILL0          ;   if address was given with four digits or more
00F434  2               AADDR:
00F434  2  A5 C2                LDA     TMP0+1          ; check whether high byte of address is zero
00F436  2  D0 02                BNE     AFILL0          ; non-zero high byte means we're not in zero page
00F438  2  A0 02                LDY     #2              ; if it's in zero page, addr is 2 hex digits
00F43A  2               AFILL0:
00F43A  2  A9 30                LDA     #$30            ; use 0 as placeholder for each hex digit in addr
00F43C  2               AFIL0L:
00F43C  2  95 D0                STA     U0AA0,X         ; put placeholder in assembly buffer
00F43E  2  E8                   INX                     ; move to next byte in buffer
00F43F  2  88                   DEY                     ; decrement number of remaining digits
00F440  2  D0 FA                BNE     AFIL0L          ; loop until all digits have been placed
00F442  2               AFORM0:
00F442  2  C6 B9                DEC     CHRPNT          ; non-numeric input; back 1 char to see what it was
00F444  2               AFORM1:
00F444  2  20 99 F7             JSR     GETCHR          ; get next character
00F447  2  F0 0D                BEQ     AESCAN          ; if there is none, we're finished scanning
00F449  2  C9 20                CMP     #$20            ; skip spaces
00F44B  2  F0 CB                BEQ     ASCAN
00F44D  2  95 D0                STA     U0AA0,X         ; store character in assembly buffer
00F44F  2  E8                   INX                     ; move to next byte in buffer
00F450  2  E0 0A                CPX     #U0AAE-U0AA0    ; is instruction buffer full?
00F452  2  90 C4                BCC     ASCAN           ; if not, keep scanning
00F454  2  B0 BD                BCS     AERROR          ; error if buffer is full
00F456  2               
00F456  2               ; find matching opcode
00F456  2               AESCAN:
00F456  2  86 B7                STX     STORE           ; save number of bytes in assembly buffer
00F458  2  A2 00                LDX     #0              ; start at opcode $00 and check every one until
00F45A  2  86 CB                STX     OPCODE          ;   we find one that matches our criteria
00F45C  2               ATRYOP:
00F45C  2  A2 00                LDX     #0
00F45E  2  86 BB                STX     U9F             ; reset index into work buffer
00F460  2  A5 CB                LDA     OPCODE
00F462  2  20 25 F6             JSR     INSTXX          ; look up instruction format for current opcode
00F465  2  A6 C5                LDX     ACMD            ; save addressing command for later
00F467  2  86 B8                STX     STORE+1
00F469  2  AA                   TAX                     ; use current opcode as index
00F46A  2  BD 59 FA             LDA     MNEMR,X         ; check right byte of compressed mnemonic
00F46D  2  20 5B F5             JSR     CHEKOP
00F470  2  BD 19 FA             LDA     MNEML,X         ; check left byte of compressed mnemonic
00F473  2  20 5B F5             JSR     CHEKOP
00F476  2  A2 06                LDX     #6              ; 6 possible characters to check against operand
00F478  2               TRYIT:
00F478  2  E0 03                CPX     #3              ; are we on character 3?
00F47A  2  D0 12                BNE     TRYMOD          ; if not, check operand characters
00F47C  2  A4 C6                LDY     LENGTH          ; otherwise, check number of bytes in operand
00F47E  2  F0 0E                BEQ     TRYMOD          ; if zero, check operand characters
00F480  2               TRYAD:
00F480  2  A5 C5                LDA     ACMD            ; otherwise, look for an address
00F482  2  C9 E8                CMP     #$E8            ; special case for relative addressing mode
00F484  2                                               ;   since it's specified with 4 digits in assembly
00F484  2                                               ;   but encoded with only 1 byte in object code
00F484  2  A9 30                LDA     #$30            ; '0' is the digit placeholder we're looking for
00F486  2  B0 1D                BCS     TRY4B           ; ACMD >= $E8 indicates relative addressing
00F488  2  20 58 F5             JSR     CHEK2B          ; ACMD < $E8 indicates normal addressing
00F48B  2  88                   DEY                     ; consume byte
00F48C  2  D0 F2                BNE     TRYAD           ; check for 2 more digits if not zero-page
00F48E  2               TRYMOD:
00F48E  2  06 C5                ASL     ACMD            ; shift a bit out of the addressing command
00F490  2  90 0E                BCC     UB4DF           ; if it's zero, skip checking current character
00F492  2  BD 0C FA             LDA     CHAR1-1,X
00F495  2  20 5B F5             JSR     CHEKOP          ; otherwise first character against operand
00F498  2  BD 12 FA             LDA     CHAR2-1,X       ; get second character to check
00F49B  2  F0 03                BEQ     UB4DF           ; if it's zero, skip checking it
00F49D  2  20 5B F5             JSR     CHEKOP          ; otherwise check it against hte operand
00F4A0  2               UB4DF:
00F4A0  2  CA                   DEX                     ; move to next character
00F4A1  2  D0 D5                BNE     TRYIT           ; repeat tests
00F4A3  2  F0 06                BEQ     TRYBRAN
00F4A5  2               TRY4B:
00F4A5  2  20 58 F5             JSR     CHEK2B          ; check for 4 digit address placeholder
00F4A8  2  20 58 F5             JSR     CHEK2B          ;   by checking for 2 digits twice
00F4AB  2               TRYBRAN:
00F4AB  2  A5 B7                LDA     STORE           ; get number of bytes in assembly buffer
00F4AD  2  C5 BB                CMP     U9F             ; more bytes left to check?
00F4AF  2  F0 03                BEQ     ABRAN           ; if not, we've found a match; build instruction
00F4B1  2  4C 65 F5             JMP     BUMPOP          ; if so, this opcode doesn't match; try the next
00F4B4  2               
00F4B4  2               ; convert branches to relative address
00F4B4  2               ABRAN:
00F4B4  2  A4 C6                LDY     LENGTH          ; get number of bytes in operand
00F4B6  2  F0 33                BEQ     A1BYTE          ; if none, just output the opcode
00F4B8  2  A5 B8                LDA     STORE+1         ; otherwise check the address format
00F4BA  2  C9 9D                CMP     #$9D            ; is it a relative branch?
00F4BC  2  D0 25                BNE     OBJPUT          ; if not, skip relative branch calculation
00F4BE  2  A5 C1                LDA     TMP0            ; calculate the difference between the current
00F4C0  2  E5 C3                SBC     TMP2            ;   address and the branch target (low byte)
00F4C2  2  AA                   TAX                     ; save it in X
00F4C3  2  A5 C2                LDA     TMP0+1          ; borrow from the high byte if necessary
00F4C5  2  E5 C4                SBC     TMP2+1
00F4C7  2  90 0B                BCC     ABBACK          ; if result is negative, we're branching back
00F4C9  2  F0 03                BEQ     :++             ; high bytes must be equal when branching forward
00F4CB  2               :
00F4CB  2  4C 55 F5             JMP     SERROR
00F4CE  2               :
00F4CE  2  E0 82                CPX     #$82            ; difference between low bytes must be < 130
00F4D0  2  B0 F9                BCS     :--             ; error if the address is too far away
00F4D2  2  90 08                BCC     ABRANX
00F4D4  2               ABBACK:
00F4D4  2  A8                   TAY                     ; when branching backward high byte of target must
00F4D5  2  C8                   INY                     ;   be 1 less than high byte of current address
00F4D6  2  D0 7D                BNE     SERROR          ; if not, it's too far away
00F4D8  2  E0 82                CPX     #$82            ; difference between low bytes must be < 130
00F4DA  2  90 79                BCC     SERROR          ; if not, it's too far away
00F4DC  2               ABRANX:
00F4DC  2  CA                   DEX                     ; adjust branch target relative to the
00F4DD  2  CA                   DEX                     ;   instruction following this one
00F4DE  2  8A                   TXA
00F4DF  2  A4 C6                LDY     LENGTH          ; load length of operand
00F4E1  2  D0 03                BNE     OBJP2           ; don't use the absolute address
00F4E3  2               
00F4E3  2               ; assemble machine code
00F4E3  2               OBJPUT:
00F4E3  2  B9 C0 00             LDA     TMP0-1,Y        ; get the operand
00F4E6  2               OBJP2:
00F4E6  2  91 C3                STA     (TMP2),Y        ; store it after the opcode
00F4E8  2  88                   DEY
00F4E9  2  D0 F8                BNE     OBJPUT          ; copy the other byte of operand if there is one
00F4EB  2               A1BYTE:
00F4EB  2  A5 CB                LDA     OPCODE          ; put opcode into instruction
00F4ED  2  91 C3                STA     (TMP2),Y
00F4EF  2  A9 0D                LDA     #$0D            ; cr
00F4F1  2  20 67 F0             JSR     CHROUT
00F4F4  2  A0 2E                LDY     #MSG7-MSGBAS    ; "A " prefix
00F4F6  2  20 DA F8             JSR     SNDCLR          ; clear line
00F4F9  2  A9 41                LDA     #'A'
00F4FB  2  20 67 F0             JSR     CHROUT
00F4FE  2  A9 20                LDA     #' '
00F500  2  20 67 F0             JSR     CHROUT
00F503  2  20 AD F5             JSR     DISLIN          ; disassemble the instruction we just assembled
00F506  2  E6 C6                INC     LENGTH          ; instruction length = operand length + 1 byte
00F508  2  A5 C6                LDA     LENGTH          ;   for the opcode
00F50A  2  20 E8 F7             JSR     BUMPAD2         ; increment address by length of instruction
00F50D  2                                               ; setup for the next assemble command
00F50D  2  20 5B F7             JSR     CRLF
00F510  2  A9 41                LDA     #'A'            ; stuff keyboard buffer with next assemble command:
00F512  2  8D 00 02             STA     INBUFF
00F515  2  20 67 F0             JSR     OUTCH
00F518  2  A9 20                LDA     #' '            ;   after the previously assembled instruction
00F51A  2  8D 01 02             STA     INBUFF+1
00F51D  2  20 67 F0             JSR     OUTCH
00F520  2  A5 C4                LDA     TMP2+1          ; convert high byte of next address to hex
00F522  2  20 82 F7             JSR     ASCTWO
00F525  2  8D 02 02             STA     INBUFF+2        ; put it in the keyboard buffer
00F528  2  20 67 F0             JSR     OUTCH
00F52B  2  8E 03 02             STX     INBUFF+3
00F52E  2  8A                   TXA
00F52F  2  20 67 F0             JSR     OUTCH
00F532  2  A5 C3                LDA     TMP2            ; convert low byte of next address to hex
00F534  2  20 82 F7             JSR     ASCTWO
00F537  2  8D 04 02             STA     INBUFF+4        ; put it in the keyboard buffer
00F53A  2  20 67 F0             JSR     OUTCH
00F53D  2  8E 05 02             STX     INBUFF+5
00F540  2  8A                   TXA
00F541  2  20 67 F0             JSR     OUTCH
00F544  2  A9 20                LDA     #' '            ;   after the previously assembled instruction
00F546  2  8D 06 02             STA     INBUFF+6
00F549  2  20 67 F0             JSR     OUTCH
00F54C  2  A2 07                LDX     #7              ; set number of chars in keyboard buffer
00F54E  2  A9 00                LDA     #$00
00F550  2  85 B9                STA     CHRPNT
00F552  2  4C BE F0             JMP     SMOVE           ; back to main loop
00F555  2               SERROR:
00F555  2  4C 06 F1             JMP     ERROR           ; handle error
00F558  2               
00F558  2               ; check characters in operand
00F558  2               CHEK2B:
00F558  2  20 5B F5             JSR     CHEKOP          ; check two bytes against value in accumulator
00F55B  2               CHEKOP:
00F55B  2  86 CA                STX     SAVX            ; stash X
00F55D  2  A6 BB                LDX     U9F             ; get current index into work buffer
00F55F  2  D5 D0                CMP     U0AA0,X         ; check whether this opcode matches the buffer
00F561  2  F0 09                BEQ     OPOK            ;   matching so far, check the next criteria
00F563  2  68                   PLA                     ; didn't match, so throw away return address
00F564  2  68                   PLA                     ;   on the stack because we're starting over
00F565  2               BUMPOP:
00F565  2  E6 CB                INC     OPCODE          ; check the next opcode
00F567  2  F0 EC                BEQ     SERROR          ; error if we tried every opcode and none fit
00F569  2  4C 5C F4             JMP     ATRYOP          ; start over with new opcode
00F56C  2               OPOK:
00F56C  2  E6 BB                INC     U9F             ; opcode matches so far; check the next criteria
00F56E  2  A6 CA                LDX     SAVX            ; restore X
00F570  2  60                   RTS
00F571  2               
00F571  2               ; -----------------------------------------------------------------------------
00F571  2               ; disassemble [D]
00F571  2               DISASS:
00F571  2  B0 08                BCS     DIS0AD          ; if no address was given, start from last address
00F573  2  20 AF F7             JSR     COPY12          ; copy start address to TMP2
00F576  2  20 8F F6             JSR     GETPAR          ; get end address in TMP0
00F579  2  90 06                BCC     DIS2AD          ; if one was given, skip default
00F57B  2               DIS0AD:
00F57B  2  A9 14                LDA     #$14            ; disassemble 14 bytes by default
00F57D  2  85 C1                STA     TMP0            ; store length in TMP0
00F57F  2  D0 05                BNE     DISGO           ; skip length calculation
00F581  2               DIS2AD:
00F581  2  20 B8 F7             JSR     SUB12           ; calculate number of bytes between start and end
00F584  2  90 1C                BCC     DERROR          ; error if end address is before start address
00F586  2               DISGO:
00F586  2  20 D4 F8             JSR     CLINE           ; clear the current line
00F589  2  20 FB F8             JSR     STOP            ; check for stop key
00F58C  2  F0 11                BEQ     DISEXIT         ; exit early if pressed
00F58E  2  20 A5 F5             JSR     DSOUT1          ; output disassembly prefix ". "
00F591  2  E6 C6                INC     LENGTH
00F593  2  A5 C6                LDA     LENGTH          ; add length of last instruction to start address
00F595  2  20 E8 F7             JSR     BUMPAD2
00F598  2  A5 C6                LDA     LENGTH          ; subtract length of last inst from end address
00F59A  2  20 C8 F7             JSR     SUBA2
00F59D  2  B0 E7                BCS     DISGO
00F59F  2               DISEXIT:
00F59F  2  4C B7 F0             JMP     STRT            ; back to mainloop
00F5A2  2               DERROR:
00F5A2  2  4C 06 F1             JMP     ERROR
00F5A5  2               
00F5A5  2               DSOUT1:
00F5A5  2  A9 2E                LDA     #'.'            ; output ". " prefix to allow edit and reassemble
00F5A7  2  20 67 F0             JSR     CHROUT
00F5AA  2  20 53 F7             JSR     SPACE
00F5AD  2               
00F5AD  2               DISLIN:
00F5AD  2  20 46 F7             JSR     SHOWAD          ; show the address of the instruction
00F5B0  2  20 53 F7             JSR     SPACE           ; insert a space
00F5B3  2  A0 00                LDY     #0              ; no offset
00F5B5  2  B1 C3                LDA     (TMP2),Y        ; load operand of current instruction
00F5B7  2  20 25 F6             JSR     INSTXX          ; get mnemonic and addressing mode for opcode
00F5BA  2  48                   PHA                     ; save index into mnemonic table
00F5BB  2  A6 C6                LDX     LENGTH          ; get length of operand
00F5BD  2  E8                   INX                     ; add 1 byte for opcode
00F5BE  2               DSBYT:
00F5BE  2  CA                   DEX                     ; decrement index
00F5BF  2  10 0C                BPL     DSHEX           ; show hex for byte being disassembled
00F5C1  2  84 BA                STY     SAVY            ; save index
00F5C3  2  A0 30                LDY     #MSG8-MSGBAS    ; skip 3 spaces
00F5C5  2  20 ED F8             JSR     SNDMSG
00F5C8  2  A4 BA                LDY     SAVY            ; restore index
00F5CA  2  4C D2 F5             JMP     NXBYT
00F5CD  2               DSHEX:
00F5CD  2  B1 C3                LDA     (TMP2),Y        ; show hex for byte
00F5CF  2  20 50 F7             JSR     WRBYTE
00F5D2  2               
00F5D2  2               NXBYT:
00F5D2  2  C8                   INY                     ; next byte
00F5D3  2  C0 03                CPY     #3              ; have we output 3 bytes yet?
00F5D5  2  90 E7                BCC     DSBYT           ; if not, loop
00F5D7  2  68                   PLA                     ; restore index into mnemonic table
00F5D8  2  A2 03                LDX     #3              ; 3 letters in mnemonic
00F5DA  2  20 6B F6             JSR     PROPXX          ; print mnemonic
00F5DD  2  A2 06                LDX     #6              ; 6 possible address mode character combos
00F5DF  2               PRADR1:
00F5DF  2  E0 03                CPX     #3              ; have we checked the third combo yet?
00F5E1  2  D0 14                BNE     PRADR3          ; if so, output the leading characters
00F5E3  2  A4 C6                LDY     LENGTH          ; get the length of the operand
00F5E5  2  F0 10                BEQ     PRADR3          ; if it's zero, there's no operand to print
00F5E7  2               PRADR2:
00F5E7  2  A5 C5                LDA     ACMD            ; otherwise, get the addressing mode
00F5E9  2  C9 E8                CMP     #$E8            ; check for relative addressing
00F5EB  2  08                   PHP                     ; save result of check
00F5EC  2  B1 C3                LDA     (TMP2),Y        ; get the operand
00F5EE  2  28                   PLP                     ; restore result of check
00F5EF  2  B0 1C                BCS     RELAD           ; handle a relative address
00F5F1  2  20 74 F7             JSR     WRTWO           ; output digits from address
00F5F4  2  88                   DEY
00F5F5  2  D0 F0                BNE     PRADR2          ; repeat for next byte of operand, if there is one
00F5F7  2               PRADR3:
00F5F7  2  06 C5                ASL     ACMD            ; check whether addr mode uses the current char
00F5F9  2  90 0E                BCC     PRADR4          ; if not, skip it
00F5FB  2  BD 0C FA             LDA     CHAR1-1,X       ; look up the first char in the table
00F5FE  2  20 67 F0             JSR     CHROUT          ; print first char
00F601  2  BD 12 FA             LDA     CHAR2-1,X       ; look up the second char in the table
00F604  2  F0 03                BEQ     PRADR4          ; if there's no second character, skip it
00F606  2  20 67 F0             JSR     CHROUT          ; print second char
00F609  2               PRADR4:
00F609  2  CA                   DEX                     ; next potential address mode character
00F60A  2  D0 D3                BNE     PRADR1          ; loop if we haven't checked them all yet
00F60C  2  60                   RTS                     ; back to caller
00F60D  2               RELAD:
00F60D  2  20 19 F6             JSR     UB64D           ; calculate absolute address from relative
00F610  2  18                   CLC
00F611  2  69 01                ADC     #1              ; adjust address relative to next instruction
00F613  2  D0 01                BNE     RELEND          ; don't increment high byte unless we overflowed
00F615  2  E8                   INX                     ; increment high byte
00F616  2               RELEND:
00F616  2  4C 4A F7             JMP     WRADDR          ; print address
00F619  2               
00F619  2               UB64D:
00F619  2  A6 C4                LDX     TMP2+1          ; get high byte of current address
00F61B  2  A8                   TAY                     ; is relative address positive or negative?
00F61C  2  10 01                BPL     RELC2           ; if positive, leave high byte alone
00F61E  2  CA                   DEX                     ; if negative, decrement high byte
00F61F  2               RELC2:
00F61F  2  65 C3                ADC     TMP2            ; add relative address to low byte
00F621  2  90 01                BCC     RELC3           ; if there's no carry, we're done
00F623  2  E8                   INX                     ; if there's a carry, increment the high byte
00F624  2               RELC3:
00F624  2  60                   RTS
00F625  2               
00F625  2               ; -----------------------------------------------------------------------------
00F625  2               ; get opcode mode and length
00F625  2               
00F625  2               ; Note: the labels are different, but the code of this subroutine is almost
00F625  2               ; identical to the INSDS2 subroutine of the Apple Mini-Assembler on page 78 of
00F625  2               ; the Apple II Red Book. I'm not sure exactly where this code originated
00F625  2               ; (MOS or Apple) but it's clear that this part of Supermon64 and the
00F625  2               ; Mini-Asssembler share a common heritage.  The comments showing the way the
00F625  2               ; opcodes are transformed into indexes for the mnemonic lookup table come
00F625  2               ; from the Mini-Assembler source.
00F625  2               
00F625  2               INSTXX:
00F625  2  A8                   TAY                     ; stash opcode in accumulator in Y for later
00F626  2  4A                   LSR     A               ; is opcode even or odd?
00F627  2  90 0B                BCC     IEVEN
00F629  2  4A                   LSR     A
00F62A  2  B0 17                BCS     ERR             ; invalid opcodes XXXXXX11
00F62C  2  C9 22                CMP     #$22
00F62E  2  F0 13                BEQ     ERR             ; invalid opcode 10001001
00F630  2  29 07                AND     #$07            ; mask bits to 10000XXX
00F632  2  09 80                ORA     #$80
00F634  2               IEVEN:
00F634  2  4A                   LSR     A               ; LSB determines whether to use left/right nybble
00F635  2  AA                   TAX                     ; get format index using remaining high bytes
00F636  2  BD BB F9             LDA     MODE,X
00F639  2  B0 04                BCS     RTMODE          ; look at left or right nybble based on carry bit
00F63B  2  4A                   LSR     A               ; if carry = 0, use left nybble
00F63C  2  4A                   LSR     A
00F63D  2  4A                   LSR     A
00F63E  2  4A                   LSR     A
00F63F  2               RTMODE:
00F63F  2  29 0F                AND     #$0F            ; if carry = 1, use right nybble
00F641  2  D0 04                BNE     GETFMT
00F643  2               ERR:
00F643  2  A0 80                LDY     #$80            ; substitute 10000000 for invalid opcodes
00F645  2  A9 00                LDA     #0
00F647  2               GETFMT:
00F647  2  AA                   TAX
00F648  2  BD FF F9             LDA     MODE2,X         ; lookup operand format using selected nybble
00F64B  2  85 C5                STA     ACMD            ; save for later use
00F64D  2  29 03                AND     #$03            ; lower 2 bits indicate number of bytes in operand
00F64F  2  85 C6                STA     LENGTH
00F651  2  98                   TYA                     ; restore original opcode
00F652  2  29 8F                AND     #$8F            ; mask bits to X000XXXX
00F654  2  AA                   TAX                     ; save it
00F655  2  98                   TYA                     ; restore original opcode
00F656  2  A0 03                LDY     #3
00F658  2  E0 8A                CPX     #$8A            ; check if opcode = 1XXX1010
00F65A  2  F0 0B                BEQ     GTFM4
00F65C  2               GTFM2:
00F65C  2  4A                   LSR     A               ; transform opcode into index for mnemonic table
00F65D  2  90 08                BCC     GTFM4
00F65F  2  4A                   LSR     A               ; opcodes transformed as follows:
00F660  2               GTFM3:
00F660  2  4A                   LSR     A               ; 1XXX1010->00101XXX
00F661  2  09 20                ORA     #$20            ; XXXYYY01->00111XXX
00F663  2  88                   DEY                     ; XXXYYY10->00111XXX
00F664  2  D0 FA                BNE     GTFM3           ; XXXYY100->00110XXX
00F666  2  C8                   INY                     ; XXXXX000->000XXXXX
00F667  2               GTFM4:
00F667  2  88                   DEY
00F668  2  D0 F2                BNE     GTFM2
00F66A  2  60                   RTS
00F66B  2               
00F66B  2               ; -----------------------------------------------------------------------------
00F66B  2               ; extract and print packed mnemonics
00F66B  2               PROPXX:
00F66B  2  A8                   TAY                     ; use index in accumulator to look up mnemonic
00F66C  2  B9 19 FA             LDA     MNEML,Y         ;   and place a temporary copy in STORE
00F66F  2  85 B7                STA     STORE
00F671  2  B9 59 FA             LDA     MNEMR,Y
00F674  2  85 B8                STA     STORE+1
00F676  2               PRMN1:
00F676  2  A9 00                LDA     #0              ; clear accumulator
00F678  2  A0 05                LDY     #$05            ; shift 5 times
00F67A  2               PRMN2:
00F67A  2  06 B8                ASL     STORE+1         ; shift right byte
00F67C  2  26 B7                ROL     STORE           ; rotate bits from right byte into left byte
00F67E  2  2A                   ROL     A               ; rotate bits from left byte into accumulator
00F67F  2  88                   DEY                     ; next bit
00F680  2  D0 F8                BNE     PRMN2           ; loop until all bits shifted
00F682  2  69 3F                ADC     #$3F            ; calculate ascii code for letter by adding to '?'
00F684  2  20 67 F0             JSR     CHROUT          ; output letter
00F687  2  CA                   DEX                     ; next letter
00F688  2  D0 EC                BNE     PRMN1           ; loop until all 3 letters are output
00F68A  2  4C 53 F7             JMP     SPACE           ; output space
00F68D  2               
00F68D  2               ; -----------------------------------------------------------------------------
00F68D  2               ; read parameters
00F68D  2               RDPAR:
00F68D  2  C6 B9                DEC     CHRPNT          ; back up one char
00F68F  2               GETPAR:
00F68F  2  20 B4 F6             JSR     RDVAL           ; read the value
00F692  2  B0 15                BCS     GTERR           ; carry set indicates error
00F694  2  20 97 F7             JSR     GOTCHR          ; check previous character
00F697  2  D0 08                BNE     CKTERM          ; if it's not null, check if it's a valid separator
00F699  2  C6 B9                DEC     CHRPNT          ; back up one char
00F69B  2  A5 CB                LDA     DIGCNT          ; get number of digits read
00F69D  2  D0 11                BNE     GETGOT          ; found some digits
00F69F  2  F0 0D                BEQ     GTNIL           ; didn't find any digits
00F6A1  2               CKTERM:
00F6A1  2  C9 20                CMP     #$20            ; space or comma are valid separators
00F6A3  2  F0 0B                BEQ     GETGOT          ; anything else is an error
00F6A5  2  C9 2C                CMP     #','
00F6A7  2  F0 07                BEQ     GETGOT
00F6A9  2               GTERR:
00F6A9  2  68                   PLA                     ; encountered error
00F6AA  2  68                   PLA                     ; get rid of command vector pushed on stack
00F6AB  2  4C 06 F1             JMP     ERROR           ; handle error
00F6AE  2               GTNIL:
00F6AE  2  38                   SEC                     ; set carry to indicate no parameter found
00F6AF  2  24                   .BYTE   $24             ; BIT ZP opcode consumes next byte (CLC)
00F6B0  2               GETGOT:
00F6B0  2  18                   CLC                     ; clear carry to indicate paremeter returned
00F6B1  2  A5 CB                LDA     DIGCNT          ; return number of digits in A
00F6B3  2  60                   RTS                     ; return to address pushed from vector table
00F6B4  2               
00F6B4  2               ; -----------------------------------------------------------------------------
00F6B4  2               ; read a value in the specified base
00F6B4  2               RDVAL:
00F6B4  2  A9 00                LDA     #0              ; clear temp
00F6B6  2  85 C1                STA     TMP0
00F6B8  2  85 C2                STA     TMP0+1
00F6BA  2  85 CB                STA     DIGCNT          ; clear digit counter
00F6BC  2  8A                   TXA                     ; save X and Y
00F6BD  2  48                   PHA
00F6BE  2  98                   TYA
00F6BF  2  48                   PHA
00F6C0  2               RDVMOR:
00F6C0  2  20 99 F7             JSR     GETCHR          ; get next character from input buffer
00F6C3  2  F0 1C                BEQ     RDNILK          ; null at end of buffer
00F6C5  2  C9 20                CMP     #$20            ; skip spaces
00F6C7  2  F0 F7                BEQ     RDVMOR
00F6C9  2  A2 03                LDX     #3              ; check numeric base [$+&%]
00F6CB  2               GNMODE:
00F6CB  2  DD AE FA             CMP     HIKEY,X
00F6CE  2  F0 06                BEQ     GOTMOD          ; got a match, set up base
00F6D0  2  CA                   DEX
00F6D1  2  10 F8                BPL     GNMODE          ; check next base
00F6D3  2  E8                   INX                     ; default to hex
00F6D4  2  C6 B9                DEC     CHRPNT          ; back up one character
00F6D6  2               GOTMOD:
00F6D6  2  BC D4 FA             LDY     MODTAB,X        ; get base value
00F6D9  2  BD D8 FA             LDA     LENTAB,X        ; get bits per digit
00F6DC  2  85 CD                STA     NUMBIT          ; store bits per digit
00F6DE  2               NUDIG:
00F6DE  2  20 99 F7             JSR     GETCHR          ; get next char in A
00F6E1  2               RDNILK:
00F6E1  2  F0 59                BEQ     RDNIL           ; end of number if no more characters
00F6E3  2  38                   SEC
00F6E4  2  E9 30                SBC     #$30            ; subtract ascii value of 0 to get numeric value
00F6E6  2  90 54                BCC     RDNIL           ; end of number if character was less than 0
00F6E8  2  C9 0A                CMP     #$0A
00F6EA  2  90 06                BCC     DIGMOR          ; not a hex digit if less than A
00F6EC  2  E9 07                SBC     #$07            ; 7 chars between ascii 9 and A, so subtract 7
00F6EE  2  C9 10                CMP     #$10            ; end of number if char is greater than F
00F6F0  2  B0 4A                BCS     RDNIL
00F6F2  2               DIGMOR:
00F6F2  2  85 CC                STA     INDIG           ; store the digit
00F6F4  2  C4 CC                CPY     INDIG           ; compare base with the digit
00F6F6  2  90 42                BCC     RDERR           ; error if the digit >= the base
00F6F8  2  F0 40                BEQ     RDERR
00F6FA  2  E6 CB                INC     DIGCNT          ; increment the number of digits
00F6FC  2  C0 0A                CPY     #10
00F6FE  2  D0 09                BNE     NODECM          ; skip the next part if not using base 10
00F700  2  A2 01                LDX     #1
00F702  2               DECLP1:
00F702  2  B5 C1                LDA     TMP0,X          ; stash the previous 16-bit value for later use
00F704  2  95 CE                STA     STASH,X
00F706  2  CA                   DEX
00F707  2  10 F9                BPL     DECLP1
00F709  2               NODECM:
00F709  2  A6 CD                LDX     NUMBIT          ; number of bits to shift
00F70B  2               TIMES2:
00F70B  2  06 C1                ASL     TMP0            ; shift 16-bit value by specified number of bits
00F70D  2  26 C2                ROL     TMP0+1
00F70F  2  B0 29                BCS     RDERR           ; error if we overflowed 16 bits
00F711  2  CA                   DEX
00F712  2  D0 F7                BNE     TIMES2          ; shift remaining bits
00F714  2  C0 0A                CPY     #10
00F716  2  D0 14                BNE     NODEC2          ; skip the next part if not using base 10
00F718  2  06 CE                ASL     STASH           ; shift the previous 16-bit value one bit left
00F71A  2  26 CF                ROL     STASH+1
00F71C  2  B0 1C                BCS     RDERR           ; error if we overflowed 16 bits
00F71E  2  A5 CE                LDA     STASH           ; add shifted previous value to current value
00F720  2  65 C1                ADC     TMP0
00F722  2  85 C1                STA     TMP0
00F724  2  A5 CF                LDA     STASH+1
00F726  2  65 C2                ADC     TMP0+1
00F728  2  85 C2                STA     TMP0+1
00F72A  2  B0 0E                BCS     RDERR           ; error if we overflowed 16 bits
00F72C  2               NODEC2:
00F72C  2  18                   CLC
00F72D  2  A5 CC                LDA     INDIG           ; load current digit
00F72F  2  65 C1                ADC     TMP0            ; add current digit to low byte
00F731  2  85 C1                STA     TMP0            ; and store result back in low byte
00F733  2  8A                   TXA                     ; A=0
00F734  2  65 C2                ADC     TMP0+1          ; add carry to high byte
00F736  2  85 C2                STA     TMP0+1          ; and store result back in high byte
00F738  2  90 A4                BCC     NUDIG           ; get next digit if we didn't overflow
00F73A  2               RDERR:
00F73A  2  38                   SEC                     ; set carry to indicate error
00F73B  2  24                   .BYTE   $24             ; BIT ZP opcode consumes next byte (CLC)
00F73C  2               RDNIL:
00F73C  2  18                   CLC                     ; clear carry to indicate success
00F73D  2  84 CD                STY     NUMBIT          ; save base of number
00F73F  2  68                   PLA                     ; restore X and Y
00F740  2  A8                   TAY
00F741  2  68                   PLA
00F742  2  AA                   TAX
00F743  2  A5 CB                LDA     DIGCNT          ; return number of digits in A
00F745  2  60                   RTS
00F746  2               
00F746  2               ; -----------------------------------------------------------------------------
00F746  2               ; print address
00F746  2               SHOWAD:
00F746  2  A5 C3                LDA     TMP2
00F748  2  A6 C4                LDX     TMP2+1
00F74A  2               
00F74A  2               WRADDR:
00F74A  2  48                   PHA                     ; save low byte
00F74B  2  8A                   TXA                     ; put high byte in A
00F74C  2  20 74 F7             JSR     WRTWO           ; output high byte
00F74F  2  68                   PLA                     ; restore low byte
00F750  2               
00F750  2               WRBYTE:
00F750  2  20 74 F7             JSR     WRTWO           ; output byte in A
00F753  2               
00F753  2               SPACE:
00F753  2  A9 20                LDA     #$20            ; output space
00F755  2  D0 0F                BNE     FLIP
00F757  2               
00F757  2               CHOUT:
00F757  2  C9 0D                CMP     #$0D            ; output char with special handling of CR
00F759  2  D0 0B                BNE     FLIP
00F75B  2               CRLF:
00F75B  2  A9 0D                LDA     #$0D            ; load CR in A
00F75D  2  24 13                BIT     $13             ; check default channel
00F75F  2  10 05                BPL     FLIP            ; if high bit is clear output CR only
00F761  2  20 67 F0             JSR     CHROUT          ; otherwise output CR+LF
00F764  2  A9 0A                LDA     #$0A            ; output LF
00F766  2               FLIP:
00F766  2  4C 67 F0             JMP     CHROUT
00F769  2               
00F769  2               FRESH:
00F769  2  20 5B F7             JSR     CRLF            ; output CR
00F76C  2  A9 20                LDA     #$20            ; load space in A
00F76E  2  20 67 F0             JSR     CHROUT
00F771  2  4C DD F8             JMP     SNCLR
00F774  2               
00F774  2               ; -----------------------------------------------------------------------------
00F774  2               ; output two hex digits for byte
00F774  2               WRTWO:
00F774  2  86 CA                STX     SAVX            ; save X
00F776  2  20 82 F7             JSR     ASCTWO          ; get hex chars for byte in X (lower) and A (upper)
00F779  2  20 67 F0             JSR     CHROUT          ; output upper nybble
00F77C  2  8A                   TXA                     ; transfer lower to A
00F77D  2  A6 CA                LDX     SAVX            ; restore X
00F77F  2  4C 67 F0             JMP     CHROUT          ; output lower nybble
00F782  2               
00F782  2               ; -----------------------------------------------------------------------------
00F782  2               ; convert byte in A to hex digits
00F782  2               ASCTWO:
00F782  2  48                   PHA                     ; save byte
00F783  2  20 8C F7             JSR     ASCII           ; do low nybble
00F786  2  AA                   TAX                     ; save in X
00F787  2  68                   PLA                     ; restore byte
00F788  2  4A                   LSR     A               ; shift upper nybble down
00F789  2  4A                   LSR     A
00F78A  2  4A                   LSR     A
00F78B  2  4A                   LSR     A
00F78C  2               
00F78C  2               ; convert low nybble in A to hex digit
00F78C  2               ASCII:
00F78C  2  29 0F                AND     #$0F            ; clear upper nibble
00F78E  2  C9 0A                CMP     #$0A            ; if less than A, skip next step
00F790  2  90 02                BCC     ASC1
00F792  2  69 06                ADC     #6              ; skip ascii chars between 9 and A
00F794  2               ASC1:
00F794  2  69 30                ADC     #$30            ; add ascii char 0 to value
00F796  2  60                   RTS
00F797  2               
00F797  2               ; -----------------------------------------------------------------------------
00F797  2               ; get prev char from input buffer
00F797  2               GOTCHR:
00F797  2  C6 B9                DEC     CHRPNT
00F799  2               
00F799  2               ; get next char from input buffer
00F799  2               GETCHR:
00F799  2  86 CA                STX     SAVX
00F79B  2  A6 B9                LDX     CHRPNT          ; get pointer to next char
00F79D  2  BD 00 02             LDA     INBUFF,X        ; load next char in A
00F7A0  2  F0 06                BEQ     NOCHAR          ; null, :, or ? signal end of buffer
00F7A2  2  C9 3A                CMP     #':'
00F7A4  2  F0 02                BEQ     NOCHAR
00F7A6  2  C9 3F                CMP     #'?'
00F7A8  2               NOCHAR:
00F7A8  2  08                   PHP
00F7A9  2  E6 B9                INC     CHRPNT          ; next char
00F7AB  2  A6 CA                LDX     SAVX
00F7AD  2  28                   PLP                     ; Z flag will signal last character
00F7AE  2  60                   RTS
00F7AF  2               
00F7AF  2               ; -----------------------------------------------------------------------------
00F7AF  2               ; copy TMP0 to TMP2
00F7AF  2               COPY12:
00F7AF  2  A5 C1                LDA     TMP0            ; low byte
00F7B1  2  85 C3                STA     TMP2
00F7B3  2  A5 C2                LDA     TMP0+1          ; high byte
00F7B5  2  85 C4                STA     TMP2+1
00F7B7  2  60                   RTS
00F7B8  2               
00F7B8  2               ; -----------------------------------------------------------------------------
00F7B8  2               ; subtract TMP2 from TMP0
00F7B8  2               SUB12:
00F7B8  2  38                   SEC
00F7B9  2  A5 C1                LDA     TMP0            ; subtract low byte
00F7BB  2  E5 C3                SBC     TMP2
00F7BD  2  85 C1                STA     TMP0
00F7BF  2  A5 C2                LDA     TMP0+1
00F7C1  2  E5 C4                SBC     TMP2+1          ; subtract high byte
00F7C3  2  85 C2                STA     TMP0+1
00F7C5  2  60                   RTS
00F7C6  2               
00F7C6  2               ; -----------------------------------------------------------------------------
00F7C6  2               ; subtract from TMP0
00F7C6  2               SUBA1:
00F7C6  2  A9 01                LDA     #1              ; shortcut to decrement by 1
00F7C8  2               SUBA2:
00F7C8  2  85 CA                STA     SAVX            ; subtrahend in accumulator
00F7CA  2  38                   SEC
00F7CB  2  A5 C1                LDA     TMP0            ; minuend in low byte
00F7CD  2  E5 CA                SBC     SAVX
00F7CF  2  85 C1                STA     TMP0
00F7D1  2  A5 C2                LDA     TMP0+1          ; borrow from high byte
00F7D3  2  E9 00                SBC     #0
00F7D5  2  85 C2                STA     TMP0+1
00F7D7  2  60                   RTS
00F7D8  2               
00F7D8  2               ; -----------------------------------------------------------------------------
00F7D8  2               ; subtract 1 from STORE
00F7D8  2               SUB13:
00F7D8  2  38                   SEC
00F7D9  2  A5 B7                LDA     STORE
00F7DB  2  E9 01                SBC     #1              ; decrement low byte
00F7DD  2  85 B7                STA     STORE
00F7DF  2  A5 B8                LDA     STORE+1
00F7E1  2  E9 00                SBC     #0              ; borrow from high byte
00F7E3  2  85 B8                STA     STORE+1
00F7E5  2  60                   RTS
00F7E6  2               
00F7E6  2               ; -----------------------------------------------------------------------------
00F7E6  2               ; add to TMP2
00F7E6  2               ADDA2:
00F7E6  2  A9 01                LDA     #1              ; shortcut to increment by 1
00F7E8  2               BUMPAD2:
00F7E8  2  18                   CLC
00F7E9  2  65 C3                ADC     TMP2            ; add value in accumulator to low byte
00F7EB  2  85 C3                STA     TMP2
00F7ED  2  90 02                BCC     BUMPEX
00F7EF  2  E6 C4                INC     TMP2+1          ; carry to high byte
00F7F1  2               BUMPEX:
00F7F1  2  60                   RTS
00F7F2  2               
00F7F2  2               ; -----------------------------------------------------------------------------
00F7F2  2               ; subtract 1 from TMP2
00F7F2  2               SUB21:
00F7F2  2  38                   SEC
00F7F3  2  A5 C3                LDA     TMP2            ; decrement low byte
00F7F5  2  E9 01                SBC     #1
00F7F7  2  85 C3                STA     TMP2
00F7F9  2  A5 C4                LDA     TMP2+1          ; borrow from high byte
00F7FB  2  E9 00                SBC     #0
00F7FD  2  85 C4                STA     TMP2+1
00F7FF  2  60                   RTS
00F800  2               
00F800  2               ; -----------------------------------------------------------------------------
00F800  2               ; copy TMP0 to PC
00F800  2               COPY1P:
00F800  2  B0 08                BCS     CPY1PX          ; do nothing if parameter is empty
00F802  2  A5 C1                LDA     TMP0            ; copy low byte
00F804  2  A4 C2                LDY     TMP0+1          ; copy high byte
00F806  2  85 B1                STA     PCL
00F808  2  84 B0                STY     PCH
00F80A  2               CPY1PX:
00F80A  2  60                   RTS
00F80B  2               
00F80B  2               ; -----------------------------------------------------------------------------
00F80B  2               ; get start/end addresses and calc difference
00F80B  2               GETDIF:
00F80B  2  B0 1F                BCS     GDIFX           ; exit with error if no parameter given
00F80D  2  20 AF F7             JSR     COPY12          ; save start address in TMP2
00F810  2  20 8F F6             JSR     GETPAR          ; get end address in TMP0
00F813  2  B0 17                BCS     GDIFX           ; exit with error if no parameter given
00F815  2  A5 C1                LDA     TMP0            ; save end address in STASH
00F817  2  85 CE                STA     STASH
00F819  2  A5 C2                LDA     TMP0+1
00F81B  2  85 CF                STA     STASH+1
00F81D  2  20 B8 F7             JSR     SUB12           ; subtract start address from end address
00F820  2  A5 C1                LDA     TMP0
00F822  2  85 B7                STA     STORE           ; save difference in STORE
00F824  2  A5 C2                LDA     TMP0+1
00F826  2  85 B8                STA     STORE+1
00F828  2  90 02                BCC     GDIFX           ; error if start address is after end address
00F82A  2  18                   CLC                     ; clear carry to indicate success
00F82B  2  24                   .BYTE   $24             ; BIT ZP opcode consumes next byte (SEC)
00F82C  2               GDIFX:
00F82C  2  38                   SEC                     ; set carry to indicate error
00F82D  2  60                   RTS
00F82E  2               
00F82E  2               ; -----------------------------------------------------------------------------
00F82E  2               ; convert base [$+&%]
00F82E  2               CONVRT:
00F82E  2  20 8D F6             JSR     RDPAR           ; read a parameter
00F831  2  20 69 F7             JSR     FRESH           ; next line and clear
00F834  2  A9 24                LDA     #'$'            ; output $ sigil for hex
00F836  2  20 67 F0             JSR     CHROUT
00F839  2  A5 C1                LDA     TMP0            ; load the 16-bit value entered
00F83B  2  A6 C2                LDX     TMP0+1
00F83D  2  20 4A F7             JSR     WRADDR          ; print it in 4 hex digits
00F840  2  20 69 F7             JSR     FRESH
00F843  2  A9 2B                LDA     #'+'            ; output + sigil for decimal
00F845  2  20 67 F0             JSR     CHROUT
00F848  2  20 79 F8             JSR     CVTDEC          ; convert to BCD using hardware mode
00F84B  2  A9 00                LDA     #0              ; clear digit counter
00F84D  2  A2 06                LDX     #6              ; max digits + 1
00F84F  2  A0 03                LDY     #3              ; bits per digit - 1
00F851  2  20 AC F8             JSR     NMPRNT          ; print result without leading zeros
00F854  2  20 69 F7             JSR     FRESH           ; next line and clear
00F857  2  A9 26                LDA     #'&'            ; print & sigil for octal
00F859  2  20 67 F0             JSR     CHROUT
00F85C  2  A9 00                LDA     #0              ; clear digit counter
00F85E  2  A2 08                LDX     #8              ; max digits + 1
00F860  2  A0 02                LDY     #2              ; bits per digit - 1
00F862  2  20 9E F8             JSR     PRINUM          ; output number
00F865  2  20 69 F7             JSR     FRESH           ; next line and clear
00F868  2  A9 25                LDA     #'%'            ; print % sigil for binary
00F86A  2  20 67 F0             JSR     CHROUT
00F86D  2  A9 00                LDA     #0              ; clear digit counter
00F86F  2  A2 18                LDX     #$18            ; max digits + 1
00F871  2  A0 00                LDY     #0              ; bits per digit - 1
00F873  2  20 9E F8             JSR     PRINUM          ; output number
00F876  2  4C B7 F0             JMP     STRT            ; back to mainloop
00F879  2               
00F879  2               ; -----------------------------------------------------------------------------
00F879  2               ; convert binary to BCD
00F879  2               
00F879  2               CVTDEC:
00F879  2  20 AF F7             JSR     COPY12          ; copy value from TMP0 to TMP2
00F87C  2  A9 00                LDA     #0
00F87E  2  A2 02                LDX     #2              ; clear 3 bytes in work buffer
00F880  2               DECML1:
00F880  2  95 D0                STA     U0AA0,X
00F882  2  CA                   DEX
00F883  2  10 FB                BPL     DECML1
00F885  2  A0 10                LDY     #16             ; 16 bits in input
00F887  2  08                   PHP                     ; save status register
00F888  2  78                   SEI                     ; make sure no interrupts occur with BCD enabled
00F889  2  F8                   SED
00F88A  2               DECML2:
00F88A  2  06 C3                ASL     TMP2            ; rotate bytes out of input low byte
00F88C  2  26 C4                ROL     TMP2+1          ; .. into high byte and carry bit
00F88E  2  A2 02                LDX     #2              ; process 3 bytes
00F890  2               DECDBL:
00F890  2  B5 D0                LDA     U0AA0,X         ; load current value of byte
00F892  2  75 D0                ADC     U0AA0,X         ; add it to itself plus the carry bit
00F894  2  95 D0                STA     U0AA0,X         ; store it back in the same location
00F896  2  CA                   DEX                     ; decrement byte counter
00F897  2  10 F7                BPL     DECDBL          ; loop until all bytes processed
00F899  2  88                   DEY                     ; decrement bit counter
00F89A  2  D0 EE                BNE     DECML2          ; loop until all bits processed
00F89C  2  28                   PLP                     ; restore processor status
00F89D  2  60                   RTS
00F89E  2               
00F89E  2               ; load the input value and fall through to print it
00F89E  2               PRINUM:
00F89E  2  48                   PHA                     ; save accumulator
00F89F  2  A5 C1                LDA     TMP0            ; copy input low byte to work buffer
00F8A1  2  85 D2                STA     U0AA0+2
00F8A3  2  A5 C2                LDA     TMP0+1          ; copy input high byte to work buffer
00F8A5  2  85 D1                STA     U0AA0+1
00F8A7  2  A9 00                LDA     #0              ; clear overflow byte in work buffer
00F8A9  2  85 D0                STA     U0AA0
00F8AB  2  68                   PLA                     ; restore accumulator
00F8AC  2               
00F8AC  2               ; print number in specified base without leading zeros
00F8AC  2               NMPRNT:
00F8AC  2  85 CB                STA     DIGCNT          ; number of digits in accumulator
00F8AE  2  84 CD                STY     NUMBIT          ; bits per digit passed in Y register
00F8B0  2               DIGOUT:
00F8B0  2  A4 CD                LDY     NUMBIT          ; get bits to process
00F8B2  2  A9 00                LDA     #0              ; clear accumulator
00F8B4  2               ROLBIT:
00F8B4  2  06 D2                ASL     U0AA0+2         ; shift bits out of low byte
00F8B6  2  26 D1                ROL     U0AA0+1         ; ... into high byte
00F8B8  2  26 D0                ROL     U0AA0           ; ... into overflow byte
00F8BA  2  2A                   ROL     A               ; ... into accumulator
00F8BB  2  88                   DEY                     ; decrement bit counter
00F8BC  2  10 F6                BPL     ROLBIT          ; loop until all bits processed
00F8BE  2  A8                   TAY                     ; check whether accumulator is 0
00F8BF  2  D0 08                BNE     NZERO           ; if not, print it
00F8C1  2  E0 01                CPX     #1              ; have we output the max number of digits?
00F8C3  2  F0 04                BEQ     NZERO           ; if not, print it
00F8C5  2  A4 CB                LDY     DIGCNT          ; how many digits have we output?
00F8C7  2  F0 07                BEQ     ZERSUP          ; skip output if digit is 0
00F8C9  2               NZERO:
00F8C9  2  E6 CB                INC     DIGCNT          ; increment digit counter
00F8CB  2  09 30                ORA     #$30            ; add numeric value to ascii '0' to get ascii char
00F8CD  2  20 67 F0             JSR     CHROUT          ; output character
00F8D0  2               ZERSUP:
00F8D0  2  CA                   DEX                     ; decrement number of leading zeros
00F8D1  2  D0 DD                BNE     DIGOUT          ; next digit
00F8D3  2  60                   RTS
00F8D4  2               
00F8D4  2               
00F8D4  2               ; -----------------------------------------------------------------------------
00F8D4  2               ; print and clear routines
00F8D4  2               CLINE:
00F8D4  2  20 5B F7             JSR     CRLF
00F8D7  2  4C DD F8             JMP     SNCLR           ; clear line
00F8DA  2               SNDCLR:
00F8DA  2  20 ED F8             JSR     SNDMSG
00F8DD  2               SNCLR:
00F8DD  2  A0 28                LDY     #$28            ; loop 40 times
00F8DF  2               SNCLP:
00F8DF  2  A9 20                LDA     #$20            ; output space character
00F8E1  2  20 67 F0             JSR     CHROUT
00F8E4  2  88                   DEY
00F8E5  2  D0 F8                BNE     SNCLP
00F8E7  2  A9 0D                LDA     #13             ; output CR
00F8E9  2  20 67 F0             JSR     CHROUT          ; send CR
00F8EC  2  60                   RTS
00F8ED  2               
00F8ED  2               ; -----------------------------------------------------------------------------
00F8ED  2               ; display message from table
00F8ED  2               SNDMSG:
00F8ED  2  B9 88 F9             LDA     MSGBAS,Y        ; Y contains offset in msg table
00F8F0  2  08                   PHP
00F8F1  2  29 7F                AND     #$7F            ; strip high bit before output
00F8F3  2  20 57 F7             JSR     CHOUT
00F8F6  2  C8                   INY
00F8F7  2  28                   PLP
00F8F8  2  10 F3                BPL     SNDMSG          ; loop until high bit is set
00F8FA  2  60                   RTS
00F8FB  2               
00F8FB  2               ; -----------------------------------------------------------------------------
00F8FB  2               ; check for stop key
00F8FB  2               STOP:
00F8FB  2  20 60 F0             JSR     IOF_CONIN
00F8FE  2  C9 03                CMP     #$03
00F900  2  F0 03                BEQ     :+
00F902  2  A9 FF                LDA     #$FF
00F904  2  60                   RTS
00F905  2               :
00F905  2  A9 00                LDA     #$00
00F907  2  60                   RTS
00F908  2               
00F908  2               ; -----------------------------------------------------------------------------
00F908  2               ; LOAD A MOTOROLA FORMATTED HEX FILE
00F908  2               LOADS19:
00F908  2  20 59 F0             JSR     IOF_CONINW      ;
00F90B  2  C9 53                CMP     #'S'            ;
00F90D  2  D0 F9                BNE     LOADS19         ; FIRST CHAR NOT (S)
00F90F  2  20 59 F0             JSR     IOF_CONINW      ; READ CHAR
00F912  2  C9 39                CMP     #'9'            ;
00F914  2  F0 33                BEQ     LOAD21          ;
00F916  2  C9 31                CMP     #'1'            ;
00F918  2  D0 EE                BNE     LOADS19         ; SECOND CHAR NOT (1)
00F91A  2  A9 00                LDA     #$00            ;
00F91C  2  85 BC                STA     CKSM            ; ZERO CHECKSUM
00F91E  2  20 4A F9             JSR     GETBYTE         ; READ BYTE
00F921  2  E9 01                SBC     #$01            ;
00F923  2  85 CB                STA     DIGCNT          ; BYTE COUNT
00F925  2  20 77 F9             JSR     BADDR           ; BUILD ADDRESS
00F928  2  A0 00                LDY     #$00            ;
00F92A  2               LOAD11:
00F92A  2  20 4A F9             JSR     GETBYTE         ;
00F92D  2  C6 CB                DEC     DIGCNT          ;
00F92F  2  F0 0F                BEQ     LOAD15          ; ZERO BYTE COUNT
00F931  2  91 BD                STA     (LOADADR),Y     ; STORE DATA
00F933  2  E6 BD                INC     LOADADR         ; INCREMENT LOWBYTE
00F935  2  A5 BD                LDA     LOADADR
00F937  2  C9 00                CMP     #$00
00F939  2  D0 EF                BNE     LOAD11          ; NOT ZERO?, LOOP
00F93B  2  E6 BE                INC     LOADADR+1       ; ZERO, INC HIGH BYTE
00F93D  2  4C 2A F9             JMP     LOAD11          ;
00F940  2               
00F940  2               LOAD15:
00F940  2  E6 BC                INC     CKSM            ;
00F942  2  F0 C4                BEQ     LOADS19         ;
00F944  2               LOAD19:
00F944  2  A9 3F                LDA     #'?'            ;
00F946  2  20 67 F0             JSR     OUTCH           ;
00F949  2               LOAD21:
00F949  2  60                   RTS
00F94A  2               GETBYTE:
00F94A  2  20 62 F9             JSR     INHEX           ; GET HEX CHAR
00F94D  2  0A                   ASL                     ;
00F94E  2  0A                   ASL                     ;
00F94F  2  0A                   ASL                     ;
00F950  2  0A                   ASL                     ;
00F951  2  85 BF                STA     LOADWRK         ;
00F953  2  20 62 F9             JSR     INHEX           ;
00F956  2  29 0F                AND     #$0F            ; MASK TO 4 BITS
00F958  2  05 BF                ORA     LOADWRK         ;
00F95A  2  48                   PHA                     ;
00F95B  2  18                   CLC                     ;
00F95C  2  65 BC                ADC     CKSM            ;
00F95E  2  85 BC                STA     CKSM            ;
00F960  2  68                   PLA                     ;
00F961  2  60                   RTS                     ;
00F962  2               ; INPUT HEX CHAR
00F962  2               INHEX:
00F962  2  20 59 F0             JSR     IOF_CONINW      ;
00F965  2  48                   PHA                     ;
00F966  2  20 67 F0             JSR     OUTCH           ;
00F969  2  68                   PLA                     ;
00F96A  2  C9 3A                CMP     #$3A            ; LESS THAN 9?
00F96C  2  B0 02                BCS     INHEX_BIG       ; NO, SKIP NEXT
00F96E  2  E9 2F                SBC     #$2F            ; CONVERT 0-9
00F970  2               INHEX_BIG:
00F970  2  C9 41                CMP     #$41            ; A OR MORE?
00F972  2  90 02                BCC     INHEX_SMALL     ; NO, SKIP NEXT
00F974  2  E9 37                SBC     #$37            ; CONVERT A-F
00F976  2               INHEX_SMALL:
00F976  2  60                   RTS                     ;
00F977  2               ; BUILD ADDRESS
00F977  2               BADDR:
00F977  2  20 4A F9             JSR     GETBYTE         ; READ 2 FRAMES
00F97A  2  85 BE                STA     LOADADR+1       ;
00F97C  2  20 4A F9             JSR     GETBYTE         ;
00F97F  2  85 BD                STA     LOADADR         ;
00F981  2  60                   RTS
00F982  2               LOAD:
00F982  2  20 08 F9             JSR     LOADS19
00F985  2  4C B7 F0             JMP     STRT            ; back to main loop
00F988  2               
00F988  2               
00F988  2               
00F988  2               
00F988  2               ; -----------------------------------------------------------------------------
00F988  2               ; message table; last character has high bit set
00F988  2               MSGBAS:
00F988  2               
00F988  2               MSG2:
00F988  2  0D                   .BYTE   $0D             ; header for registers
00F989  2  20 20 20 50          .BYTE   "   PC  SR AC XR YR SP   V1.2"
00F98D  2  43 20 20 53  
00F991  2  52 20 41 43  
00F9A5  2  8D                   .BYTE   $0D+$80
00F9A6  2               MSG3:
00F9A6  2  1D BF                .BYTE   $1D,$3F+$80     ; syntax error: move right, display "?"
00F9A8  2               MSG4:
00F9A8  2  2E 2E 53 59          .BYTE   "..SYS"         ; SYS call to enter monitor
00F9AC  2  53           
00F9AD  2  A0                   .BYTE   $20+$80
00F9AE  2               MSG5:
00F9AE  2  3A 92                .BYTE   $3A,$12+$80     ; ":" then RVS ON for memory ASCII dump
00F9B0  2               MSG6:
00F9B0  2  20 45 52 52          .BYTE   " ERRO"         ; I/O error: display " ERROR"
00F9B4  2  4F           
00F9B5  2  D2                   .BYTE   'R'+$80
00F9B6  2               MSG7:
00F9B6  2  41 A0                .BYTE   $41,$20+$80     ; assemble next instruction: "A " + addr
00F9B8  2               MSG8:
00F9B8  2  20 20                .BYTE   "  "            ; pad non-existent byte: skip 3 spaces
00F9BA  2  A0                   .BYTE   $20+$80
00F9BB  2               
00F9BB  2               ; -----------------------------------------------------------------------------
00F9BB  2               ; addressing mode table - nybbles provide index into MODE2 table
00F9BB  2               ; for opcodes XXXXXXY0, use XXXXXX as index into table
00F9BB  2               ; for opcodes WWWXXY01  use $40 + XX as index into table
00F9BB  2               ; use right nybble if Y=0; use left nybble if Y=1
00F9BB  2               
00F9BB  2               MODE:
00F9BB  2  40 02 45 03          .BYTE   $40,$02,$45,$03 ; even opcodes
00F9BF  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
00F9C3  2  30 22 45 33          .BYTE   $30,$22,$45,$33
00F9C7  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
00F9CB  2  40 02 45 33          .BYTE   $40,$02,$45,$33
00F9CF  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
00F9D3  2  40 02 45 B3          .BYTE   $40,$02,$45,$B3
00F9D7  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
00F9DB  2  00 22 44 33          .BYTE   $00,$22,$44,$33
00F9DF  2  D0 8C 44 00          .BYTE   $D0,$8C,$44,$00
00F9E3  2  11 22 44 33          .BYTE   $11,$22,$44,$33
00F9E7  2  D0 8C 44 9A          .BYTE   $D0,$8C,$44,$9A
00F9EB  2  10 22 44 33          .BYTE   $10,$22,$44,$33
00F9EF  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
00F9F3  2  10 22 44 33          .BYTE   $10,$22,$44,$33
00F9F7  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
00F9FB  2  62 13 78 A9          .BYTE   $62,$13,$78,$A9 ; opcodes ending in 01
00F9FF  2               
00F9FF  2               ; addressing mode format definitions indexed by nybbles from MODE table
00F9FF  2               
00F9FF  2               ; left 6 bits define which characters appear in the assembly operand
00F9FF  2               ; left 3 bits are before the address; next 3 bits are after
00F9FF  2               
00F9FF  2               ; right-most 2 bits define length of binary operand
00F9FF  2               
00F9FF  2               ; index               654 321
00F9FF  2               ; 1st character       $(# ,),
00F9FF  2               ; 2nd character        $$ X Y    length  format      idx mode
00F9FF  2               MODE2:
00F9FF  2  00                   .BYTE   $00             ; 000 000    00                  0   error
00FA00  2  21                   .BYTE   $21             ; 001 000    01      #$00        1   immediate
00FA01  2  81                   .BYTE   $81             ; 100 000    01      $00         2   zero-page
00FA02  2  82                   .BYTE   $82             ; 100 000    10      $0000       3   absolute
00FA03  2  00                   .BYTE   $00             ; 000 000    00                  4   implied
00FA04  2  00                   .BYTE   $00             ; 000 000    00                  5   accumulator
00FA05  2  59                   .BYTE   $59             ; 010 110    01      ($00,X)     6   indirect,X
00FA06  2  4D                   .BYTE   $4D             ; 010 011    01      ($00),Y     7   indirect,Y
00FA07  2  91                   .BYTE   $91             ; 100 100    01      $00,X       8   zero-page,X
00FA08  2  92                   .BYTE   $92             ; 100 100    10      $0000,X     9   absolute,X
00FA09  2  86                   .BYTE   $86             ; 100 001    10      $0000,Y     A   absolute,Y
00FA0A  2  4A                   .BYTE   $4A             ; 010 010    10      ($0000)     B   indirect
00FA0B  2  85                   .BYTE   $85             ; 100 001    01      $00,Y       C   zero-page,Y
00FA0C  2  9D                   .BYTE   $9D             ; 100 111    01      $0000*      D   relative
00FA0D  2               
00FA0D  2               ; * relative is special-cased so format bits don't match
00FA0D  2               
00FA0D  2               
00FA0D  2               ; character lookup tables for the format definitions in MODE2
00FA0D  2               
00FA0D  2               CHAR1:
00FA0D  2  2C 29 2C             .BYTE   $2C,$29,$2C     ; ","  ")"  ","
00FA10  2  23 28 24             .BYTE   $23,$28,$24     ; "#"  "("  "$"
00FA13  2               
00FA13  2               CHAR2:
00FA13  2  59 00 58             .BYTE   $59,$00,$58     ; "Y"   0   "X"
00FA16  2  24 24 00             .BYTE   $24,$24,$00     ; "$"  "$"   0
00FA19  2               
00FA19  2               ; -----------------------------------------------------------------------------
00FA19  2               ; 3-letter mnemonics packed into two bytes (5 bits per letter)
00FA19  2               
00FA19  2               ; left 8 bits
00FA19  2               ; XXXXX000 opcodes
00FA19  2               MNEML:
00FA19  2  1C 8A 1C 23          .BYTE   $1C,$8A,$1C,$23 ; BRK PHP BPL CLC
00FA1D  2  5D 8B 1B A1          .BYTE   $5D,$8B,$1B,$A1 ; JSR PLP BMI SEC
00FA21  2  9D 8A 1D 23          .BYTE   $9D,$8A,$1D,$23 ; RTI PHA BVC CLI
00FA25  2  9D 8B 1D A1          .BYTE   $9D,$8B,$1D,$A1 ; RTS PLA BVS SEI
00FA29  2  00 29 19 AE          .BYTE   $00,$29,$19,$AE ; ??? DEY BCC TYA
00FA2D  2  69 A8 19 23          .BYTE   $69,$A8,$19,$23 ; LDY TAY BCS CLV
00FA31  2  24 53 1B 23          .BYTE   $24,$53,$1B,$23 ; CPY INY BNE CLD
00FA35  2  24 53 19 A1          .BYTE   $24,$53,$19,$A1 ; CPX INX BEQ SED
00FA39  2               ; XXXYY100 opcodes
00FA39  2  00 1A 5B 5B          .BYTE   $00,$1A,$5B,$5B ; ??? BIT JMP JMP
00FA3D  2  A5 69 24 24          .BYTE   $A5,$69,$24,$24 ; STY LDY CPY CPX
00FA41  2               ; 1XXX1010 opcodes
00FA41  2  AE AE A8 AD          .BYTE   $AE,$AE,$A8,$AD ; TXA TXS TAX TSX
00FA45  2  29 00 7C 00          .BYTE   $29,$00,$7C,$00 ; DEX ??? NOP ???
00FA49  2               ; XXXYYY10 opcodes
00FA49  2  15 9C 6D 9C          .BYTE   $15,$9C,$6D,$9C ; ASL ROL LSR ROR
00FA4D  2  A5 69 29 53          .BYTE   $A5,$69,$29,$53 ; STX LDX DEC INC
00FA51  2               ; XXXYYY01 opcodes
00FA51  2  84 13 34 11          .BYTE   $84,$13,$34,$11 ; ORA AND EOR ADC
00FA55  2  A5 69 23 A0          .BYTE   $A5,$69,$23,$A0 ; STA LDA CMP SBC
00FA59  2               
00FA59  2               ; right 7 bits, left justified
00FA59  2               ; XXXXX000 opcodes
00FA59  2               MNEMR:
00FA59  2  D8 62 5A 48          .BYTE   $D8,$62,$5A,$48 ; BRK PHP BPL CLC
00FA5D  2  26 62 94 88          .BYTE   $26,$62,$94,$88 ; JSR PLP BMI SEC
00FA61  2  54 44 C8 54          .BYTE   $54,$44,$C8,$54 ; RTI PHA BVC CLI
00FA65  2  68 44 E8 94          .BYTE   $68,$44,$E8,$94 ; RTS PLA BVS SEI
00FA69  2  00 B4 08 84          .BYTE   $00,$B4,$08,$84 ; ??? DEY BCC TYA
00FA6D  2  74 B4 28 6E          .BYTE   $74,$B4,$28,$6E ; LDY TAY BCS CLV
00FA71  2  74 F4 CC 4A          .BYTE   $74,$F4,$CC,$4A ; CPY INY BNE CLD
00FA75  2  72 F2 A4 8A          .BYTE   $72,$F2,$A4,$8A ; CPX INX BEQ SED
00FA79  2               ; XXXYY100 opcodes
00FA79  2  00 AA A2 A2          .BYTE   $00,$AA,$A2,$A2 ; ??? BIT JMP JMP
00FA7D  2  74 74 74 72          .BYTE   $74,$74,$74,$72 ; STY LDY CPY CPX
00FA81  2               ; 1XXX1010 opcodes
00FA81  2  44 68 B2 32          .BYTE   $44,$68,$B2,$32 ; TXA TXS TAX TSX
00FA85  2  B2 00 22 00          .BYTE   $B2,$00,$22,$00 ; DEX ??? NOP ???
00FA89  2               ; XXXYYY10 opcodes
00FA89  2  1A 1A 26 26          .BYTE   $1A,$1A,$26,$26 ; ASL ROL LSR ROR
00FA8D  2  72 72 88 C8          .BYTE   $72,$72,$88,$C8 ; STX LDX DEC INC
00FA91  2               ; XXXYYY01 opcodes
00FA91  2  C4 CA 26 48          .BYTE   $C4,$CA,$26,$48 ; ORA AND EOR ADC
00FA95  2  44 44 A2 C8          .BYTE   $44,$44,$A2,$C8 ; STA LDA CMP SBC
00FA99  2  0D 20 20 20          .BYTE   $0D,$20,$20,$20
00FA9D  2               
00FA9D  2               ; -----------------------------------------------------------------------------
00FA9D  2               ; single-character commands
00FA9D  2               KEYW:
00FA9D  2  41 42 43 44          .BYTE   "ABCDFGHJLMRTWZ.>;"
00FAA1  2  46 47 48 4A  
00FAA5  2  4C 4D 52 54  
00FAAE  2               HIKEY:
00FAAE  2  24 2B 26 25          .BYTE   "$+&%"
00FAB2  2               KEYTOP:
00FAB2  2               
00FAB2  2               
00FAB2  2               ; vectors corresponding to commands above
00FAB2  2               KADDR:
00FAB2  2  DF F3 FA F2          .WORD   ASSEM-1,BOOT-1,COMPAR-1,DISASS-1
00FAB6  2  F8 F1 70 F5  
00FABA  2  D2 F2 8F F1          .WORD   FILL-1,GOTO-1,HUNT-1,JSUB-1,LOAD-1
00FABE  2  73 F2 A6 F1  
00FAC2  2  81 F9        
00FAC4  2  22 F1 95 F0          .WORD   DSPLYM-1,DSPLYR-1,TRANS-1,WRITEOS-1
00FAC8  2  FB F1 5D F3  
00FACC  2  A8 F3 DF F3          .WORD   CLRDIR-1,ASSEM-1,ALTM-1,ALTR-1
00FAD0  2  6F F1 58 F1  
00FAD4  2               
00FAD4  2               ; -----------------------------------------------------------------------------
00FAD4  2               MODTAB:
00FAD4  2  10 0A 08 02          .BYTE   $10,$0A,$08,02  ; modulo number systems
00FAD8  2               LENTAB:
00FAD8  2  04 03 03 01          .BYTE   $04,$03,$03,$01 ; bits per digit
00FADC  2               
00FADC  1                       .INCLUDE"../DOS65/OS/DOSPAGER.ASM"
00FADC  2               ;__pager_________________________________________________________________________________________________________________________
00FADC  2               ;
00FADC  2               ; 	Nhyodyne Memory page management code
00FADC  2               ;
00FADC  2               ;	Entry points:
00FADC  2               ;		PAGER_INIT          - called during OS init
00FADC  2               ;________________________________________________________________________________________________________________________________
00FADC  2               ;
00FADC  2               ; RAM BANK $0C is RAM area for Drivers
00FADC  2               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
00FADC  2               ; RAM BANK $0F is fixed bank $0000-$7FFF
00FADC  2               ;
00FADC  2               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
00FADC  2               ;
00FADC  2               ; ROM MEMORY PAGE CONFIGURATION LATCH CONTROL PORT
00FADC  2               ;       A15 IS INVERTED FOR THE NYHODYNE 65C02 CPU . . .
00FADC  2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
00FADC  2               ;	^ ^ ^ ^  ^ ^ ^ ^
00FADC  2               ;	: : : :  : : : :--0 = A15 ROM ONLY ADDRESS LINE DEFAULT IS 0 x
00FADC  2               ;	: : : :  : : :----0 = A16 ROM ONLY ADDRESS LINE DEFAULT IS 0
00FADC  2               ;	: : : :  : :------0 = A17 ROM ONLY ADDRESS LINE DEFAULT IS 0
00FADC  2               ;	: : : :  :--------0 = A18 ROM ONLY ADDRESS LINE DEFAULT IS 0 X
00FADC  2               ;	: : : :-----------0 = A19 ROM ONLY ADDRESS LINE DEFAULT IS 0
00FADC  2               ;	: : :-------------0 = A20 ROM ONLY ADDRESS LINE DEFAULT IS 0
00FADC  2               ;	: :---------------0 = ROM BOOT OVERRIDE DEFAULT IS 0
00FADC  2               ;	:-----------------0 = LOWER PAGE ROM SELECT (0=ROM, 1=NOTHING) DEFAULT IS 0
00FADC  2               ;
00FADC  2               ; RAM PAGE CONFIGURATION LATCH CONTROL PORT
00FADC  2               ;
00FADC  2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
00FADC  2               ;	^ ^ ^ ^  ^ ^ ^ ^
00FADC  2               ;	: : : :  : : : :--0 = A15 RAM ONLY ADDRESS LINE DEFAULT IS 0
00FADC  2               ;	: : : :  : : :----0 = A16 RAM ONLY ADDRESS LINE DEFAULT IS 0
00FADC  2               ;	: : : :  : :------0 = A17 RAM ONLY ADDRESS LINE DEFAULT IS 0
00FADC  2               ;	: : : :  :--------0 = A18 RAM ONLY ADDRESS LINE DEFAULT IS 0
00FADC  2               ;	: : : :-----------0 = A19 RAM ONLY ADDRESS LINE DEFAULT IS 0
00FADC  2               ;	: : :-------------0 = UNDEFINED DEFAULT IS 0
00FADC  2               ;	: :---------------0 = RAM BOOT OVERRIDE DEFAULT IS 0
00FADC  2               ;	:-----------------0 = LOWER PAGE RAM SELECT (0=NOTHING, 1=RAM) DEFAULT IS 0;
00FADC  2               
00FADC  2               
00FADC  2               ;__PAGER_INIT___________________________________________________________________________________________
00FADC  2               ;
00FADC  2               ;  INIT -- Copy code into $0200-$02FF for controling banking and copying
00FADC  2               ;____________________________________________________________________________________________________
00FADC  2               PAGER_INIT:
00FADC  2  A2 00                LDX     #$00
00FADE  2               :
00FADE  2  BD EA FA             LDA     md_pagecode,X
00FAE1  2  9D 00 05             STA     MD_PAGERA,X
00FAE4  2  E8                   INX
00FAE5  2  E0 00                CPX     #$00
00FAE7  2  D0 F5                BNE     :-
00FAE9  2  60                   RTS
00FAEA  2               
00FAEA  2               ;       X=Control Word
00FAEA  2               ;	7 6 5 4  3 2 1 0
00FAEA  2               ;	^ ^ ^ ^  ^ ^ ^ ^
00FAEA  2               ;       : : : X  X X X X    = UNUSED
00FAEA  2               ;	: : :-------------0 = Read=0, Write=1
00FAEA  2               ;	: :---------------0 = RAM=0, ROM=1
00FAEA  2               ;	:-----------------0 = LOW=0, HIGH=1
00FAEA  2               ;       A= bank
00FAEA  2               ;       Y= page
00FAEA  2               ;
00FAEA  2               md_pagecode:
00FAEA  2  48                   PHA
00FAEB  2  84 15                STY     MD_PAGESE+1     ; setup copy from pointer
00FAED  2  8A                   TXA
00FAEE  2  29 80                AND     #$80
00FAF0  2  A8                   TAY
00FAF1  2  84 14                STY     MD_PAGESE
00FAF3  2  8A                   TXA
00FAF4  2  29 20                AND     #%00100000
00FAF6  2  C9 00                CMP     #$00
00FAF8  2  D0 3E                BNE     MD_PAGE_WRITE
00FAFA  2               ; PERFORM READ HERE
00FAFA  2  8A                   TXA
00FAFB  2  29 40                AND     #%01000000
00FAFD  2  C9 00                CMP     #$00
00FAFF  2  D0 0E                BNE     MD_PAGE_ROREAD
00FB01  2               ; DO RAM READ
00FB01  2  A9 80                LDA     #$80
00FB03  2  8D 7C 03             STA     MPCL_ROM
00FB06  2  68                   PLA
00FB07  2  09 80                ORA     #$80
00FB09  2  8D 78 03             STA     MPCL_RAM
00FB0C  2  4C 1A FB             JMP     MD_PAGE_COPYFRM
00FB0F  2               MD_PAGE_ROREAD:
00FB0F  2  A9 00                LDA     #$00
00FB11  2  8D 78 03             STA     MPCL_RAM
00FB14  2  68                   PLA
00FB15  2  29 7F                AND     #$7F
00FB17  2  8D 7C 03             STA     MPCL_ROM
00FB1A  2               MD_PAGE_COPYFRM:
00FB1A  2               ; DO THE COPY
00FB1A  2  A2 00                LDX     #$00
00FB1C  2  A0 00                LDY     #$00
00FB1E  2               :
00FB1E  2  B1 14                LDA     (MD_PAGESE),Y
00FB20  2  9D 00 04             STA     MD_PAGEBU,X
00FB23  2  E8                   INX
00FB24  2  C8                   INY
00FB25  2  E0 80                CPX     #$80
00FB27  2  D0 F5                BNE     :-
00FB29  2  A9 80                LDA     #$80
00FB2B  2  8D 7C 03             STA     MPCL_ROM
00FB2E  2  EA                   NOP
00FB2F  2  EA                   NOP
00FB30  2  A9 8C                LDA     #$8C
00FB32  2  8D 78 03             STA     MPCL_RAM
00FB35  2  EA                   NOP
00FB36  2  EA                   NOP
00FB37  2  60                   RTS
00FB38  2               MD_PAGE_WRITE:
00FB38  2  68                   PLA
00FB39  2  09 80                ORA     #%10000000
00FB3B  2  8D 78 03             STA     MPCL_RAM
00FB3E  2               ; DO THE COPY
00FB3E  2  A2 00                LDX     #$00
00FB40  2  A0 00                LDY     #$00
00FB42  2               :
00FB42  2  BD 00 04             LDA     MD_PAGEBU,X
00FB45  2  91 14                STA     (MD_PAGESE),Y
00FB47  2  E8                   INX
00FB48  2  C8                   INY
00FB49  2  E0 80                CPX     #$80
00FB4B  2  D0 F5                BNE     :-
00FB4D  2  A9 8C                LDA     #$8C
00FB4F  2  8D 78 03             STA     MPCL_RAM
00FB52  2  EA                   NOP
00FB53  2  EA                   NOP
00FB54  2  60                   RTS
00FB55  2               md_pagecodeend:
00FB55  2               farcall:
00FB55  2                       .IF     USEROM=1
00FB55  2  48                       PHA
00FB56  2  A9 80                    LDA     #$80
00FB58  2  8D 7C 03                 STA     MPCL_ROM
00FB5B  2  EA                       NOP
00FB5C  2  EA                       NOP
00FB5D  2  A9 8C                    LDA     #$8C
00FB5F  2  8D 78 03                 STA     MPCL_RAM
00FB62  2  EA                       NOP
00FB63  2  EA                       NOP
00FB64  2  68                       PLA
00FB65  2  20 00 88                 JSR     BANKED_DRIVER_DISPATCHER
00FB68  2  48                       PHA
00FB69  2  A9 00                    LDA     #$00
00FB6B  2  8D 78 03                 STA     MPCL_RAM
00FB6E  2  EA                       NOP
00FB6F  2  EA                       NOP
00FB70  2  8D 7C 03                 STA     MPCL_ROM
00FB73  2  EA                       NOP
00FB74  2  EA                       NOP
00FB75  2  68                       PLA
00FB76  2  60                       RTS
00FB77  2               md_farrun:
00FB77  2  A9 80                    LDA     #$80
00FB79  2  8D 7C 03                 STA     MPCL_ROM
00FB7C  2  EA                       NOP
00FB7D  2  EA                       NOP
00FB7E  2  A5 00                    LDA     $00
00FB80  2  8D 78 03                 STA     MPCL_RAM
00FB83  2  EA                       NOP
00FB84  2  EA                       NOP
00FB85  2  6C 01 00                 JMP     ($0001)
00FB88  2                       .ELSE
00FB88  2                           PHA
00FB88  2                           LDA     #$8C
00FB88  2                           STA     MPCL_RAM
00FB88  2                           NOP
00FB88  2                           NOP
00FB88  2                           PLA
00FB88  2                           JSR     BANKED_DRIVER_DISPATCHER
00FB88  2                           PHA
00FB88  2                           LDA     #$8E
00FB88  2                           STA     MPCL_RAM
00FB88  2                           PLA
00FB88  2                           RTS
00FB88  2                       .ENDIF
00FB88  2               
00FB88  1               
00FB88  1               DO_FARCALL      = farcall - md_pagecode + $0500
00FB88  1               DO_FARRUN       = md_farrun - md_pagecode + $0500
00FB88  1               
00FB88  1               ;__RELOCATE_DRIVERS______________________________________________________________________________________
00FB88  1               ;
00FB88  1               ; MOVE ROM BIOS HARDWARE DRIVERS FROM ROM PAGE 0D TO RAM PAGE 0C PERFORM CONSOLE WRITE
00FB88  1               ;________________________________________________________________________________________________________
00FB88  1               RELOCATE_DRIVERS:
00FB88  1               
00FB88  1               ; MOVE RELCODE TO LOWRAM
00FB88  1  A2 00                LDX     #$00
00FB8A  1               :
00FB8A  1  BD 98 FB             LDA     RELCODE,X
00FB8D  1  9D 00 06             STA     $0600,X
00FB90  1  E8                   INX
00FB91  1  E0 00                CPX     #$00
00FB93  1  D0 F5                BNE     :-
00FB95  1               
00FB95  1  4C 00 06             JMP     $0600           ; RUN IT
00FB98  1               
00FB98  1               RELCODE:
00FB98  1  A9 00                LDA     #$00
00FB9A  1  85 39                STA     TEMPWORD
00FB9C  1  A9 88                LDA     #$88
00FB9E  1  85 3A                STA     TEMPWORD+1
00FBA0  1  A0 00                LDY     #$00
00FBA2  1               :
00FBA2  1  A9 00                LDA     #$00
00FBA4  1  8D 78 03             STA     MPCL_RAM
00FBA7  1  EA                   NOP
00FBA8  1  EA                   NOP
00FBA9  1  A9 0D                LDA     #$0D
00FBAB  1  8D 7C 03             STA     MPCL_ROM
00FBAE  1  EA                   NOP
00FBAF  1  EA                   NOP
00FBB0  1  B1 39                LDA     (TEMPWORD),Y
00FBB2  1  48                   PHA
00FBB3  1  A9 80                LDA     #$80
00FBB5  1  8D 7C 03             STA     MPCL_ROM
00FBB8  1  EA                   NOP
00FBB9  1  EA                   NOP
00FBBA  1  A9 8C                LDA     #$8C
00FBBC  1  8D 78 03             STA     MPCL_RAM
00FBBF  1  68                   PLA
00FBC0  1  91 39                STA     (TEMPWORD),Y
00FBC2  1               
00FBC2  1  E6 39                INC     TEMPWORD
00FBC4  1  A5 39                LDA     TEMPWORD
00FBC6  1  C9 00                CMP     #$00
00FBC8  1  D0 D8                BNE     :-
00FBCA  1  E6 3A                INC     TEMPWORD+1
00FBCC  1  A5 3A                LDA     TEMPWORD+1
00FBCE  1  C9 FF                CMP     #$FF
00FBD0  1  D0 D0                BNE     :-
00FBD2  1               
00FBD2  1  A9 00                LDA     #$00
00FBD4  1  8D 78 03             STA     MPCL_RAM
00FBD7  1  EA                   NOP
00FBD8  1  EA                   NOP
00FBD9  1  A9 00                LDA     #$00
00FBDB  1  8D 7C 03             STA     MPCL_ROM
00FBDE  1               
00FBDE  1  60                   RTS
00FBDF  1               
00FBDF  1               ; START BANNER
00FBDF  1               STARTUP:
00FBDF  1  0D 0A                .BYTE   $0D,$0A
00FBE1  1               
00FBE1  1  20 20 4E 68          .BYTE   "  Nhyodyne",$0D,$0A
00FBE5  1  79 6F 64 79  
00FBE9  1  6E 65 0D 0A  
00FBED  1  20 20 20 5F          .BYTE   "   __ _____  _____ ___ ___ ",$0D,$0A
00FBF1  1  5F 20 5F 5F  
00FBF5  1  5F 5F 5F 20  
00FC0A  1  20 20 2F 20          .BYTE   "  / /| ____|/ ____/ _ \__ \ ",$0D,$0A
00FC0E  1  2F 7C 20 5F  
00FC12  1  5F 5F 5F 7C  
00FC28  1  20 2F 20 2F          .BYTE   " / /_| |__ | |   | | | | ) | ",$0D,$0A
00FC2C  1  5F 7C 20 7C  
00FC30  1  5F 5F 20 7C  
00FC47  1  7C 20 27 5F          .BYTE   "| '_ \___ \| |   | | | |/ / ",$0D,$0A
00FC4B  1  20 5C 5F 5F  
00FC4F  1  5F 20 5C 7C  
00FC65  1  7C 20 28 5F          .BYTE   "| (_) |__) | |___| |_| / /_ ",$0D,$0A
00FC69  1  29 20 7C 5F  
00FC6D  1  5F 29 20 7C  
00FC83  1  20 5C 5F 5F          .BYTE   " \___/____/ \_____\___/____| ",$0D,$0A
00FC87  1  5F 2F 5F 5F  
00FC8B  1  5F 5F 2F 20  
00FCA2  1  2A 20 36 35          .BYTE   "* 65c02 SuperMON ",$0D,$0A,$00
00FCA6  1  63 30 32 20  
00FCAA  1  53 75 70 65  
00FCB6  1               
00FCB6  1                       .SEGMENT "IVECTOR"
00FCB6  1                       .ORG    $FFF0
00FFF0  1  4C 08 F9             JMP     LOADS19
00FFF3  1               
00FFF3  1                       .SEGMENT "VECTORS"
00FFF3  1               NNTVECTOR:
00FFF3  1  3E F0                .WORD   NINTERRUPT      ;
00FFF5  1               RSTVECTOR:
00FFF5  1  00 F0                .WORD   COLD_START      ;
00FFF7  1               INTVECTOR:
00FFF7  1  28 F0                .WORD   INTERRUPT       ; ROM VECTOR FOR IRQ
00FFF9  1               
00FFF9  1                       .END
