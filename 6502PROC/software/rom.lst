ca65 V2.18 - Ubuntu 2.19-1
Main file   : rom.asm
Current file: rom.asm

000000r 1               
000000r 1               ;__MONITOR_______________________________________________________
000000r 1               ; This is a simple monitor program that can be uploaded to the MBC
000000r 1               ; from Z80 mode.
000000r 1               ;
000000r 1               ; It assumes that the 65C02 board is set for IOPage 03.
000000r 1               ; remember that bit A15 is inverted on the board so the dip switch is set to $83.
000000r 1               ;
000000r 1               ; If the SBC is the only CPU in the system, ensure that jumpers
000000r 1               ; J1 and J2 are set for 1&2.   Then burn ROM.BIN into EPROM.
000000r 1               ;
000000r 1               ; If the SBC is secondary to a Z80, the monitor.com file can be run from CP/M or the
000000r 1               ; monitor.hex file can be loaded from the monitor. Ensure that jumpers J1 and J4
000000r 1               ; are set for 2&3, the 6502 toggle IO address is set for $FF and
000000r 1               ; the 65C02 board is set for IOPage 03.
000000r 1               ; remember that bit A15 is inverted on the board so the dip switch is set to $83.
000000r 1               ;
000000r 1               ;
000000r 1               ; to run from the MBC Z80 monitor
000000r 1               ;
000000r 1               ; first set the MPCL to allow RAM in the low bank
000000r 1               ; >O 7C 80
000000r 1               ; >O 78 80
000000r 1               ;
000000r 1               ; then load the .HEX file.
000000r 1               ; >L
000000r 1               ;
000000r 1               ;
000000r 1               ; Finally transfer control to the 65C02 by reading the toggle register
000000r 1               ; >I FF
000000r 1               ;
000000r 1               ; The '02 should reset and run this program
000000r 1               ;
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;
000000r 1               ; DATA CONSTANTS
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;REGISTER		IO PORT		; FUNCTION
000000r 1               farfunct	=   $32         ;function to call in driver area
000000r 1               IRQVECTOR   =  	$35   		; VECTOR FOR USER IRQ RTN
000000r 1               NMIVECTOR   =  	$37   		; VECTOR FOR USER IRQ RTN
000000r 1               WORKPTR		=  	$39			; WORK POINTER FOR COMMAND PROCESSOR
000000r 1               JUMPPTR		=	$3B			; JUMP VECTOR FOR LOOKUP TABLE
000000r 1               TEMPWORD	=	$3D			;
000000r 1               TEMPWORD1	=  	$3F			;
000000r 1               TEMPWORD2	=  	$40			;
000000r 1               
000000r 1               TEMPBYTE	=	$42			;
000000r 1               ACC      	=  	$43			; ACC STORAGE
000000r 1               XREG     	=  	$44 		; X REG STORAGE
000000r 1               YREG     	=  	$45 		; Y REG STORAGE
000000r 1               PREG     	=  	$46 		; CURRENT STACK POINTER
000000r 1               PCL      	=  	$47 		; PROGRAM COUNTER LOW
000000r 1               PCH      	=  	$48 		; PROGRAM COUNTER HIGH
000000r 1               SPTR     	=  	$49 		; CPU STATUS REGISTER
000000r 1               CKSM		=	$4A			; CHECKSUM
000000r 1               BYTECT		=	$4B			; BYTE COUNT
000000r 1               STRPTR	 	=	$4C			;
000000r 1               COUNTER	 	=	$4E			;
000000r 1               SRC	 		=	$50			;
000000r 1               DEST	 	=	$52			;
000000r 1               INBUFFER	=	$0200		;
000000r 1               IO          =   $0300       ; 0300-03FF Memory mapped IO
000000r 1               MPCL_ROM	=	$037C		; ROM MAPPER
000000r 1               MPCL_RAM	=	$0378		; RAM MAPPER
000000r 1               
000000r 1               MD_PAGEBU   =   $0400       ; 0400-04FF PAGE BUFFER ADDRESS
000000r 1               memmovr     =	$0500		; 0200-02ff subr to move data from ram/rom disks
000000r 1               MD_PAGERA   =   $0500       ; PAGE DRIVER ADDRESS
000000r 1               MD_PAGESE   =   $14	      	; PAGE SECTOR STORAGE
000000r 1               BANKED_DRIVER_DISPATCHER=$8800  ; LOCATION OF DRIVER DISPATCHER
000000r 1               USEROM		=	1
000000r 1               
000000r 1               ; UART 16C550 SERIAL -- Assumes IO is in page $03 -- DIP Switch settings $83
000000r 1               UART0       =  	$0368       ; DATA IN/OUT
000000r 1               UART1       =  	$0369       ; CHECK RX
000000r 1               UART2       =  	$036A       ; INTERRUPTS
000000r 1               UART3       =  	$036B       ; LINE CONTROL
000000r 1               UART4       =  	$036C       ; MODEM CONTROL
000000r 1               UART5       =  	$036D       ; LINE STATUS
000000r 1               UART6       =  	$036E       ; MODEM STATUS
000000r 1               UART7	    =  	$036F       ; SCRATCH REG.
000000r 1               
000000r 1               				.PC02
000000r 1                               .segment "TROM"
000000r 1               
000000r 1               ;__COLD_START___________________________________________________
000000r 1               ;
000000r 1               ; PERFORM SYSTEM COLD INIT
000000r 1               ;
000000r 1               ;_______________________________________________________________
000000r 1               COLD_START:
000000r 1  78           		SEI 				; DISABLE INTERRUPTS
000001r 1  D8                   CLD					;  VERIFY DECIMAL MODE IS OFF
000002r 1  A2 FF                LDX   #$FF          ;
000004r 1  9A                   TXS                 ; CLEAR STACK
000005r 1  8A           		txa
000006r 1               
000006r 1  A5 rr        		LDA <IRQROUTINE
000008r 1  85 35        		STA IRQVECTOR
00000Ar 1  85 37        		STA NMIVECTOR
00000Cr 1  A5 rr        		LDA >IRQROUTINE
00000Er 1  85 36        		STA IRQVECTOR+1
000010r 1  85 38        		STA NMIVECTOR+1
000012r 1               
000012r 1  20 rr rr     		JSR INIT_SERIAL
000015r 1  20 rr rr     		JSR PAGER_INIT
000018r 1               
000018r 1  20 rr rr     		JSR RELOCATE_DRIVERS
00001Br 1               
00001Br 1  A9 rr        	  	LDA #<STARTUP		; OUTPUT STARTUP STRING
00001Dr 1  85 4C                STA STRPTR			;
00001Fr 1  A9 rr                LDA #>STARTUP		;
000021r 1  85 4D                STA STRPTR+1		;
000023r 1  20 rr rr             JSR OUTSTR			;
000026r 1               
000026r 1  A9 00        		LDA #$00			;
000028r 1  8D 00 02     		STA INBUFFER		; MAKE SURE INPUT BUFFER IS EMPTY
00002Br 1               							;
00002Br 1  00                   BRK					; PERFORM BRK (START MONITOR)
00002Cr 1               
00002Cr 1               ;__BRKROUTINE___________________________________________________
00002Cr 1               ;
00002Cr 1               ; HANDLE CPU BRK INTERRUPT PROCESING AND START MONITOR
00002Cr 1               ;
00002Cr 1               ;_______________________________________________________________
00002Cr 1               BRKROUTINE:
00002Cr 1               							; MONITOR'S BREAK HANDLER
00002Cr 1  18           		CLC
00002Dr 1  68                   PLA  				;
00002Er 1  AA                   TAX           		; LOW BYTE OF PC
00002Fr 1  68                   PLA 				;
000030r 1  A8           		TAY					; HIGH BYTE OF PC
000031r 1  38           		SEC					;
000032r 1  8A           		TXA					;
000033r 1  E9 02                SBC   #$02     		; REMOVE BREAK INSTRUCTION
000035r 1  85 47                STA   PCL     		;
000037r 1  B0 01                BCS   BRK2     		;
000039r 1  88                   DEY
00003Ar 1               BRK2:
00003Ar 1  84 48        		STY   PCH       	; SAVE PCH
00003Cr 1  BA                   TSX                 ; GET STACK POINTER
00003Dr 1  86 49                STX   SPTR          ; SAVE STACK POINTER
00003Fr 1  20 rr rr             JSR   PRINT_REG     ; DUMP REGISTER CONTENTS
000042r 1  A2 FF                LDX   #$FF          ;
000044r 1  9A                   TXS                 ; CLEAR STACK
000045r 1  58                   CLI                 ; ENABLE INTERRUPTS AGAIN
000046r 1  4C rr rr             JMP   COMMAND_PROCESSOR 	; START THE MONITOR
000049r 1               
000049r 1               
000049r 1               ;__IRQROUTINE___________________________________________________
000049r 1               ;
000049r 1               ; HANDLE INTERRUPT PROCESING
000049r 1               ;
000049r 1               ;_______________________________________________________________
000049r 1               IRQROUTINE:
000049r 1  58                   CLI                 ; ENABLE INTERRUPTS AGAIN
00004Ar 1  40           		RTI
00004Br 1               
00004Br 1               ;__INTERRUPT____________________________________________________
00004Br 1               ;
00004Br 1               ; HANDLE IRQ INTERRUPT AND DETERMINE IF IT IS A BRK OR AN IRQ
00004Br 1               ;
00004Br 1               ;_______________________________________________________________
00004Br 1               INTERRUPT:
00004Br 1  78           		SEI 				; DISABLE INTERRUPTS
00004Cr 1  84 45        		STY	YREG			; SAVE Y
00004Er 1  86 44               	STX	XREG    		; SAVE X
000050r 1  85 43        		STA	ACC       		; SAVE A
000052r 1  68           		PLA					; GET STATUS REGISTER
000053r 1  85 46        		STA	PREG			; SAVE STATUS REGISTER
000055r 1  29 10               	AND #$10      	    ; MASK BRK
000057r 1  D0 03               	BNE BRKCMD     	 	; BRK CMD
000059r 1  6C 35 00            	JMP (IRQVECTOR)   	; LET USER ROUTINE HAVE IT (USER DEFINED IRQ)
00005Cr 1               BRKCMD:
00005Cr 1  4C rr rr     		JMP BRKROUTINE 		; MONITOR BRK ROUTINE
00005Fr 1               
00005Fr 1               NINTERRUPT:
00005Fr 1  6C 37 00           	JMP (NMIVECTOR)   	; LET USER ROUTINE HAVE IT (USER DEFINED NMI)
000062r 1               
000062r 1               ;__________________________________________________________________________________________________________
000062r 1               ;
000062r 1               ;  AT SOME POINT, REPLACE THIS WITH 6502HBIOS CALLS
000062r 1               ;
000062r 1               
000062r 1               INIT_SERIAL:
000062r 1  A9 80        		LDA	#$80			;
000064r 1  8D 6B 03     		STA	UART3			; SET DLAB FLAG
000067r 1  A9 0C        		LDA	#12				; SET TO 12 = 9600 BAUD
000069r 1  8D 68 03     		STA	UART0			; save baud rate
00006Cr 1  A9 00        		LDA	#00				;
00006Er 1  8D 69 03     		STA	UART1			;
000071r 1  A9 03        		LDA	#03				;
000073r 1  8D 6B 03     		STA	UART3			; SET 8 BIT DATA, 1 STOPBIT
000076r 1  8D 6C 03     		STA	UART4			;
000079r 1  60           		RTS
00007Ar 1               
00007Ar 1               
00007Ar 1               ;__IOF_CONINW____________________________________________________________________________________________
00007Ar 1               ;
00007Ar 1               ; PERFORM BLOCKING CONSOLE READ
00007Ar 1               ;________________________________________________________________________________________________________
00007Ar 1               IOF_CONINW:
00007Ar 1  A9 02        	lda #02
00007Cr 1  85 32        	sta farfunct
00007Er 1  4C 6A 05     	jmp DO_FARCALL
000081r 1               
000081r 1               ;__IOF_CONIN_____________________________________________________________________________________________
000081r 1               ;
000081r 1               ; PERFORM NON-BLOCKING CONSOLE READ
000081r 1               ;________________________________________________________________________________________________________
000081r 1               IOF_CONIN:
000081r 1  A9 02        	lda #02
000083r 1  85 32        	sta farfunct
000085r 1  4C 6A 05     	jmp DO_FARCALL
000088r 1               
000088r 1               ;__OUTCH_________________________________________________________________________________________________
000088r 1               ;
000088r 1               ; PERFORM CONSOLE WRITE
000088r 1               ;________________________________________________________________________________________________________
000088r 1               OUTCH:
000088r 1  48           	pha
000089r 1  A9 00        	lda #00
00008Br 1  85 32        	sta farfunct
00008Dr 1  68           	pla
00008Er 1  4C 6A 05     	jmp DO_FARCALL
000091r 1               
000091r 1               
000091r 1               Z80:
000091r 1  00           		BRK
000092r 1  00 00 00     	.BYTE 00,00,00
000095r 1               
000095r 1               	.include"moncode.asm"
000095r 2               
000095r 2               ;__MONITOR_______________________________________________________
000095r 2               ; This is a simple monitor program.
000095r 2               ;
000095r 2               ; It is used in:
000095r 2               ;
000095r 2               ;
000095r 2               ; * lowmon - monitor program loaded in low memory for debugging
000095r 2               ; * monitor - monitor program used to boot the 6502 board from a Z80 master
000095r 2               ; * rom  - rom code for stand alone 6502 BIOS
000095r 2               ;
000095r 2               ;__PRINT_REG____________________________________________________
000095r 2               ;
000095r 2               ; PRINT OUT REGISTERS ON THE DISPLAY
000095r 2               ;
000095r 2               ;_______________________________________________________________
000095r 2               PRINT_REG:
000095r 2  A9 rr        	  	LDA #<REGDATA		; OUTPUT HEADER STRING
000097r 2  85 4C                STA STRPTR			;
000099r 2  A9 rr            	LDA #>REGDATA		;
00009Br 2  85 4D             	STA STRPTR+1		;
00009Dr 2  20 rr rr            	JSR OUTSTR			;
0000A0r 2  A5 48               	LDA PCH				; OUTPUT PROGRAM COUNTER HIGH BYTE
0000A2r 2  20 rr rr            	JSR PRINT_BYTE		;
0000A5r 2  A5 47               	LDA PCL				; OUTPUT PROGRAM COUNTER LOW BYTE
0000A7r 2  20 rr rr            	JSR PRINT_BYTE		;
0000AAr 2  A9 20               	LDA #$20			; OUTPUT SPACE
0000ACr 2  20 rr rr            	JSR OUTCH			;
0000AFr 2  A5 43               	LDA ACC				; OUTPUT ACCUMULATOR
0000B1r 2  20 rr rr            	JSR PRINT_BYTE		;
0000B4r 2  A9 20               	LDA #$20			; OUTPUT 2 SPACES
0000B6r 2  20 rr rr            	JSR OUTCH			;
0000B9r 2  A9 20               	LDA #$20			;
0000BBr 2  20 rr rr            	JSR OUTCH			;
0000BEr 2  A5 44        	   	LDA XREG			; OUTPUT X REGISTER
0000C0r 2  20 rr rr     	   	JSR PRINT_BYTE			;
0000C3r 2  A9 20               	LDA #$20			; OUTPUT 2 SPACES
0000C5r 2  20 rr rr            	JSR OUTCH			;
0000C8r 2  A9 20               	LDA #$20			;
0000CAr 2  20 rr rr            	JSR OUTCH			;
0000CDr 2  A5 45        	   	LDA YREG			; OUTPUT Y REGISTER
0000CFr 2  20 rr rr     	   	JSR PRINT_BYTE		;
0000D2r 2  A9 20               	LDA #$20			; OUTPUT 2 SPACES
0000D4r 2  20 rr rr            	JSR OUTCH       	;
0000D7r 2  A9 20               	LDA #$20			;
0000D9r 2  20 rr rr            	JSR OUTCH			;
0000DCr 2  A5 49               	LDA SPTR			; OUTPUT STACK POINTER
0000DEr 2  20 rr rr     	   	JSR PRINT_BYTE		;
0000E1r 2  A9 20               	LDA #$20			; OUTPUT 2 SPACES
0000E3r 2  20 rr rr            	JSR OUTCH     		;
0000E6r 2  A9 20               	LDA #$20			;
0000E8r 2  20 rr rr            	JSR OUTCH			;
0000EBr 2  A5 46               	LDA PREG			; OUTPUT STATUS REGISTER
0000EDr 2  20 rr rr     	   	JSR PRINT_BYTE		; OUTPUT IN HEX
0000F0r 2  A9 2D               	LDA #$2D			; OUTPUT '-'
0000F2r 2  20 rr rr            	JSR OUTCH			;
0000F5r 2  A5 46               	LDA PREG			; OUTPUT STATUS REGISTER
0000F7r 2  20 rr rr     	   	JSR PRINT_BIN_BYTE	; OUTPUT IN BINARY
0000FAr 2  A9 0D               	LDA #$0D			; PRINT NEW LINE
0000FCr 2  4C rr rr            	JMP OUTCH           ;
0000FFr 2               
0000FFr 2               ;__COMMAND_PROCESSOR____________________________________________
0000FFr 2               ;
0000FFr 2               ; PROMPT FOR, INPUT, AND PROCESS INCOMMING USER COMMANDS
0000FFr 2               ;
0000FFr 2               ;_______________________________________________________________
0000FFr 2               COMMAND_PROCESSOR:
0000FFr 2               
0000FFr 2  20 rr rr     	 	JSR DISPLAY_PROMPT	; PRINT PROMPT STRING
000102r 2  A9 00        	    LDA #<INBUFFER		; SETUP INPUT COMMAND BUFFER
000104r 2  85 4C             	STA STRPTR			;
000106r 2  A9 02             	LDA #>INBUFFER		;
000108r 2  85 4D             	STA STRPTR +1 		;
00010Ar 2               
00010Ar 2  20 rr rr          	JSR INSTR			; GET A STRING FROM THE CONSOLE
00010Dr 2               
00010Dr 2  A9 0D             	LDA #$0D			;
00010Fr 2  20 rr rr          	JSR OUTCH			;
000112r 2  A9 0A             	LDA #$0A			;
000114r 2  20 rr rr          	JSR OUTCH			;
000117r 2               
000117r 2               
000117r 2  A0 00        		LDY #$00			; SET INDEX = 0
000119r 2               
000119r 2  A9 rr        	    LDA #<COMMAND_LOOKUP_TABLE 	; SETUP INPUT COMMAND POINTER
00011Br 2  85 39             	STA WORKPTR			;
00011Dr 2  A9 rr             	LDA #>COMMAND_LOOKUP_TABLE	;
00011Fr 2  85 3A             	STA WORKPTR +1 		;
000121r 2  B9 00 02             LDA INBUFFER,Y		; MOVE FIRST BYTE OF COMMAND BUFFER TO ACC
000124r 2  C9 00                CMP #$00			; IS NULL?
000126r 2  F0 D7                BEQ COMMAND_PROCESSOR		; YES, GET NEXT COMMAND
000128r 2               
000128r 2               COMMAND_PROCESSOR_CMP:
000128r 2  A2 00               	LDX #$00			; X=0
00012Ar 2  B9 00 02     		LDA INBUFFER,Y		; ACC= NEXT BYTE OF INPUT BUFFER
00012Dr 2  C1 39        		CMP (WORKPTR,X)		; DOES NEXT BYTE OF INPUT BUFFER MATCH NEXT BYTE OF LOOKUP TABLE
00012Fr 2  D0 1A        		BNE CMD_PROCESOR_NEXT_CMD	; NO, GO TO NEXT COMMAND IN LOOKUP TABLE
000131r 2  C8           		INY					; YES, Y=Y+1
000132r 2  B9 00 02     		LDA INBUFFER,Y		; LOAD NEXT BYTE OF INPUT BUFFER
000135r 2  C9 20        		CMP #$20			; IS IT A SPACE (SINGALING END OF COMMAND)
000137r 2  F0 33        		BEQ CMD_PROCESSOR_MATCH_FOUND	; YES, POSSIBLE MATCH FOUND
000139r 2  C9 00        		CMP #$00			; IS IT A NULL (SINGALING END OF COMMAND)
00013Br 2  F0 2F        		BEQ CMD_PROCESSOR_MATCH_FOUND	; YES, POSSIBLE MATCH FOUND
00013Dr 2  20 rr rr     		JSR INCWORKPTR		; NO, INCREMENT POINTER TO LOOKUP TABLE
000140r 2  A2 00        		LDX #$00			;
000142r 2  A1 39        	   	LDA (WORKPTR,X)		; A= NEXT BYTE OF LOOKUP TABLE
000144r 2  C9 00        		CMP #$00			; IS IT A NULL? (SIGNALING END OF TABLE ENTRY)
000146r 2  F0 0E        		BEQ CMD_PROCESOR_NEXT_CMD1	; YES, ADVANCE TO NEXT COMMAND IN TABLE
000148r 2  4C rr rr     		JMP COMMAND_PROCESSOR_CMP	; LOOP TO CHECK NEXT CHAR
00014Br 2               
00014Br 2               CMD_PROCESOR_NEXT_CMD:
00014Br 2  20 rr rr     		JSR INCWORKPTR		; INCREMENT POINTER TO LOOKUP TABLE
00014Er 2  A2 00        		LDX #$00			;
000150r 2  A1 39        	   	LDA (WORKPTR,X)		; A = NEXT BYTE OF LOOKUP TABLE
000152r 2  C9 00        		CMP #$00			; IS IT A NULL?
000154r 2  D0 F5        		BNE CMD_PROCESOR_NEXT_CMD	; NO, LOOP
000156r 2               
000156r 2               CMD_PROCESOR_NEXT_CMD1:
000156r 2  20 rr rr     		JSR INCWORKPTR		; INCREMENT POINTER TO LOOKUP TABLE
000159r 2  20 rr rr     		JSR INCWORKPTR		; INCREMENT POINTER TO LOOKUP TABLE
00015Cr 2  20 rr rr     		JSR INCWORKPTR		; INCREMENT POINTER TO LOOKUP TABLE
00015Fr 2  A2 00        	   	LDX #$00			;
000161r 2  A1 39        	   	LDA (WORKPTR,X)		; A = NEXT BYTE OF LOOKUP TABLE
000163r 2  C9 01        		CMP #$01			; IS IT $01 (SINGALING END OF LOOKUP TABLE)
000165r 2  F0 28        		BEQ CMD_PROCESOR_NOT_FOUND	; YES, DISPLAY NOT FOUND MESSAGE
000167r 2  A0 00        		LDY #$00			; NO RESET INPUT BUFFER COUNTER
000169r 2  4C rr rr     		JMP COMMAND_PROCESSOR_CMP	; LOOP
00016Cr 2               
00016Cr 2               CMD_PROCESSOR_MATCH_FOUND:
00016Cr 2  20 rr rr     		JSR INCWORKPTR		; INCREMENT POINTER TO LOOKUP TABLE
00016Fr 2  A2 00        	   	LDX #$00			;
000171r 2  A1 39        	   	LDA (WORKPTR,X)		; A = NEXT BYTE OF LOOKUP TABLE
000173r 2  C9 00        		CMP #$00			; IS IT A NULL?
000175r 2  D0 D4        		BNE CMD_PROCESOR_NEXT_CMD	; NO, TRY NEXT COMMAND
000177r 2  20 rr rr     		JSR INCWORKPTR		; YES, INCREMENT POINTER TO LOOKUP TABLE
00017Ar 2  A2 00        		LDX #$00			;
00017Cr 2  A1 39        		LDA (WORKPTR,X)		; A = NEXT BYTE OF LOOKUP TABLE
00017Er 2  85 3B        		STA JUMPPTR			; STORE A INTO LOW BYTE OF JUMP VECTOR
000180r 2  20 rr rr     		JSR INCWORKPTR		; INCREMENT POINTER TO LOOKUP TABLE
000183r 2  A2 00        		LDX #$00			;
000185r 2  A1 39        		LDA (WORKPTR,X)		; A = NEXT BYTE OF LOOKUP TABLE
000187r 2  85 3C        		STA JUMPPTR+1		; INCREMENT POINTER TO LOOKUP TABLE
000189r 2  20 rr rr     		JSR CMD_PROCESOR_RUN		; RUN COMMAND
00018Cr 2  4C rr rr     		JMP COMMAND_PROCESSOR		; GET NEXT COMMAND
00018Fr 2               
00018Fr 2               CMD_PROCESOR_NOT_FOUND:
00018Fr 2  A9 rr        		LDA #<ERROR 		; LOAD LOW BYTE OF ERROR STRING
000191r 2  85 4C             	STA STRPTR			; STORE IN POINTER LOW BYTE
000193r 2  A9 rr             	LDA #>ERROR		    ; LOAD HIGH BYTE OF ERROR STRING
000195r 2  85 4D             	STA STRPTR +1 		; STORE IN POINTER HIGH BYTE
000197r 2               
000197r 2  20 rr rr          	JSR OUTSTR			; OUTPUT THE STRING
00019Ar 2  4C rr rr     		JMP COMMAND_PROCESSOR		;
00019Dr 2               CMD_PROCESOR_RUN:
00019Dr 2  6C 3B 00     		JMP (JUMPPTR)		; JUMP TO COMMAND VECTOR
0001A0r 2               
0001A0r 2               
0001A0r 2               ;__LOAD_________________________________________________________
0001A0r 2               
0001A0r 2               ; LOAD A MOTOROLA FORMATTED HEX FILE
0001A0r 2               ;
0001A0r 2               ;_______________________________________________________________
0001A0r 2               LOAD:
0001A0r 2  20 rr rr     		JSR	IOF_CONINW			;
0001A3r 2  C9 53        		CMP	#'S'				;
0001A5r 2  D0 F9        		BNE	LOAD				; FIRST CHAR NOT (S)
0001A7r 2  20 rr rr     		JSR	IOF_CONINW			; READ CHAR
0001AAr 2  C9 39        		CMP	#'9'				;
0001ACr 2  F0 2C        		BEQ	LOAD21				;
0001AEr 2  C9 31        		CMP	#'1'				;
0001B0r 2  D0 EE        		BNE	LOAD				; SECOND CHAR NOT (1)
0001B2r 2  A9 00        		LDA	#$00				;
0001B4r 2  85 4A        		STA	CKSM				; ZERO CHECKSUM
0001B6r 2  20 rr rr     		JSR	GETBYTE				; READ BYTE
0001B9r 2  E9 01        		SBC	#$01				;
0001BBr 2  85 4B        		STA	BYTECT				; BYTE COUNT
0001BDr 2  20 rr rr     		JSR	BADDR				; BUILD ADDRESS
0001C0r 2  A0 00        		LDY	#$00				;
0001C2r 2               LOAD11:
0001C2r 2  20 rr rr     		JSR	GETBYTE				;
0001C5r 2  C6 4B        		DEC	BYTECT				;
0001C7r 2  F0 08        		BEQ	LOAD15				; ZERO BYTE COUNT
0001C9r 2  91 3F        		STA	(TEMPWORD1),Y		; STORE DATA
0001CBr 2  20 rr rr     		JSR 	INCTEMPWORD		;
0001CEr 2  4C rr rr     		JMP	LOAD11				;
0001D1r 2               
0001D1r 2               LOAD15:
0001D1r 2  E6 4A        		INC	CKSM				;
0001D3r 2  F0 CB        		BEQ	LOAD				;
0001D5r 2               LOAD19:
0001D5r 2  A9 3F        		LDA	#'?'				;
0001D7r 2  20 rr rr     		JSR	OUTCH				;
0001DAr 2               LOAD21:
0001DAr 2  60           		RTS
0001DBr 2               GETBYTE:
0001DBr 2  20 rr rr     		JSR	INHEX				; GET HEX CHAR
0001DEr 2  0A           		ASL						;
0001DFr 2  0A           		ASL						;
0001E0r 2  0A           		ASL						;
0001E1r 2  0A           		ASL						;
0001E2r 2  85 42        		STA	TEMPBYTE			;
0001E4r 2  20 rr rr     		JSR	INHEX				;
0001E7r 2  29 0F        		AND	#$0F				; MASK TO 4 BITS
0001E9r 2  05 42        		ORA	TEMPBYTE			;
0001EBr 2  48           		PHA						;
0001ECr 2  18           		CLC						;
0001EDr 2  65 4A        		ADC	CKSM				;
0001EFr 2  85 4A        		STA	CKSM				;
0001F1r 2  68           		PLA						;
0001F2r 2  60           		RTS						;
0001F3r 2               ; INPUT HEX CHAR
0001F3r 2               INHEX:
0001F3r 2  20 rr rr     		JSR	IOF_CONINW			;
0001F6r 2  48           		PHA						;
0001F7r 2  20 rr rr     		JSR	OUTCH				;
0001FAr 2  68           		PLA						;
0001FBr 2  C9 3A            	CMP #$3A  				; LESS THAN 9?
0001FDr 2  B0 02              	BCS INHEX_BIG  			; NO, SKIP NEXT
0001FFr 2  E9 2F              	SBC #$2F  				; CONVERT 0-9
000201r 2               INHEX_BIG:
000201r 2  C9 41        		CMP #$41  				; A OR MORE?
000203r 2  90 02              	BCC INHEX_SMALL 		; NO, SKIP NEXT
000205r 2  E9 37              	SBC #$37  				; CONVERT A-F
000207r 2               INHEX_SMALL:
000207r 2  60           		RTS						;
000208r 2               
000208r 2               ; BUILD ADDRESS
000208r 2               BADDR:
000208r 2  20 rr rr     		JSR	GETBYTE				; READ 2 FRAMES
00020Br 2  85 40        		STA	TEMPWORD1+1			;
00020Dr 2  20 rr rr     		JSR	GETBYTE				;
000210r 2  85 3F        		STA	TEMPWORD1			;
000212r 2  60           		RTS
000213r 2               
000213r 2               
000213r 2               ;__GO______________________________________________________
000213r 2               ;
000213r 2               ; GO COMMAND
000213r 2               ;
000213r 2               ; GO XXXX
000213r 2               ;_______________________________________________________________
000213r 2               GO:
000213r 2               
000213r 2  A9 00        	    LDA #<INBUFFER 		   	; SETUP WORK BUFFER
000215r 2  85 39                STA WORKPTR				;
000217r 2  A9 02                LDA #>INBUFFER		    ;
000219r 2  85 3A                STA WORKPTR +1 			;
00021Br 2               
00021Br 2  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "G"
00021Er 2  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "O"
000221r 2               
000221r 2  20 rr rr     		JSR EATWHITESPACE		; SKIP OVER THE WHITESPACE
000224r 2  20 rr rr     		JSR GETNUMBER			; GET THE STARTING ADDRESS
000227r 2  B0 53        		BCS DUMP_ERROR			; IF NOT A NUMBER, REPORT ERROR
000229r 2               
000229r 2  6C 3D 00     		JMP (TEMPWORD)			;
00022Cr 2               
00022Cr 2               
00022Cr 2               
00022Cr 2               
00022Cr 2               ;__DUMPMEM______________________________________________________
00022Cr 2               ;
00022Cr 2               ; DUMP MEMORY COMMAND
00022Cr 2               ;
00022Cr 2               ; DUMP XXXX (XXXX)
00022Cr 2               ;_______________________________________________________________
00022Cr 2               DUMP:
00022Cr 2               
00022Cr 2  A9 00        	    LDA #<INBUFFER 		   	; SETUP WORK BUFFER
00022Er 2  85 39                STA WORKPTR				;
000230r 2  A9 02                LDA #>INBUFFER		    ;
000232r 2  85 3A                STA WORKPTR +1 			;
000234r 2               
000234r 2  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "D"
000237r 2  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "U"
00023Ar 2  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "M"
00023Dr 2  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "P"
000240r 2               
000240r 2  20 rr rr     		JSR EATWHITESPACE		; SKIP OVER THE WHITESPACE
000243r 2  20 rr rr     		JSR GETNUMBER			; GET THE STARTING ADDRESS
000246r 2  B0 34        		BCS DUMP_ERROR			; IF NOT A NUMBER, REPORT ERROR
000248r 2               
000248r 2  A5 3D        		LDA TEMPWORD			; STORE STARTING ADDRESS IN WORD POINTER (TEMPWORD1)
00024Ar 2  85 3F        		STA TEMPWORD1			;
00024Cr 2  A5 3E        		LDA TEMPWORD+1			;
00024Er 2  85 40        		STA TEMPWORD1+1			;
000250r 2               
000250r 2  20 rr rr     		JSR EATWHITESPACE		; SKIP OVER ANY WHITESPACE
000253r 2  20 rr rr     		JSR GETNUMBER			; GET THE ENDING ADDRESS
000256r 2  B0 24        		BCS DUMP_ERROR			; IF NOT A NUMBER, REPORT ERROR
000258r 2               
000258r 2  A5 3F        		LDA TEMPWORD1			; STORE ENDING ADDRESS IN WORD POINTER (WORKPTR)
00025Ar 2  85 39        		STA WORKPTR				;
00025Cr 2  A5 40        		LDA TEMPWORD1+1			;
00025Er 2  85 3A        		STA WORKPTR+1			;
000260r 2               DUMP_LOOP:
000260r 2  20 rr rr     	    JSR PRINT_MEM_LINE		;
000263r 2  A9 0D        	    LDA #$0D				;
000265r 2  20 rr rr     	    JSR OUTCH				;
000268r 2  A9 0A        	    LDA #$0A				;
00026Ar 2  20 rr rr     	    JSR OUTCH				;
00026Dr 2  A5 3A                LDA WORKPTR+1  			; COMPARE HIGH BYTES
00026Fr 2  C5 3E                CMP TEMPWORD+1
000271r 2  90 ED                BCC DUMP_LOOP 			; IF NUM1H < NUM2H THEN NUM1 < NUM2
000273r 2  D0 06                BNE DUMP_DONE			; IF NUM1H <> NUM2H THEN NUM1 > NUM2 (SO NUM1 >= NUM2)
000275r 2  A5 39                LDA WORKPTR  			; COMPARE LOW BYTES
000277r 2  C5 3D                CMP TEMPWORD
000279r 2  90 E5                BCC DUMP_LOOP			; IF NUM1L < NUM2L THEN NUM1 < NUM2
00027Br 2               DUMP_DONE:
00027Br 2  60           		RTS
00027Cr 2               DUMP_ERROR:
00027Cr 2  4C rr rr     		JMP INVALID_NUMBER_ERROR
00027Fr 2               
00027Fr 2               
00027Fr 2               
00027Fr 2               ;__ENTERMEM_____________________________________________________
00027Fr 2               ;
00027Fr 2               ; ENTER MEMORY COMMAND
00027Fr 2               ;
00027Fr 2               ; ENTER XXXX (XX XX XX XX XX XX XX XX XX XX XX XX XX XX )
00027Fr 2               ;_______________________________________________________________
00027Fr 2               ENTERMEM:
00027Fr 2               
00027Fr 2  A9 00        	    LDA #<INBUFFER 			; SETUP WORK BUFFER
000281r 2  85 39                STA WORKPTR				;
000283r 2  A9 02                LDA #>INBUFFER		    ;
000285r 2  85 3A                STA WORKPTR +1 			;
000287r 2               
000287r 2  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "E"
00028Ar 2  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "N"
00028Dr 2  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "T"
000290r 2  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "E"
000293r 2  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "R"
000296r 2               
000296r 2  20 rr rr     		JSR EATWHITESPACE		; SKIP OVER ANY WHITESPACE
000299r 2  20 rr rr     		JSR GETNUMBER			; GET NUMBER
00029Cr 2  B0 67        		BCS ENTER_ERROR			; IF NOT A NUMBER REPORT ERROR
00029Er 2               
00029Er 2  A5 3D        		LDA TEMPWORD			; STORE ADDRESS INTO WORD POINTER (TEMPWORD1)
0002A0r 2  85 3F        		STA TEMPWORD1			;
0002A2r 2  A5 3E        		LDA TEMPWORD+1			;
0002A4r 2  85 40        		STA TEMPWORD1+1			;
0002A6r 2  A0 00        		LDY #$00				; RESET COUNTER TO 0
0002A8r 2               ENTERLOOP:
0002A8r 2  A2 00        		LDX #$00				;
0002AAr 2  A1 39        		LDA (WORKPTR,X)			; GET NEXT BYTE FROM BUFFER
0002ACr 2  C9 00        		CMP #$00				; IS NULL?
0002AEr 2  F0 10        		BEQ ENTER_DONE			; YES, WE'RE DONE
0002B0r 2  20 rr rr     		JSR EATWHITESPACE		; SKIP OVER ANY WHITESPACE
0002B3r 2  20 rr rr     		JSR GETNUMBER			; GET NEXT NUMBER
0002B6r 2  B0 4D        		BCS ENTER_ERROR			; IF NOT A NUMBER REPORT ERROR
0002B8r 2  A5 3D        		LDA TEMPWORD			; STORE BYTE IN ADDRESS (INDEXED BY Y)
0002BAr 2  91 3F        		STA (TEMPWORD1),Y		;
0002BCr 2  C8           		INY						; GO TO NEXT BYTE
0002BDr 2  4C rr rr     		JMP ENTERLOOP			; LOOP
0002C0r 2               ENTER_DONE:
0002C0r 2  C0 00        		CPY #$00				; WAS LINE BLANK?
0002C2r 2  D0 01        		BNE ENTER_CONTINUE		; NO, PREPARE FOR NEXT LINE
0002C4r 2  60           		RTS						; YES, END DATA ENTRY
0002C5r 2               ENTER_CONTINUE:
0002C5r 2  A9 0D        		LDA #$0D				;
0002C7r 2  20 rr rr     		JSR OUTCH				;
0002CAr 2  A9 0A        		LDA #$0A				;
0002CCr 2  20 rr rr     		JSR OUTCH
0002CFr 2  A9 3A        		LDA #$3A				; OUTPUT ":" TO SCREEN
0002D1r 2  20 rr rr     		JSR OUTCH				;
0002D4r 2  18           		CLC						; CLEAR CARRY
0002D5r 2  98           		TYA						; A=Y (LAST COUNTER)
0002D6r 2  65 3F        		ADC TEMPWORD1			; ADD LAST COUNT TO BEGINNING POINTER
0002D8r 2  85 3F        		STA TEMPWORD1			; STORE RESULT IN BEGINNING POINTER
0002DAr 2  D0 02        		BNE ENTER_INCREMENT		; NOT ZERO?, DONE
0002DCr 2  E6 40        		INC TEMPWORD1+1			; ZERO, INC HIGH BYTE
0002DEr 2               ENTER_INCREMENT:
0002DEr 2  A5 40        		LDA TEMPWORD1+1			; PRINTOUT STARTING ADDRESS TO SCREEN
0002E0r 2  20 rr rr     		JSR PRINT_BYTE			; (HIGH)
0002E3r 2  A5 3F        		LDA TEMPWORD1			;
0002E5r 2  20 rr rr     		JSR PRINT_BYTE			; (LOW)
0002E8r 2  A9 20        		LDA #$20				; OUTPUT SPACE TO SCREEN
0002EAr 2  20 rr rr     		JSR OUTCH				;
0002EDr 2  A9 00        	    LDA #<INBUFFER 		   	; SETUP INPUT COMMAND BUFFER
0002EFr 2  85 4C                STA STRPTR				;
0002F1r 2  A9 02                LDA #>INBUFFER 		 	;
0002F3r 2  85 4D                STA STRPTR +1 			;
0002F5r 2  20 rr rr             JSR INSTR				; GET A STRING FROM THE CONSOLE
0002F8r 2  A9 00        	    LDA #<INBUFFER 		   	; SETUP WORK BUFFER
0002FAr 2  85 39                STA WORKPTR				;
0002FCr 2  A9 02                LDA #>INBUFFER 		    ;
0002FEr 2  85 3A                STA WORKPTR +1 			;
000300r 2  A0 00                LDY #$00 				;
000302r 2  4C rr rr             JMP ENTERLOOP			; LOOP
000305r 2               
000305r 2               
000305r 2               ENTER_ERROR:
000305r 2  4C rr rr     		JMP INVALID_NUMBER_ERROR
000308r 2               
000308r 2               ;__PRINT_MEM_LINE_______________________________________________
000308r 2               ;
000308r 2               ; PRINT MEMORY DUMP LINE
000308r 2               ;
000308r 2               ; PRINT 16 HEX LOCATIONS STARTING WITH ADDRESS WORKPTR
000308r 2               ;_______________________________________________________________
000308r 2               PRINT_MEM_LINE:
000308r 2  A9 3A        		LDA #$3A				; LOAD ':' INTO ACC
00030Ar 2  20 rr rr     		JSR OUTCH				; PRINT ':'
00030Dr 2  A5 3A            	LDA WORKPTR+1			; PRINT ADDRESS
00030Fr 2  20 rr rr     	    JSR PRINT_BYTE			;
000312r 2  A5 39              	LDA WORKPTR				;
000314r 2  20 rr rr     	    JSR PRINT_BYTE			;
000317r 2  A9 2D         	    LDA #$2D				; LOAD '-'
000319r 2  20 rr rr     	    JSR OUTCH				; PRINT '-'
00031Cr 2  A0 00        	    LDY #$00				;
00031Er 2               PRINT_MEM_LINE_LOOP:
00031Er 2  B1 39        		LDA (WORKPTR),Y			; LOAD NEXT BYTE
000320r 2  20 rr rr     		JSR PRINT_BYTE	       	; PRINT BYTE
000323r 2  A9 20         	    LDA #$20				; LOAD ' '
000325r 2  20 rr rr     	    JSR OUTCH				; PRINT ' '
000328r 2  C8           	    INY						; INCREMENT COUNTER
000329r 2  C0 10        	    CPY #$10				; HAVE WE PRINTED 16 ADDRESSES
00032Br 2  D0 F1        	    BNE PRINT_MEM_LINE_LOOP	; NO, LOOP
00032Dr 2  A9 3A        		LDA #$3A				; LOAD ':' INTO ACC
00032Fr 2  20 rr rr     		JSR OUTCH				; PRINT ':'
000332r 2  A2 00                LDX #$00				;
000334r 2  A0 00        		LDY #$00				;
000336r 2               PRINT_MEM_LINE_LOOP_ASCII:
000336r 2  A1 39        		LDA (WORKPTR,X)			; GET NEXT BYTE
000338r 2  20 rr rr     		JSR OUTASCII			; PRINT ASCII VALUE OF BYTE
00033Br 2  C8           		INY						; INCREMENT COUNTER
00033Cr 2  20 rr rr     		JSR INCWORKPTR			; INCREMENT BUFFER POINTER
00033Fr 2  C0 10        	    CPY #$10				; HAVE WE PRINTED 16 ADDRESSES
000341r 2  D0 F3        	    BNE PRINT_MEM_LINE_LOOP_ASCII	; NO, LOOP
000343r 2  A9 0D        	    LDA #$0D				; YES, PRINT CR
000345r 2  20 rr rr     	    JSR OUTCH				;
000348r 2  60           	    RTS						; RETURN
000349r 2               
000349r 2               
000349r 2               
000349r 2               ;__DISPLAY_PROMPT______________________________________________
000349r 2               ;
000349r 2               ; DISPLAY THE INPUT PROMPT ON THE SCREEN
000349r 2               ;
000349r 2               ;______________________________________________________________
000349r 2               DISPLAY_PROMPT:
000349r 2  A9 rr        		LDA #<PROMPT 			; LOAD LOW BYTE OF PROMPT STRING
00034Br 2  85 4C                STA STRPTR				; STORE IN POINTER LOW BYTE
00034Dr 2  A9 rr                LDA #>PROMPT 		    ; LOAD HOGH BYTE OF PROMPR STRING
00034Fr 2  85 4D                STA STRPTR +1 			; STORE IN POINTER HIGH BYTE
000351r 2               
000351r 2  4C rr rr             JMP OUTSTR				; OUTPUT THE STRING
000354r 2               
000354r 2               
000354r 2               ;__INCWORKPTR___________________________________________________
000354r 2               ; INCREMENT THE 16BIT WORK POINTER
000354r 2               ;
000354r 2               ;
000354r 2               ;
000354r 2               ;_______________________________________________________________
000354r 2               INCWORKPTR:
000354r 2  E6 39        		INC WORKPTR				; INCREMENT LOWBYTE
000356r 2  D0 02        		BNE INCWORKPTR_OUT		; NOT ZERO?, DONE
000358r 2  E6 3A        		INC WORKPTR+1			; ZERO, INC HIGH BYTE
00035Ar 2               INCWORKPTR_OUT:
00035Ar 2  60           		RTS						; RETURN
00035Br 2               
00035Br 2               
00035Br 2               ;__INCTEMPWORD__________________________________________________
00035Br 2               ;
00035Br 2               ; INCREMENT THE 16BIT WORK POINTER
00035Br 2               ;
00035Br 2               ;_______________________________________________________________
00035Br 2               INCTEMPWORD:
00035Br 2  E6 3F        		INC TEMPWORD1			; INCREMENT LOWBYTE
00035Dr 2  D0 02        		BNE INCTEMPWORD_OUT		; NOT ZERO?, DONE
00035Fr 2  E6 40        		INC TEMPWORD1+1			; ZERO, INC HIGH BYTE
000361r 2               INCTEMPWORD_OUT:
000361r 2  60           		RTS						; RETURN
000362r 2               
000362r 2               ;__INCTEMPWORD2__________________________________________________
000362r 2               ;
000362r 2               ; INCREMENT THE 16BIT WORK POINTER
000362r 2               ;
000362r 2               ;
000362r 2               ;_______________________________________________________________
000362r 2               INCTEMPWORD2:
000362r 2  E6 40        		INC TEMPWORD2			; INCREMENT LOWBYTE
000364r 2  D0 02        		BNE INCTEMPWORD2_OUT	; NOT ZERO?, DONE
000366r 2  E6 41        		INC TEMPWORD2+1			; ZERO, INC HIGH BYTE
000368r 2               INCTEMPWORD2_OUT:
000368r 2  60           		RTS						; RETURN
000369r 2               
000369r 2               ;__OUTASCII_____________________________________________________
000369r 2               ;
000369r 2               ; PRINT CHAR IF VALID, ELSE PRINT '.'
000369r 2               ;
000369r 2               ;_______________________________________________________________
000369r 2               OUTASCII:
000369r 2  C9 20        		CMP #$20				; IS < 20
00036Br 2  30 07        		BMI OUTASCII_DOT		; YES, SKIP
00036Dr 2  C9 7E        		CMP #$7E				; IS >7E
00036Fr 2  10 03        		BPL OUTASCII_DOT		; YES, SKIP
000371r 2  4C rr rr     		JMP OUTCH				; NO, PRINT CHAR AND RETURN
000374r 2               OUTASCII_DOT:
000374r 2  A9 2E        		LDA #$2E				; A= '.'
000376r 2  4C rr rr     		JMP OUTCH				; PRINT '.' AND RETURN
000379r 2               
000379r 2               ;__INVALID_NUMBER_ERROR__________________________________________
000379r 2               ;
000379r 2               ; PRINT "INVALID HEX NUMBER MESSAGE"
000379r 2               ;
000379r 2               ;_______________________________________________________________
000379r 2               INVALID_NUMBER_ERROR:
000379r 2  A9 rr        		LDA #<INERROR 			; LOAD LOW BYTE OF ERROR STRING
00037Br 2  85 4C                STA STRPTR				; STORE IN POINTER LOW BYTE
00037Dr 2  A9 rr                LDA #>INERROR		    ; LOAD HOGH BYTE OF ERROR STRING
00037Fr 2  85 4D                STA STRPTR +1 			; STORE IN POINTER HIGH BYTE
000381r 2  4C rr rr             JMP OUTSTR				; OUTPUT THE STRING
000384r 2               
000384r 2               
000384r 2               ;__GETNUMBER______________________________________________________
000384r 2               ;
000384r 2               ; GET ASCII NUMBER FROM BUFFER AND PARSE INTO TEMPWORD
000384r 2               ;
000384r 2               ;_______________________________________________________________
000384r 2               GETNUMBER:
000384r 2  A9 00        		LDA #$00				;
000386r 2  85 3D        		STA TEMPWORD			; CLEAR OUT TEMPWORD (OUTPUT OF GETNUMBER)
000388r 2  85 3E        		STA TEMPWORD+1			;
00038Ar 2  A2 00        		LDX #$00				;
00038Cr 2               GETNUMBER_LOOP:
00038Cr 2  A1 39        		LDA (WORKPTR,X)			; GET NEXT BYTE FROM BUFFER
00038Er 2  C9 20        		CMP #$20				; IS SPACE?
000390r 2  F0 31        		BEQ GETNUMBER_DONE		; YES, WE'RE DONE
000392r 2  C9 00        		CMP #$00				; IS NULL?
000394r 2  F0 2D        		BEQ GETNUMBER_DONE		; YES, WE'RE DONE
000396r 2  C9 2C        		CMP #$2C				; IS ","?
000398r 2  F0 29        		BEQ GETNUMBER_DONE		; YES, WE'RE DONE
00039Ar 2  C9 29        		CMP #$29				; IS ")"?
00039Cr 2  F0 25        		BEQ GETNUMBER_DONE		; YES, WE'RE DONE
00039Er 2  20 rr rr     		JSR HEXIN				; GET HEX DIGIT
0003A1r 2  B0 1E        		BCS GETNUMBER_ERROR		; IS INVALID DIGIT?, YES PRINT ERROR AND ABORT
0003A3r 2  18           		CLC						; CLEAR CARRY
0003A4r 2  26 3D        		ROL TEMPWORD			; MOVE WORD OVER 4 BITS TO LEFT
0003A6r 2  26 3E        		ROL TEMPWORD+1			;
0003A8r 2  18           		CLC						;
0003A9r 2  26 3D        		ROL TEMPWORD			;
0003ABr 2  26 3E        		ROL TEMPWORD+1			;
0003ADr 2  18           		CLC						;
0003AEr 2  26 3D        		ROL TEMPWORD			;
0003B0r 2  26 3E        		ROL TEMPWORD+1			;
0003B2r 2  18           		CLC						;
0003B3r 2  26 3D        		ROL TEMPWORD			;
0003B5r 2  26 3E        		ROL TEMPWORD+1			;
0003B7r 2  05 3D        		ORA TEMPWORD			; ADD IN NEW DIGIT
0003B9r 2  85 3D        		STA TEMPWORD			; STORE BACK TO TEMPWORD
0003BBr 2  20 rr rr     		JSR INCWORKPTR			; INCREMENT BUFFER POINTER
0003BEr 2  4C rr rr     		JMP GETNUMBER_LOOP		; LOOP
0003C1r 2               GETNUMBER_ERROR:
0003C1r 2  38           		SEC						; SET ERROR FLAG (CARRY)
0003C2r 2  60           		RTS						; RETURN
0003C3r 2               GETNUMBER_DONE:
0003C3r 2  18           		CLC						; CLEAR ERROR FLAG (CARRY)
0003C4r 2  60           		RTS						; RETURN
0003C5r 2               
0003C5r 2               ;__HEXIN________________________________________________________
0003C5r 2               ;
0003C5r 2               ; GET NEXT CHAR FROM INPUT BUFFER AND CHANGE TO HEX DIGIT
0003C5r 2               ;
0003C5r 2               ; IF INVALID, SET CARRY FLAG
0003C5r 2               ;_______________________________________________________________
0003C5r 2               HEXIN:
0003C5r 2  A2 00        		LDX #$00				;
0003C7r 2  A1 39        		LDA (WORKPTR,X)			; GET NEXT CHAR FROM BUFFER
0003C9r 2  C9 3A              	CMP #$3A  				; LESS THAN 9?
0003CBr 2  B0 02              	BCS HEXIN_BIG  			; NO, SKIP NEXT
0003CDr 2  E9 2F              	SBC #$2F  				; CONVERT 0-9
0003CFr 2               HEXIN_BIG:
0003CFr 2  C9 41        		CMP #$41  				; A OR MORE?
0003D1r 2  90 02              	BCC HEXIN_SMALL 		; NO, SKIP NEXT
0003D3r 2  E9 37              	SBC #$37  				; CONVERT A-F
0003D5r 2               HEXIN_SMALL:
0003D5r 2  C9 10        		CMP #$10  				; RESULT TOO BIG?
0003D7r 2  60                 	RTS
0003D8r 2               
0003D8r 2               
0003D8r 2               ;__EATWHITESPACE___________________________________________________
0003D8r 2               ;
0003D8r 2               ; FORWARD THE BUFFER POINTER PAST ANY WHITE SPACE IN THE INPUT BUFFER
0003D8r 2               ;
0003D8r 2               ;_______________________________________________________________
0003D8r 2               EATWHITESPACE:
0003D8r 2  A2 00        		LDX #$00				;
0003DAr 2  A1 39        		LDA (WORKPTR,X)			; GET NEXT CHAR FROM BUFFER
0003DCr 2  C9 20        		CMP #$20				; IS SPACE
0003DEr 2  D0 06        		BNE EATWHITESPACE_OUT	; NO, DONE
0003E0r 2  20 rr rr     		JSR INCWORKPTR			; YES, INCREMENT BUFFER POINTER
0003E3r 2  4C rr rr     		JMP EATWHITESPACE		; LOOP
0003E6r 2               EATWHITESPACE_OUT:
0003E6r 2  60           		RTS						; RETURN
0003E7r 2               
0003E7r 2               
0003E7r 2               ;__PRINT_BYTE__________________________________________________
0003E7r 2               ;
0003E7r 2               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
0003E7r 2               ;
0003E7r 2               ;______________________________________________________________
0003E7r 2               PRINT_BYTE:
0003E7r 2  AA           		TAX						; SAVE A REGISTER
0003E8r 2  4A           		LSR 					; SHIFT HIGH NIBBLE TO LOW NIBBLE
0003E9r 2  4A           		LSR 					;
0003EAr 2  4A           		LSR 					;
0003EBr 2  4A           		LSR 					;
0003ECr 2  18           		CLC              		; CLEAR CARRY
0003EDr 2  20 rr rr     		JSR PRINT_DIGIT			; PRINT LOW NIBBLE
0003F0r 2  8A           		TXA						; RESTORE ACCUMULATOR
0003F1r 2  4C rr rr     		JMP PRINT_DIGIT			; PRINT LOW NIBBLE
0003F4r 2               
0003F4r 2               ;__PRINT_DIGIT_________________________________________________
0003F4r 2               ;
0003F4r 2               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
0003F4r 2               ;
0003F4r 2               ;______________________________________________________________
0003F4r 2               PRINT_DIGIT:
0003F4r 2  29 0F        		AND #$0F				; STRIP OFF HIGH NIBBLE
0003F6r 2  09 30        		ORA #$30				; ADD $30 TO PRODUCE ASCII
0003F8r 2  C9 3A        		CMP #$3A             	; IS GREATER THAN 9
0003FAr 2  30 03        		BMI PRINT_DIGIT_OUT		; NO, SKIP ADD
0003FCr 2  18           		CLC						; CLEAR CARRY
0003FDr 2  69 07        		ADC #$07				; ADD ON FOR LETTER VALUES
0003FFr 2               PRINT_DIGIT_OUT:				;
0003FFr 2  4C rr rr     		JMP OUTCH           	; PRINT OUT CHAR
000402r 2               
000402r 2               
000402r 2               ;__PRINT_BIN_BYTE______________________________________________
000402r 2               ;
000402r 2               ; PRINT OUT BYTE IN BINARY
000402r 2               ;
000402r 2               ;______________________________________________________________
000402r 2               PRINT_BIN_BYTE:
000402r 2  0A           		ASL						; ROTATE BIT 7 INTO CARRY FLAG
000403r 2  90 06        		BCC PRINT_BIN8_0		;  IS ZERO?
000405r 2  20 rr rr     		JSR PRINT_1				;  NO, PRINT OUT A '1'
000408r 2  4C rr rr     		JMP PRINT_BIN_BIT_7		;  JUMP TO NEXT BIT
00040Br 2               PRINT_BIN8_0:
00040Br 2  20 rr rr     		JSR PRINT_0				;  YES, PRINT A '0'
00040Er 2               PRINT_BIN_BIT_7:				;
00040Er 2  0A           		ASL						; ROTATE BIT 6 INTO CARRY FLAG
00040Fr 2  90 06        		BCC PRINT_BIN7_0		;  IS ZERO?
000411r 2  20 rr rr     		JSR PRINT_1				;  NO, PRINT OUT A '1'
000414r 2  4C rr rr     		JMP PRINT_BIN_BIT_6		;  JUMP TO NEXT BIT
000417r 2               PRINT_BIN7_0:
000417r 2  20 rr rr     		JSR PRINT_0				;  YES, PRINT A '0'
00041Ar 2               PRINT_BIN_BIT_6:				;
00041Ar 2  0A           		ASL						; ROTATE BIT 5 INTO CARRY FLAG
00041Br 2  90 06        		BCC PRINT_BIN6_0		;  IS ZERO?
00041Dr 2  20 rr rr     		JSR PRINT_1				;  NO, PRINT OUT A '1'
000420r 2  4C rr rr     		JMP PRINT_BIN_BIT_5		;  JUMP TO NEXT BIT
000423r 2               PRINT_BIN6_0:					;
000423r 2  20 rr rr     		JSR PRINT_0				;  YES, PRINT A '0'
000426r 2               PRINT_BIN_BIT_5:				;
000426r 2  0A           		ASL						; ROTATE BIT 4 INTO CARRY FLAG
000427r 2  90 06        		BCC PRINT_BIN5_0		;  IS ZERO?
000429r 2  20 rr rr     		JSR PRINT_1				;  NO, PRINT OUT A '1'
00042Cr 2  4C rr rr     		JMP PRINT_BIN_BIT_4		;  JUMP TO NEXT BIT
00042Fr 2               PRINT_BIN5_0:					;
00042Fr 2  20 rr rr     		JSR PRINT_0				;  YES, PRINT A '0'
000432r 2               PRINT_BIN_BIT_4:				;
000432r 2  0A           		ASL						; ROTATE BIT 3 INTO CARRY FLAG
000433r 2  90 06        		BCC PRINT_BIN3_0		;  IS ZERO?
000435r 2  20 rr rr     		JSR PRINT_1				;  NO, PRINT OUT A '1'
000438r 2  4C rr rr     		JMP PRINT_BIN_BIT_2		;  JUMP TO NEXT BIT
00043Br 2               PRINT_BIN3_0:					;
00043Br 2  20 rr rr     		JSR PRINT_0				;  YES, PRINT A '0'
00043Er 2               PRINT_BIN_BIT_2:				;
00043Er 2  0A           		ASL						; ROTATE BIT 2 INTO CARRY FLAG
00043Fr 2  90 06        		BCC PRINT_BIN2_0		;  IS ZERO?
000441r 2  20 rr rr     		JSR PRINT_1				;  NO, PRINT OUT A '1'
000444r 2  4C rr rr     		JMP PRINT_BIN_BIT_1		;  JUMP TO NEXT BIT
000447r 2               PRINT_BIN2_0:					;
000447r 2  20 rr rr     		JSR PRINT_0				;  YES, PRINT A '0'
00044Ar 2               PRINT_BIN_BIT_1:				;
00044Ar 2  0A           		ASL						; ROTATE BIT 1 INTO CARRY FLAG
00044Br 2  90 06        		BCC PRINT_BIN1_0		;  IS ZERO?
00044Dr 2  20 rr rr     		JSR PRINT_1				;  NO, PRINT OUT A '1'
000450r 2  4C rr rr     		JMP PRINT_BIN_BIT_0		;  JUMP TO NEXT BIT
000453r 2               PRINT_BIN1_0:					;
000453r 2  20 rr rr     		JSR PRINT_0				;  YES, PRINT A '0'
000456r 2               PRINT_BIN_BIT_0:				;
000456r 2  0A           		ASL						; ROTATE BIT 0 INTO CARRY FLAG
000457r 2  90 03        		BCC PRINT_BIN0_0		;  IS ZERO?
000459r 2  4C rr rr     		JMP PRINT_1				;  NO, PRINT OUT A '1'
00045Cr 2               PRINT_BIN0_0:					;
00045Cr 2  4C rr rr     		JMP PRINT_0				;   YES, PRINT A '0'
00045Fr 2               
00045Fr 2               
00045Fr 2               
00045Fr 2               ;__PRINT_1_____________________________________________________
00045Fr 2               ;
00045Fr 2               ; PRINT OUT A '1'
00045Fr 2               ;
00045Fr 2               ;______________________________________________________________
00045Fr 2               PRINT_1:
00045Fr 2  48           		PHA						; PUSH ACC TO STACK
000460r 2  A9 31        		LDA #$31				; LOAD '1'
000462r 2  20 rr rr     		JSR OUTCH				; OUTPUT CHAR TO SCREEN
000465r 2  68           		PLA						; PULL ACC FROM STACK
000466r 2  60           		RTS						; RETURN
000467r 2               
000467r 2               
000467r 2               ;__PRINT_0_____________________________________________________
000467r 2               ;
000467r 2               ; PRINT OUT A '0'
000467r 2               ;
000467r 2               ;______________________________________________________________
000467r 2               PRINT_0:
000467r 2  48           		PHA						; PUSH ACC TO STACK
000468r 2  A9 30        		LDA #$30				; LOAD '0'
00046Ar 2  20 rr rr     		JSR OUTCH				; OUTPUT CHAR TO SCREEN
00046Dr 2  68           		PLA						; PULL ACC FROM STACK
00046Er 2  60           		RTS						; RETURN
00046Fr 2               
00046Fr 2               
00046Fr 2               ;__OUTSTR______________________________________________________
00046Fr 2               ;
00046Fr 2               ; OUTPUT THE STRING POINTED TO BU OUTSTR TO THE SCREEN
00046Fr 2               ;
00046Fr 2               ;______________________________________________________________
00046Fr 2               OUTSTR:
00046Fr 2  A0 00        		LDY   #$00				; LOAD $00 INTO Y
000471r 2               OUTSTRLP:
000471r 2  B1 4C        		LDA (STRPTR),Y    	 	; LOAD NEXT CHAR FROM STRING INTO ACC
000473r 2  C9 00        		CMP #$00				; IS NULL?
000475r 2  F0 07        		BEQ ENDOUTSTR			; YES, END PRINT OUT
000477r 2  20 rr rr     		JSR OUTCH  				; PRINT CHAR IN ACC
00047Ar 2  C8           		INY      				; Y=Y+1 (BUMP INDEX)
00047Br 2  4C rr rr     		JMP OUTSTRLP			; DO NEXT CHAR
00047Er 2               ENDOUTSTR:
00047Er 2  60           		RTS						; RETURN
00047Fr 2               
00047Fr 2               ;__INSTR_______________________________________________________
00047Fr 2               ;
00047Fr 2               ; INPUT STRING FROM KEYBOARD INTO KEYBOARD BUFFER
00047Fr 2               ;
00047Fr 2               ;______________________________________________________________
00047Fr 2               INSTR:
00047Fr 2  A0 00        		LDY   #$00				; LOAD $00 INTO Y
000481r 2               INSTRLP:
000481r 2  20 rr rr     		JSR IOF_CONINW
000484r 2  C9 0D        		CMP #$0D				; IS CR?
000486r 2  F0 1E        		BEQ ENDINSTR			; YES, DONE WITH INPUT
000488r 2  C9 08        		CMP #$08				; IS BACKSPACE?
00048Ar 2  D0 10        		BNE INSTR_NOTBS			; NO, SKIP BACKSPACE RTN
00048Cr 2  C0 00        		CPY #$00				; IS INDEX =0 ?
00048Er 2  F0 1B        		BEQ INSTR_EMPTY_BS		; YES, SKIP BACKSPACE
000490r 2  20 rr rr     		JSR OUTCH     			; OUTPUT CHAR TO SCREEN
000493r 2  88           		DEY						; Y=Y-1
000494r 2  A9 00        		LDA #$00				;
000496r 2  91 4C        		STA (STRPTR),Y			; NULL TERMINATE INPUT BUFFER
000498r 2  88           		DEY						; Y=Y-1
000499r 2  4C rr rr     		JMP INSTR_SKIP_STORE    ; SKIP STORE OF CHAR TO INPUT BUFFER
00049Cr 2               INSTR_NOTBS:
00049Cr 2  91 4C        		STA (STRPTR),Y			; STORE CHAR IN KEYBAORD BUFFER
00049Er 2  20 rr rr     		JSR OUTCH     			; OUTPUT CHAR TO SCREEN
0004A1r 2               INSTR_SKIP_STORE:
0004A1r 2  C8           		INY						; Y=Y+1
0004A2r 2  C0 FF        		CPY #$FF				; DOES Y=$FF
0004A4r 2  D0 DB        		BNE INSTRLP         	; NO, LOOP FOR NEXT CHAR
0004A6r 2               ENDINSTR:
0004A6r 2  A9 00        		LDA #$00				; A=0
0004A8r 2  91 4C        		STA (STRPTR),Y			; NULL TERMINATE INPUT BUFFER
0004AAr 2  60           		RTS
0004ABr 2               INSTR_EMPTY_BS:
0004ABr 2  A9 00        		LDA #$00				; BLANK OUT KEYBOARD CHAR, TO SIGNAL READY FOR NEXT CHAR
0004ADr 2  4C rr rr     		JMP INSTRLP				; JUMP TO INPUT LOOP
0004B0r 2               
0004B0r 2               	.include"assmb.asm"
0004B0r 3               ;*
0004B0r 3               ;* ASSEMBLER/DISSASSEMBLER
0004B0r 3               ;*
0004B0r 3               ;* Based on original source code by Jim Butterfield
0004B0r 3               ;*
0004B0r 3               ;* Mr. Butterfield inspired many of us with his work on the commodore series of computers.
0004B0r 3               ;* May he rest in peace. (1936-2007)
0004B0r 3               ;*
0004B0r 3               
0004B0r 3               
0004B0r 3               savx	=	$1c
0004B0r 3               tmpc	=	$1d
0004B0r 3               length	=	$1f
0004B0r 3               wrap	=	$26
0004B0r 3               aflg	=	$28
0004B0r 3               acmd	=	$2a
0004B0r 3               nemo	=	$44
0004B0r 3               tmp0	=	$c1
0004B0r 3               tmp2	=	$c3
0004B0r 3               stage	=	$0210
0004B0r 3               
0004B0r 3               
0004B0r 3               ;__DISASSEMBLE_________________________________________________
0004B0r 3               ;
0004B0r 3               ; Disassemble assembly lines to screen
0004B0r 3               ; USAGE:
0004B0r 3               ;
0004B0r 3               ; DISSASSEMBLE XXXX
0004B0r 3               ;______________________________________________________________
0004B0r 3               DISASSEMBLE:
0004B0r 3               
0004B0r 3  A9 00        	LDA #<INBUFFER             	; SETUP WORK BUFFER
0004B2r 3  85 39        	STA WORKPTR			;
0004B4r 3  A9 02        	LDA #>INBUFFER              	;
0004B6r 3  85 3A        	STA WORKPTR +1 			;
0004B8r 3               
0004B8r 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "D"
0004BBr 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "I"
0004BEr 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "S"
0004C1r 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "S"
0004C4r 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "A"
0004C7r 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "S"
0004CAr 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "S"
0004CDr 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "E"
0004D0r 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "M"
0004D3r 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "B"
0004D6r 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "L"
0004D9r 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "E"
0004DCr 3               
0004DCr 3  20 rr rr     	JSR EATWHITESPACE		; SKIP OVER THE WHITESPACE
0004DFr 3  20 rr rr     	JSR GETNUMBER			; GET THE STARTING ADDRESS
0004E2r 3  B0 45        	BCS DISASSEMBLE_ERROR		; IF NOT A NUMBER, REPORT ERROR
0004E4r 3  A5 3D                LDA TEMPWORD
0004E6r 3  85 C1                STA tmp0
0004E8r 3  A5 3E                LDA TEMPWORD+1
0004EAr 3  85 C2                STA tmp0+1
0004ECr 3  A9 0F        diss:	lda #$0f
0004EEr 3  85 42                sta TEMPBYTE
0004F0r 3  20 rr rr     dislp:  jsr diss1
0004F3r 3  20 rr rr             jsr pcadj
0004F6r 3  85 C1                sta tmp0
0004F8r 3  84 C2                sty tmp0+1
0004FAr 3  C6 42                dec TEMPBYTE
0004FCr 3  D0 F2                bne dislp
0004FEr 3               
0004FEr 3               
0004FEr 3  A9 rr        	LDA #<DISSASSEMBLE_TEXT         ; LOAD LOW BYTE OF PROMPT STRING
000500r 3  85 4C        	STA STRPTR			; STORE IN POINTER LOW BYTE
000502r 3  A9 rr        	LDA #>DISSASSEMBLE_TEXT         ; LOAD HOGH BYTE OF PROMPR STRING
000504r 3  85 4D        	STA STRPTR +1 			; STORE IN POINTER HIGH BYTE
000506r 3  20 rr rr     	JSR OUTSTR			; OUTPUT THE STRING
000509r 3               
000509r 3  20 rr rr           	JSR IOF_CONINW
00050Cr 3  C9 59        	cmp #'Y'
00050Er 3  D0 03        	bne dissexit
000510r 3  4C rr rr     	jmp diss
000513r 3               dissexit:
000513r 3  60                   rts
000514r 3               DISSASSEMBLE_TEXT:
000514r 3  0D 0A        	.BYTE $0d,$0a
000516r 3  43 4F 4E 54  	.BYTE "CONTINUE? (Y/N) "
00051Ar 3  49 4E 55 45  
00051Er 3  3F 20 28 59  
000526r 3  0D 0A 00     	.BYTE $0d,$0a,$00
000529r 3               
000529r 3               DISASSEMBLE_ERROR:
000529r 3  4C rr rr     	JMP INVALID_NUMBER_ERROR
00052Cr 3               ENTER_BYTE:
00052Cr 3  AA           	TAX				; SAVE A REGISTER
00052Dr 3  4A           	LSR A				; SHIFT HIGH NIBBLE TO LOW NIBBLE
00052Er 3  4A           	LSR A				;
00052Fr 3  4A           	LSR A				;
000530r 3  4A           	LSR A				;
000531r 3  18           	CLC               		; CLEAR CARRY
000532r 3  20 rr rr     	JSR ENTER_DIGIT			; PRINT LOW NIBBLE
000535r 3  8A           	TXA				; RESTORE ACCUMULATOR
000536r 3  4C rr rr     	JMP ENTER_DIGIT			; PRINT LOW NIBBLE
000539r 3               ENTER_DIGIT:
000539r 3  29 0F        	AND #$0F			; STRIP OFF HIGH NIBBLE
00053Br 3  09 30        	ORA #$30			; ADD $30 TO PRODUCE ASCII
00053Dr 3  C9 3A        	CMP #$3A               		; IS GREATER THAN 9
00053Fr 3  30 03        	BMI ENTER_DIGIT_OUT		; NO, SKIP ADD
000541r 3  18           	CLC				; CLEAR CARRY
000542r 3  69 07        	ADC #$07			; ADD ON FOR LETTER VALUES
000544r 3               ENTER_DIGIT_OUT:			;
000544r 3  48           	PHA
000545r 3  20 rr rr     	JSR OUTCH                   	; PRINT OUT CHAR
000548r 3  68           	PLA
000549r 3  85 39        	STA WORKPTR
00054Br 3  4C rr rr     	JMP INCWORKPTR
00054Er 3               
00054Er 3               
00054Er 3               
00054Er 3               
00054Er 3               ;__diss1_______________________________________________________
00054Er 3               ;
00054Er 3               ; Disassemble 1 assembly line to screen
00054Er 3               ; Parms:
00054Er 3               ; tmp0 (WORD) Word Pointer to begin disassembly
00054Er 3               ;______________________________________________________________
00054Er 3               diss1:
00054Er 3  20 rr rr              JSR crlf
000551r 3  A9 2E        	 lda #'.'
000553r 3  20 rr rr              jsr OUTCH
000556r 3  20 rr rr              jsr space
000559r 3  20 rr rr     diss1a:  jsr PRINT_WORD
00055Cr 3  20 rr rr              jsr space
00055Fr 3  A2 00                 ldx #0
000561r 3  A1 C1                 lda (tmp0,x)
000563r 3  20 rr rr              jsr instxx
000566r 3  48                    pha
000567r 3  20 rr rr              jsr disvv
00056Ar 3  68                    pla
00056Br 3  20 rr rr              jsr propxx
00056Er 3  A2 06                 ldx #$06
000570r 3  E0 03        pradr1:  cpx #$03
000572r 3  D0 12                 bne pradr3
000574r 3  A4 1F                 ldy length
000576r 3  F0 0E                 beq pradr3
000578r 3  A5 2A        pradr2:  lda acmd
00057Ar 3  C9 E8                 cmp #$e8
00057Cr 3  B1 C1                 lda (tmp0),y
00057Er 3  B0 1C                 bcs reladr
000580r 3  20 rr rr              jsr prbyte
000583r 3  88                    dey
000584r 3  D0 F2                 bne pradr2
000586r 3  06 2A        pradr3:  asl acmd
000588r 3  90 0E                 bcc pradr4
00058Ar 3  BD rr rr              lda char1-1,x
00058Dr 3  20 rr rr              jsr chrout
000590r 3  BD rr rr              lda char2-1,x
000593r 3  F0 03                 beq pradr4
000595r 3  20 rr rr              jsr chrout
000598r 3  CA           pradr4:  dex
000599r 3  D0 D5                 bne pradr1
00059Br 3  60                    rts
00059Cr 3               ; ** print rel address **
00059Cr 3  20 rr rr     reladr:  jsr pcadj3
00059Fr 3  AA                    tax
0005A0r 3  E8                    inx
0005A1r 3  D0 01                 bne prntyx
0005A3r 3  C8                    iny
0005A4r 3               ; ** print word address **
0005A4r 3  98           prntyx:  tya
0005A5r 3  20 rr rr              jsr prbyte
0005A8r 3  8A                    txa
0005A9r 3               ; ** print Byte **
0005A9r 3  86 1C        prbyte:  stx savx
0005ABr 3  20 rr rr              jsr PRINT_BYTE
0005AEr 3  A6 1C                 ldx savx
0005B0r 3  60                    rts
0005B1r 3               ; ** advance the program counter **
0005B1r 3  A5 1F        pcadj:   lda length
0005B3r 3  38                    sec
0005B4r 3  A4 C2        pcadj3:  ldy tmp0+1
0005B6r 3  AA                    tax
0005B7r 3  10 01                 bpl pcadj4
0005B9r 3  88                    dey
0005BAr 3  65 C1        pcadj4:  adc tmp0
0005BCr 3  90 01                 bcc rts1
0005BEr 3  C8                    iny
0005BFr 3  60           rts1:    rts
0005C0r 3               ; ** check inst valid, len **
0005C0r 3  A8           instxx:  tay
0005C1r 3  4A                    lsr a
0005C2r 3  90 0B                 bcc ieven
0005C4r 3  4A                    lsr a
0005C5r 3  B0 17                 bcs err
0005C7r 3  C9 22                 cmp #$22
0005C9r 3  F0 13                 beq err
0005CBr 3  29 07                 and #$07
0005CDr 3  09 80                 ora #$80
0005CFr 3  4A           ieven:   lsr a
0005D0r 3  AA                    tax
0005D1r 3  BD rr rr              lda mode,x
0005D4r 3  B0 04                 bcs rtmode
0005D6r 3  4A                    lsr a
0005D7r 3  4A                    lsr a
0005D8r 3  4A                    lsr a
0005D9r 3  4A                    lsr a
0005DAr 3  29 0F        rtmode:  and #$0f
0005DCr 3  D0 04                 bne getfmt
0005DEr 3  A0 80        err:     ldy #$80
0005E0r 3  A9 00                 lda #0
0005E2r 3               ; ** get addr mode, length **
0005E2r 3  AA           getfmt:  tax
0005E3r 3  BD rr rr              lda mode2,x
0005E6r 3  85 2A                 sta acmd
0005E8r 3  29 03                 and #$03
0005EAr 3  85 1F                 sta length
0005ECr 3               ; ** extract intructn **
0005ECr 3  98                    tya
0005EDr 3  29 8F                 and #$8f
0005EFr 3  AA                    tax
0005F0r 3  98                    tya
0005F1r 3  A0 03                 ldy #$03
0005F3r 3  E0 8A                 cpx #$8a
0005F5r 3  F0 0B                 beq mnndx3
0005F7r 3  4A           mnndx1:  lsr a
0005F8r 3  90 08                 bcc mnndx3
0005FAr 3  4A                    lsr a
0005FBr 3  4A           mnndx2:  lsr a
0005FCr 3  09 20                 ora #$20
0005FEr 3  88                    dey
0005FFr 3  D0 FA                 bne mnndx2
000601r 3  C8                    iny
000602r 3  88           mnndx3:  dey
000603r 3  D0 F2                 bne mnndx1
000605r 3  60                    rts
000606r 3               ; print bytes
000606r 3  B1 C1        disvv:   lda (tmp0),y
000608r 3  20 rr rr              jsr prbyte
00060Br 3  A2 01                 ldx #1
00060Dr 3  20 rr rr     disvl:   jsr spacd
000610r 3  C4 1F                 cpy length
000612r 3  C8                    iny
000613r 3  90 F1                 bcc disvv
000615r 3  A2 03                 ldx #$03
000617r 3  C0 04                 cpy #4
000619r 3  90 F2                 bcc disvl
00061Br 3  60                    rts
00061Cr 3               ; ** print mnemonic **
00061Cr 3  A8           propxx:  tay
00061Dr 3  B9 rr rr              lda mneml,y
000620r 3  85 28                 sta aflg
000622r 3  B9 rr rr              lda mnemr,y
000625r 3  85 29                 sta aflg+1
000627r 3  A9 00        prmn1:   lda #0
000629r 3  A0 05                 ldy #$05
00062Br 3  06 29        prmn2:   asl aflg+1
00062Dr 3  26 28                 rol aflg
00062Fr 3  2A                    rol a
000630r 3  88                    dey
000631r 3  D0 F8                 bne prmn2
000633r 3  69 3F                 adc #$3f
000635r 3  20 rr rr              jsr OUTCH
000638r 3  CA                    dex
000639r 3  D0 EC                 bne prmn1
00063Br 3               ; ** print space **
00063Br 3  A9 20        space:   lda #$20
00063Dr 3  D0 07                 bne flip
00063Fr 3               ; ** print cr, maybe lf **
00063Fr 3  A9 0D        crlf:    lda #$0d
000641r 3  20 rr rr              jsr OUTCH
000644r 3  A9 0A                 lda #$0a
000646r 3  4C rr rr     flip:    jmp OUTCH
000649r 3               
000649r 3               
000649r 3               ;__ASSEMBLE____________________________________________________
000649r 3               ;
000649r 3               ; Assemble line from keyboard to memory
000649r 3               ;______________________________________________________________
000649r 3               ASSEMBLE:
000649r 3  A9 00                LDA #<INBUFFER                  ; SETUP WORK BUFFER
00064Br 3  85 39        	STA WORKPTR			;
00064Dr 3  A9 02        	LDA #>INBUFFER                  ;
00064Fr 3  85 3A        	STA WORKPTR +1 			;
000651r 3               
000651r 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "A"
000654r 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "S"
000657r 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "S"
00065Ar 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "E"
00065Dr 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "M"
000660r 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "B"
000663r 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "L"
000666r 3  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "E"
000669r 3               
000669r 3  20 rr rr     	JSR EATWHITESPACE		; SKIP OVER ANY WHITESPACE
00066Cr 3  20 rr rr     	JSR GETNUMBER			; GET NUMBER
00066Fr 3  B0 03        	BCS ASSEMBLE_ERROR		; IF NOT A NUMBER REPORT ERROR
000671r 3  4C rr rr             jmp asvald
000674r 3               ASSEMBLE_ERROR:
000674r 3  4C rr rr     	jmp error
000677r 3               asvald:
000677r 3  A5 3D        	LDA TEMPWORD
000679r 3  85 C1        	STA tmp0
00067Br 3  A5 3E        	LDA TEMPWORD+1
00067Dr 3  85 C2        	STA tmp0+1
00067Fr 3               asv1:
00067Fr 3  20 rr rr     	JSR crlf
000682r 3  A9 2E        	lda #'.'
000684r 3  20 rr rr             jsr OUTCH
000687r 3  20 rr rr             jsr space
00068Ar 3  20 rr rr             jsr PRINT_WORD
00068Dr 3  20 rr rr             jsr space
000690r 3  20 rr rr             JSR t2t2
000693r 3  8E 11 02             STX stage+1
000696r 3  A9 00         	LDA #<INBUFFER                 	; SETUP INPUT COMMAND BUFFER
000698r 3  85 4C        	STA STRPTR			;
00069Ar 3  85 39        	sta WORKPTR			;
00069Cr 3  A9 02        	LDA #>INBUFFER              	;
00069Er 3  85 4D        	STA STRPTR +1 			;
0006A0r 3  85 3A        	STA WORKPTR+1	             	;
0006A2r 3  20 rr rr     	JSR INSTR			; GET A STRING FROM THE CONSOLE
0006A5r 3  20 rr rr     	jsr EATWHITESPACE
0006A8r 3  A2 03        	LDX #$03			; push opcode to stack
0006AAr 3  A0 00        	LDY #$00
0006ACr 3  B1 39        apush:  LDA (WORKPTR),Y			; GET NEXT CHAR FROM BUFFER
0006AEr 3  48           	pha
0006AFr 3  20 rr rr     	JSR INCWORKPTR
0006B2r 3  CA           	dex
0006B3r 3  D0 F7        	bne apush
0006B5r 3               
0006B5r 3  A2 03                ldx #$03
0006B7r 3  68           apull:   pla
0006B8r 3  38                    sec
0006B9r 3  E9 3F                 sbc #$3f
0006BBr 3  A0 05                 ldy #$05
0006BDr 3  4A           acrun:   lsr a
0006BEr 3  6E 11 02              ror stage+1
0006C1r 3  6E 10 02              ror stage
0006C4r 3  88                    dey
0006C5r 3  D0 F6                 bne acrun
0006C7r 3  CA                    dex
0006C8r 3  D0 ED                 bne apull
0006CAr 3  A2 02                 ldx #$02
0006CCr 3  A0 00        ainp:    LDY #$00
0006CEr 3  B1 39        	 LDA (WORKPTR),Y		; GET NEXT CHAR FROM BUFFER
0006D0r 3  20 rr rr       	 JSR INCWORKPTR
0006D3r 3  C9 00                 cmp #$00
0006D5r 3  F0 1E                 beq aret
0006D7r 3  C9 20                 cmp #$20
0006D9r 3  F0 F1                 beq ainp
0006DBr 3  20 rr rr              jsr ahex
0006DEr 3  B0 0F                 bcs stone
0006E0r 3               
0006E0r 3  20 rr rr              jsr rdob2
0006E3r 3  A4 C1                 ldy tmp0
0006E5r 3  84 C2                 sty tmp0+1
0006E7r 3  85 C1                 sta tmp0
0006E9r 3               
0006E9r 3  A9 30                 lda #$30
0006EBr 3  9D 10 02              sta stage,x
0006EEr 3  E8                    inx
0006EFr 3  9D 10 02     stone:   sta stage,x
0006F2r 3  E8                    inx
0006F3r 3  D0 D7                 bne ainp
0006F5r 3  86 28        aret:    stx aflg
0006F7r 3  A2 00                 ldx #0
0006F9r 3  86 26                 stx wrap
0006FBr 3  F0 04                 beq atry
0006FDr 3  E6 26        abump:   inc wrap
0006FFr 3  F0 75                 beq aerr
000701r 3  A2 00        atry:    ldx #0
000703r 3  86 1D                 stx tmpc
000705r 3  A5 26                 lda wrap
000707r 3  20 rr rr              jsr instxx
00070Ar 3  A6 2A                 ldx acmd
00070Cr 3  86 29                 stx aflg+1
00070Er 3  AA                    tax
00070Fr 3  BC rr rr              ldy mneml,x
000712r 3  BD rr rr              lda mnemr,x
000715r 3  20 rr rr              jsr achek2
000718r 3  D0 E3                 bne abump
00071Ar 3  A2 06                 ldx #$06
00071Cr 3  E0 03        aoprnd:  cpx #$03
00071Er 3  D0 19                 bne ashf
000720r 3  A4 1F                 ldy length
000722r 3  F0 15                 beq ashf
000724r 3  A5 2A        arsc:    lda acmd
000726r 3  C9 E8                 cmp #$e8
000728r 3  A9 30                 lda #$30
00072Ar 3  B0 21                 bcs arel1
00072Cr 3  20 rr rr              jsr acheck
00072Fr 3  D0 CC                 bne abump
000731r 3  20 rr rr              jsr achick
000734r 3  D0 C7                 bne abump
000736r 3  88                    dey
000737r 3  D0 EB                 bne arsc
000739r 3  06 2A        ashf:    asl acmd
00073Br 3  90 0B                 bcc adex
00073Dr 3  BC rr rr              ldy char2-1,x
000740r 3  BD rr rr              lda char1-1,x
000743r 3  20 rr rr              jsr achek2
000746r 3  D0 B5                 bne abump
000748r 3  CA           adex:    dex
000749r 3  D0 D1                 bne aoprnd
00074Br 3  F0 0A                 beq ald
00074Dr 3  20 rr rr     arel1:   jsr acdb1
000750r 3  D0 AB                 bne abump
000752r 3  20 rr rr              jsr acdb1
000755r 3  D0 A6                 bne abump
000757r 3  A5 28        ald:     lda aflg
000759r 3  C5 1D                 cmp tmpc
00075Br 3  D0 A0                 bne abump
00075Dr 3  20 rr rr              jsr t2t2
000760r 3  A4 1F                 ldy length
000762r 3  F0 28                 beq aopset
000764r 3  A5 29                 lda aflg+1
000766r 3  C9 9D                 cmp #$9d
000768r 3  D0 1A                 bne aopnd
00076Ar 3  20 rr rr              jsr diffb
00076Dr 3  90 0A                 bcc abdown
00076Fr 3  98                    tya
000770r 3  D0 04                 bne aerr
000772r 3  A5 44                 lda nemo
000774r 3  10 0A                 bpl abran
000776r 3  4C rr rr     aerr:    jmp error
000779r 3  C8           abdown:  iny
00077Ar 3  D0 FA                 bne aerr
00077Cr 3  A5 44                 lda nemo
00077Er 3  10 F6                 bpl aerr
000780r 3  A4 1F        abran:   ldy length
000782r 3  D0 03                 bne abrel
000784r 3  B9 C2 00     aopnd:   lda tmp2-1,y
000787r 3  91 C1        abrel:   sta (tmp0),y
000789r 3  88                    dey
00078Ar 3  D0 F8                 bne aopnd
00078Cr 3  A5 26        aopset:  lda wrap
00078Er 3  91 C1                 sta (tmp0),y
000790r 3  20 rr rr              jsr pcadj
000793r 3  85 C1                 sta tmp0
000795r 3  84 C2                 sty tmp0+1
000797r 3  4C rr rr              jmp asv1
00079Ar 3  A8           acdb1:   tay
00079Br 3  20 rr rr     achek2:  jsr acheck
00079Er 3  D0 11                 bne acex
0007A0r 3  98                    tya
0007A1r 3  F0 0E        acheck:  beq acex
0007A3r 3  86 1C        achick:  stx savx
0007A5r 3  A6 1D                 ldx tmpc
0007A7r 3  DD 10 02              cmp stage,x
0007AAr 3  08                    php
0007ABr 3  E8                    inx
0007ACr 3  86 1D                 stx tmpc
0007AEr 3  A6 1C                 ldx savx
0007B0r 3  28                    plp
0007B1r 3  60           acex:    rts
0007B2r 3  C9 30        ahex:    cmp #$30
0007B4r 3  90 03                 bcc asx
0007B6r 3  C9 47                 cmp #$47
0007B8r 3  60                    rts
0007B9r 3  38           asx:     sec
0007BAr 3  60                    rts
0007BBr 3               
0007BBr 3               
0007BBr 3               
0007BBr 3                                        ; ** swap tmp0, tmp2 **
0007BBr 3  A2 02        t2t2:    ldx #$02
0007BDr 3  B5 C0        t2t21:   lda tmp0-1,x
0007BFr 3  48                    pha
0007C0r 3  B5 C2                 lda tmp2-1,x
0007C2r 3  95 C0                 sta tmp0-1,x
0007C4r 3  68                    pla
0007C5r 3  95 C2                 sta tmp2-1,x
0007C7r 3  CA                    dex
0007C8r 3  D0 F3                 bne t2t21
0007CAr 3  60                    rts
0007CBr 3               
0007CBr 3               PRINT_WORD:
0007CBr 3  48           	pha
0007CCr 3  A5 C2        	lda tmp0+1
0007CEr 3  20 rr rr     	jsr prbyte
0007D1r 3  A5 C1        	lda tmp0
0007D3r 3  20 rr rr     	jsr prbyte
0007D6r 3  68           	pla
0007D7r 3  60           	rts
0007D8r 3                                         ; ** calc tmp2-tmp0-2 **
0007D8r 3  A5 C3        diffb:   lda tmp2
0007DAr 3  A4 C4                 ldy tmp2+1
0007DCr 3  38                    sec
0007DDr 3  E9 02                 sbc #2
0007DFr 3  B0 0E                 bcs deck
0007E1r 3  88                    dey
0007E2r 3  90 0B                 bcc deck
0007E4r 3                                         ; ** calc aflg-tmp0 **
0007E4r 3  A5 28        diffa:   lda aflg
0007E6r 3  A4 29                 ldy aflg+1
0007E8r 3  4C rr rr              jmp deck
0007EBr 3                                         ; ** calc tmp2-tmp0 **
0007EBr 3  A5 C3        diffp:   lda tmp2
0007EDr 3  A4 C4                 ldy tmp2+1
0007EFr 3  38           deck:    sec
0007F0r 3  E5 C1                 sbc tmp0
0007F2r 3  85 44                 sta nemo
0007F4r 3  98                    tya
0007F5r 3  E5 C2                 sbc tmp0+1
0007F7r 3  A8                    tay
0007F8r 3  05 44                 ora nemo
0007FAr 3  60                    rts
0007FBr 3               
0007FBr 3  A9 3F        error:   lda #$3f
0007FDr 3  20 rr rr              jsr OUTCH
000800r 3  60                    rts
000801r 3                                      ; ** print spaces **
000801r 3  20 rr rr     spacd:   jsr space
000804r 3  CA                    dex
000805r 3  D0 FA                 bne spacd
000807r 3  60                    rts
000808r 3  C5 28        chrout:  cmp aflg
00080Ar 3  F0 03                 beq caltrit
00080Cr 3  20 rr rr              jsr OUTCH
00080Fr 3  60           caltrit: rts
000810r 3               
000810r 3  98           altrit:  tya
000811r 3  48                    pha
000812r 3  20 rr rr              jsr crlf
000815r 3  68                    pla
000816r 3  20 rr rr              jsr OUTCH
000819r 3  A9 2E                 lda #$2e
00081Br 3  4C rr rr              jmp OUTCH
00081Er 3               
00081Er 3                                         ; ** print hex byte **
00081Er 3  A5 C2        wroa:    lda tmp0+1
000820r 3  20 rr rr              jsr PRINT_BYTE
000823r 3  A5 C1                 lda tmp0
000825r 3  4C rr rr              jmp PRINT_BYTE
000828r 3               
000828r 3                                        ; ** read hex byte **
000828r 3  20 rr rr     rdob2:   jsr hexit
00082Br 3  0A                    asl a
00082Cr 3  0A                    asl a
00082Dr 3  0A                    asl a
00082Er 3  0A                    asl a
00082Fr 3  85 2A                 sta acmd
000831r 3  B1 39                 LDA (WORKPTR),Y			; GET NEXT CHAR FROM BUFFER
000833r 3  20 rr rr       	 JSR INCWORKPTR
000836r 3  20 rr rr     rdob3:   jsr hexit
000839r 3  05 2A                 ora acmd
00083Br 3  38                    sec
00083Cr 3  60                    rts
00083Dr 3                                         ; ** convert from hex **
00083Dr 3  C9 3A        hexit:   cmp #$3a
00083Fr 3  90 02                 bcc hex08
000841r 3  69 08                 adc #$08
000843r 3  29 0F        hex08:   and #$0f
000845r 3  60                    rts
000846r 3               
000846r 3               
000846r 3                                         ; mode table... nybble organized
000846r 3                                         ; 0= err  4= implied  8= zer,x   c= zer,y
000846r 3                                         ; 1= imm  5= acc      9= abs,x   d= rel
000846r 3                                         ; 2= zer  6= (ind,x)  a= abs,y
000846r 3                                         ; 3= abs  7= (ind),y  b= (ind)
000846r 3  40 02 45 03  mode:    .byte $40,$02,$45,$03
00084Ar 3  D0 08 40 09           .byte $d0,$08,$40,$09
00084Er 3  30 22 45 33           .byte $30,$22,$45,$33
000852r 3  D0 08 40 09           .byte $d0,$08,$40,$09
000856r 3  40 02 45 33           .byte $40,$02,$45,$33
00085Ar 3  D0 08 40 09           .byte $d0,$08,$40,$09
00085Er 3  40 02 45 B3           .byte $40,$02,$45,$b3
000862r 3  D0 08 40 09           .byte $d0,$08,$40,$09
000866r 3  00 22 44 33           .byte $00,$22,$44,$33
00086Ar 3  D0 8C 44 00           .byte $d0,$8c,$44,$00
00086Er 3  11 22 44 33           .byte $11,$22,$44,$33
000872r 3  D0 8C 44 9A           .byte $d0,$8c,$44,$9a
000876r 3  10 22 44 33           .byte $10,$22,$44,$33
00087Ar 3  D0 08 40 09           .byte $d0,$08,$40,$09
00087Er 3  10 22 44 33           .byte $10,$22,$44,$33
000882r 3  D0 08 40 09           .byte $d0,$08,$40,$09
000886r 3  62 13 78 A9           .byte $62,$13,$78,$a9
00088Ar 3                                         ;master modes
00088Ar 3                                         ;six hi-order bits  mode options
00088Ar 3                                         ;two lo-order bits  operand length ready.
00088Ar 3  00 21 81 82  mode2:   .byte $00,$21,$81,$82
00088Er 3  00 00 59 4D           .byte $00,$00,$59,$4d
000892r 3  91 92 86 4A           .byte $91,$92,$86,$4a,$85,$9d
000896r 3  85 9D        
000898r 3  2C 29 2C 23  char1:   .byte $2c,$29,$2c,$23,$28,$24
00089Cr 3  28 24        
00089Er 3  59 00 58 24  char2:   .byte $59,$00,$58,$24,$24,$00
0008A2r 3  24 00        
0008A4r 3                                         ; packed mnemonics
0008A4r 3  1C 8A 1C 23  mneml:   .byte $1c,$8a,$1c,$23
0008A8r 3  5D 8B 1B A1           .byte $5d,$8b,$1b,$a1
0008ACr 3  9D 8A 1D 23           .byte $9d,$8a,$1d,$23
0008B0r 3  9D 8B 1D A1           .byte $9d,$8b,$1d,$a1
0008B4r 3  00 29 19 AE           .byte $00,$29,$19,$ae
0008B8r 3  69 A8 19 23           .byte $69,$a8,$19,$23
0008BCr 3  24 53 1B 23           .byte $24,$53,$1b,$23
0008C0r 3  24 53 19 A1           .byte $24,$53,$19,$a1
0008C4r 3  00 1A 5B 5B           .byte $00,$1a,$5b,$5b
0008C8r 3  A5 69 24 24           .byte $a5,$69,$24,$24
0008CCr 3  AE AE A8 AD           .byte $ae,$ae,$a8,$ad
0008D0r 3  29 00 7C 00           .byte $29,$00,$7c,$00
0008D4r 3  15 9C 6D 9C           .byte $15,$9c,$6d,$9c
0008D8r 3  A5 69 29 53           .byte $a5,$69,$29,$53
0008DCr 3  84 13 34 11           .byte $84,$13,$34,$11
0008E0r 3  A5 69 23 A0           .byte $a5,$69,$23,$a0
0008E4r 3               
0008E4r 3  D8 62 5A 48  mnemr:   .byte $d8,$62,$5a,$48
0008E8r 3  26 62 94 88           .byte $26,$62,$94,$88
0008ECr 3  54 44 C8 54           .byte $54,$44,$c8,$54
0008F0r 3  68 44 E8 94           .byte $68,$44,$e8,$94
0008F4r 3  00 B4 08 84           .byte $00,$b4,$08,$84
0008F8r 3  74 B4 28 6E           .byte $74,$b4,$28,$6e
0008FCr 3  74 F4 CC 4A           .byte $74,$f4,$cc,$4a
000900r 3  72 F2 A4 8A           .byte $72,$f2,$a4,$8a
000904r 3  00 AA A2 A2           .byte $00,$aa,$a2,$a2
000908r 3  74 74 74 72           .byte $74,$74,$74,$72
00090Cr 3  44 68 B2 32           .byte $44,$68,$b2,$32
000910r 3  B2 00 22 00           .byte $b2,$00,$22,$00
000914r 3  1A 1A 26 26           .byte $1a,$1a,$26,$26
000918r 3  72 72 88 C8           .byte $72,$72,$88,$c8
00091Cr 3  C4 CA 26 48           .byte $c4,$ca,$26,$48
000920r 3  44 44 A2 C8           .byte $44,$44,$a2,$c8
000924r 3               
000924r 2               
000924r 2               ; COMMAND PROCESSOR JUMP TABLE
000924r 2               COMMAND_LOOKUP_TABLE:
000924r 2  52 45 47 49   		.BYTE "REGISTER",0,<PRINT_REG,>PRINT_REG
000928r 2  53 54 45 52  
00092Cr 2  00 rr rr     
00092Fr 2  44 55 4D 50   		.BYTE "DUMP",0,<DUMP,>DUMP
000933r 2  00 rr rr     
000936r 2  45 4E 54 45   		.BYTE "ENTER",0,<ENTERMEM,>ENTERMEM
00093Ar 2  52 00 rr rr  
00093Er 2  47 4F 00 rr   		.BYTE "GO",0,<GO,>GO
000942r 2  rr           
000943r 2  4C 4F 41 44   		.BYTE "LOAD",0,<LOAD,>LOAD
000947r 2  00 rr rr     
00094Ar 2  5A 38 30 00   		.BYTE "Z80",0,<Z80,>Z80
00094Er 2  rr rr        
000950r 2  44 49 53 41  		.BYTE "DISASSEMBLE",0,<DISASSEMBLE,>DISASSEMBLE
000954r 2  53 53 45 4D  
000958r 2  42 4C 45 00  
00095Er 2  41 53 53 45  		.BYTE "ASSEMBLE",0,<ASSEMBLE,>ASSEMBLE
000962r 2  4D 42 4C 45  
000966r 2  00 rr rr     
000969r 2  01 00        		.BYTE 01,0
00096Br 2               ; COMMAND PROMPT STRING
00096Br 2  0D 0A 2E 00  PROMPT:  	.BYTE   $0D,$0A,".",0
00096Fr 2               ; ERROR STRING
00096Fr 2  0D 0A 3F 20  ERROR:	 	.BYTE   $0D,$0A,"? COMMAND NOT FOUND",$0D,0
000973r 2  43 4F 4D 4D  
000977r 2  41 4E 44 20  
000986r 2  0D 0A 3F 20  INERROR:	.BYTE   $0D,$0A,"? INVALID HEX NUMBER",$0D,0
00098Ar 2  49 4E 56 41  
00098Er 2  4C 49 44 20  
00099Er 2               ; STRINGS FOR REGISTER DISPLY
00099Er 2  0D 0A        REGDATA: 	.BYTE   $0D,$0A
0009A0r 2  20 20 20 50  		.BYTE   "   PC  AC  XR  YR  SP  SR(NVRBDIZC)"
0009A4r 2  43 20 20 41  
0009A8r 2  43 20 20 58  
0009C3r 2  0D 0A 21 20  		.BYTE   $0D,$0A,"! ",0
0009C7r 2  00           
0009C8r 2               
0009C8r 1               	.INCLUDE"../DOS65/os/dospager.asm"
0009C8r 2               ;__pager_________________________________________________________________________________________________________________________
0009C8r 2               ;
0009C8r 2               ; 	Nhyodyne Memory page management code
0009C8r 2               ;
0009C8r 2               ;	Entry points:
0009C8r 2               ;		PAGER_INIT          - called during OS init
0009C8r 2               ;________________________________________________________________________________________________________________________________
0009C8r 2               ;
0009C8r 2               ; RAM BANK $0C is RAM area for Drivers
0009C8r 2               ; RAM BANK $0E is operating bank for DOS/65 $8000-$FFFF
0009C8r 2               ; RAM BANK $0F is fixed bank $0000-$7FFF
0009C8r 2               ;
0009C8r 2               ; ROM BANKS $00 and $0C-$0F are reserved for ROMWBW code
0009C8r 2               ;
0009C8r 2               ; ROM MEMORY PAGE CONFIGURATION LATCH CONTROL PORT
0009C8r 2               ;       A15 IS INVERTED FOR THE NYHODYNE 65C02 CPU . . .
0009C8r 2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
0009C8r 2               ;	^ ^ ^ ^  ^ ^ ^ ^
0009C8r 2               ;	: : : :  : : : :--0 = A15 ROM ONLY ADDRESS LINE DEFAULT IS 0 x
0009C8r 2               ;	: : : :  : : :----0 = A16 ROM ONLY ADDRESS LINE DEFAULT IS 0
0009C8r 2               ;	: : : :  : :------0 = A17 ROM ONLY ADDRESS LINE DEFAULT IS 0
0009C8r 2               ;	: : : :  :--------0 = A18 ROM ONLY ADDRESS LINE DEFAULT IS 0 X
0009C8r 2               ;	: : : :-----------0 = A19 ROM ONLY ADDRESS LINE DEFAULT IS 0
0009C8r 2               ;	: : :-------------0 = A20 ROM ONLY ADDRESS LINE DEFAULT IS 0
0009C8r 2               ;	: :---------------0 = ROM BOOT OVERRIDE DEFAULT IS 0
0009C8r 2               ;	:-----------------0 = LOWER PAGE ROM SELECT (0=ROM, 1=NOTHING) DEFAULT IS 0
0009C8r 2               ;
0009C8r 2               ; RAM PAGE CONFIGURATION LATCH CONTROL PORT
0009C8r 2               ;
0009C8r 2               ;	7 6 5 4  3 2 1 0      APPLICABLE TO THE UPPER MEMORY PAGE $8000-$FFFF
0009C8r 2               ;	^ ^ ^ ^  ^ ^ ^ ^
0009C8r 2               ;	: : : :  : : : :--0 = A15 RAM ONLY ADDRESS LINE DEFAULT IS 0
0009C8r 2               ;	: : : :  : : :----0 = A16 RAM ONLY ADDRESS LINE DEFAULT IS 0
0009C8r 2               ;	: : : :  : :------0 = A17 RAM ONLY ADDRESS LINE DEFAULT IS 0
0009C8r 2               ;	: : : :  :--------0 = A18 RAM ONLY ADDRESS LINE DEFAULT IS 0
0009C8r 2               ;	: : : :-----------0 = A19 RAM ONLY ADDRESS LINE DEFAULT IS 0
0009C8r 2               ;	: : :-------------0 = UNDEFINED DEFAULT IS 0
0009C8r 2               ;	: :---------------0 = RAM BOOT OVERRIDE DEFAULT IS 0
0009C8r 2               ;	:-----------------0 = LOWER PAGE RAM SELECT (0=NOTHING, 1=RAM) DEFAULT IS 0;
0009C8r 2               
0009C8r 2               
0009C8r 2               ;__PAGER_INIT___________________________________________________________________________________________
0009C8r 2               ;
0009C8r 2               ;  INIT -- Copy code into $0200-$02FF for controling banking and copying
0009C8r 2               ;____________________________________________________________________________________________________
0009C8r 2               PAGER_INIT:
0009C8r 2  A2 00                LDX     #$00
0009CAr 2               :
0009CAr 2  BD rr rr             LDA     md_pagecode,X
0009CDr 2  9D 00 05             STA     MD_PAGERA,X
0009D0r 2  E8                   INX
0009D1r 2  E0 00                CPX     #$00
0009D3r 2  D0 F5                BNE     :-
0009D5r 2  60                   RTS
0009D6r 2               
0009D6r 2               ;       X=Control Word
0009D6r 2               ;	7 6 5 4  3 2 1 0
0009D6r 2               ;	^ ^ ^ ^  ^ ^ ^ ^
0009D6r 2               ;       : : : X  X X X X    = UNUSED
0009D6r 2               ;	: : :-------------0 = Read=0, Write=1
0009D6r 2               ;	: :---------------0 = RAM=0, ROM=1
0009D6r 2               ;	:-----------------0 = LOW=0, HIGH=1
0009D6r 2               ;       A= bank
0009D6r 2               ;       Y= page
0009D6r 2               ;
0009D6r 2               md_pagecode:
0009D6r 2  48                   PHA
0009D7r 2  84 15                STY     MD_PAGESE+1     ; setup copy from pointer
0009D9r 2  8A                   TXA
0009DAr 2  29 80                AND     #$80
0009DCr 2  A8                   TAY
0009DDr 2  84 14                STY     MD_PAGESE
0009DFr 2  8A                   TXA
0009E0r 2  29 20                AND     #%00100000
0009E2r 2  C9 00                CMP     #$00
0009E4r 2  D0 3D                BNE     MD_PAGE_WRITE
0009E6r 2               ; PERFORM READ HERE
0009E6r 2  8A                   TXA
0009E7r 2  29 40                AND     #%01000000
0009E9r 2  C9 00                CMP     #$00
0009EBr 2  D0 0D                BNE     MD_PAGE_ROREAD
0009EDr 2               ; DO RAM READ
0009EDr 2  A9 80                LDA     #$80
0009EFr 2  8D 7C 03             STA     MPCL_ROM
0009F2r 2  68                   PLA
0009F3r 2  09 80                ORA     #$80
0009F5r 2  8D 78 03             STA     MPCL_RAM
0009F8r 2  80 0B                BRA     MD_PAGE_COPYFRM
0009FAr 2               MD_PAGE_ROREAD:
0009FAr 2  A9 00                LDA     #$00
0009FCr 2  8D 78 03             STA     MPCL_RAM
0009FFr 2  68                   PLA
000A00r 2  29 7F                AND     #$7F
000A02r 2  8D 7C 03             STA     MPCL_ROM
000A05r 2               MD_PAGE_COPYFRM:
000A05r 2               ; DO THE COPY
000A05r 2  A2 00                LDX     #$00
000A07r 2  A0 00                LDY     #$00
000A09r 2               :
000A09r 2  B1 14                LDA     (MD_PAGESE),Y
000A0Br 2  9D 00 04             STA     MD_PAGEBU,X
000A0Er 2  E8                   INX
000A0Fr 2  C8                   INY
000A10r 2  E0 80                CPX     #$80
000A12r 2  D0 F5                BNE     :-
000A14r 2  A9 80                LDA     #$80
000A16r 2  8D 7C 03             STA     MPCL_ROM
000A19r 2  EA                   NOP
000A1Ar 2  EA                   NOP
000A1Br 2  A9 8C                LDA     #$8C
000A1Dr 2  8D 78 03             STA     MPCL_RAM
000A20r 2  EA                   nop
000A21r 2  EA                   nop
000A22r 2  60                   RTS
000A23r 2               MD_PAGE_WRITE:
000A23r 2  68                   PLA
000A24r 2  09 80                ORA     #%10000000
000A26r 2  8D 78 03             STA     MPCL_RAM
000A29r 2               ; DO THE COPY
000A29r 2  A2 00                LDX     #$00
000A2Br 2  A0 00                LDY     #$00
000A2Dr 2               :
000A2Dr 2  BD 00 04             LDA     MD_PAGEBU,X
000A30r 2  91 14                STA     (MD_PAGESE),Y
000A32r 2  E8                   INX
000A33r 2  C8                   INY
000A34r 2  E0 80                CPX     #$80
000A36r 2  D0 F5                BNE     :-
000A38r 2  A9 8C                LDA     #$8C
000A3Ar 2  8D 78 03             STA     MPCL_RAM
000A3Dr 2  EA                   nop
000A3Er 2  EA                   nop
000A3Fr 2  60                   RTS
000A40r 2               md_pagecodeend:
000A40r 2               farcall:
000A40r 2                 .IF USEROM=1
000A40r 2  48                   PHA
000A41r 2  A9 80                LDA     #$80
000A43r 2  8D 7C 03             STA     MPCL_ROM
000A46r 2  EA                   NOP
000A47r 2  EA                   NOP
000A48r 2  A9 8C                LDA     #$8C
000A4Ar 2  8D 78 03             STA     MPCL_RAM
000A4Dr 2  EA                   nop
000A4Er 2  EA                   nop
000A4Fr 2  68                   PLA
000A50r 2  20 00 88             JSR     BANKED_DRIVER_DISPATCHER
000A53r 2  48                   pha
000A54r 2  A9 00                LDA     #$00
000A56r 2  8D 78 03             STA     MPCL_RAM
000A59r 2  EA                   NOP
000A5Ar 2  EA                   NOP
000A5Br 2  8D 7C 03             STA     MPCL_ROM
000A5Er 2  EA                   NOP
000A5Fr 2  EA                   NOP
000A60r 2  68                   pla
000A61r 2  60                   RTS
000A62r 2                  .ELSE
000A62r 2                       PHA
000A62r 2                       LDA     #$8C
000A62r 2                       STA     MPCL_RAM
000A62r 2                       nop
000A62r 2                       nop
000A62r 2                       PLA
000A62r 2                       JSR     BANKED_DRIVER_DISPATCHER
000A62r 2                       pha
000A62r 2                       LDA     #$8E
000A62r 2                       STA     MPCL_RAM
000A62r 2                       pla
000A62r 2                       RTS
000A62r 2                  .ENDIF
000A62r 2               
000A62r 1               
000A62r 1               DO_FARCALL = farcall - md_pagecode + $0500
000A62r 1               
000A62r 1               ;__RELOCATE_DRIVERS______________________________________________________________________________________
000A62r 1               ;
000A62r 1               ; MOVE ROM BIOS HARDWARE DRIVERS FROM ROM PAGE 0D TO RAM PAGE 0C PERFORM CONSOLE WRITE
000A62r 1               ;________________________________________________________________________________________________________
000A62r 1               RELOCATE_DRIVERS:
000A62r 1               
000A62r 1               							; MOVE RELCODE TO LOWRAM
000A62r 1  A2 00        		LDX 	#$00
000A64r 1               :
000A64r 1  BD rr rr             LDA     RELCODE,X
000A67r 1  9D 00 06             STA     $0600,X
000A6Ar 1  E8                   INX
000A6Br 1  E0 00                CPX     #$00
000A6Dr 1  D0 F5                BNE     :-
000A6Fr 1               
000A6Fr 1  4C 00 06     		JMP 	$0600		; RUN IT
000A72r 1               
000A72r 1               RELCODE:
000A72r 1  A9 00        		LDA     #$00
000A74r 1  85 3D        		STA 	TEMPWORD
000A76r 1  A9 88        		LDA     #$88
000A78r 1  85 3E        		STA 	TEMPWORD+1
000A7Ar 1  A0 00        		LDY 	#$00
000A7Cr 1               :
000A7Cr 1  A9 00        		LDA     #$00
000A7Er 1  8D 78 03             STA     MPCL_RAM
000A81r 1  EA           		NOP
000A82r 1  EA           		NOP
000A83r 1  A9 0D        		LDA     #$0D
000A85r 1  8D 7C 03             STA     MPCL_ROM
000A88r 1  EA           		NOP
000A89r 1  EA           		NOP
000A8Ar 1  B1 3D        		LDA 	(TEMPWORD),Y
000A8Cr 1  48           		PHA
000A8Dr 1  A9 80        		LDA     #$80
000A8Fr 1  8D 7C 03             STA     MPCL_ROM
000A92r 1  EA           		NOP
000A93r 1  EA           		NOP
000A94r 1  A9 8C        		LDA     #$8C
000A96r 1  8D 78 03             STA     MPCL_RAM
000A99r 1  68           		PLA
000A9Ar 1  91 3D        		STA 	(TEMPWORD),Y
000A9Cr 1               
000A9Cr 1  E6 3D        		INC 	TEMPWORD
000A9Er 1  A5 3D        		LDA 	TEMPWORD
000AA0r 1  C9 00        		CMP 	#$00
000AA2r 1  D0 D8        		BNE 	:-
000AA4r 1  E6 3E        		INC 	TEMPWORD+1
000AA6r 1  A5 3E        		LDA 	TEMPWORD+1
000AA8r 1  C9 FF        		CMP 	#$FF
000AAAr 1  D0 D0        		BNE 	:-
000AACr 1               
000AACr 1  A9 00        		LDA     #$00
000AAEr 1  8D 78 03             STA     MPCL_RAM
000AB1r 1  EA           		NOP
000AB2r 1  EA           		NOP
000AB3r 1  A9 00        		LDA     #$00
000AB5r 1  8D 7C 03             STA     MPCL_ROM
000AB8r 1               
000AB8r 1  60           		RTS
000AB9r 1               
000AB9r 1               ; START BANNER
000AB9r 1  0D 0A        STARTUP: 	.BYTE   $0D,$0A
000ABBr 1               
000ABBr 1  20 20 4E 68  		.BYTE   "  Nhyodyne",$0D,$0A
000ABFr 1  79 6F 64 79  
000AC3r 1  6E 65 0D 0A  
000AC7r 1  20 20 20 5F  		.BYTE   "   __ _____  _____ ___ ___ ",$0D,$0A
000ACBr 1  5F 20 5F 5F  
000ACFr 1  5F 5F 5F 20  
000AE4r 1  20 20 2F 20     		.BYTE   "  / /| ____|/ ____/ _ \__ \ ",$0D,$0A
000AE8r 1  2F 7C 20 5F  
000AECr 1  5F 5F 5F 7C  
000B02r 1  20 2F 20 2F    		.BYTE   " / /_| |__ | |   | | | | ) | ",$0D,$0A
000B06r 1  5F 7C 20 7C  
000B0Ar 1  5F 5F 20 7C  
000B21r 1  7C 20 27 5F   		.BYTE   "| '_ \___ \| |   | | | |/ / ",$0D,$0A
000B25r 1  20 5C 5F 5F  
000B29r 1  5F 20 5C 7C  
000B3Fr 1  7C 20 28 5F   		.BYTE   "| (_) |__) | |___| |_| / /_ ",$0D,$0A
000B43r 1  29 20 7C 5F  
000B47r 1  5F 29 20 7C  
000B5Dr 1  20 5C 5F 5F    		.BYTE   " \___/____/ \_____\___/____| ",$0D,$0A
000B61r 1  5F 2F 5F 5F  
000B65r 1  5F 5F 2F 20  
000B7Cr 1  2A 20 36 35  		.BYTE   "* 65c02 MONITOR ",$0D,$0A,$00
000B80r 1  63 30 32 20  
000B84r 1  4D 4F 4E 49  
000B8Fr 1               
000B8Fr 1                                .segment "VECTORS"
000000r 1  rr rr        NNTVECTOR:  .WORD   NINTERRUPT		;
000002r 1  rr rr        RSTVECTOR:  .WORD   COLD_START		;
000004r 1  rr rr        INTVECTOR: 	.WORD   INTERRUPT		; ROM VECTOR FOR IRQ
000006r 1               
000006r 1               	.END
