ca65 V2.18 - Ubuntu 2.19-1
Main file   : lowmon.asm
Current file: lowmon.asm

000000r 1               
000000r 1               ;__LOWMON__________________________________________________________________________________________
000000r 1               ; This is a simple monitor program that can loaded into low ram
000000r 1               ; for debugging.
000000r 1               ;
000000r 1               ; It assumes that the 65C02 board is set for IOPage 03.
000000r 1               ; remember that bit A15 is inverted on the board so the dip switch is set to $83.
000000r 1               ;
000000r 1               ;
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;
000000r 1               ; DATA CONSTANTS
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;REGISTER			; FUNCTION
000000r 1               farfunct        = $32           ;function to call in driver area
000000r 1               farpointer      = $33           ;WORD POINTER to call in driver area
000000r 1               IRQVECTOR       = $35           ; VECTOR FOR USER IRQ RTN
000000r 1               NMIVECTOR       = $37           ; VECTOR FOR USER IRQ RTN
000000r 1               STRPTR          = $3B           ;
000000r 1               INBUFFER        = $0200         ;
000000r 1               
000000r 1               IO              = $0300         ; 0300-03FF Memory mapped IO
000000r 1               MPCL_ROM        = $037C         ; ROM MAPPER
000000r 1               MPCL_RAM        = $0378         ; RAM MAPPER
000000r 1               
000000r 1               BANKED_DRIVER_DISPATCHER=$8800  ; LOCATION OF DRIVER DISPATCHER
000000r 1               
000000r 1               
000000r 1               ; UART 16C550 SERIAL -- Assumes IO is in page $03 -- DIP Switch settings $83
000000r 1               UART0           = $0368         ; DATA IN/OUT
000000r 1               UART1           = $0369         ; CHECK RX
000000r 1               UART2           = $036A         ; INTERRUPTS
000000r 1               UART3           = $036B         ; LINE CONTROL
000000r 1               UART4           = $036C         ; MODEM CONTROL
000000r 1               UART5           = $036D         ; LINE STATUS
000000r 1               UART6           = $036E         ; MODEM STATUS
000000r 1               UART7           = $036F         ; SCRATCH REG.
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1                       .ORG    $1000
001000  1               
001000  1               
001000  1  A9 0D                LDA     #<STARTUP       ; OUTPUT STARTUP STRING
001002  1  85 3B                STA     STRPTR          ;
001004  1  A9 1B                LDA     #>STARTUP       ;
001006  1  85 3C                STA     STRPTR+1        ;
001008  1  20 14 10             JSR     OUTSTR          ;
00100B  1               
00100B  1  A9 00                LDA     #$00            ;
00100D  1  8D 00 02             STA     INBUFFER        ; MAKE SURE INPUT BUFFER IS EMPTY
001010  1               ;
001010  1  4C 8A 10             JMP     STRT            ; START THE MONITOR
001013  1               
001013  1               
001013  1               Z80:
001013  1  60                   RTS
001014  1               
001014  1               ;__OUTSTR______________________________________________________
001014  1               ;
001014  1               ; OUTPUT THE STRING POINTED TO BY OUTSTR TO THE SCREEN
001014  1               ;
001014  1               ;______________________________________________________________
001014  1               OUTSTR:
001014  1  A0 00                LDY     #$00            ; LOAD $00 INTO Y
001016  1               OUTSTRLP:
001016  1  B1 3B                LDA     (STRPTR),Y      ; LOAD NEXT CHAR FROM STRING INTO ACC
001018  1  C9 00                CMP     #$00            ; IS NULL?
00101A  1  F0 0C                BEQ     ENDOUTSTR       ; YES, END PRINT OUT
00101C  1  20 FE 1A             JSR     OUTCH           ; PRINT CHAR IN ACC
00101F  1  E6 3B                INC     STRPTR
001021  1  D0 F3                BNE     OUTSTRLP
001023  1  E6 3C                INC     STRPTR+1
001025  1  4C 16 10             JMP     OUTSTRLP        ; DO NEXT CHAR
001028  1               ENDOUTSTR:
001028  1  60                   RTS                     ; RETURN
001029  1               
001029  1               DO_FARCALL:
001029  1  48                   PHA
00102A  1  A9 80                LDA     #$80
00102C  1  8D 7C 03             STA     MPCL_ROM
00102F  1  EA                   NOP
001030  1  EA                   NOP
001031  1  A9 8C                LDA     #$8C
001033  1  8D 78 03             STA     MPCL_RAM
001036  1  EA                   NOP
001037  1  EA                   NOP
001038  1  68                   PLA
001039  1  20 00 88             JSR     BANKED_DRIVER_DISPATCHER
00103C  1  48                   PHA
00103D  1  A9 00                LDA     #$00
00103F  1  8D 78 03             STA     MPCL_RAM
001042  1  EA                   NOP
001043  1  EA                   NOP
001044  1  8D 7C 03             STA     MPCL_ROM
001047  1  EA                   NOP
001048  1  EA                   NOP
001049  1  68                   PLA
00104A  1  60                   RTS
00104B  1               
00104B  1               DO_FARRUN:
00104B  1  A9 80                LDA     #$80
00104D  1  8D 7C 03             STA     MPCL_ROM
001050  1  EA                   NOP
001051  1  EA                   NOP
001052  1  A5 00                LDA     $00
001054  1  8D 78 03             STA     MPCL_RAM
001057  1  EA                   NOP
001058  1  EA                   NOP
001059  1  6C 01 00             JMP     ($0001)
00105C  1               
00105C  1                       .INCLUDE "supermon.asm"
00105C  2               ; ********************************
00105C  2               ; * SUPERMON+ 64 JIM BUTTERFIELD *
00105C  2               ; * V1.2   AUGUST 20 1985        *
00105C  2               ; ********************************
00105C  2               
00105C  2               ; Reformatted and annotated in late 2016/early 2017 by J.B. Langston.
00105C  2               ; Modified for Nhyodyne 3/12/2023 D. Werner
00105C  2               ;
00105C  2               ; Mr. Butterfield . . you inspired many of us, thank you.
00105C  2               ;
00105C  2               ; -----------------------------------------------------------------------------
00105C  2               ; temporary pointers
00105C  2               TMP0            = $C1           ; used to return input, often holds end address
00105C  2               TMP2            = $C3           ; usually holds start address
00105C  2               
00105C  2               ; these 7 locations are used to store the registers when
00105C  2               ; entering the monitor and restore them when exiting.
00105C  2               
00105C  2               PCH             = $B0           ; program counter high byte
00105C  2               PCL             = $B1           ; program counter low byte
00105C  2               SR              = $B2           ; status register
00105C  2               ACC             = $B3           ; accumulator
00105C  2               XR              = $B4           ; X register
00105C  2               YR              = $B5           ; Y register
00105C  2               SP              = $B6           ; stack pointer
00105C  2               STORE           = $B7           ; 2-byte temp storage
00105C  2               CHRPNT          = $B9           ; current position in input buffer
00105C  2               SAVY            = $BA           ; temp storage, often to save Y register
00105C  2               U9F             = $BB           ; index into assembler work buffer
00105C  2               CKSM            = $BC           ; S19 loader checksum store
00105C  2               LOADADR         = $BD           ; S19 load address
00105C  2               LOADWRK         = $BF           ; S19 load work
00105C  2               
00105C  2               ;-----------------------------------------------------------------------------
00105C  2               ; variables
00105C  2               ACMD            = $C5           ; addressing command
00105C  2               LENGTH          = $C6           ; length of operand
00105C  2               MNEMW           = $C7           ; 3 letter mnemonic buffer
00105C  2               SAVX            = $CA           ; 1 byte temp storage, often to save X register
00105C  2               OPCODE          = $CB           ; current opcode for assembler/disassembler
00105C  2               UPFLG           = $CC           ; flag: count up (bit 7 clear) or down (bit 7 set)
00105C  2               DIGCNT          = $CB           ; digit count
00105C  2               INDIG           = $CC           ; numeric value of single digit
00105C  2               NUMBIT          = $CD           ; numeric base of input
00105C  2               STASH           = $CE           ; 2-byte temp storage
00105C  2               U0AA0           = $D0           ; 10 byte work buffer
00105C  2               U0AAE           = $D0+10        ; end of 10 byte work buffer
00105C  2               STAGE           = $DA           ; 30 byte staging buffer for filename, search, etc.
00105C  2               ESTAGE          = $DA+30        ; end of 30 byte staging buffer for filename, search, etc.
00105C  2               INBUFF          = $0200
00105C  2               CHROUT          = OUTCH
00105C  2               
00105C  2               
00105C  2               ; -----------------------------------------------------------------------------
00105C  2               ; BRK handler
00105C  2               BRKROUTINE:
00105C  2               BREAK:
00105C  2  A2 05                LDX     #$05            ; pull registers off the stack
00105E  2               BSTACK:
00105E  2  68                   PLA                     ; order: Y,X,A,SR,PCL,PCH
00105F  2  95 B0                STA     PCH,X           ; store in memory
001061  2  CA                   DEX
001062  2  10 FA                BPL     BSTACK
001064  2  D8                   CLD                     ; disable bcd mode
001065  2  BA                   TSX                     ; store stack pointer in memory
001066  2  86 B6                STX     SP
001068  2  58                   CLI                     ; enable interupts
001069  2               
001069  2               ; -----------------------------------------------------------------------------
001069  2               ; display registers [R]
001069  2               DSPLYR:
001069  2  A0 00                LDY     #MSG2-MSGBAS    ; display headers
00106B  2  20 C9 18             JSR     SNDCLR
00106E  2  A9 3B                LDA     #$3B            ; prefix registers with "; " to allow editing
001070  2  20 FE 1A             JSR     CHROUT
001073  2  A9 20                LDA     #$20
001075  2  20 FE 1A             JSR     CHROUT
001078  2  A5 B0                LDA     PCH             ; print 2-byte program counter
00107A  2  20 63 17             JSR     WRTWO
00107D  2  A0 01                LDY     #1              ; start 1 byte after PC high byte
00107F  2               DISJ:
00107F  2  B9 B0 00             LDA     PCH,Y           ; loop through rest of the registers
001082  2  20 3F 17             JSR     WRBYTE          ; print 1-byte register value
001085  2  C8                   INY
001086  2  C0 07                CPY     #7              ; there are a total of 5 registers to print
001088  2  90 F5                BCC     DISJ
00108A  2               
00108A  2               ; -----------------------------------------------------------------------------
00108A  2               ; main loop
00108A  2               STRT:
00108A  2  20 4A 17             JSR     CRLF            ; new line
00108D  2  A2 00                LDX     #0              ; point at start of input buffer
00108F  2  86 B9                STX     CHRPNT
001091  2               SMOVE:
001091  2  20 E3 1A             JSR     IOF_CONINW      ; CHRIN kernal call to input a character
001094  2               
001094  2  C9 08                CMP     #$08            ; IS BACKSPACE?
001096  2  D0 1A                BNE     :+              ; NO, SKUP BACKSPACE RTN
001098  2  E0 00                CPX     #$00            ; IS INDEX =0 ?
00109A  2  F0 F5                BEQ     SMOVE           ; YES, SKIP BACKSPACE
00109C  2  20 FE 1A             JSR     OUTCH           ; BACK UP CURSOR
00109F  2  A9 20                LDA     #$20
0010A1  2  20 FE 1A             JSR     OUTCH           ; SPACE ON SCREEN
0010A4  2  A9 08                LDA     #$08
0010A6  2  20 FE 1A             JSR     OUTCH           ; BACK UP CURSOR
0010A9  2               
0010A9  2  A9 00                LDA     #0
0010AB  2  9D 00 02             STA     INBUFF,X        ; store in input buffer
0010AE  2  CA                   DEX
0010AF  2  4C 91 10             JMP     SMOVE
0010B2  2               :
0010B2  2  20 FE 1A             JSR     OUTCH           ; OUTPUT CHAR TO SCREEN
0010B5  2               
0010B5  2  9D 00 02             STA     INBUFF,X        ; store in input buffer
0010B8  2  E8                   INX
0010B9  2  E0 00                CPX     #00             ; error if buffer is full
0010BB  2  F0 1C                BEQ     ERROR
0010BD  2  C9 0D                CMP     #$0D            ; keep reading until CR
0010BF  2  D0 D0                BNE     SMOVE
0010C1  2  A9 00                LDA     #0              ; null-terminate input buffer
0010C3  2  9D FF 01             STA     INBUFF-1,X      ; (replacing the CR)
0010C6  2               ST1:
0010C6  2  20 88 17             JSR     GETCHR          ; get a character from the buffer
0010C9  2  F0 BF                BEQ     STRT            ; start over if buffer is empty
0010CB  2  C9 20                CMP     #$20            ; skip leading spaces
0010CD  2  F0 F7                BEQ     ST1
0010CF  2               S0:
0010CF  2  A2 15                LDX     #KEYTOP-KEYW    ; loop through valid command characters
0010D1  2               S1:
0010D1  2  DD 8C 1A             CMP     KEYW,X          ; see if input character matches
0010D4  2  F0 0B                BEQ     S2              ; command matched, dispatch it
0010D6  2  CA                   DEX                     ; no match, check next command
0010D7  2  10 F8                BPL     S1              ; keep trying until we've checked them all
0010D9  2                                               ; then fall through to error handler
0010D9  2               
0010D9  2               ; -----------------------------------------------------------------------------
0010D9  2               ; handle error
0010D9  2               ERROR:
0010D9  2  A0 1E                LDY     #MSG3-MSGBAS    ; display "?" to indicate error and go to new line
0010DB  2  20 DC 18             JSR     SNDMSG
0010DE  2  4C 8A 10             JMP     STRT            ; back to main loop
0010E1  2               
0010E1  2               ; -----------------------------------------------------------------------------
0010E1  2               ; dispatch command
0010E1  2               S2:
0010E1  2  E0 10                CPX     #$10            ; next 4 commands are base conversions
0010E3  2  B0 0E                BCS     CNVLNK          ;   which are handled by the same subroutine
0010E5  2  8A                   TXA                     ; remaining commands dispatch through vector table
0010E6  2  0A                   ASL     A               ; multiply index of command by 2
0010E7  2  AA                   TAX                     ;   since table contains 2-byte addresses
0010E8  2  BD A2 1A             LDA     KADDR+1,X       ; push address from vector table onto stack
0010EB  2  48                   PHA                     ;   so that the RTS from GETPAR will jump there
0010EC  2  BD A1 1A             LDA     KADDR,X
0010EF  2  48                   PHA
0010F0  2  4C 7E 16             JMP     GETPAR          ; get the first parameter for the command
0010F3  2               CNVLNK:
0010F3  2  4C 1D 18             JMP     CONVRT          ; handle base conversion
0010F6  2               
0010F6  2               
0010F6  2               ; -----------------------------------------------------------------------------
0010F6  2               ; display memory [M]
0010F6  2               DSPLYM:
0010F6  2  B0 08                BCS     DSPM11          ; start from previous end addr if no address given
0010F8  2  20 9E 17             JSR     COPY12          ; save start address in TMP2
0010FB  2  20 7E 16             JSR     GETPAR          ; get end address in TMP0
0010FE  2  90 06                BCC     DSMNEW          ; did user specify one?
001100  2               DSPM11:
001100  2  A9 0B                LDA     #$0B            ; if not, show 12 lines by default
001102  2  85 C1                STA     TMP0
001104  2  D0 0E                BNE     DSPBYT          ; always true, but BNE uses 1 byte less than JMP
001106  2               DSMNEW:
001106  2  20 A7 17             JSR     SUB12           ; end addr given, calc bytes between start and end
001109  2  90 1E                BCC     MERROR          ; error if start is after end
00110B  2  A2 03                LDX     #3              ; divide by 8 (shift right 3 times)
00110D  2               DSPM01:
00110D  2  46 C2                LSR     TMP0+1
00110F  2  66 C1                ROR     TMP0
001111  2  CA                   DEX
001112  2  D0 F9                BNE     DSPM01
001114  2               DSPBYT:
001114  2  20 EA 18             JSR     STOP            ; check for stop key
001117  2  F0 0D                BEQ     DSPMX           ; exit early if pressed
001119  2  20 8D 11             JSR     DISPMEM         ; display 1 line containing 8 bytes
00111C  2  A9 08                LDA     #8              ; increase start address by 8 bytes
00111E  2  20 D7 17             JSR     BUMPAD2
001121  2  20 B5 17             JSR     SUBA1           ; decrement line counter
001124  2  B0 EE                BCS     DSPBYT          ; show another line until it's < 0
001126  2               DSPMX:
001126  2  4C 8A 10             JMP     STRT            ; back to main loop
001129  2               MERROR:
001129  2  4C D9 10             JMP     ERROR           ; handle error
00112C  2               
00112C  2               ; -----------------------------------------------------------------------------
00112C  2               ; alter registers [;]
00112C  2               ALTR:
00112C  2  20 EF 17             JSR     COPY1P          ; store first parameter in PC
00112F  2  A0 00                LDY     #0              ; init counter
001131  2               ALTR1:
001131  2  20 7E 16             JSR     GETPAR          ; get value for next register
001134  2  B0 0A                BCS     ALTRX           ; exit early if no more values given
001136  2  A5 C1                LDA     TMP0            ; store in memory, offset from SR
001138  2  99 B2 00             STA     SR,Y            ; these locations will be transferred to the
00113B  2  C8                   INY                     ;   actual registers before exiting the monitor
00113C  2  C0 05                CPY     #$05            ; have we updated all 5 yet?
00113E  2  90 F1                BCC     ALTR1           ; if not, get next
001140  2               ALTRX:
001140  2  4C 8A 10             JMP     STRT            ; back to main loop
001143  2               
001143  2               ; -----------------------------------------------------------------------------
001143  2               ; alter memory [>]
001143  2               ALTM:
001143  2  B0 13                BCS     ALTMX           ; exit if no parameter provided
001145  2  20 9E 17             JSR     COPY12          ; copy parameter to start address
001148  2  A0 00                LDY     #0
00114A  2               ALTM1:
00114A  2  20 7E 16             JSR     GETPAR          ; get value for next byte of memory
00114D  2  B0 09                BCS     ALTMX           ; if none given, exit early
00114F  2  A5 C1                LDA     TMP0            ; poke value into memory at start address + Y
001151  2  91 C3                STA     (TMP2),Y
001153  2  C8                   INY                     ; next byte
001154  2  C0 08                CPY     #8              ; have we read 8 bytes yet?
001156  2  90 F2                BCC     ALTM1           ; if not, read the next one
001158  2               ALTMX:
001158  2  A9 91                LDA     #$91            ; move cursor up
00115A  2  20 FE 1A             JSR     CHROUT
00115D  2  20 8D 11             JSR     DISPMEM         ; re-display line to make ascii match hex
001160  2  4C 8A 10             JMP     STRT            ; back to main loop
001163  2               
001163  2               ; -----------------------------------------------------------------------------
001163  2               ; goto (run) [G]
001163  2               GOTO:
001163  2  A6 B6                LDX     SP              ; load stack pointer from memory
001165  2  9A                   TXS                     ; save in SP register
001166  2               GOTO2:
001166  2  20 EF 17             JSR     COPY1P          ; copy provided address to PC
001169  2  78                   SEI                     ; disable interrupts
00116A  2  A5 B0                LDA     PCH             ; push PC high byte on stack
00116C  2  48                   PHA
00116D  2  A5 B1                LDA     PCL             ; push PC low byte on stack
00116F  2  48                   PHA
001170  2  A5 B2                LDA     SR              ; push status byte on stack
001172  2  48                   PHA
001173  2  A5 B3                LDA     ACC             ; load accumulator from memory
001175  2  A6 B4                LDX     XR              ; load X from memory
001177  2  A4 B5                LDY     YR              ; load Y from memory
001179  2  40                   RTI                     ; return from interrupt (pops PC and SR)
00117A  2               
00117A  2               ; jump to subroutine [J]
00117A  2               JSUB:
00117A  2  A6 B6                LDX     SP              ; load stack pointer from memory
00117C  2  9A                   TXS                     ; save value in SP register
00117D  2  20 66 11             JSR     GOTO2           ; same as goto command
001180  2  84 B5                STY     YR              ; save Y to memory
001182  2  86 B4                STX     XR              ; save X to memory
001184  2  85 B3                STA     ACC             ; save accumulator to memory
001186  2  08                   PHP                     ; push processor status on stack
001187  2  68                   PLA                     ; pull processor status into A
001188  2  85 B2                STA     SR              ; save processor status to memory
00118A  2  4C 69 10             JMP     DSPLYR          ; display registers
00118D  2               
00118D  2               ; -----------------------------------------------------------------------------
00118D  2               ; display 8 bytes of memory
00118D  2               DISPMEM:
00118D  2  20 4A 17             JSR     CRLF            ; new line
001190  2  A9 3E                LDA     #'>'            ; prefix > so memory can be edited in place
001192  2  20 FE 1A             JSR     CHROUT
001195  2  20 35 17             JSR     SHOWAD          ; show address of first byte on line
001198  2  A0 00                LDY     #0
00119A  2  F0 03                BEQ     DMEMGO          ; SHOWAD already printed a space after the address
00119C  2               DMEMLP:
00119C  2  20 42 17             JSR     SPACE           ; print space between bytes
00119F  2               DMEMGO:
00119F  2  B1 C3                LDA     (TMP2),Y        ; load byte from start address + Y
0011A1  2  20 63 17             JSR     WRTWO           ; output hex digits for byte
0011A4  2  C8                   INY                     ; next byte
0011A5  2  C0 08                CPY     #8              ; have we output 8 bytes yet?
0011A7  2  90 F3                BCC     DMEMLP          ; if not, output next byte
0011A9  2  A0 26                LDY     #MSG5-MSGBAS    ; if so, output : and turn on reverse video
0011AB  2  20 DC 18             JSR     SNDMSG          ;   before displaying ascii representation
0011AE  2  A0 00                LDY     #0              ; back to first byte in line
0011B0  2               DCHAR:
0011B0  2  B1 C3                LDA     (TMP2),Y        ; load byte at start address + Y
0011B2  2  AA                   TAX                     ; stash in X
0011B3  2  29 BF                AND     #$BF            ; clear 6th bit
0011B5  2  C9 22                CMP     #$22            ; is it a quote (")?
0011B7  2  F0 08                BEQ     DDOT            ; if so, print . instead
0011B9  2  8A                   TXA                     ; if not, restore character
0011BA  2  29 7F                AND     #$7F            ; clear top bit
0011BC  2  C9 20                CMP     #$20            ; is it a printable character (>= $20)?
0011BE  2  8A                   TXA                     ; restore character
0011BF  2  B0 02                BCS     DCHROK          ; if printable, output character
0011C1  2               DDOT:
0011C1  2  A9 2E                LDA     #$2E            ; if not, output '.' instaed
0011C3  2               DCHROK:
0011C3  2  20 FE 1A             JSR     CHROUT
0011C6  2  C8                   INY                     ; next byte
0011C7  2  C0 08                CPY     #8              ; have we output 8 bytes yet?
0011C9  2  90 E5                BCC     DCHAR           ; if not, output next byte
0011CB  2  60                   RTS
0011CC  2               
0011CC  2               ; -----------------------------------------------------------------------------
0011CC  2               ; compare memory [C]
0011CC  2               COMPAR:
0011CC  2  A9 00                LDA     #0              ; bit 7 clear signals compare
0011CE  2  2C                   .BYTE   $2C             ; absolute BIT opcode consumes next word (LDA #$80)
0011CF  2               
0011CF  2               ; transfer memory [T]
0011CF  2               TRANS:
0011CF  2  A9 80                LDA     #$80            ; bit 7 set signals transfer
0011D1  2  85 BA                STA     SAVY            ; save compare/transfer flag in SAVY
0011D3  2  A9 00                LDA     #0              ; assume we're counting up (bit 7 clear)
0011D5  2  85 CC                STA     UPFLG           ; save direction flag
0011D7  2  20 FA 17             JSR     GETDIF          ; get two addresses and calculate difference
0011DA  2                                               ;   TMP2 = source start
0011DA  2                                               ;   STASH = source end
0011DA  2                                               ;   STORE = length
0011DA  2  B0 05                BCS     TERROR          ; carry set indicates error
0011DC  2  20 7E 16             JSR     GETPAR          ; get destination address in TMP0
0011DF  2  90 03                BCC     TOKAY           ; carry set indicates error
0011E1  2               TERROR:
0011E1  2  4C D9 10             JMP     ERROR           ; handle error
0011E4  2               TOKAY:
0011E4  2  24 BA                BIT     SAVY            ; transfer or compare?
0011E6  2  10 23                BPL     COMPAR1         ; high bit clear indicates compare
0011E8  2  A5 C3                LDA     TMP2            ; if it's a transfer, we must take steps
0011EA  2  C5 C1                CMP     TMP0            ;   to avoid overwriting the source bytes before
0011EC  2  A5 C4                LDA     TMP2+1          ;   they have been transferred
0011EE  2  E5 C2                SBC     TMP0+1          ; compare source (TMP2) to destination (TMP0)
0011F0  2  B0 19                BCS     COMPAR1         ; and count up if source is before than desitnation
0011F2  2  A5 B7                LDA     STORE           ; otherwise, start at end and count down...
0011F4  2  65 C1                ADC     TMP0            ; add length (STORE) to desintation (TMP0)
0011F6  2  85 C1                STA     TMP0            ; to calculate end of destination
0011F8  2  A5 B8                LDA     STORE+1
0011FA  2  65 C2                ADC     TMP0+1
0011FC  2  85 C2                STA     TMP0+1
0011FE  2  A2 01                LDX     #1              ; change source pointer from beginning to end
001200  2               TDOWN:
001200  2  B5 CE                LDA     STASH,X         ; TMP2 = source end (STASH)
001202  2  95 C3                STA     TMP2,X
001204  2  CA                   DEX
001205  2  10 F9                BPL     TDOWN
001207  2  A9 80                LDA     #$80            ; high bit set in UPFLG means count down
001209  2  85 CC                STA     UPFLG
00120B  2               COMPAR1:
00120B  2  20 4A 17             JSR     CRLF            ; new line
00120E  2  A0 00                LDY     #0              ; no offset from pointer
001210  2               TCLOOP:
001210  2  20 EA 18             JSR     STOP            ; check for stop key
001213  2  F0 2F                BEQ     TEXIT           ; exit if pressed
001215  2  B1 C3                LDA     (TMP2),Y        ; load byte from source
001217  2  24 BA                BIT     SAVY            ; transfer or compare?
001219  2  10 02                BPL     COMPAR2         ; skip store if comparing
00121B  2  91 C1                STA     (TMP0),Y        ; otherwise, store in destination
00121D  2               COMPAR2:
00121D  2  D1 C1                CMP     (TMP0),Y        ; compare to destination
00121F  2  F0 03                BEQ     TMVAD           ; don't show address if equal
001221  2  20 35 17             JSR     SHOWAD          ; show address
001224  2               TMVAD:
001224  2  24 CC                BIT     UPFLG           ; counting up or down?
001226  2  30 0B                BMI     TDECAD          ; high bit set means we're counting down
001228  2  E6 C1                INC     TMP0            ; increment destination low byte
00122A  2  D0 10                BNE     TINCOK
00122C  2  E6 C2                INC     TMP0+1          ; carry to high byte if necessary
00122E  2  D0 0C                BNE     TINCOK
001230  2  4C D9 10             JMP     ERROR           ; error if high byte overflowed
001233  2               TDECAD:
001233  2  20 B5 17             JSR     SUBA1           ; decrement destination (TMP0)
001236  2  20 E1 17             JSR     SUB21           ; decrement source (TMP2)
001239  2  4C 3F 12             JMP     TMOR
00123C  2               TINCOK:
00123C  2  20 D5 17             JSR     ADDA2           ; increment source (TMP2)
00123F  2               TMOR:
00123F  2  20 C7 17             JSR     SUB13           ; decrement length
001242  2  B0 CC                BCS     TCLOOP          ; loop until length is 0
001244  2               TEXIT:
001244  2  4C 8A 10             JMP     STRT            ; back to main loop
001247  2               
001247  2               ; -----------------------------------------------------------------------------
001247  2               ; hunt memory [H]
001247  2               HUNT:
001247  2  20 FA 17             JSR     GETDIF          ; get start (TMP2) and end (TMP0) of haystack
00124A  2  B0 57                BCS     HERROR          ; carry indicates error
00124C  2  A0 00                LDY     #0
00124E  2  20 88 17             JSR     GETCHR          ; get a single character
001251  2  C9 27                CMP     #39             ; is it a single quote?
001253  2  D0 16                BNE     NOSTRH          ; if not, input needle as hex bytes
001255  2  20 88 17             JSR     GETCHR          ; if so, input needle as string
001258  2  C9 00                CMP     #0
00125A  2  F0 47                BEQ     HERROR          ; error if needle isn't at least one byte
00125C  2               HPAR:
00125C  2  99 DA 00             STA     STAGE,Y         ; save char in staging area
00125F  2  C8                   INY
001260  2  20 88 17             JSR     GETCHR          ; get another char
001263  2  F0 18                BEQ     HTGO            ; if it's null start searching
001265  2  C0 1E                CPY     #ESTAGE-STAGE   ; have we filled up the needle staging area?
001267  2  D0 F3                BNE     HPAR            ; if not, get another character
001269  2  F0 12                BEQ     HTGO            ; if so, start searching
00126B  2               NOSTRH:
00126B  2  20 7C 16             JSR     RDPAR           ; read hex bytes if string not indicated
00126E  2               HLP:
00126E  2  A5 C1                LDA     TMP0            ; save last read byte in staging area
001270  2  99 DA 00             STA     STAGE,Y
001273  2  C8                   INY                     ; get another hex byte
001274  2  20 7E 16             JSR     GETPAR
001277  2  B0 04                BCS     HTGO            ; if there is none, start searching
001279  2  C0 1E                CPY     #ESTAGE-STAGE   ; have we filled up the needle staging area?
00127B  2  D0 F1                BNE     HLP             ; if not, get another byte
00127D  2               HTGO:
00127D  2  84 BA                STY     SAVY            ; save length of needle
00127F  2  20 4A 17             JSR     CRLF            ; new line
001282  2               HSCAN:
001282  2  A0 00                LDY     #0
001284  2               HLP3:
001284  2  B1 C3                LDA     (TMP2),Y        ; get first byte in haystack
001286  2  D9 DA 00             CMP     STAGE,Y         ; compare it to first byte of needle
001289  2  D0 08                BNE     HNOFT           ; if it doesn't match, we haven't found anything
00128B  2  C8                   INY                     ; if it does, check the next byte
00128C  2  C4 BA                CPY     SAVY            ; have we reached the end of the needle?
00128E  2  D0 F4                BNE     HLP3            ; if not, keep comparing bytes
001290  2  20 35 17             JSR     SHOWAD          ; match found, show address
001293  2               HNOFT:
001293  2  20 EA 18             JSR     STOP            ; no match, check for stop key
001296  2  F0 08                BEQ     HEXIT           ; exit prematurely if pressed
001298  2  20 D5 17             JSR     ADDA2           ; increment haystack pointer
00129B  2  20 C7 17             JSR     SUB13           ; decrement haystack length
00129E  2  B0 E2                BCS     HSCAN           ; still more haystack? keep searching
0012A0  2               HEXIT:
0012A0  2  4C 8A 10             JMP     STRT            ; back to main loop
0012A3  2               HERROR:
0012A3  2  4C D9 10             JMP     ERROR           ; handle error
0012A6  2               
0012A6  2               
0012A6  2               ; -----------------------------------------------------------------------------
0012A6  2               ; fill memory [F]
0012A6  2               FILL:
0012A6  2  20 FA 17             JSR     GETDIF          ; start in TMP2, end in STASH, length in STORE
0012A9  2  B0 20                BCS     FERROR          ; carry set indicates error
0012AB  2  20 7E 16             JSR     GETPAR          ; get value to fill in TMP0
0012AE  2  B0 1B                BCS     FERROR          ; carry set indicates error
0012B0  2  20 88 17             JSR     GETCHR          ; any more characters triggers an error
0012B3  2  D0 16                BNE     FERROR
0012B5  2  A0 00                LDY     #0              ; no offset
0012B7  2               FILLP:
0012B7  2  A5 C1                LDA     TMP0            ; load value to fill in accumulator
0012B9  2  91 C3                STA     (TMP2),Y        ; store fill value in current address
0012BB  2  20 EA 18             JSR     STOP            ; check for stop key
0012BE  2  F0 08                BEQ     FSTART          ; if pressed, back to main loop
0012C0  2  20 D5 17             JSR     ADDA2           ; increment address
0012C3  2  20 C7 17             JSR     SUB13           ; decrement length
0012C6  2  B0 EF                BCS     FILLP           ; keep going until length reaches 0
0012C8  2               FSTART:
0012C8  2  4C 8A 10             JMP     STRT            ; back to main loop
0012CB  2               FERROR:
0012CB  2  4C D9 10             JMP     ERROR           ; handle error
0012CE  2               ; -----------------------------------------------------------------------------
0012CE  2               ; Boot System [B]
0012CE  2               BOOT:
0012CE  2  B0 6C                BCS     BOOTX           ; exit with error if no parameter given
0012D0  2  A5 C1                LDA     TMP0
0012D2  2  29 0F                AND     #$0F
0012D4  2  8D 00 18             STA     $1800
0012D7  2  A9 8E                LDA     #$8E
0012D9  2  8D 01 18             STA     $1801
0012DC  2  A9 00                LDA     #$00
0012DE  2  8D 02 18             STA     $1802
0012E1  2  A9 D0                LDA     #$D0
0012E3  2  8D 03 18             STA     $1803
0012E6  2  A9 17                LDA     #$17
0012E8  2  8D 04 18             STA     $1804
0012EB  2  A5 C1                LDA     TMP0
0012ED  2  29 F0                AND     #$F0            ; filter out unit
0012EF  2  C9 00                CMP     #$00            ; is IDE?
0012F1  2  F0 07                BEQ     BOOT_IDE
0012F3  2  C9 10                CMP     #$10            ; is Floppy?
0012F5  2  F0 24                BEQ     BOOT_FLOPPY
0012F7  2  4C 3C 13             JMP     BOOTX
0012FA  2               BOOT_IDE:
0012FA  2  A9 04                LDA     #04             ;PPIDE_INIT
0012FC  2  85 32                STA     farfunct
0012FE  2  20 29 10             JSR     DO_FARCALL
001301  2  A9 1D                LDA     #29
001303  2  85 32                STA     farfunct
001305  2  A0 18                LDY     #$18
001307  2  A9 00                LDA     #00
001309  2  20 29 10             JSR     DO_FARCALL
00130C  2  A9 8E                LDA     #$8E
00130E  2  85 00                STA     $00
001310  2  A9 00                LDA     #$00
001312  2  85 01                STA     $01
001314  2  A9 D0                LDA     #$D0
001316  2  85 02                STA     $02
001318  2  4C 4B 10             JMP     DO_FARRUN
00131B  2               BOOT_FLOPPY:
00131B  2  A9 19                LDA     #25             ;FD_INIT
00131D  2  85 32                STA     farfunct
00131F  2  20 29 10             JSR     DO_FARCALL
001322  2  A9 20                LDA     #32
001324  2  85 32                STA     farfunct
001326  2  A0 18                LDY     #$18
001328  2  A9 00                LDA     #00
00132A  2  20 29 10             JSR     DO_FARCALL
00132D  2  A9 8E                LDA     #$8E
00132F  2  85 00                STA     $00
001331  2  A9 00                LDA     #$00
001333  2  85 01                STA     $01
001335  2  A9 D0                LDA     #$D0
001337  2  85 02                STA     $02
001339  2  4C 4B 10             JMP     DO_FARRUN
00133C  2               BOOTX:
00133C  2  4C D9 10             JMP     ERROR           ; back to main loop
00133F  2               
00133F  2               ; -----------------------------------------------------------------------------
00133F  2               ; Write OS [W]
00133F  2               WRITEOS:
00133F  2  B0 54                BCS     WRITEOSX        ; exit with error if no parameter given
001341  2  A5 C1                LDA     TMP0
001343  2  29 0F                AND     #$0F
001345  2  8D 00 08             STA     $0800
001348  2  A9 8E                LDA     #$8E
00134A  2  8D 01 08             STA     $0801
00134D  2  A9 00                LDA     #$00
00134F  2  8D 02 08             STA     $0802
001352  2  A9 D0                LDA     #$D0
001354  2  8D 03 08             STA     $0803
001357  2  A9 17                LDA     #$17
001359  2  8D 04 08             STA     $0804
00135C  2  A5 C1                LDA     TMP0
00135E  2  29 F0                AND     #$F0            ; filter out unit
001360  2  C9 00                CMP     #$00            ; is IDE?
001362  2  F0 07                BEQ     WRITEOS_IDE
001364  2  C9 10                CMP     #$10            ; is Floppy?
001366  2  F0 18                BEQ     WRITEOS_FLOPPY
001368  2  4C 95 13             JMP     WRITEOSX
00136B  2               WRITEOS_IDE:
00136B  2  A9 04                LDA     #04             ;PPIDE_INIT
00136D  2  85 32                STA     farfunct
00136F  2  20 29 10             JSR     DO_FARCALL
001372  2  A9 1C                LDA     #28
001374  2  85 32                STA     farfunct
001376  2  A0 08                LDY     #08
001378  2  A9 00                LDA     #00
00137A  2  20 29 10             JSR     DO_FARCALL
00137D  2  4C 8A 10             JMP     STRT
001380  2               WRITEOS_FLOPPY:
001380  2  A9 19                LDA     #25             ;FD_INIT
001382  2  85 32                STA     farfunct
001384  2  20 29 10             JSR     DO_FARCALL
001387  2  A9 1F                LDA     #31
001389  2  85 32                STA     farfunct
00138B  2  A0 08                LDY     #08
00138D  2  A9 00                LDA     #00
00138F  2  20 29 10             JSR     DO_FARCALL
001392  2  4C 8A 10             JMP     STRT
001395  2               WRITEOSX:
001395  2  4C D9 10             JMP     ERROR           ; back to main loop
001398  2               
001398  2               ; -----------------------------------------------------------------------------
001398  2               ; CLEAR DIRECTORY SECTORS [Z]
001398  2               CLRDIR:
001398  2  B0 2F                BCS     CLRDIRX         ; abort if no device specified
00139A  2  A5 C1                LDA     TMP0
00139C  2  8D 00 08             STA     $0800           ; save specified disk unit here
00139F  2  20 7E 16             JSR     GETPAR          ; get start track
0013A2  2  B0 25                BCS     CLRDIRX         ; abort if not specified
0013A4  2  20 9E 17             JSR     COPY12          ; save start track in TMP2
0013A7  2  20 7E 16             JSR     GETPAR          ; get number of tracks in TMP0
0013AA  2  B0 1D                BCS     CLRDIRX         ; abort if not specified
0013AC  2  A5 C3                LDA     TMP2
0013AE  2  8D 01 08             STA     $0801
0013B1  2  A5 C4                LDA     TMP2+1
0013B3  2  8D 02 08             STA     $0802
0013B6  2  A5 C1                LDA     TMP0
0013B8  2  8D 03 08             STA     $0803
0013BB  2  A9 1E                LDA     #30
0013BD  2  85 32                STA     farfunct
0013BF  2  A0 08                LDY     #08
0013C1  2  A9 00                LDA     #00
0013C3  2  20 29 10             JSR     DO_FARCALL
0013C6  2  4C 8A 10             JMP     STRT            ; back to main loop
0013C9  2               CLRDIRX:
0013C9  2  4C D9 10             JMP     ERROR           ; back to main loop
0013CC  2               
0013CC  2               ; -----------------------------------------------------------------------------
0013CC  2               ; assemble [A.]
0013CC  2               ; read in mnemonic
0013CC  2               ASTART:
0013CC  2  4C 8A 10             JMP     STRT            ; back to main loop
0013CF  2               ASSEM:
0013CF  2  B0 31                BCS     AERROR          ; error if no address given
0013D1  2  20 9E 17             JSR     COPY12          ; copy address to TMP2
0013D4  2               AGET1:
0013D4  2  A2 00                LDX     #0
0013D6  2  86 D1                STX     U0AA0+1         ; clear byte that mnemonic gets shifted into
0013D8  2  86 CB                STX     DIGCNT          ; clear digit count
0013DA  2               AGET2:
0013DA  2  20 88 17             JSR     GETCHR          ; get a char
0013DD  2  D0 04                BNE     ALMOR           ; proceed if the character isn't null
0013DF  2  E0 00                CPX     #0              ; it's null, have read a mnemonic yet?
0013E1  2  F0 E9                BEQ     ASTART          ; if not, silently go back to main loop
0013E3  2               ALMOR:
0013E3  2  C9 20                CMP     #$20            ; skip leading spaces
0013E5  2  F0 ED                BEQ     AGET1
0013E7  2  95 C7                STA     MNEMW,X         ; put character in mnemonic buffer
0013E9  2  E8                   INX
0013EA  2  E0 03                CPX     #3              ; have we read 3 characters yet?
0013EC  2  D0 EC                BNE     AGET2           ; if not, get next character
0013EE  2               
0013EE  2               ; compress mnemonic into two bytes
0013EE  2               ASQEEZ:
0013EE  2  CA                   DEX                     ; move to previous char
0013EF  2  30 14                BMI     AOPRND          ; if we're done with mnemonic, look for operand
0013F1  2  B5 C7                LDA     MNEMW,X         ; get current character
0013F3  2  38                   SEC                     ; pack 3-letter mnemonic into 2 bytes (15 bits)
0013F4  2  E9 3F                SBC     #$3F            ; subtract $3F from ascii code so A-Z = 2 to 27
0013F6  2  A0 05                LDY     #$05            ; letters now fit in 5 bits; shift them out
0013F8  2               ASHIFT:
0013F8  2  4A                   LSR     A               ;   into the first two bytes of the inst buffer
0013F9  2  66 D1                ROR     U0AA0+1         ; catch the low bit from accumulator in right byte
0013FB  2  66 D0                ROR     U0AA0           ; catch the low bit from right byte in left byte
0013FD  2  88                   DEY                     ; count down bits
0013FE  2  D0 F8                BNE     ASHIFT          ; keep looping until we reach zero
001400  2  F0 EC                BEQ     ASQEEZ          ; unconditional branch to handle next char
001402  2               AERROR:
001402  2  4C D9 10             JMP     ERROR           ; handle error
001405  2               
001405  2               ; parse operand
001405  2               AOPRND:
001405  2  A2 02                LDX     #2              ; mnemonic is in first two bytes so start at third
001407  2               ASCAN:
001407  2  A5 CB                LDA     DIGCNT          ; did we find address digits last time?
001409  2  D0 28                BNE     AFORM1          ; if so, look for mode chars
00140B  2  20 A3 16             JSR     RDVAL           ; otherwise, look for an address
00140E  2  F0 21                BEQ     AFORM0          ; we didn't find an address, look for characters
001410  2  B0 F0                BCS     AERROR          ; carry flag indicates error
001412  2  A9 24                LDA     #'$'
001414  2  95 D0                STA     U0AA0,X         ; prefix addresses with $
001416  2  E8                   INX                     ; next position in buffer
001417  2  A0 04                LDY     #4              ; non-zero page addresses are 4 hex digits
001419  2  A5 CD                LDA     NUMBIT          ; check numeric base in which address was given
00141B  2  C9 08                CMP     #8              ; for addresses given in octal or binary
00141D  2  90 04                BCC     AADDR           ;   use only the high byte to determine page
00141F  2  C4 CB                CPY     DIGCNT          ; for decimal or hex, force non-zero page addressing
001421  2  F0 06                BEQ     AFILL0          ;   if address was given with four digits or more
001423  2               AADDR:
001423  2  A5 C2                LDA     TMP0+1          ; check whether high byte of address is zero
001425  2  D0 02                BNE     AFILL0          ; non-zero high byte means we're not in zero page
001427  2  A0 02                LDY     #2              ; if it's in zero page, addr is 2 hex digits
001429  2               AFILL0:
001429  2  A9 30                LDA     #$30            ; use 0 as placeholder for each hex digit in addr
00142B  2               AFIL0L:
00142B  2  95 D0                STA     U0AA0,X         ; put placeholder in assembly buffer
00142D  2  E8                   INX                     ; move to next byte in buffer
00142E  2  88                   DEY                     ; decrement number of remaining digits
00142F  2  D0 FA                BNE     AFIL0L          ; loop until all digits have been placed
001431  2               AFORM0:
001431  2  C6 B9                DEC     CHRPNT          ; non-numeric input; back 1 char to see what it was
001433  2               AFORM1:
001433  2  20 88 17             JSR     GETCHR          ; get next character
001436  2  F0 0D                BEQ     AESCAN          ; if there is none, we're finished scanning
001438  2  C9 20                CMP     #$20            ; skip spaces
00143A  2  F0 CB                BEQ     ASCAN
00143C  2  95 D0                STA     U0AA0,X         ; store character in assembly buffer
00143E  2  E8                   INX                     ; move to next byte in buffer
00143F  2  E0 0A                CPX     #U0AAE-U0AA0    ; is instruction buffer full?
001441  2  90 C4                BCC     ASCAN           ; if not, keep scanning
001443  2  B0 BD                BCS     AERROR          ; error if buffer is full
001445  2               
001445  2               ; find matching opcode
001445  2               AESCAN:
001445  2  86 B7                STX     STORE           ; save number of bytes in assembly buffer
001447  2  A2 00                LDX     #0              ; start at opcode $00 and check every one until
001449  2  86 CB                STX     OPCODE          ;   we find one that matches our criteria
00144B  2               ATRYOP:
00144B  2  A2 00                LDX     #0
00144D  2  86 BB                STX     U9F             ; reset index into work buffer
00144F  2  A5 CB                LDA     OPCODE
001451  2  20 14 16             JSR     INSTXX          ; look up instruction format for current opcode
001454  2  A6 C5                LDX     ACMD            ; save addressing command for later
001456  2  86 B8                STX     STORE+1
001458  2  AA                   TAX                     ; use current opcode as index
001459  2  BD 48 1A             LDA     MNEMR,X         ; check right byte of compressed mnemonic
00145C  2  20 4A 15             JSR     CHEKOP
00145F  2  BD 08 1A             LDA     MNEML,X         ; check left byte of compressed mnemonic
001462  2  20 4A 15             JSR     CHEKOP
001465  2  A2 06                LDX     #6              ; 6 possible characters to check against operand
001467  2               TRYIT:
001467  2  E0 03                CPX     #3              ; are we on character 3?
001469  2  D0 12                BNE     TRYMOD          ; if not, check operand characters
00146B  2  A4 C6                LDY     LENGTH          ; otherwise, check number of bytes in operand
00146D  2  F0 0E                BEQ     TRYMOD          ; if zero, check operand characters
00146F  2               TRYAD:
00146F  2  A5 C5                LDA     ACMD            ; otherwise, look for an address
001471  2  C9 E8                CMP     #$E8            ; special case for relative addressing mode
001473  2                                               ;   since it's specified with 4 digits in assembly
001473  2                                               ;   but encoded with only 1 byte in object code
001473  2  A9 30                LDA     #$30            ; '0' is the digit placeholder we're looking for
001475  2  B0 1D                BCS     TRY4B           ; ACMD >= $E8 indicates relative addressing
001477  2  20 47 15             JSR     CHEK2B          ; ACMD < $E8 indicates normal addressing
00147A  2  88                   DEY                     ; consume byte
00147B  2  D0 F2                BNE     TRYAD           ; check for 2 more digits if not zero-page
00147D  2               TRYMOD:
00147D  2  06 C5                ASL     ACMD            ; shift a bit out of the addressing command
00147F  2  90 0E                BCC     UB4DF           ; if it's zero, skip checking current character
001481  2  BD FB 19             LDA     CHAR1-1,X
001484  2  20 4A 15             JSR     CHEKOP          ; otherwise first character against operand
001487  2  BD 01 1A             LDA     CHAR2-1,X       ; get second character to check
00148A  2  F0 03                BEQ     UB4DF           ; if it's zero, skip checking it
00148C  2  20 4A 15             JSR     CHEKOP          ; otherwise check it against hte operand
00148F  2               UB4DF:
00148F  2  CA                   DEX                     ; move to next character
001490  2  D0 D5                BNE     TRYIT           ; repeat tests
001492  2  F0 06                BEQ     TRYBRAN
001494  2               TRY4B:
001494  2  20 47 15             JSR     CHEK2B          ; check for 4 digit address placeholder
001497  2  20 47 15             JSR     CHEK2B          ;   by checking for 2 digits twice
00149A  2               TRYBRAN:
00149A  2  A5 B7                LDA     STORE           ; get number of bytes in assembly buffer
00149C  2  C5 BB                CMP     U9F             ; more bytes left to check?
00149E  2  F0 03                BEQ     ABRAN           ; if not, we've found a match; build instruction
0014A0  2  4C 54 15             JMP     BUMPOP          ; if so, this opcode doesn't match; try the next
0014A3  2               
0014A3  2               ; convert branches to relative address
0014A3  2               ABRAN:
0014A3  2  A4 C6                LDY     LENGTH          ; get number of bytes in operand
0014A5  2  F0 33                BEQ     A1BYTE          ; if none, just output the opcode
0014A7  2  A5 B8                LDA     STORE+1         ; otherwise check the address format
0014A9  2  C9 9D                CMP     #$9D            ; is it a relative branch?
0014AB  2  D0 25                BNE     OBJPUT          ; if not, skip relative branch calculation
0014AD  2  A5 C1                LDA     TMP0            ; calculate the difference between the current
0014AF  2  E5 C3                SBC     TMP2            ;   address and the branch target (low byte)
0014B1  2  AA                   TAX                     ; save it in X
0014B2  2  A5 C2                LDA     TMP0+1          ; borrow from the high byte if necessary
0014B4  2  E5 C4                SBC     TMP2+1
0014B6  2  90 0B                BCC     ABBACK          ; if result is negative, we're branching back
0014B8  2  F0 03                BEQ     :++             ; high bytes must be equal when branching forward
0014BA  2               :
0014BA  2  4C 44 15             JMP     SERROR
0014BD  2               :
0014BD  2  E0 82                CPX     #$82            ; difference between low bytes must be < 130
0014BF  2  B0 F9                BCS     :--             ; error if the address is too far away
0014C1  2  90 08                BCC     ABRANX
0014C3  2               ABBACK:
0014C3  2  A8                   TAY                     ; when branching backward high byte of target must
0014C4  2  C8                   INY                     ;   be 1 less than high byte of current address
0014C5  2  D0 7D                BNE     SERROR          ; if not, it's too far away
0014C7  2  E0 82                CPX     #$82            ; difference between low bytes must be < 130
0014C9  2  90 79                BCC     SERROR          ; if not, it's too far away
0014CB  2               ABRANX:
0014CB  2  CA                   DEX                     ; adjust branch target relative to the
0014CC  2  CA                   DEX                     ;   instruction following this one
0014CD  2  8A                   TXA
0014CE  2  A4 C6                LDY     LENGTH          ; load length of operand
0014D0  2  D0 03                BNE     OBJP2           ; don't use the absolute address
0014D2  2               
0014D2  2               ; assemble machine code
0014D2  2               OBJPUT:
0014D2  2  B9 C0 00             LDA     TMP0-1,Y        ; get the operand
0014D5  2               OBJP2:
0014D5  2  91 C3                STA     (TMP2),Y        ; store it after the opcode
0014D7  2  88                   DEY
0014D8  2  D0 F8                BNE     OBJPUT          ; copy the other byte of operand if there is one
0014DA  2               A1BYTE:
0014DA  2  A5 CB                LDA     OPCODE          ; put opcode into instruction
0014DC  2  91 C3                STA     (TMP2),Y
0014DE  2  A9 0D                LDA     #$0D            ; cr
0014E0  2  20 FE 1A             JSR     CHROUT
0014E3  2  A0 2E                LDY     #MSG7-MSGBAS    ; "A " prefix
0014E5  2  20 C9 18             JSR     SNDCLR          ; clear line
0014E8  2  A9 41                LDA     #'A'
0014EA  2  20 FE 1A             JSR     CHROUT
0014ED  2  A9 20                LDA     #' '
0014EF  2  20 FE 1A             JSR     CHROUT
0014F2  2  20 9C 15             JSR     DISLIN          ; disassemble the instruction we just assembled
0014F5  2  E6 C6                INC     LENGTH          ; instruction length = operand length + 1 byte
0014F7  2  A5 C6                LDA     LENGTH          ;   for the opcode
0014F9  2  20 D7 17             JSR     BUMPAD2         ; increment address by length of instruction
0014FC  2                                               ; setup for the next assemble command
0014FC  2  20 4A 17             JSR     CRLF
0014FF  2  A9 41                LDA     #'A'            ; stuff keyboard buffer with next assemble command:
001501  2  8D 00 02             STA     INBUFF
001504  2  20 FE 1A             JSR     OUTCH
001507  2  A9 20                LDA     #' '            ;   after the previously assembled instruction
001509  2  8D 01 02             STA     INBUFF+1
00150C  2  20 FE 1A             JSR     OUTCH
00150F  2  A5 C4                LDA     TMP2+1          ; convert high byte of next address to hex
001511  2  20 71 17             JSR     ASCTWO
001514  2  8D 02 02             STA     INBUFF+2        ; put it in the keyboard buffer
001517  2  20 FE 1A             JSR     OUTCH
00151A  2  8E 03 02             STX     INBUFF+3
00151D  2  8A                   TXA
00151E  2  20 FE 1A             JSR     OUTCH
001521  2  A5 C3                LDA     TMP2            ; convert low byte of next address to hex
001523  2  20 71 17             JSR     ASCTWO
001526  2  8D 04 02             STA     INBUFF+4        ; put it in the keyboard buffer
001529  2  20 FE 1A             JSR     OUTCH
00152C  2  8E 05 02             STX     INBUFF+5
00152F  2  8A                   TXA
001530  2  20 FE 1A             JSR     OUTCH
001533  2  A9 20                LDA     #' '            ;   after the previously assembled instruction
001535  2  8D 06 02             STA     INBUFF+6
001538  2  20 FE 1A             JSR     OUTCH
00153B  2  A2 07                LDX     #7              ; set number of chars in keyboard buffer
00153D  2  A9 00                LDA     #$00
00153F  2  85 B9                STA     CHRPNT
001541  2  4C 91 10             JMP     SMOVE           ; back to main loop
001544  2               SERROR:
001544  2  4C D9 10             JMP     ERROR           ; handle error
001547  2               
001547  2               ; check characters in operand
001547  2               CHEK2B:
001547  2  20 4A 15             JSR     CHEKOP          ; check two bytes against value in accumulator
00154A  2               CHEKOP:
00154A  2  86 CA                STX     SAVX            ; stash X
00154C  2  A6 BB                LDX     U9F             ; get current index into work buffer
00154E  2  D5 D0                CMP     U0AA0,X         ; check whether this opcode matches the buffer
001550  2  F0 09                BEQ     OPOK            ;   matching so far, check the next criteria
001552  2  68                   PLA                     ; didn't match, so throw away return address
001553  2  68                   PLA                     ;   on the stack because we're starting over
001554  2               BUMPOP:
001554  2  E6 CB                INC     OPCODE          ; check the next opcode
001556  2  F0 EC                BEQ     SERROR          ; error if we tried every opcode and none fit
001558  2  4C 4B 14             JMP     ATRYOP          ; start over with new opcode
00155B  2               OPOK:
00155B  2  E6 BB                INC     U9F             ; opcode matches so far; check the next criteria
00155D  2  A6 CA                LDX     SAVX            ; restore X
00155F  2  60                   RTS
001560  2               
001560  2               ; -----------------------------------------------------------------------------
001560  2               ; disassemble [D]
001560  2               DISASS:
001560  2  B0 08                BCS     DIS0AD          ; if no address was given, start from last address
001562  2  20 9E 17             JSR     COPY12          ; copy start address to TMP2
001565  2  20 7E 16             JSR     GETPAR          ; get end address in TMP0
001568  2  90 06                BCC     DIS2AD          ; if one was given, skip default
00156A  2               DIS0AD:
00156A  2  A9 14                LDA     #$14            ; disassemble 14 bytes by default
00156C  2  85 C1                STA     TMP0            ; store length in TMP0
00156E  2  D0 05                BNE     DISGO           ; skip length calculation
001570  2               DIS2AD:
001570  2  20 A7 17             JSR     SUB12           ; calculate number of bytes between start and end
001573  2  90 1C                BCC     DERROR          ; error if end address is before start address
001575  2               DISGO:
001575  2  20 C3 18             JSR     CLINE           ; clear the current line
001578  2  20 EA 18             JSR     STOP            ; check for stop key
00157B  2  F0 11                BEQ     DISEXIT         ; exit early if pressed
00157D  2  20 94 15             JSR     DSOUT1          ; output disassembly prefix ". "
001580  2  E6 C6                INC     LENGTH
001582  2  A5 C6                LDA     LENGTH          ; add length of last instruction to start address
001584  2  20 D7 17             JSR     BUMPAD2
001587  2  A5 C6                LDA     LENGTH          ; subtract length of last inst from end address
001589  2  20 B7 17             JSR     SUBA2
00158C  2  B0 E7                BCS     DISGO
00158E  2               DISEXIT:
00158E  2  4C 8A 10             JMP     STRT            ; back to mainloop
001591  2               DERROR:
001591  2  4C D9 10             JMP     ERROR
001594  2               
001594  2               DSOUT1:
001594  2  A9 2E                LDA     #'.'            ; output ". " prefix to allow edit and reassemble
001596  2  20 FE 1A             JSR     CHROUT
001599  2  20 42 17             JSR     SPACE
00159C  2               
00159C  2               DISLIN:
00159C  2  20 35 17             JSR     SHOWAD          ; show the address of the instruction
00159F  2  20 42 17             JSR     SPACE           ; insert a space
0015A2  2  A0 00                LDY     #0              ; no offset
0015A4  2  B1 C3                LDA     (TMP2),Y        ; load operand of current instruction
0015A6  2  20 14 16             JSR     INSTXX          ; get mnemonic and addressing mode for opcode
0015A9  2  48                   PHA                     ; save index into mnemonic table
0015AA  2  A6 C6                LDX     LENGTH          ; get length of operand
0015AC  2  E8                   INX                     ; add 1 byte for opcode
0015AD  2               DSBYT:
0015AD  2  CA                   DEX                     ; decrement index
0015AE  2  10 0C                BPL     DSHEX           ; show hex for byte being disassembled
0015B0  2  84 BA                STY     SAVY            ; save index
0015B2  2  A0 30                LDY     #MSG8-MSGBAS    ; skip 3 spaces
0015B4  2  20 DC 18             JSR     SNDMSG
0015B7  2  A4 BA                LDY     SAVY            ; restore index
0015B9  2  4C C1 15             JMP     NXBYT
0015BC  2               DSHEX:
0015BC  2  B1 C3                LDA     (TMP2),Y        ; show hex for byte
0015BE  2  20 3F 17             JSR     WRBYTE
0015C1  2               
0015C1  2               NXBYT:
0015C1  2  C8                   INY                     ; next byte
0015C2  2  C0 03                CPY     #3              ; have we output 3 bytes yet?
0015C4  2  90 E7                BCC     DSBYT           ; if not, loop
0015C6  2  68                   PLA                     ; restore index into mnemonic table
0015C7  2  A2 03                LDX     #3              ; 3 letters in mnemonic
0015C9  2  20 5A 16             JSR     PROPXX          ; print mnemonic
0015CC  2  A2 06                LDX     #6              ; 6 possible address mode character combos
0015CE  2               PRADR1:
0015CE  2  E0 03                CPX     #3              ; have we checked the third combo yet?
0015D0  2  D0 14                BNE     PRADR3          ; if so, output the leading characters
0015D2  2  A4 C6                LDY     LENGTH          ; get the length of the operand
0015D4  2  F0 10                BEQ     PRADR3          ; if it's zero, there's no operand to print
0015D6  2               PRADR2:
0015D6  2  A5 C5                LDA     ACMD            ; otherwise, get the addressing mode
0015D8  2  C9 E8                CMP     #$E8            ; check for relative addressing
0015DA  2  08                   PHP                     ; save result of check
0015DB  2  B1 C3                LDA     (TMP2),Y        ; get the operand
0015DD  2  28                   PLP                     ; restore result of check
0015DE  2  B0 1C                BCS     RELAD           ; handle a relative address
0015E0  2  20 63 17             JSR     WRTWO           ; output digits from address
0015E3  2  88                   DEY
0015E4  2  D0 F0                BNE     PRADR2          ; repeat for next byte of operand, if there is one
0015E6  2               PRADR3:
0015E6  2  06 C5                ASL     ACMD            ; check whether addr mode uses the current char
0015E8  2  90 0E                BCC     PRADR4          ; if not, skip it
0015EA  2  BD FB 19             LDA     CHAR1-1,X       ; look up the first char in the table
0015ED  2  20 FE 1A             JSR     CHROUT          ; print first char
0015F0  2  BD 01 1A             LDA     CHAR2-1,X       ; look up the second char in the table
0015F3  2  F0 03                BEQ     PRADR4          ; if there's no second character, skip it
0015F5  2  20 FE 1A             JSR     CHROUT          ; print second char
0015F8  2               PRADR4:
0015F8  2  CA                   DEX                     ; next potential address mode character
0015F9  2  D0 D3                BNE     PRADR1          ; loop if we haven't checked them all yet
0015FB  2  60                   RTS                     ; back to caller
0015FC  2               RELAD:
0015FC  2  20 08 16             JSR     UB64D           ; calculate absolute address from relative
0015FF  2  18                   CLC
001600  2  69 01                ADC     #1              ; adjust address relative to next instruction
001602  2  D0 01                BNE     RELEND          ; don't increment high byte unless we overflowed
001604  2  E8                   INX                     ; increment high byte
001605  2               RELEND:
001605  2  4C 39 17             JMP     WRADDR          ; print address
001608  2               
001608  2               UB64D:
001608  2  A6 C4                LDX     TMP2+1          ; get high byte of current address
00160A  2  A8                   TAY                     ; is relative address positive or negative?
00160B  2  10 01                BPL     RELC2           ; if positive, leave high byte alone
00160D  2  CA                   DEX                     ; if negative, decrement high byte
00160E  2               RELC2:
00160E  2  65 C3                ADC     TMP2            ; add relative address to low byte
001610  2  90 01                BCC     RELC3           ; if there's no carry, we're done
001612  2  E8                   INX                     ; if there's a carry, increment the high byte
001613  2               RELC3:
001613  2  60                   RTS
001614  2               
001614  2               ; -----------------------------------------------------------------------------
001614  2               ; get opcode mode and length
001614  2               
001614  2               ; Note: the labels are different, but the code of this subroutine is almost
001614  2               ; identical to the INSDS2 subroutine of the Apple Mini-Assembler on page 78 of
001614  2               ; the Apple II Red Book. I'm not sure exactly where this code originated
001614  2               ; (MOS or Apple) but it's clear that this part of Supermon64 and the
001614  2               ; Mini-Asssembler share a common heritage.  The comments showing the way the
001614  2               ; opcodes are transformed into indexes for the mnemonic lookup table come
001614  2               ; from the Mini-Assembler source.
001614  2               
001614  2               INSTXX:
001614  2  A8                   TAY                     ; stash opcode in accumulator in Y for later
001615  2  4A                   LSR     A               ; is opcode even or odd?
001616  2  90 0B                BCC     IEVEN
001618  2  4A                   LSR     A
001619  2  B0 17                BCS     ERR             ; invalid opcodes XXXXXX11
00161B  2  C9 22                CMP     #$22
00161D  2  F0 13                BEQ     ERR             ; invalid opcode 10001001
00161F  2  29 07                AND     #$07            ; mask bits to 10000XXX
001621  2  09 80                ORA     #$80
001623  2               IEVEN:
001623  2  4A                   LSR     A               ; LSB determines whether to use left/right nybble
001624  2  AA                   TAX                     ; get format index using remaining high bytes
001625  2  BD AA 19             LDA     MODE,X
001628  2  B0 04                BCS     RTMODE          ; look at left or right nybble based on carry bit
00162A  2  4A                   LSR     A               ; if carry = 0, use left nybble
00162B  2  4A                   LSR     A
00162C  2  4A                   LSR     A
00162D  2  4A                   LSR     A
00162E  2               RTMODE:
00162E  2  29 0F                AND     #$0F            ; if carry = 1, use right nybble
001630  2  D0 04                BNE     GETFMT
001632  2               ERR:
001632  2  A0 80                LDY     #$80            ; substitute 10000000 for invalid opcodes
001634  2  A9 00                LDA     #0
001636  2               GETFMT:
001636  2  AA                   TAX
001637  2  BD EE 19             LDA     MODE2,X         ; lookup operand format using selected nybble
00163A  2  85 C5                STA     ACMD            ; save for later use
00163C  2  29 03                AND     #$03            ; lower 2 bits indicate number of bytes in operand
00163E  2  85 C6                STA     LENGTH
001640  2  98                   TYA                     ; restore original opcode
001641  2  29 8F                AND     #$8F            ; mask bits to X000XXXX
001643  2  AA                   TAX                     ; save it
001644  2  98                   TYA                     ; restore original opcode
001645  2  A0 03                LDY     #3
001647  2  E0 8A                CPX     #$8A            ; check if opcode = 1XXX1010
001649  2  F0 0B                BEQ     GTFM4
00164B  2               GTFM2:
00164B  2  4A                   LSR     A               ; transform opcode into index for mnemonic table
00164C  2  90 08                BCC     GTFM4
00164E  2  4A                   LSR     A               ; opcodes transformed as follows:
00164F  2               GTFM3:
00164F  2  4A                   LSR     A               ; 1XXX1010->00101XXX
001650  2  09 20                ORA     #$20            ; XXXYYY01->00111XXX
001652  2  88                   DEY                     ; XXXYYY10->00111XXX
001653  2  D0 FA                BNE     GTFM3           ; XXXYY100->00110XXX
001655  2  C8                   INY                     ; XXXXX000->000XXXXX
001656  2               GTFM4:
001656  2  88                   DEY
001657  2  D0 F2                BNE     GTFM2
001659  2  60                   RTS
00165A  2               
00165A  2               ; -----------------------------------------------------------------------------
00165A  2               ; extract and print packed mnemonics
00165A  2               PROPXX:
00165A  2  A8                   TAY                     ; use index in accumulator to look up mnemonic
00165B  2  B9 08 1A             LDA     MNEML,Y         ;   and place a temporary copy in STORE
00165E  2  85 B7                STA     STORE
001660  2  B9 48 1A             LDA     MNEMR,Y
001663  2  85 B8                STA     STORE+1
001665  2               PRMN1:
001665  2  A9 00                LDA     #0              ; clear accumulator
001667  2  A0 05                LDY     #$05            ; shift 5 times
001669  2               PRMN2:
001669  2  06 B8                ASL     STORE+1         ; shift right byte
00166B  2  26 B7                ROL     STORE           ; rotate bits from right byte into left byte
00166D  2  2A                   ROL     A               ; rotate bits from left byte into accumulator
00166E  2  88                   DEY                     ; next bit
00166F  2  D0 F8                BNE     PRMN2           ; loop until all bits shifted
001671  2  69 3F                ADC     #$3F            ; calculate ascii code for letter by adding to '?'
001673  2  20 FE 1A             JSR     CHROUT          ; output letter
001676  2  CA                   DEX                     ; next letter
001677  2  D0 EC                BNE     PRMN1           ; loop until all 3 letters are output
001679  2  4C 42 17             JMP     SPACE           ; output space
00167C  2               
00167C  2               ; -----------------------------------------------------------------------------
00167C  2               ; read parameters
00167C  2               RDPAR:
00167C  2  C6 B9                DEC     CHRPNT          ; back up one char
00167E  2               GETPAR:
00167E  2  20 A3 16             JSR     RDVAL           ; read the value
001681  2  B0 15                BCS     GTERR           ; carry set indicates error
001683  2  20 86 17             JSR     GOTCHR          ; check previous character
001686  2  D0 08                BNE     CKTERM          ; if it's not null, check if it's a valid separator
001688  2  C6 B9                DEC     CHRPNT          ; back up one char
00168A  2  A5 CB                LDA     DIGCNT          ; get number of digits read
00168C  2  D0 11                BNE     GETGOT          ; found some digits
00168E  2  F0 0D                BEQ     GTNIL           ; didn't find any digits
001690  2               CKTERM:
001690  2  C9 20                CMP     #$20            ; space or comma are valid separators
001692  2  F0 0B                BEQ     GETGOT          ; anything else is an error
001694  2  C9 2C                CMP     #','
001696  2  F0 07                BEQ     GETGOT
001698  2               GTERR:
001698  2  68                   PLA                     ; encountered error
001699  2  68                   PLA                     ; get rid of command vector pushed on stack
00169A  2  4C D9 10             JMP     ERROR           ; handle error
00169D  2               GTNIL:
00169D  2  38                   SEC                     ; set carry to indicate no parameter found
00169E  2  24                   .BYTE   $24             ; BIT ZP opcode consumes next byte (CLC)
00169F  2               GETGOT:
00169F  2  18                   CLC                     ; clear carry to indicate paremeter returned
0016A0  2  A5 CB                LDA     DIGCNT          ; return number of digits in A
0016A2  2  60                   RTS                     ; return to address pushed from vector table
0016A3  2               
0016A3  2               ; -----------------------------------------------------------------------------
0016A3  2               ; read a value in the specified base
0016A3  2               RDVAL:
0016A3  2  A9 00                LDA     #0              ; clear temp
0016A5  2  85 C1                STA     TMP0
0016A7  2  85 C2                STA     TMP0+1
0016A9  2  85 CB                STA     DIGCNT          ; clear digit counter
0016AB  2  8A                   TXA                     ; save X and Y
0016AC  2  48                   PHA
0016AD  2  98                   TYA
0016AE  2  48                   PHA
0016AF  2               RDVMOR:
0016AF  2  20 88 17             JSR     GETCHR          ; get next character from input buffer
0016B2  2  F0 1C                BEQ     RDNILK          ; null at end of buffer
0016B4  2  C9 20                CMP     #$20            ; skip spaces
0016B6  2  F0 F7                BEQ     RDVMOR
0016B8  2  A2 03                LDX     #3              ; check numeric base [$+&%]
0016BA  2               GNMODE:
0016BA  2  DD 9D 1A             CMP     HIKEY,X
0016BD  2  F0 06                BEQ     GOTMOD          ; got a match, set up base
0016BF  2  CA                   DEX
0016C0  2  10 F8                BPL     GNMODE          ; check next base
0016C2  2  E8                   INX                     ; default to hex
0016C3  2  C6 B9                DEC     CHRPNT          ; back up one character
0016C5  2               GOTMOD:
0016C5  2  BC C3 1A             LDY     MODTAB,X        ; get base value
0016C8  2  BD C7 1A             LDA     LENTAB,X        ; get bits per digit
0016CB  2  85 CD                STA     NUMBIT          ; store bits per digit
0016CD  2               NUDIG:
0016CD  2  20 88 17             JSR     GETCHR          ; get next char in A
0016D0  2               RDNILK:
0016D0  2  F0 59                BEQ     RDNIL           ; end of number if no more characters
0016D2  2  38                   SEC
0016D3  2  E9 30                SBC     #$30            ; subtract ascii value of 0 to get numeric value
0016D5  2  90 54                BCC     RDNIL           ; end of number if character was less than 0
0016D7  2  C9 0A                CMP     #$0A
0016D9  2  90 06                BCC     DIGMOR          ; not a hex digit if less than A
0016DB  2  E9 07                SBC     #$07            ; 7 chars between ascii 9 and A, so subtract 7
0016DD  2  C9 10                CMP     #$10            ; end of number if char is greater than F
0016DF  2  B0 4A                BCS     RDNIL
0016E1  2               DIGMOR:
0016E1  2  85 CC                STA     INDIG           ; store the digit
0016E3  2  C4 CC                CPY     INDIG           ; compare base with the digit
0016E5  2  90 42                BCC     RDERR           ; error if the digit >= the base
0016E7  2  F0 40                BEQ     RDERR
0016E9  2  E6 CB                INC     DIGCNT          ; increment the number of digits
0016EB  2  C0 0A                CPY     #10
0016ED  2  D0 09                BNE     NODECM          ; skip the next part if not using base 10
0016EF  2  A2 01                LDX     #1
0016F1  2               DECLP1:
0016F1  2  B5 C1                LDA     TMP0,X          ; stash the previous 16-bit value for later use
0016F3  2  95 CE                STA     STASH,X
0016F5  2  CA                   DEX
0016F6  2  10 F9                BPL     DECLP1
0016F8  2               NODECM:
0016F8  2  A6 CD                LDX     NUMBIT          ; number of bits to shift
0016FA  2               TIMES2:
0016FA  2  06 C1                ASL     TMP0            ; shift 16-bit value by specified number of bits
0016FC  2  26 C2                ROL     TMP0+1
0016FE  2  B0 29                BCS     RDERR           ; error if we overflowed 16 bits
001700  2  CA                   DEX
001701  2  D0 F7                BNE     TIMES2          ; shift remaining bits
001703  2  C0 0A                CPY     #10
001705  2  D0 14                BNE     NODEC2          ; skip the next part if not using base 10
001707  2  06 CE                ASL     STASH           ; shift the previous 16-bit value one bit left
001709  2  26 CF                ROL     STASH+1
00170B  2  B0 1C                BCS     RDERR           ; error if we overflowed 16 bits
00170D  2  A5 CE                LDA     STASH           ; add shifted previous value to current value
00170F  2  65 C1                ADC     TMP0
001711  2  85 C1                STA     TMP0
001713  2  A5 CF                LDA     STASH+1
001715  2  65 C2                ADC     TMP0+1
001717  2  85 C2                STA     TMP0+1
001719  2  B0 0E                BCS     RDERR           ; error if we overflowed 16 bits
00171B  2               NODEC2:
00171B  2  18                   CLC
00171C  2  A5 CC                LDA     INDIG           ; load current digit
00171E  2  65 C1                ADC     TMP0            ; add current digit to low byte
001720  2  85 C1                STA     TMP0            ; and store result back in low byte
001722  2  8A                   TXA                     ; A=0
001723  2  65 C2                ADC     TMP0+1          ; add carry to high byte
001725  2  85 C2                STA     TMP0+1          ; and store result back in high byte
001727  2  90 A4                BCC     NUDIG           ; get next digit if we didn't overflow
001729  2               RDERR:
001729  2  38                   SEC                     ; set carry to indicate error
00172A  2  24                   .BYTE   $24             ; BIT ZP opcode consumes next byte (CLC)
00172B  2               RDNIL:
00172B  2  18                   CLC                     ; clear carry to indicate success
00172C  2  84 CD                STY     NUMBIT          ; save base of number
00172E  2  68                   PLA                     ; restore X and Y
00172F  2  A8                   TAY
001730  2  68                   PLA
001731  2  AA                   TAX
001732  2  A5 CB                LDA     DIGCNT          ; return number of digits in A
001734  2  60                   RTS
001735  2               
001735  2               ; -----------------------------------------------------------------------------
001735  2               ; print address
001735  2               SHOWAD:
001735  2  A5 C3                LDA     TMP2
001737  2  A6 C4                LDX     TMP2+1
001739  2               
001739  2               WRADDR:
001739  2  48                   PHA                     ; save low byte
00173A  2  8A                   TXA                     ; put high byte in A
00173B  2  20 63 17             JSR     WRTWO           ; output high byte
00173E  2  68                   PLA                     ; restore low byte
00173F  2               
00173F  2               WRBYTE:
00173F  2  20 63 17             JSR     WRTWO           ; output byte in A
001742  2               
001742  2               SPACE:
001742  2  A9 20                LDA     #$20            ; output space
001744  2  D0 0F                BNE     FLIP
001746  2               
001746  2               CHOUT:
001746  2  C9 0D                CMP     #$0D            ; output char with special handling of CR
001748  2  D0 0B                BNE     FLIP
00174A  2               CRLF:
00174A  2  A9 0D                LDA     #$0D            ; load CR in A
00174C  2  24 13                BIT     $13             ; check default channel
00174E  2  10 05                BPL     FLIP            ; if high bit is clear output CR only
001750  2  20 FE 1A             JSR     CHROUT          ; otherwise output CR+LF
001753  2  A9 0A                LDA     #$0A            ; output LF
001755  2               FLIP:
001755  2  4C FE 1A             JMP     CHROUT
001758  2               
001758  2               FRESH:
001758  2  20 4A 17             JSR     CRLF            ; output CR
00175B  2  A9 20                LDA     #$20            ; load space in A
00175D  2  20 FE 1A             JSR     CHROUT
001760  2  4C CC 18             JMP     SNCLR
001763  2               
001763  2               ; -----------------------------------------------------------------------------
001763  2               ; output two hex digits for byte
001763  2               WRTWO:
001763  2  86 CA                STX     SAVX            ; save X
001765  2  20 71 17             JSR     ASCTWO          ; get hex chars for byte in X (lower) and A (upper)
001768  2  20 FE 1A             JSR     CHROUT          ; output upper nybble
00176B  2  8A                   TXA                     ; transfer lower to A
00176C  2  A6 CA                LDX     SAVX            ; restore X
00176E  2  4C FE 1A             JMP     CHROUT          ; output lower nybble
001771  2               
001771  2               ; -----------------------------------------------------------------------------
001771  2               ; convert byte in A to hex digits
001771  2               ASCTWO:
001771  2  48                   PHA                     ; save byte
001772  2  20 7B 17             JSR     ASCII           ; do low nybble
001775  2  AA                   TAX                     ; save in X
001776  2  68                   PLA                     ; restore byte
001777  2  4A                   LSR     A               ; shift upper nybble down
001778  2  4A                   LSR     A
001779  2  4A                   LSR     A
00177A  2  4A                   LSR     A
00177B  2               
00177B  2               ; convert low nybble in A to hex digit
00177B  2               ASCII:
00177B  2  29 0F                AND     #$0F            ; clear upper nibble
00177D  2  C9 0A                CMP     #$0A            ; if less than A, skip next step
00177F  2  90 02                BCC     ASC1
001781  2  69 06                ADC     #6              ; skip ascii chars between 9 and A
001783  2               ASC1:
001783  2  69 30                ADC     #$30            ; add ascii char 0 to value
001785  2  60                   RTS
001786  2               
001786  2               ; -----------------------------------------------------------------------------
001786  2               ; get prev char from input buffer
001786  2               GOTCHR:
001786  2  C6 B9                DEC     CHRPNT
001788  2               
001788  2               ; get next char from input buffer
001788  2               GETCHR:
001788  2  86 CA                STX     SAVX
00178A  2  A6 B9                LDX     CHRPNT          ; get pointer to next char
00178C  2  BD 00 02             LDA     INBUFF,X        ; load next char in A
00178F  2  F0 06                BEQ     NOCHAR          ; null, :, or ? signal end of buffer
001791  2  C9 3A                CMP     #':'
001793  2  F0 02                BEQ     NOCHAR
001795  2  C9 3F                CMP     #'?'
001797  2               NOCHAR:
001797  2  08                   PHP
001798  2  E6 B9                INC     CHRPNT          ; next char
00179A  2  A6 CA                LDX     SAVX
00179C  2  28                   PLP                     ; Z flag will signal last character
00179D  2  60                   RTS
00179E  2               
00179E  2               ; -----------------------------------------------------------------------------
00179E  2               ; copy TMP0 to TMP2
00179E  2               COPY12:
00179E  2  A5 C1                LDA     TMP0            ; low byte
0017A0  2  85 C3                STA     TMP2
0017A2  2  A5 C2                LDA     TMP0+1          ; high byte
0017A4  2  85 C4                STA     TMP2+1
0017A6  2  60                   RTS
0017A7  2               
0017A7  2               ; -----------------------------------------------------------------------------
0017A7  2               ; subtract TMP2 from TMP0
0017A7  2               SUB12:
0017A7  2  38                   SEC
0017A8  2  A5 C1                LDA     TMP0            ; subtract low byte
0017AA  2  E5 C3                SBC     TMP2
0017AC  2  85 C1                STA     TMP0
0017AE  2  A5 C2                LDA     TMP0+1
0017B0  2  E5 C4                SBC     TMP2+1          ; subtract high byte
0017B2  2  85 C2                STA     TMP0+1
0017B4  2  60                   RTS
0017B5  2               
0017B5  2               ; -----------------------------------------------------------------------------
0017B5  2               ; subtract from TMP0
0017B5  2               SUBA1:
0017B5  2  A9 01                LDA     #1              ; shortcut to decrement by 1
0017B7  2               SUBA2:
0017B7  2  85 CA                STA     SAVX            ; subtrahend in accumulator
0017B9  2  38                   SEC
0017BA  2  A5 C1                LDA     TMP0            ; minuend in low byte
0017BC  2  E5 CA                SBC     SAVX
0017BE  2  85 C1                STA     TMP0
0017C0  2  A5 C2                LDA     TMP0+1          ; borrow from high byte
0017C2  2  E9 00                SBC     #0
0017C4  2  85 C2                STA     TMP0+1
0017C6  2  60                   RTS
0017C7  2               
0017C7  2               ; -----------------------------------------------------------------------------
0017C7  2               ; subtract 1 from STORE
0017C7  2               SUB13:
0017C7  2  38                   SEC
0017C8  2  A5 B7                LDA     STORE
0017CA  2  E9 01                SBC     #1              ; decrement low byte
0017CC  2  85 B7                STA     STORE
0017CE  2  A5 B8                LDA     STORE+1
0017D0  2  E9 00                SBC     #0              ; borrow from high byte
0017D2  2  85 B8                STA     STORE+1
0017D4  2  60                   RTS
0017D5  2               
0017D5  2               ; -----------------------------------------------------------------------------
0017D5  2               ; add to TMP2
0017D5  2               ADDA2:
0017D5  2  A9 01                LDA     #1              ; shortcut to increment by 1
0017D7  2               BUMPAD2:
0017D7  2  18                   CLC
0017D8  2  65 C3                ADC     TMP2            ; add value in accumulator to low byte
0017DA  2  85 C3                STA     TMP2
0017DC  2  90 02                BCC     BUMPEX
0017DE  2  E6 C4                INC     TMP2+1          ; carry to high byte
0017E0  2               BUMPEX:
0017E0  2  60                   RTS
0017E1  2               
0017E1  2               ; -----------------------------------------------------------------------------
0017E1  2               ; subtract 1 from TMP2
0017E1  2               SUB21:
0017E1  2  38                   SEC
0017E2  2  A5 C3                LDA     TMP2            ; decrement low byte
0017E4  2  E9 01                SBC     #1
0017E6  2  85 C3                STA     TMP2
0017E8  2  A5 C4                LDA     TMP2+1          ; borrow from high byte
0017EA  2  E9 00                SBC     #0
0017EC  2  85 C4                STA     TMP2+1
0017EE  2  60                   RTS
0017EF  2               
0017EF  2               ; -----------------------------------------------------------------------------
0017EF  2               ; copy TMP0 to PC
0017EF  2               COPY1P:
0017EF  2  B0 08                BCS     CPY1PX          ; do nothing if parameter is empty
0017F1  2  A5 C1                LDA     TMP0            ; copy low byte
0017F3  2  A4 C2                LDY     TMP0+1          ; copy high byte
0017F5  2  85 B1                STA     PCL
0017F7  2  84 B0                STY     PCH
0017F9  2               CPY1PX:
0017F9  2  60                   RTS
0017FA  2               
0017FA  2               ; -----------------------------------------------------------------------------
0017FA  2               ; get start/end addresses and calc difference
0017FA  2               GETDIF:
0017FA  2  B0 1F                BCS     GDIFX           ; exit with error if no parameter given
0017FC  2  20 9E 17             JSR     COPY12          ; save start address in TMP2
0017FF  2  20 7E 16             JSR     GETPAR          ; get end address in TMP0
001802  2  B0 17                BCS     GDIFX           ; exit with error if no parameter given
001804  2  A5 C1                LDA     TMP0            ; save end address in STASH
001806  2  85 CE                STA     STASH
001808  2  A5 C2                LDA     TMP0+1
00180A  2  85 CF                STA     STASH+1
00180C  2  20 A7 17             JSR     SUB12           ; subtract start address from end address
00180F  2  A5 C1                LDA     TMP0
001811  2  85 B7                STA     STORE           ; save difference in STORE
001813  2  A5 C2                LDA     TMP0+1
001815  2  85 B8                STA     STORE+1
001817  2  90 02                BCC     GDIFX           ; error if start address is after end address
001819  2  18                   CLC                     ; clear carry to indicate success
00181A  2  24                   .BYTE   $24             ; BIT ZP opcode consumes next byte (SEC)
00181B  2               GDIFX:
00181B  2  38                   SEC                     ; set carry to indicate error
00181C  2  60                   RTS
00181D  2               
00181D  2               ; -----------------------------------------------------------------------------
00181D  2               ; convert base [$+&%]
00181D  2               CONVRT:
00181D  2  20 7C 16             JSR     RDPAR           ; read a parameter
001820  2  20 58 17             JSR     FRESH           ; next line and clear
001823  2  A9 24                LDA     #'$'            ; output $ sigil for hex
001825  2  20 FE 1A             JSR     CHROUT
001828  2  A5 C1                LDA     TMP0            ; load the 16-bit value entered
00182A  2  A6 C2                LDX     TMP0+1
00182C  2  20 39 17             JSR     WRADDR          ; print it in 4 hex digits
00182F  2  20 58 17             JSR     FRESH
001832  2  A9 2B                LDA     #'+'            ; output + sigil for decimal
001834  2  20 FE 1A             JSR     CHROUT
001837  2  20 68 18             JSR     CVTDEC          ; convert to BCD using hardware mode
00183A  2  A9 00                LDA     #0              ; clear digit counter
00183C  2  A2 06                LDX     #6              ; max digits + 1
00183E  2  A0 03                LDY     #3              ; bits per digit - 1
001840  2  20 9B 18             JSR     NMPRNT          ; print result without leading zeros
001843  2  20 58 17             JSR     FRESH           ; next line and clear
001846  2  A9 26                LDA     #'&'            ; print & sigil for octal
001848  2  20 FE 1A             JSR     CHROUT
00184B  2  A9 00                LDA     #0              ; clear digit counter
00184D  2  A2 08                LDX     #8              ; max digits + 1
00184F  2  A0 02                LDY     #2              ; bits per digit - 1
001851  2  20 8D 18             JSR     PRINUM          ; output number
001854  2  20 58 17             JSR     FRESH           ; next line and clear
001857  2  A9 25                LDA     #'%'            ; print % sigil for binary
001859  2  20 FE 1A             JSR     CHROUT
00185C  2  A9 00                LDA     #0              ; clear digit counter
00185E  2  A2 18                LDX     #$18            ; max digits + 1
001860  2  A0 00                LDY     #0              ; bits per digit - 1
001862  2  20 8D 18             JSR     PRINUM          ; output number
001865  2  4C 8A 10             JMP     STRT            ; back to mainloop
001868  2               
001868  2               ; -----------------------------------------------------------------------------
001868  2               ; convert binary to BCD
001868  2               
001868  2               CVTDEC:
001868  2  20 9E 17             JSR     COPY12          ; copy value from TMP0 to TMP2
00186B  2  A9 00                LDA     #0
00186D  2  A2 02                LDX     #2              ; clear 3 bytes in work buffer
00186F  2               DECML1:
00186F  2  95 D0                STA     U0AA0,X
001871  2  CA                   DEX
001872  2  10 FB                BPL     DECML1
001874  2  A0 10                LDY     #16             ; 16 bits in input
001876  2  08                   PHP                     ; save status register
001877  2  78                   SEI                     ; make sure no interrupts occur with BCD enabled
001878  2  F8                   SED
001879  2               DECML2:
001879  2  06 C3                ASL     TMP2            ; rotate bytes out of input low byte
00187B  2  26 C4                ROL     TMP2+1          ; .. into high byte and carry bit
00187D  2  A2 02                LDX     #2              ; process 3 bytes
00187F  2               DECDBL:
00187F  2  B5 D0                LDA     U0AA0,X         ; load current value of byte
001881  2  75 D0                ADC     U0AA0,X         ; add it to itself plus the carry bit
001883  2  95 D0                STA     U0AA0,X         ; store it back in the same location
001885  2  CA                   DEX                     ; decrement byte counter
001886  2  10 F7                BPL     DECDBL          ; loop until all bytes processed
001888  2  88                   DEY                     ; decrement bit counter
001889  2  D0 EE                BNE     DECML2          ; loop until all bits processed
00188B  2  28                   PLP                     ; restore processor status
00188C  2  60                   RTS
00188D  2               
00188D  2               ; load the input value and fall through to print it
00188D  2               PRINUM:
00188D  2  48                   PHA                     ; save accumulator
00188E  2  A5 C1                LDA     TMP0            ; copy input low byte to work buffer
001890  2  85 D2                STA     U0AA0+2
001892  2  A5 C2                LDA     TMP0+1          ; copy input high byte to work buffer
001894  2  85 D1                STA     U0AA0+1
001896  2  A9 00                LDA     #0              ; clear overflow byte in work buffer
001898  2  85 D0                STA     U0AA0
00189A  2  68                   PLA                     ; restore accumulator
00189B  2               
00189B  2               ; print number in specified base without leading zeros
00189B  2               NMPRNT:
00189B  2  85 CB                STA     DIGCNT          ; number of digits in accumulator
00189D  2  84 CD                STY     NUMBIT          ; bits per digit passed in Y register
00189F  2               DIGOUT:
00189F  2  A4 CD                LDY     NUMBIT          ; get bits to process
0018A1  2  A9 00                LDA     #0              ; clear accumulator
0018A3  2               ROLBIT:
0018A3  2  06 D2                ASL     U0AA0+2         ; shift bits out of low byte
0018A5  2  26 D1                ROL     U0AA0+1         ; ... into high byte
0018A7  2  26 D0                ROL     U0AA0           ; ... into overflow byte
0018A9  2  2A                   ROL     A               ; ... into accumulator
0018AA  2  88                   DEY                     ; decrement bit counter
0018AB  2  10 F6                BPL     ROLBIT          ; loop until all bits processed
0018AD  2  A8                   TAY                     ; check whether accumulator is 0
0018AE  2  D0 08                BNE     NZERO           ; if not, print it
0018B0  2  E0 01                CPX     #1              ; have we output the max number of digits?
0018B2  2  F0 04                BEQ     NZERO           ; if not, print it
0018B4  2  A4 CB                LDY     DIGCNT          ; how many digits have we output?
0018B6  2  F0 07                BEQ     ZERSUP          ; skip output if digit is 0
0018B8  2               NZERO:
0018B8  2  E6 CB                INC     DIGCNT          ; increment digit counter
0018BA  2  09 30                ORA     #$30            ; add numeric value to ascii '0' to get ascii char
0018BC  2  20 FE 1A             JSR     CHROUT          ; output character
0018BF  2               ZERSUP:
0018BF  2  CA                   DEX                     ; decrement number of leading zeros
0018C0  2  D0 DD                BNE     DIGOUT          ; next digit
0018C2  2  60                   RTS
0018C3  2               
0018C3  2               
0018C3  2               ; -----------------------------------------------------------------------------
0018C3  2               ; print and clear routines
0018C3  2               CLINE:
0018C3  2  20 4A 17             JSR     CRLF
0018C6  2  4C CC 18             JMP     SNCLR           ; clear line
0018C9  2               SNDCLR:
0018C9  2  20 DC 18             JSR     SNDMSG
0018CC  2               SNCLR:
0018CC  2  A0 28                LDY     #$28            ; loop 40 times
0018CE  2               SNCLP:
0018CE  2  A9 20                LDA     #$20            ; output space character
0018D0  2  20 FE 1A             JSR     CHROUT
0018D3  2  88                   DEY
0018D4  2  D0 F8                BNE     SNCLP
0018D6  2  A9 0D                LDA     #13             ; output CR
0018D8  2  20 FE 1A             JSR     CHROUT          ; send CR
0018DB  2  60                   RTS
0018DC  2               
0018DC  2               ; -----------------------------------------------------------------------------
0018DC  2               ; display message from table
0018DC  2               SNDMSG:
0018DC  2  B9 77 19             LDA     MSGBAS,Y        ; Y contains offset in msg table
0018DF  2  08                   PHP
0018E0  2  29 7F                AND     #$7F            ; strip high bit before output
0018E2  2  20 46 17             JSR     CHOUT
0018E5  2  C8                   INY
0018E6  2  28                   PLP
0018E7  2  10 F3                BPL     SNDMSG          ; loop until high bit is set
0018E9  2  60                   RTS
0018EA  2               
0018EA  2               ; -----------------------------------------------------------------------------
0018EA  2               ; check for stop key
0018EA  2               STOP:
0018EA  2  20 F0 1A             JSR     IOF_CONIN
0018ED  2  C9 03                CMP     #$03
0018EF  2  F0 03                BEQ     :+
0018F1  2  A9 FF                LDA     #$FF
0018F3  2  60                   RTS
0018F4  2               :
0018F4  2  A9 00                LDA     #$00
0018F6  2  60                   RTS
0018F7  2               
0018F7  2               ; -----------------------------------------------------------------------------
0018F7  2               ; LOAD A MOTOROLA FORMATTED HEX FILE
0018F7  2               LOADS19:
0018F7  2  20 E3 1A             JSR     IOF_CONINW      ;
0018FA  2  C9 53                CMP     #'S'            ;
0018FC  2  D0 F9                BNE     LOADS19         ; FIRST CHAR NOT (S)
0018FE  2  20 E3 1A             JSR     IOF_CONINW      ; READ CHAR
001901  2  C9 39                CMP     #'9'            ;
001903  2  F0 33                BEQ     LOAD21          ;
001905  2  C9 31                CMP     #'1'            ;
001907  2  D0 EE                BNE     LOADS19         ; SECOND CHAR NOT (1)
001909  2  A9 00                LDA     #$00            ;
00190B  2  85 BC                STA     CKSM            ; ZERO CHECKSUM
00190D  2  20 39 19             JSR     GETBYTE         ; READ BYTE
001910  2  E9 01                SBC     #$01            ;
001912  2  85 CB                STA     DIGCNT          ; BYTE COUNT
001914  2  20 66 19             JSR     BADDR           ; BUILD ADDRESS
001917  2  A0 00                LDY     #$00            ;
001919  2               LOAD11:
001919  2  20 39 19             JSR     GETBYTE         ;
00191C  2  C6 CB                DEC     DIGCNT          ;
00191E  2  F0 0F                BEQ     LOAD15          ; ZERO BYTE COUNT
001920  2  91 BD                STA     (LOADADR),Y     ; STORE DATA
001922  2  E6 BD                INC     LOADADR         ; INCREMENT LOWBYTE
001924  2  A5 BD                LDA     LOADADR
001926  2  C9 00                CMP     #$00
001928  2  D0 EF                BNE     LOAD11          ; NOT ZERO?, LOOP
00192A  2  E6 BE                INC     LOADADR+1       ; ZERO, INC HIGH BYTE
00192C  2  4C 19 19             JMP     LOAD11          ;
00192F  2               
00192F  2               LOAD15:
00192F  2  E6 BC                INC     CKSM            ;
001931  2  F0 C4                BEQ     LOADS19         ;
001933  2               LOAD19:
001933  2  A9 3F                LDA     #'?'            ;
001935  2  20 FE 1A             JSR     OUTCH           ;
001938  2               LOAD21:
001938  2  60                   RTS
001939  2               GETBYTE:
001939  2  20 51 19             JSR     INHEX           ; GET HEX CHAR
00193C  2  0A                   ASL                     ;
00193D  2  0A                   ASL                     ;
00193E  2  0A                   ASL                     ;
00193F  2  0A                   ASL                     ;
001940  2  85 BF                STA     LOADWRK         ;
001942  2  20 51 19             JSR     INHEX           ;
001945  2  29 0F                AND     #$0F            ; MASK TO 4 BITS
001947  2  05 BF                ORA     LOADWRK         ;
001949  2  48                   PHA                     ;
00194A  2  18                   CLC                     ;
00194B  2  65 BC                ADC     CKSM            ;
00194D  2  85 BC                STA     CKSM            ;
00194F  2  68                   PLA                     ;
001950  2  60                   RTS                     ;
001951  2               ; INPUT HEX CHAR
001951  2               INHEX:
001951  2  20 E3 1A             JSR     IOF_CONINW      ;
001954  2  48                   PHA                     ;
001955  2  20 FE 1A             JSR     OUTCH           ;
001958  2  68                   PLA                     ;
001959  2  C9 3A                CMP     #$3A            ; LESS THAN 9?
00195B  2  B0 02                BCS     INHEX_BIG       ; NO, SKIP NEXT
00195D  2  E9 2F                SBC     #$2F            ; CONVERT 0-9
00195F  2               INHEX_BIG:
00195F  2  C9 41                CMP     #$41            ; A OR MORE?
001961  2  90 02                BCC     INHEX_SMALL     ; NO, SKIP NEXT
001963  2  E9 37                SBC     #$37            ; CONVERT A-F
001965  2               INHEX_SMALL:
001965  2  60                   RTS                     ;
001966  2               ; BUILD ADDRESS
001966  2               BADDR:
001966  2  20 39 19             JSR     GETBYTE         ; READ 2 FRAMES
001969  2  85 BE                STA     LOADADR+1       ;
00196B  2  20 39 19             JSR     GETBYTE         ;
00196E  2  85 BD                STA     LOADADR         ;
001970  2  60                   RTS
001971  2               LOAD:
001971  2  20 F7 18             JSR     LOADS19
001974  2  4C 8A 10             JMP     STRT            ; back to main loop
001977  2               
001977  2               
001977  2               
001977  2               
001977  2               ; -----------------------------------------------------------------------------
001977  2               ; message table; last character has high bit set
001977  2               MSGBAS:
001977  2               
001977  2               MSG2:
001977  2  0D                   .BYTE   $0D             ; header for registers
001978  2  20 20 20 50          .BYTE   "   PC  SR AC XR YR SP   V1.2"
00197C  2  43 20 20 53  
001980  2  52 20 41 43  
001994  2  8D                   .BYTE   $0D+$80
001995  2               MSG3:
001995  2  1D BF                .BYTE   $1D,$3F+$80     ; syntax error: move right, display "?"
001997  2               MSG4:
001997  2  2E 2E 53 59          .BYTE   "..SYS"         ; SYS call to enter monitor
00199B  2  53           
00199C  2  A0                   .BYTE   $20+$80
00199D  2               MSG5:
00199D  2  3A 92                .BYTE   $3A,$12+$80     ; ":" then RVS ON for memory ASCII dump
00199F  2               MSG6:
00199F  2  20 45 52 52          .BYTE   " ERRO"         ; I/O error: display " ERROR"
0019A3  2  4F           
0019A4  2  D2                   .BYTE   'R'+$80
0019A5  2               MSG7:
0019A5  2  41 A0                .BYTE   $41,$20+$80     ; assemble next instruction: "A " + addr
0019A7  2               MSG8:
0019A7  2  20 20                .BYTE   "  "            ; pad non-existent byte: skip 3 spaces
0019A9  2  A0                   .BYTE   $20+$80
0019AA  2               
0019AA  2               ; -----------------------------------------------------------------------------
0019AA  2               ; addressing mode table - nybbles provide index into MODE2 table
0019AA  2               ; for opcodes XXXXXXY0, use XXXXXX as index into table
0019AA  2               ; for opcodes WWWXXY01  use $40 + XX as index into table
0019AA  2               ; use right nybble if Y=0; use left nybble if Y=1
0019AA  2               
0019AA  2               MODE:
0019AA  2  40 02 45 03          .BYTE   $40,$02,$45,$03 ; even opcodes
0019AE  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
0019B2  2  30 22 45 33          .BYTE   $30,$22,$45,$33
0019B6  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
0019BA  2  40 02 45 33          .BYTE   $40,$02,$45,$33
0019BE  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
0019C2  2  40 02 45 B3          .BYTE   $40,$02,$45,$B3
0019C6  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
0019CA  2  00 22 44 33          .BYTE   $00,$22,$44,$33
0019CE  2  D0 8C 44 00          .BYTE   $D0,$8C,$44,$00
0019D2  2  11 22 44 33          .BYTE   $11,$22,$44,$33
0019D6  2  D0 8C 44 9A          .BYTE   $D0,$8C,$44,$9A
0019DA  2  10 22 44 33          .BYTE   $10,$22,$44,$33
0019DE  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
0019E2  2  10 22 44 33          .BYTE   $10,$22,$44,$33
0019E6  2  D0 08 40 09          .BYTE   $D0,$08,$40,$09
0019EA  2  62 13 78 A9          .BYTE   $62,$13,$78,$A9 ; opcodes ending in 01
0019EE  2               
0019EE  2               ; addressing mode format definitions indexed by nybbles from MODE table
0019EE  2               
0019EE  2               ; left 6 bits define which characters appear in the assembly operand
0019EE  2               ; left 3 bits are before the address; next 3 bits are after
0019EE  2               
0019EE  2               ; right-most 2 bits define length of binary operand
0019EE  2               
0019EE  2               ; index               654 321
0019EE  2               ; 1st character       $(# ,),
0019EE  2               ; 2nd character        $$ X Y    length  format      idx mode
0019EE  2               MODE2:
0019EE  2  00                   .BYTE   $00             ; 000 000    00                  0   error
0019EF  2  21                   .BYTE   $21             ; 001 000    01      #$00        1   immediate
0019F0  2  81                   .BYTE   $81             ; 100 000    01      $00         2   zero-page
0019F1  2  82                   .BYTE   $82             ; 100 000    10      $0000       3   absolute
0019F2  2  00                   .BYTE   $00             ; 000 000    00                  4   implied
0019F3  2  00                   .BYTE   $00             ; 000 000    00                  5   accumulator
0019F4  2  59                   .BYTE   $59             ; 010 110    01      ($00,X)     6   indirect,X
0019F5  2  4D                   .BYTE   $4D             ; 010 011    01      ($00),Y     7   indirect,Y
0019F6  2  91                   .BYTE   $91             ; 100 100    01      $00,X       8   zero-page,X
0019F7  2  92                   .BYTE   $92             ; 100 100    10      $0000,X     9   absolute,X
0019F8  2  86                   .BYTE   $86             ; 100 001    10      $0000,Y     A   absolute,Y
0019F9  2  4A                   .BYTE   $4A             ; 010 010    10      ($0000)     B   indirect
0019FA  2  85                   .BYTE   $85             ; 100 001    01      $00,Y       C   zero-page,Y
0019FB  2  9D                   .BYTE   $9D             ; 100 111    01      $0000*      D   relative
0019FC  2               
0019FC  2               ; * relative is special-cased so format bits don't match
0019FC  2               
0019FC  2               
0019FC  2               ; character lookup tables for the format definitions in MODE2
0019FC  2               
0019FC  2               CHAR1:
0019FC  2  2C 29 2C             .BYTE   $2C,$29,$2C     ; ","  ")"  ","
0019FF  2  23 28 24             .BYTE   $23,$28,$24     ; "#"  "("  "$"
001A02  2               
001A02  2               CHAR2:
001A02  2  59 00 58             .BYTE   $59,$00,$58     ; "Y"   0   "X"
001A05  2  24 24 00             .BYTE   $24,$24,$00     ; "$"  "$"   0
001A08  2               
001A08  2               ; -----------------------------------------------------------------------------
001A08  2               ; 3-letter mnemonics packed into two bytes (5 bits per letter)
001A08  2               
001A08  2               ; left 8 bits
001A08  2               ; XXXXX000 opcodes
001A08  2               MNEML:
001A08  2  1C 8A 1C 23          .BYTE   $1C,$8A,$1C,$23 ; BRK PHP BPL CLC
001A0C  2  5D 8B 1B A1          .BYTE   $5D,$8B,$1B,$A1 ; JSR PLP BMI SEC
001A10  2  9D 8A 1D 23          .BYTE   $9D,$8A,$1D,$23 ; RTI PHA BVC CLI
001A14  2  9D 8B 1D A1          .BYTE   $9D,$8B,$1D,$A1 ; RTS PLA BVS SEI
001A18  2  00 29 19 AE          .BYTE   $00,$29,$19,$AE ; ??? DEY BCC TYA
001A1C  2  69 A8 19 23          .BYTE   $69,$A8,$19,$23 ; LDY TAY BCS CLV
001A20  2  24 53 1B 23          .BYTE   $24,$53,$1B,$23 ; CPY INY BNE CLD
001A24  2  24 53 19 A1          .BYTE   $24,$53,$19,$A1 ; CPX INX BEQ SED
001A28  2               ; XXXYY100 opcodes
001A28  2  00 1A 5B 5B          .BYTE   $00,$1A,$5B,$5B ; ??? BIT JMP JMP
001A2C  2  A5 69 24 24          .BYTE   $A5,$69,$24,$24 ; STY LDY CPY CPX
001A30  2               ; 1XXX1010 opcodes
001A30  2  AE AE A8 AD          .BYTE   $AE,$AE,$A8,$AD ; TXA TXS TAX TSX
001A34  2  29 00 7C 00          .BYTE   $29,$00,$7C,$00 ; DEX ??? NOP ???
001A38  2               ; XXXYYY10 opcodes
001A38  2  15 9C 6D 9C          .BYTE   $15,$9C,$6D,$9C ; ASL ROL LSR ROR
001A3C  2  A5 69 29 53          .BYTE   $A5,$69,$29,$53 ; STX LDX DEC INC
001A40  2               ; XXXYYY01 opcodes
001A40  2  84 13 34 11          .BYTE   $84,$13,$34,$11 ; ORA AND EOR ADC
001A44  2  A5 69 23 A0          .BYTE   $A5,$69,$23,$A0 ; STA LDA CMP SBC
001A48  2               
001A48  2               ; right 7 bits, left justified
001A48  2               ; XXXXX000 opcodes
001A48  2               MNEMR:
001A48  2  D8 62 5A 48          .BYTE   $D8,$62,$5A,$48 ; BRK PHP BPL CLC
001A4C  2  26 62 94 88          .BYTE   $26,$62,$94,$88 ; JSR PLP BMI SEC
001A50  2  54 44 C8 54          .BYTE   $54,$44,$C8,$54 ; RTI PHA BVC CLI
001A54  2  68 44 E8 94          .BYTE   $68,$44,$E8,$94 ; RTS PLA BVS SEI
001A58  2  00 B4 08 84          .BYTE   $00,$B4,$08,$84 ; ??? DEY BCC TYA
001A5C  2  74 B4 28 6E          .BYTE   $74,$B4,$28,$6E ; LDY TAY BCS CLV
001A60  2  74 F4 CC 4A          .BYTE   $74,$F4,$CC,$4A ; CPY INY BNE CLD
001A64  2  72 F2 A4 8A          .BYTE   $72,$F2,$A4,$8A ; CPX INX BEQ SED
001A68  2               ; XXXYY100 opcodes
001A68  2  00 AA A2 A2          .BYTE   $00,$AA,$A2,$A2 ; ??? BIT JMP JMP
001A6C  2  74 74 74 72          .BYTE   $74,$74,$74,$72 ; STY LDY CPY CPX
001A70  2               ; 1XXX1010 opcodes
001A70  2  44 68 B2 32          .BYTE   $44,$68,$B2,$32 ; TXA TXS TAX TSX
001A74  2  B2 00 22 00          .BYTE   $B2,$00,$22,$00 ; DEX ??? NOP ???
001A78  2               ; XXXYYY10 opcodes
001A78  2  1A 1A 26 26          .BYTE   $1A,$1A,$26,$26 ; ASL ROL LSR ROR
001A7C  2  72 72 88 C8          .BYTE   $72,$72,$88,$C8 ; STX LDX DEC INC
001A80  2               ; XXXYYY01 opcodes
001A80  2  C4 CA 26 48          .BYTE   $C4,$CA,$26,$48 ; ORA AND EOR ADC
001A84  2  44 44 A2 C8          .BYTE   $44,$44,$A2,$C8 ; STA LDA CMP SBC
001A88  2  0D 20 20 20          .BYTE   $0D,$20,$20,$20
001A8C  2               
001A8C  2               ; -----------------------------------------------------------------------------
001A8C  2               ; single-character commands
001A8C  2               KEYW:
001A8C  2  41 42 43 44          .BYTE   "ABCDFGHJLMRTWZ.>;"
001A90  2  46 47 48 4A  
001A94  2  4C 4D 52 54  
001A9D  2               HIKEY:
001A9D  2  24 2B 26 25          .BYTE   "$+&%"
001AA1  2               KEYTOP:
001AA1  2               
001AA1  2               
001AA1  2               ; vectors corresponding to commands above
001AA1  2               KADDR:
001AA1  2  CE 13 CD 12          .WORD   ASSEM-1,BOOT-1,COMPAR-1,DISASS-1
001AA5  2  CB 11 5F 15  
001AA9  2  A5 12 62 11          .WORD   FILL-1,GOTO-1,HUNT-1,JSUB-1,LOAD-1
001AAD  2  46 12 79 11  
001AB1  2  70 19        
001AB3  2  F5 10 68 10          .WORD   DSPLYM-1,DSPLYR-1,TRANS-1,WRITEOS-1
001AB7  2  CE 11 3E 13  
001ABB  2  97 13 CE 13          .WORD   CLRDIR-1,ASSEM-1,ALTM-1,ALTR-1
001ABF  2  42 11 2B 11  
001AC3  2               
001AC3  2               ; -----------------------------------------------------------------------------
001AC3  2               MODTAB:
001AC3  2  10 0A 08 02          .BYTE   $10,$0A,$08,02  ; modulo number systems
001AC7  2               LENTAB:
001AC7  2  04 03 03 01          .BYTE   $04,$03,$03,$01 ; bits per digit
001ACB  2               
001ACB  1               
001ACB  1               ;__________________________________________________________________________________________________________
001ACB  1               ;
001ACB  1               ;  AT SOME POINT, REPLACE THIS WITH 6502HBIOS CALLS
001ACB  1               ;
001ACB  1               
001ACB  1               INIT_SERIAL:
001ACB  1  A9 80                LDA     #$80            ;
001ACD  1  8D 6B 03             STA     UART3           ; SET DLAB FLAG
001AD0  1  A9 0C                LDA     #12             ; SET TO 12 = 9600 BAUD
001AD2  1  8D 68 03             STA     UART0           ; save baud rate
001AD5  1  A9 00                LDA     #00             ;
001AD7  1  8D 69 03             STA     UART1           ;
001ADA  1  A9 03                LDA     #03             ;
001ADC  1  8D 6B 03             STA     UART3           ; SET 8 BIT DATA, 1 STOPBIT
001ADF  1  8D 6C 03             STA     UART4           ;
001AE2  1  60                   RTS
001AE3  1               
001AE3  1               
001AE3  1               IOF_CONINW:                     ;
001AE3  1               SERIAL_INCHW1:
001AE3  1  AD 6D 03             LDA     UART5           ; READ LINE STATUS REGISTER
001AE6  1  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
001AE8  1  C9 00                CMP     #$00
001AEA  1  F0 F7                BEQ     SERIAL_INCHW1   ; LOOP UNTIL DATA IS READY
001AEC  1  AD 68 03             LDA     UART0           ; THEN READ THE CHAR FROM THE UART
001AEF  1               
001AEF  1  60                   RTS
001AF0  1               
001AF0  1               IOF_CONIN:                      ;
001AF0  1  AD 6D 03             LDA     UART5           ; READ LINE STATUS REGISTER
001AF3  1  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
001AF5  1  F0 04                BEQ     SERIAL_INCH1    ; NO CHAR FOUND
001AF7  1  AD 68 03             LDA     UART0           ; THEN READ THE CHAR FROM THE UART
001AFA  1  60                   RTS
001AFB  1               SERIAL_INCH1:                   ;
001AFB  1  A9 00                LDA     #$00
001AFD  1  60                   RTS                     ;
001AFE  1               
001AFE  1               OUTCH:  ;
001AFE  1  48                   PHA                     ; STORE A
001AFF  1               TX_BUSYLP:
001AFF  1  AD 6D 03             LDA     UART5           ; READ LINE STATUS REGISTER
001B02  1  29 20                AND     #$20            ; TEST IF UART IS READY TO SEND (BIT 5)
001B04  1  C9 00                CMP     #$00
001B06  1  F0 F7                BEQ     TX_BUSYLP       ; IF NOT REPEAT
001B08  1  68                   PLA                     ; RESTORE ACC
001B09  1  8D 68 03             STA     UART0           ; THEN WRITE THE CHAR TO UART
001B0C  1  60                   RTS
001B0D  1               
001B0D  1               
001B0D  1               ; START BANNER
001B0D  1               STARTUP:
001B0D  1  0D 0A                .BYTE   $0D,$0A
001B0F  1               
001B0F  1  20 20 4E 68          .BYTE   "  Nhyodyne",$0D,$0A
001B13  1  79 6F 64 79  
001B17  1  6E 65 0D 0A  
001B1B  1  20 20 20 5F          .BYTE   "   __ _____  _____ ___ ___ ",$0D,$0A
001B1F  1  5F 20 5F 5F  
001B23  1  5F 5F 5F 20  
001B38  1  20 20 2F 20          .BYTE   "  / /| ____|/ ____/ _ \__ \ ",$0D,$0A
001B3C  1  2F 7C 20 5F  
001B40  1  5F 5F 5F 7C  
001B56  1  20 2F 20 2F          .BYTE   " / /_| |__ | |   | | | | ) | ",$0D,$0A
001B5A  1  5F 7C 20 7C  
001B5E  1  5F 5F 20 7C  
001B75  1  7C 20 27 5F          .BYTE   "| '_ \___ \| |   | | | |/ / ",$0D,$0A
001B79  1  20 5C 5F 5F  
001B7D  1  5F 20 5C 7C  
001B93  1  7C 20 28 5F          .BYTE   "| (_) |__) | |___| |_| / /_ ",$0D,$0A
001B97  1  29 20 7C 5F  
001B9B  1  5F 29 20 7C  
001BB1  1  20 5C 5F 5F          .BYTE   " \___/____/ \_____\___/____| ",$0D,$0A
001BB5  1  5F 2F 5F 5F  
001BB9  1  5F 5F 2F 20  
001BD0  1  2A 20 4C 6F          .BYTE   "* Low Memory ($1000-$2000) SuperMON 65c02 ",$0D,$0A,$00
001BD4  1  77 20 4D 65  
001BD8  1  6D 6F 72 79  
001BFD  1               
001BFD  1                       .END
