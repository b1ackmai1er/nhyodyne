ca65 V2.18 - Ubuntu 2.19-1
Main file   : monitor.asm
Current file: monitor.asm

000000r 1
000000r 1               ;__MONITOR_______________________________________________________
000000r 1               ; This is a simple monitor program that can be uploaded to the MBC
000000r 1               ; from Z80 mode.
000000r 1               ;
000000r 1               ; It assumes that the 65C02 board is set for IOPage 03.
000000r 1               ; remember that bit A15 is inverted on the board so the dip switch is set to $83.
000000r 1               ;
000000r 1               ; If the SBC is the only CPU in the system, ensure that jumpers
000000r 1               ; J1 and J2 are set for 1&2.   Then burn monrom.hex into EPROM.
000000r 1               ; (note that this monitor does not initialize the UART yet, so this is broken at the moment)
000000r 1               ;
000000r 1               ; If the SBC is secondary to a Z80, the monitor.com file can be run from CP/M or the
000000r 1               ; monitor.hex file can be loaded from the monitor. Ensure that jumpers J1 and J4
000000r 1               ; are set for 2&3, the 6502 toggle IO address is set for $FF and
000000r 1               ; the 65C02 board is set for IOPage 03.
000000r 1               ; remember that bit A15 is inverted on the board so the dip switch is set to $83.
000000r 1               ;
000000r 1               ;
000000r 1               ; to run from the MBC Z80 monitor
000000r 1               ;
000000r 1               ; first set the MPCL to allow RAM in the low bank
000000r 1               ; >O 7C 80
000000r 1               ; >O 78 80
000000r 1               ;
000000r 1               ; then load the .HEX file.
000000r 1               ; >L
000000r 1               ;
000000r 1               ;
000000r 1               ; Finally transfer control to the 65C02 by reading the toggle register
000000r 1               ; >I FF
000000r 1               ;
000000r 1               ; The '02 should reset and run this program
000000r 1               ;
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;
000000r 1               ; DATA CONSTANTS
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;REGISTER		IO PORT		; FUNCTION
000000r 1               IRQVECTOR   =  	$30   		; VECTOR FOR USER IRQ RTN
000000r 1               WORKPTR		=  	$32			; WORK POINTER FOR COMMAND PROCESSOR
000000r 1               JUMPPTR		=	$34			; JUMP VECTOR FOR LOOKUP TABLE
000000r 1               TEMPWORD	=	$36			;
000000r 1               TEMPWORD1	=  	$38			;
000000r 1               TEMPWORD2	=  	$3A			;
000000r 1               TEMPBYTE	=	$3B			;
000000r 1               ACC      	=  	$3D			; ACC STORAGE
000000r 1               XREG     	=  	$3E 		; X REG STORAGE
000000r 1               YREG     	=  	$3F 		; Y REG STORAGE
000000r 1               PREG     	=  	$40 		; CURRENT STACK POINTER
000000r 1               PCL      	=  	$41 		; PROGRAM COUNTER LOW
000000r 1               PCH      	=  	$42 		; PROGRAM COUNTER HIGH
000000r 1               SPTR     	=  	$43 		; CPU STATUS REGISTER
000000r 1               CKSM		=	$44			; CHECKSUM
000000r 1               BYTECT		=	$45			; BYTE COUNT
000000r 1               STRPTR	 	=	$48			;
000000r 1               COUNTER	 	=	$4A			;
000000r 1               SRC	 		=	$4C			;
000000r 1               DEST	 	=	$4E			;
000000r 1               INBUFFER	=	$0200		;
000000r 1
000000r 1               ; UART 16C550 SERIAL -- Assumes IO is in page $03 -- DIP Switch settings $83
000000r 1               UART0       =  	$0368       ; DATA IN/OUT
000000r 1               UART1       =  	$0369       ; CHECK RX
000000r 1               UART2       =  	$036A       ; INTERRUPTS
000000r 1               UART3       =  	$036B       ; LINE CONTROL
000000r 1               UART4       =  	$036C       ; MODEM CONTROL
000000r 1               UART5       =  	$036D       ; LINE STATUS
000000r 1               UART6       =  	$036E       ; MODEM STATUS
000000r 1               UART7	    =  	$036F       ; SCRATCH REG.
000000r 1
000000r 1               ; this is Z80 code that is used to be able to run this as a .COM file.  It is truncated
000000r 1               ; when the various .HEX files are generated
000000r 1               ;
000000r 1                               .segment "LOADER"
000000r 1  F3           		.BYTE 		$F3 			;DI - DISABLE INTERRUPTS
000001r 1  01 00 10     		.BYTE 		$01,$00,$10    	;LD	BC,$1000 -BYTES TO MOVE
000004r 1  11 00 70     		.BYTE 		$11,$00,$70    	;LD	DE,$7000 -DESTINATION ADDRESS (6502 IS !A15)
000007r 1  21 20 01     		.BYTE 		$21,$20,$01	    ;LD	HL,$0120 -SOURCE ADDRESS
00000Ar 1  ED B0        		.BYTE 		$ED,$B0       	;LDIR  		 -COPY RAM
00000Cr 1  DB FF        		.BYTE		$DB,$FF       	;IN 	A,$FF    -ENABLE 6502
00000Er 1  0E 00        		.BYTE		$0E,$00       	;LD	C,00H    -CP/M SYSTEM RESET CALL
000010r 1  CD 05 00     		.BYTE		$CD,$05,$00		;CALL	0005H	 -RETURN TO PROMPT
000013r 1               ;
000013r 1               ;
000013r 1               ;
000013r 1
000013r 1
000013r 1                               .segment "TROM"
000000r 1
000000r 1               ;__COLD_START___________________________________________________
000000r 1               ;
000000r 1               ; PERFORM SYSTEM COLD INIT
000000r 1               ;
000000r 1               ;_______________________________________________________________
000000r 1               COLD_START:
000000r 1  78           		SEI 				; DISABLE INTERRUPTS
000001r 1  D8                   CLD					;  VERIFY DECIMAL MODE IS OFF
000002r 1  A2 FF                LDX   #$FF          ;
000004r 1  9A                   TXS                 ; CLEAR STACK
000005r 1  8A           		txa
000006r 1
000006r 1  A5 rr        		LDA <IRQROUTINE
000008r 1  85 30        		STA IRQVECTOR
00000Ar 1  A5 rr        		LDA >IRQROUTINE
00000Cr 1  85 31        		STA IRQVECTOR+1
00000Er 1
00000Er 1  A9 rr        	  	LDA #<STARTUP		; OUTPUT STARTUP STRING
000010r 1  85 48                STA STRPTR			;
000012r 1  A9 rr                LDA #>STARTUP		;
000014r 1  85 49                STA STRPTR+1		;
000016r 1  20 rr rr             JSR OUTSTR			;
000019r 1
000019r 1  A9 00        		LDA #$00			;
00001Br 1  8D 00 02     		STA INBUFFER		; MAKE SURE INPUT BUFFER IS EMPTY
00001Er 1               							;
00001Er 1  00                   BRK					; PERFORM BRK (START MONITOR)
00001Fr 1
00001Fr 1               ;__BRKROUTINE___________________________________________________
00001Fr 1               ;
00001Fr 1               ; HANDLE CPU BRK INTERRUPT PROCESING AND START MONITOR
00001Fr 1               ;
00001Fr 1               ;_______________________________________________________________
00001Fr 1               BRKROUTINE:
00001Fr 1               							; MONITOR'S BREAK HANDLER
00001Fr 1  18           		CLC
000020r 1  68                   PLA  				;
000021r 1  AA                   TAX           		; LOW BYTE OF PC
000022r 1  68                   PLA 				;
000023r 1  A8           		TAY					; HIGH BYTE OF PC
000024r 1  38           		SEC					;
000025r 1  8A           		TXA					;
000026r 1  E9 02                SBC   #$02     		; REMOVE BREAK INSTRUCTION
000028r 1  85 41                STA   PCL     		;
00002Ar 1  B0 01                BCS   BRK2     		;
00002Cr 1  88                   DEY
00002Dr 1               BRK2:
00002Dr 1  84 42        		STY   PCH       	; SAVE PCH
00002Fr 1  BA                   TSX                 ; GET STACK POINTER
000030r 1  86 43                STX   SPTR          ; SAVE STACK POINTER
000032r 1  20 rr rr             JSR   PRINT_REG     ; DUMP REGISTER CONTENTS
000035r 1  A2 FF                LDX   #$FF          ;
000037r 1  9A                   TXS                 ; CLEAR STACK
000038r 1  58                   CLI                 ; ENABLE INTERRUPTS AGAIN
000039r 1  4C rr rr             JMP   COMMAND_PROCESSOR 	; START THE MONITOR
00003Cr 1
00003Cr 1
00003Cr 1               ;__IRQROUTINE___________________________________________________
00003Cr 1               ;
00003Cr 1               ; HANDLE INTERRUPT PROCESING
00003Cr 1               ;
00003Cr 1               ;_______________________________________________________________
00003Cr 1               IRQROUTINE:
00003Cr 1  58                   CLI                 ; ENABLE INTERRUPTS AGAIN
00003Dr 1  40           		RTI
00003Er 1
00003Er 1               ;__PRINT_REG____________________________________________________
00003Er 1               ;
00003Er 1               ; PRINT OUT REGISTERS ON THE DISPLAY
00003Er 1               ;
00003Er 1               ;_______________________________________________________________
00003Er 1               PRINT_REG:
00003Er 1  A9 rr        	  	LDA #<REGDATA		; OUTPUT HEADER STRING
000040r 1  85 48                STA STRPTR			;
000042r 1  A9 rr            	LDA #>REGDATA		;
000044r 1  85 49             	STA STRPTR+1		;
000046r 1  20 rr rr            	JSR OUTSTR			;
000049r 1  A5 42               	LDA PCH				; OUTPUT PROGRAM COUNTER HIGH BYTE
00004Br 1  20 rr rr            	JSR PRINT_BYTE		;
00004Er 1  A5 41               	LDA PCL				; OUTPUT PROGRAM COUNTER LOW BYTE
000050r 1  20 rr rr            	JSR PRINT_BYTE		;
000053r 1  A9 20               	LDA #$20			; OUTPUT SPACE
000055r 1  20 rr rr            	JSR OUTCH			;
000058r 1  A5 3D               	LDA ACC				; OUTPUT ACCUMULATOR
00005Ar 1  20 rr rr            	JSR PRINT_BYTE		;
00005Dr 1  A9 20               	LDA #$20			; OUTPUT 2 SPACES
00005Fr 1  20 rr rr            	JSR OUTCH			;
000062r 1  A9 20               	LDA #$20			;
000064r 1  20 rr rr            	JSR OUTCH			;
000067r 1  A5 3E        	   	LDA XREG			; OUTPUT X REGISTER
000069r 1  20 rr rr     	   	JSR PRINT_BYTE			;
00006Cr 1  A9 20               	LDA #$20			; OUTPUT 2 SPACES
00006Er 1  20 rr rr            	JSR OUTCH			;
000071r 1  A9 20               	LDA #$20			;
000073r 1  20 rr rr            	JSR OUTCH			;
000076r 1  A5 3F        	   	LDA YREG			; OUTPUT Y REGISTER
000078r 1  20 rr rr     	   	JSR PRINT_BYTE		;
00007Br 1  A9 20               	LDA #$20			; OUTPUT 2 SPACES
00007Dr 1  20 rr rr            	JSR OUTCH       	;
000080r 1  A9 20               	LDA #$20			;
000082r 1  20 rr rr            	JSR OUTCH			;
000085r 1  A5 43               	LDA SPTR			; OUTPUT STACK POINTER
000087r 1  20 rr rr     	   	JSR PRINT_BYTE		;
00008Ar 1  A9 20               	LDA #$20			; OUTPUT 2 SPACES
00008Cr 1  20 rr rr            	JSR OUTCH     		;
00008Fr 1  A9 20               	LDA #$20			;
000091r 1  20 rr rr            	JSR OUTCH			;
000094r 1  A5 40               	LDA PREG			; OUTPUT STATUS REGISTER
000096r 1  20 rr rr     	   	JSR PRINT_BYTE		; OUTPUT IN HEX
000099r 1  A9 2D               	LDA #$2D			; OUTPUT '-'
00009Br 1  20 rr rr            	JSR OUTCH			;
00009Er 1  A5 40               	LDA PREG			; OUTPUT STATUS REGISTER
0000A0r 1  20 rr rr     	   	JSR PRINT_BIN_BYTE	; OUTPUT IN BINARY
0000A3r 1  A9 0D               	LDA #$0D			; PRINT NEW LINE
0000A5r 1  4C rr rr            	JMP OUTCH           ;
0000A8r 1
0000A8r 1               DO_PRINT_REG:
0000A8r 1  00           		BRK
0000A9r 1
0000A9r 1               ;__INTERRUPT____________________________________________________
0000A9r 1               ;
0000A9r 1               ; HANDLE IRQ INTERRUPT AND DETERMINE IF IT IS A BRK OR AN IRQ
0000A9r 1               ;
0000A9r 1               ;_______________________________________________________________
0000A9r 1               INTERRUPT:
0000A9r 1  78           		SEI 				; DISABLE INTERRUPTS
0000AAr 1  84 3F        		STY	YREG			; SAVE Y
0000ACr 1  86 3E               	STX	XREG    		; SAVE X
0000AEr 1  85 3D        		STA	ACC       		; SAVE A
0000B0r 1  68           		PLA					; GET STATUS REGISTER
0000B1r 1  85 40        		STA	PREG			; SAVE STATUS REGISTER
0000B3r 1  29 10               	AND #$10      	    ; MASK BRK
0000B5r 1  D0 03               	BNE BRKCMD     	 	; BRK CMD
0000B7r 1  6C 30 00            	JMP (IRQVECTOR)   	; LET USER ROUTINE HAVE IT (USER DEFINED IRQ)
0000BAr 1               BRKCMD:
0000BAr 1  4C rr rr     		JMP BRKROUTINE 		; MONITOR BRK ROUTINE
0000BDr 1
0000BDr 1
0000BDr 1               ;__COMMAND_PROCESSOR____________________________________________
0000BDr 1               ;
0000BDr 1               ; PROMPT FOR, INPUT, AND PROCESS INCOMMING USER COMMANDS
0000BDr 1               ;
0000BDr 1               ;_______________________________________________________________
0000BDr 1               COMMAND_PROCESSOR:
0000BDr 1
0000BDr 1  20 rr rr     	 	JSR DISPLAY_PROMPT	; PRINT PROMPT STRING
0000C0r 1  A9 00        	    LDA #<INBUFFER		; SETUP INPUT COMMAND BUFFER
0000C2r 1  85 48             	STA STRPTR			;
0000C4r 1  A9 02             	LDA #>INBUFFER		;
0000C6r 1  85 49             	STA STRPTR +1 		;
0000C8r 1
0000C8r 1  20 rr rr          	JSR INSTR			; GET A STRING FROM THE CONSOLE
0000CBr 1
0000CBr 1  A9 0D             	LDA #$0D			;
0000CDr 1  20 rr rr          	JSR OUTCH			;
0000D0r 1  A9 0A             	LDA #$0A			;
0000D2r 1  20 rr rr          	JSR OUTCH			;
0000D5r 1
0000D5r 1
0000D5r 1  A0 00        		LDY #$00			; SET INDEX = 0
0000D7r 1
0000D7r 1  A9 rr        	    LDA #<COMMAND_LOOKUP_TABLE 	; SETUP INPUT COMMAND POINTER
0000D9r 1  85 32             	STA WORKPTR			;
0000DBr 1  A9 rr             	LDA #>COMMAND_LOOKUP_TABLE	;
0000DDr 1  85 33             	STA WORKPTR +1 		;
0000DFr 1  B9 00 02             LDA INBUFFER,Y		; MOVE FIRST BYTE OF COMMAND BUFFER TO ACC
0000E2r 1  C9 00                CMP #$00			; IS NULL?
0000E4r 1  F0 D7                BEQ COMMAND_PROCESSOR		; YES, GET NEXT COMMAND
0000E6r 1
0000E6r 1               COMMAND_PROCESSOR_CMP:
0000E6r 1  A2 00               	LDX #$00			; X=0
0000E8r 1  B9 00 02     		LDA INBUFFER,Y		; ACC= NEXT BYTE OF INPUT BUFFER
0000EBr 1  C1 32        		CMP (WORKPTR,X)		; DOES NEXT BYTE OF INPUT BUFFER MATCH NEXT BYTE OF LOOKUP TABLE
0000EDr 1  D0 1A        		BNE CMD_PROCESOR_NEXT_CMD	; NO, GO TO NEXT COMMAND IN LOOKUP TABLE
0000EFr 1  C8           		INY					; YES, Y=Y+1
0000F0r 1  B9 00 02     		LDA INBUFFER,Y		; LOAD NEXT BYTE OF INPUT BUFFER
0000F3r 1  C9 20        		CMP #$20			; IS IT A SPACE (SINGALING END OF COMMAND)
0000F5r 1  F0 33        		BEQ CMD_PROCESSOR_MATCH_FOUND	; YES, POSSIBLE MATCH FOUND
0000F7r 1  C9 00        		CMP #$00			; IS IT A NULL (SINGALING END OF COMMAND)
0000F9r 1  F0 2F        		BEQ CMD_PROCESSOR_MATCH_FOUND	; YES, POSSIBLE MATCH FOUND
0000FBr 1  20 rr rr     		JSR INCWORKPTR		; NO, INCREMENT POINTER TO LOOKUP TABLE
0000FEr 1  A2 00        		LDX #$00			;
000100r 1  A1 32        	   	LDA (WORKPTR,X)		; A= NEXT BYTE OF LOOKUP TABLE
000102r 1  C9 00        		CMP #$00			; IS IT A NULL? (SIGNALING END OF TABLE ENTRY)
000104r 1  F0 0E        		BEQ CMD_PROCESOR_NEXT_CMD1	; YES, ADVANCE TO NEXT COMMAND IN TABLE
000106r 1  4C rr rr     		JMP COMMAND_PROCESSOR_CMP	; LOOP TO CHECK NEXT CHAR
000109r 1
000109r 1               CMD_PROCESOR_NEXT_CMD:
000109r 1  20 rr rr     		JSR INCWORKPTR		; INCREMENT POINTER TO LOOKUP TABLE
00010Cr 1  A2 00        		LDX #$00			;
00010Er 1  A1 32        	   	LDA (WORKPTR,X)		; A = NEXT BYTE OF LOOKUP TABLE
000110r 1  C9 00        		CMP #$00			; IS IT A NULL?
000112r 1  D0 F5        		BNE CMD_PROCESOR_NEXT_CMD	; NO, LOOP
000114r 1
000114r 1               CMD_PROCESOR_NEXT_CMD1:
000114r 1  20 rr rr     		JSR INCWORKPTR		; INCREMENT POINTER TO LOOKUP TABLE
000117r 1  20 rr rr     		JSR INCWORKPTR		; INCREMENT POINTER TO LOOKUP TABLE
00011Ar 1  20 rr rr     		JSR INCWORKPTR		; INCREMENT POINTER TO LOOKUP TABLE
00011Dr 1  A2 00        	   	LDX #$00			;
00011Fr 1  A1 32        	   	LDA (WORKPTR,X)		; A = NEXT BYTE OF LOOKUP TABLE
000121r 1  C9 01        		CMP #$01			; IS IT $01 (SINGALING END OF LOOKUP TABLE)
000123r 1  F0 28        		BEQ CMD_PROCESOR_NOT_FOUND	; YES, DISPLAY NOT FOUND MESSAGE
000125r 1  A0 00        		LDY #$00			; NO RESET INPUT BUFFER COUNTER
000127r 1  4C rr rr     		JMP COMMAND_PROCESSOR_CMP	; LOOP
00012Ar 1
00012Ar 1               CMD_PROCESSOR_MATCH_FOUND:
00012Ar 1  20 rr rr     		JSR INCWORKPTR		; INCREMENT POINTER TO LOOKUP TABLE
00012Dr 1  A2 00        	   	LDX #$00			;
00012Fr 1  A1 32        	   	LDA (WORKPTR,X)		; A = NEXT BYTE OF LOOKUP TABLE
000131r 1  C9 00        		CMP #$00			; IS IT A NULL?
000133r 1  D0 D4        		BNE CMD_PROCESOR_NEXT_CMD	; NO, TRY NEXT COMMAND
000135r 1  20 rr rr     		JSR INCWORKPTR		; YES, INCREMENT POINTER TO LOOKUP TABLE
000138r 1  A2 00        		LDX #$00			;
00013Ar 1  A1 32        		LDA (WORKPTR,X)		; A = NEXT BYTE OF LOOKUP TABLE
00013Cr 1  85 34        		STA JUMPPTR			; STORE A INTO LOW BYTE OF JUMP VECTOR
00013Er 1  20 rr rr     		JSR INCWORKPTR		; INCREMENT POINTER TO LOOKUP TABLE
000141r 1  A2 00        		LDX #$00			;
000143r 1  A1 32        		LDA (WORKPTR,X)		; A = NEXT BYTE OF LOOKUP TABLE
000145r 1  85 35        		STA JUMPPTR+1		; INCREMENT POINTER TO LOOKUP TABLE
000147r 1  20 rr rr     		JSR CMD_PROCESOR_RUN		; RUN COMMAND
00014Ar 1  4C rr rr     		JMP COMMAND_PROCESSOR		; GET NEXT COMMAND
00014Dr 1
00014Dr 1               CMD_PROCESOR_NOT_FOUND:
00014Dr 1  A9 rr        		LDA #<ERROR 		; LOAD LOW BYTE OF ERROR STRING
00014Fr 1  85 48             	STA STRPTR			; STORE IN POINTER LOW BYTE
000151r 1  A9 rr             	LDA #>ERROR		    ; LOAD HIGH BYTE OF ERROR STRING
000153r 1  85 49             	STA STRPTR +1 		; STORE IN POINTER HIGH BYTE
000155r 1
000155r 1  20 rr rr          	JSR OUTSTR			; OUTPUT THE STRING
000158r 1  4C rr rr     		JMP COMMAND_PROCESSOR		;
00015Br 1               CMD_PROCESOR_RUN:
00015Br 1  6C 34 00     		JMP (JUMPPTR)		; JUMP TO COMMAND VECTOR
00015Er 1
00015Er 1
00015Er 1               ;__LOAD_________________________________________________________
00015Er 1
00015Er 1               ; LOAD A MOTOROLA FORMATTED HEX FILE
00015Er 1               ;
00015Er 1               ;_______________________________________________________________
00015Er 1               LOAD:
00015Er 1  20 rr rr     		JSR	IOF_CONINW			;
000161r 1  C9 53        		CMP	#'S'				;
000163r 1  D0 F9        		BNE	LOAD				; FIRST CHAR NOT (S)
000165r 1  20 rr rr     		JSR	IOF_CONINW			; READ CHAR
000168r 1  C9 39        		CMP	#'9'				;
00016Ar 1  F0 2C        		BEQ	LOAD21				;
00016Cr 1  C9 31        		CMP	#'1'				;
00016Er 1  D0 EE        		BNE	LOAD				; SECOND CHAR NOT (1)
000170r 1  A9 00        		LDA	#$00				;
000172r 1  85 44        		STA	CKSM				; ZERO CHECKSUM
000174r 1  20 rr rr     		JSR	GETBYTE				; READ BYTE
000177r 1  E9 01        		SBC	#$01				;
000179r 1  85 45        		STA	BYTECT				; BYTE COUNT
00017Br 1  20 rr rr     		JSR	BADDR				; BUILD ADDRESS
00017Er 1  A0 00        		LDY	#$00				;
000180r 1               LOAD11:
000180r 1  20 rr rr     		JSR	GETBYTE				;
000183r 1  C6 45        		DEC	BYTECT				;
000185r 1  F0 08        		BEQ	LOAD15				; ZERO BYTE COUNT
000187r 1  91 38        		STA	(TEMPWORD1),Y		; STORE DATA
000189r 1  20 rr rr     		JSR 	INCTEMPWORD		;
00018Cr 1  4C rr rr     		JMP	LOAD11				;
00018Fr 1
00018Fr 1               LOAD15:
00018Fr 1  E6 44        		INC	CKSM				;
000191r 1  F0 CB        		BEQ	LOAD				;
000193r 1               LOAD19:
000193r 1  A9 3F        		LDA	#'?'				;
000195r 1  20 rr rr     		JSR	OUTCH				;
000198r 1               LOAD21:
000198r 1  60           		RTS
000199r 1               GETBYTE:
000199r 1  20 rr rr     		JSR	INHEX				; GET HEX CHAR
00019Cr 1  0A           		ASL						;
00019Dr 1  0A           		ASL						;
00019Er 1  0A           		ASL						;
00019Fr 1  0A           		ASL						;
0001A0r 1  85 3B        		STA	TEMPBYTE			;
0001A2r 1  20 rr rr     		JSR	INHEX				;
0001A5r 1  29 0F        		AND	#$0F				; MASK TO 4 BITS
0001A7r 1  05 3B        		ORA	TEMPBYTE			;
0001A9r 1  48           		PHA						;
0001AAr 1  18           		CLC						;
0001ABr 1  65 44        		ADC	CKSM				;
0001ADr 1  85 44        		STA	CKSM				;
0001AFr 1  68           		PLA						;
0001B0r 1  60           		RTS						;
0001B1r 1               ; INPUT HEX CHAR
0001B1r 1               INHEX:
0001B1r 1  20 rr rr     		JSR	IOF_CONINW			;
0001B4r 1  48           		PHA						;
0001B5r 1  20 rr rr     		JSR	OUTCH				;
0001B8r 1  68           		PLA						;
0001B9r 1  C9 3A            	CMP #$3A  				; LESS THAN 9?
0001BBr 1  B0 02              	BCS INHEX_BIG  			; NO, SKIP NEXT
0001BDr 1  E9 2F              	SBC #$2F  				; CONVERT 0-9
0001BFr 1               INHEX_BIG:
0001BFr 1  C9 41        		CMP #$41  				; A OR MORE?
0001C1r 1  90 02              	BCC INHEX_SMALL 		; NO, SKIP NEXT
0001C3r 1  E9 37              	SBC #$37  				; CONVERT A-F
0001C5r 1               INHEX_SMALL:
0001C5r 1  60           		RTS						;
0001C6r 1
0001C6r 1               ; BUILD ADDRESS
0001C6r 1               BADDR:
0001C6r 1  20 rr rr     		JSR	GETBYTE				; READ 2 FRAMES
0001C9r 1  85 39        		STA	TEMPWORD1+1			;
0001CBr 1  20 rr rr     		JSR	GETBYTE				;
0001CEr 1  85 38        		STA	TEMPWORD1			;
0001D0r 1  60           		RTS
0001D1r 1
0001D1r 1
0001D1r 1               ;__GO______________________________________________________
0001D1r 1               ;
0001D1r 1               ; GO COMMAND
0001D1r 1               ;
0001D1r 1               ; GO XXXX
0001D1r 1               ;_______________________________________________________________
0001D1r 1               GO:
0001D1r 1
0001D1r 1  A9 00        	    LDA #<INBUFFER 		   	; SETUP WORK BUFFER
0001D3r 1  85 32                STA WORKPTR				;
0001D5r 1  A9 02                LDA #>INBUFFER		    ;
0001D7r 1  85 33                STA WORKPTR +1 			;
0001D9r 1
0001D9r 1  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "G"
0001DCr 1  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "O"
0001DFr 1
0001DFr 1  20 rr rr     		JSR EATWHITESPACE		; SKIP OVER THE WHITESPACE
0001E2r 1  20 rr rr     		JSR GETNUMBER			; GET THE STARTING ADDRESS
0001E5r 1  B0 53        		BCS DUMP_ERROR			; IF NOT A NUMBER, REPORT ERROR
0001E7r 1
0001E7r 1  6C 36 00     		JMP (TEMPWORD)			;
0001EAr 1
0001EAr 1
0001EAr 1
0001EAr 1
0001EAr 1               ;__DUMPMEM______________________________________________________
0001EAr 1               ;
0001EAr 1               ; DUMP MEMORY COMMAND
0001EAr 1               ;
0001EAr 1               ; DUMP XXXX (XXXX)
0001EAr 1               ;_______________________________________________________________
0001EAr 1               DUMP:
0001EAr 1
0001EAr 1  A9 00        	    LDA #<INBUFFER 		   	; SETUP WORK BUFFER
0001ECr 1  85 32                STA WORKPTR				;
0001EEr 1  A9 02                LDA #>INBUFFER		    ;
0001F0r 1  85 33                STA WORKPTR +1 			;
0001F2r 1
0001F2r 1  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "D"
0001F5r 1  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "U"
0001F8r 1  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "M"
0001FBr 1  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "P"
0001FEr 1
0001FEr 1  20 rr rr     		JSR EATWHITESPACE		; SKIP OVER THE WHITESPACE
000201r 1  20 rr rr     		JSR GETNUMBER			; GET THE STARTING ADDRESS
000204r 1  B0 34        		BCS DUMP_ERROR			; IF NOT A NUMBER, REPORT ERROR
000206r 1
000206r 1  A5 36        		LDA TEMPWORD			; STORE STARTING ADDRESS IN WORD POINTER (TEMPWORD1)
000208r 1  85 38        		STA TEMPWORD1			;
00020Ar 1  A5 37        		LDA TEMPWORD+1			;
00020Cr 1  85 39        		STA TEMPWORD1+1			;
00020Er 1
00020Er 1  20 rr rr     		JSR EATWHITESPACE		; SKIP OVER ANY WHITESPACE
000211r 1  20 rr rr     		JSR GETNUMBER			; GET THE ENDING ADDRESS
000214r 1  B0 24        		BCS DUMP_ERROR			; IF NOT A NUMBER, REPORT ERROR
000216r 1
000216r 1  A5 38        		LDA TEMPWORD1			; STORE ENDING ADDRESS IN WORD POINTER (WORKPTR)
000218r 1  85 32        		STA WORKPTR				;
00021Ar 1  A5 39        		LDA TEMPWORD1+1			;
00021Cr 1  85 33        		STA WORKPTR+1			;
00021Er 1               DUMP_LOOP:
00021Er 1  20 rr rr     	    JSR PRINT_MEM_LINE		;
000221r 1  A9 0D        	    LDA #$0D				;
000223r 1  20 rr rr     	    JSR OUTCH				;
000226r 1  A9 0A        	    LDA #$0A				;
000228r 1  20 rr rr     	    JSR OUTCH				;
00022Br 1  A5 33                LDA WORKPTR+1  			; COMPARE HIGH BYTES
00022Dr 1  C5 37                CMP TEMPWORD+1
00022Fr 1  90 ED                BCC DUMP_LOOP 			; IF NUM1H < NUM2H THEN NUM1 < NUM2
000231r 1  D0 06                BNE DUMP_DONE			; IF NUM1H <> NUM2H THEN NUM1 > NUM2 (SO NUM1 >= NUM2)
000233r 1  A5 32                LDA WORKPTR  			; COMPARE LOW BYTES
000235r 1  C5 36                CMP TEMPWORD
000237r 1  90 E5                BCC DUMP_LOOP			; IF NUM1L < NUM2L THEN NUM1 < NUM2
000239r 1               DUMP_DONE:
000239r 1  60           		RTS
00023Ar 1               DUMP_ERROR:
00023Ar 1  4C rr rr     		JMP INVALID_NUMBER_ERROR
00023Dr 1
00023Dr 1
00023Dr 1
00023Dr 1               ;__ENTERMEM_____________________________________________________
00023Dr 1               ;
00023Dr 1               ; ENTER MEMORY COMMAND
00023Dr 1               ;
00023Dr 1               ; ENTER XXXX (XX XX XX XX XX XX XX XX XX XX XX XX XX XX )
00023Dr 1               ;_______________________________________________________________
00023Dr 1               ENTERMEM:
00023Dr 1
00023Dr 1  A9 00        	    LDA #<INBUFFER 			; SETUP WORK BUFFER
00023Fr 1  85 32                STA WORKPTR				;
000241r 1  A9 02                LDA #>INBUFFER		    ;
000243r 1  85 33                STA WORKPTR +1 			;
000245r 1
000245r 1  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "E"
000248r 1  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "N"
00024Br 1  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "T"
00024Er 1  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "E"
000251r 1  20 rr rr     		JSR INCWORKPTR			; JUMP OVER "R"
000254r 1
000254r 1  20 rr rr     		JSR EATWHITESPACE		; SKIP OVER ANY WHITESPACE
000257r 1  20 rr rr     		JSR GETNUMBER			; GET NUMBER
00025Ar 1  B0 67        		BCS ENTER_ERROR			; IF NOT A NUMBER REPORT ERROR
00025Cr 1
00025Cr 1  A5 36        		LDA TEMPWORD			; STORE ADDRESS INTO WORD POINTER (TEMPWORD1)
00025Er 1  85 38        		STA TEMPWORD1			;
000260r 1  A5 37        		LDA TEMPWORD+1			;
000262r 1  85 39        		STA TEMPWORD1+1			;
000264r 1  A0 00        		LDY #$00				; RESET COUNTER TO 0
000266r 1               ENTERLOOP:
000266r 1  A2 00        		LDX #$00				;
000268r 1  A1 32        		LDA (WORKPTR,X)			; GET NEXT BYTE FROM BUFFER
00026Ar 1  C9 00        		CMP #$00				; IS NULL?
00026Cr 1  F0 10        		BEQ ENTER_DONE			; YES, WE'RE DONE
00026Er 1  20 rr rr     		JSR EATWHITESPACE		; SKIP OVER ANY WHITESPACE
000271r 1  20 rr rr     		JSR GETNUMBER			; GET NEXT NUMBER
000274r 1  B0 4D        		BCS ENTER_ERROR			; IF NOT A NUMBER REPORT ERROR
000276r 1  A5 36        		LDA TEMPWORD			; STORE BYTE IN ADDRESS (INDEXED BY Y)
000278r 1  91 38        		STA (TEMPWORD1),Y		;
00027Ar 1  C8           		INY						; GO TO NEXT BYTE
00027Br 1  4C rr rr     		JMP ENTERLOOP			; LOOP
00027Er 1               ENTER_DONE:
00027Er 1  C0 00        		CPY #$00				; WAS LINE BLANK?
000280r 1  D0 01        		BNE ENTER_CONTINUE		; NO, PREPARE FOR NEXT LINE
000282r 1  60           		RTS						; YES, END DATA ENTRY
000283r 1               ENTER_CONTINUE:
000283r 1  A9 0D        		LDA #$0D				;
000285r 1  20 rr rr     		JSR OUTCH				;
000288r 1  A9 0A        		LDA #$0A				;
00028Ar 1  20 rr rr     		JSR OUTCH
00028Dr 1  A9 3A        		LDA #$3A				; OUTPUT ":" TO SCREEN
00028Fr 1  20 rr rr     		JSR OUTCH				;
000292r 1  18           		CLC						; CLEAR CARRY
000293r 1  98           		TYA						; A=Y (LAST COUNTER)
000294r 1  65 38        		ADC TEMPWORD1			; ADD LAST COUNT TO BEGINNING POINTER
000296r 1  85 38        		STA TEMPWORD1			; STORE RESULT IN BEGINNING POINTER
000298r 1  D0 02        		BNE ENTER_INCREMENT		; NOT ZERO?, DONE
00029Ar 1  E6 39        		INC TEMPWORD1+1			; ZERO, INC HIGH BYTE
00029Cr 1               ENTER_INCREMENT:
00029Cr 1  A5 39        		LDA TEMPWORD1+1			; PRINTOUT STARTING ADDRESS TO SCREEN
00029Er 1  20 rr rr     		JSR PRINT_BYTE			; (HIGH)
0002A1r 1  A5 38        		LDA TEMPWORD1			;
0002A3r 1  20 rr rr     		JSR PRINT_BYTE			; (LOW)
0002A6r 1  A9 20        		LDA #$20				; OUTPUT SPACE TO SCREEN
0002A8r 1  20 rr rr     		JSR OUTCH				;
0002ABr 1  A9 00        	    LDA #<INBUFFER 		   	; SETUP INPUT COMMAND BUFFER
0002ADr 1  85 48                STA STRPTR				;
0002AFr 1  A9 02                LDA #>INBUFFER 		 	;
0002B1r 1  85 49                STA STRPTR +1 			;
0002B3r 1  20 rr rr             JSR INSTR				; GET A STRING FROM THE CONSOLE
0002B6r 1  A9 00        	    LDA #<INBUFFER 		   	; SETUP WORK BUFFER
0002B8r 1  85 32                STA WORKPTR				;
0002BAr 1  A9 02                LDA #>INBUFFER 		    ;
0002BCr 1  85 33                STA WORKPTR +1 			;
0002BEr 1  A0 00                LDY #$00 				;
0002C0r 1  4C rr rr             JMP ENTERLOOP			; LOOP
0002C3r 1
0002C3r 1
0002C3r 1               ENTER_ERROR:
0002C3r 1  4C rr rr     		JMP INVALID_NUMBER_ERROR
0002C6r 1
0002C6r 1               ;__PRINT_MEM_LINE_______________________________________________
0002C6r 1               ;
0002C6r 1               ; PRINT MEMORY DUMP LINE
0002C6r 1               ;
0002C6r 1               ; PRINT 16 HEX LOCATIONS STARTING WITH ADDRESS WORKPTR
0002C6r 1               ;_______________________________________________________________
0002C6r 1               PRINT_MEM_LINE:
0002C6r 1  A9 3A        		LDA #$3A				; LOAD ':' INTO ACC
0002C8r 1  20 rr rr     		JSR OUTCH				; PRINT ':'
0002CBr 1  A5 33            	LDA WORKPTR+1			; PRINT ADDRESS
0002CDr 1  20 rr rr     	    JSR PRINT_BYTE			;
0002D0r 1  A5 32              	LDA WORKPTR				;
0002D2r 1  20 rr rr     	    JSR PRINT_BYTE			;
0002D5r 1  A9 2D         	    LDA #$2D				; LOAD '-'
0002D7r 1  20 rr rr     	    JSR OUTCH				; PRINT '-'
0002DAr 1  A0 00        	    LDY #$00				;
0002DCr 1               PRINT_MEM_LINE_LOOP:
0002DCr 1  B1 32        		LDA (WORKPTR),Y			; LOAD NEXT BYTE
0002DEr 1  20 rr rr     		JSR PRINT_BYTE	       	; PRINT BYTE
0002E1r 1  A9 20         	    LDA #$20				; LOAD ' '
0002E3r 1  20 rr rr     	    JSR OUTCH				; PRINT ' '
0002E6r 1  C8           	    INY						; INCREMENT COUNTER
0002E7r 1  C0 10        	    CPY #$10				; HAVE WE PRINTED 16 ADDRESSES
0002E9r 1  D0 F1        	    BNE PRINT_MEM_LINE_LOOP	; NO, LOOP
0002EBr 1  A9 3A        		LDA #$3A				; LOAD ':' INTO ACC
0002EDr 1  20 rr rr     		JSR OUTCH				; PRINT ':'
0002F0r 1  A2 00                LDX #$00				;
0002F2r 1  A0 00        		LDY #$00				;
0002F4r 1               PRINT_MEM_LINE_LOOP_ASCII:
0002F4r 1  A1 32        		LDA (WORKPTR,X)			; GET NEXT BYTE
0002F6r 1  20 rr rr     		JSR OUTASCII			; PRINT ASCII VALUE OF BYTE
0002F9r 1  C8           		INY						; INCREMENT COUNTER
0002FAr 1  20 rr rr     		JSR INCWORKPTR			; INCREMENT BUFFER POINTER
0002FDr 1  C0 10        	    CPY #$10				; HAVE WE PRINTED 16 ADDRESSES
0002FFr 1  D0 F3        	    BNE PRINT_MEM_LINE_LOOP_ASCII	; NO, LOOP
000301r 1  A9 0D        	    LDA #$0D				; YES, PRINT CR
000303r 1  20 rr rr     	    JSR OUTCH				;
000306r 1  60           	    RTS						; RETURN
000307r 1
000307r 1
000307r 1
000307r 1               ;__DISPLAY_PROMPT______________________________________________
000307r 1               ;
000307r 1               ; DISPLAY THE INPUT PROMPT ON THE SCREEN
000307r 1               ;
000307r 1               ;______________________________________________________________
000307r 1               DISPLAY_PROMPT:
000307r 1  A9 rr        		LDA #<PROMPT 			; LOAD LOW BYTE OF PROMPT STRING
000309r 1  85 48                STA STRPTR				; STORE IN POINTER LOW BYTE
00030Br 1  A9 rr                LDA #>PROMPT 		    ; LOAD HOGH BYTE OF PROMPR STRING
00030Dr 1  85 49                STA STRPTR +1 			; STORE IN POINTER HIGH BYTE
00030Fr 1
00030Fr 1  4C rr rr             JMP OUTSTR				; OUTPUT THE STRING
000312r 1
000312r 1
000312r 1               ;__INCWORKPTR___________________________________________________
000312r 1               ; INCREMENT THE 16BIT WORK POINTER
000312r 1               ;
000312r 1               ;
000312r 1               ;
000312r 1               ;_______________________________________________________________
000312r 1               INCWORKPTR:
000312r 1  E6 32        		INC WORKPTR				; INCREMENT LOWBYTE
000314r 1  D0 02        		BNE INCWORKPTR_OUT		; NOT ZERO?, DONE
000316r 1  E6 33        		INC WORKPTR+1			; ZERO, INC HIGH BYTE
000318r 1               INCWORKPTR_OUT:
000318r 1  60           		RTS						; RETURN
000319r 1
000319r 1
000319r 1               ;__INCTEMPWORD__________________________________________________
000319r 1               ;
000319r 1               ; INCREMENT THE 16BIT WORK POINTER
000319r 1               ;
000319r 1               ;_______________________________________________________________
000319r 1               INCTEMPWORD:
000319r 1  E6 38        		INC TEMPWORD1			; INCREMENT LOWBYTE
00031Br 1  D0 02        		BNE INCTEMPWORD_OUT		; NOT ZERO?, DONE
00031Dr 1  E6 39        		INC TEMPWORD1+1			; ZERO, INC HIGH BYTE
00031Fr 1               INCTEMPWORD_OUT:
00031Fr 1  60           		RTS						; RETURN
000320r 1
000320r 1               ;__INCTEMPWORD2__________________________________________________
000320r 1               ;
000320r 1               ; INCREMENT THE 16BIT WORK POINTER
000320r 1               ;
000320r 1               ;
000320r 1               ;_______________________________________________________________
000320r 1               INCTEMPWORD2:
000320r 1  E6 3A        		INC TEMPWORD2			; INCREMENT LOWBYTE
000322r 1  D0 02        		BNE INCTEMPWORD2_OUT	; NOT ZERO?, DONE
000324r 1  E6 3B        		INC TEMPWORD2+1			; ZERO, INC HIGH BYTE
000326r 1               INCTEMPWORD2_OUT:
000326r 1  60           		RTS						; RETURN
000327r 1
000327r 1
000327r 1
000327r 1               ;__OUTASCII_____________________________________________________
000327r 1               ;
000327r 1               ; PRINT CHAR IF VALID, ELSE PRINT '.'
000327r 1               ;
000327r 1               ;_______________________________________________________________
000327r 1               OUTASCII:
000327r 1  C9 20        		CMP #$20				; IS < 20
000329r 1  30 07        		BMI OUTASCII_DOT		; YES, SKIP
00032Br 1  C9 7E        		CMP #$7E				; IS >7E
00032Dr 1  10 03        		BPL OUTASCII_DOT		; YES, SKIP
00032Fr 1  4C rr rr     		JMP OUTCH				; NO, PRINT CHAR AND RETURN
000332r 1               OUTASCII_DOT:
000332r 1  A9 2E        		LDA #$2E				; A= '.'
000334r 1  4C rr rr     		JMP OUTCH				; PRINT '.' AND RETURN
000337r 1
000337r 1
000337r 1
000337r 1               ;__INVALID_NUMBER_ERROR__________________________________________
000337r 1               ;
000337r 1               ; PRINT "INVALID HEX NUMBER MESSAGE"
000337r 1               ;
000337r 1               ;_______________________________________________________________
000337r 1               INVALID_NUMBER_ERROR:
000337r 1  A9 rr        		LDA #<INERROR 			; LOAD LOW BYTE OF ERROR STRING
000339r 1  85 48                STA STRPTR				; STORE IN POINTER LOW BYTE
00033Br 1  A9 rr                LDA #>INERROR		    ; LOAD HOGH BYTE OF ERROR STRING
00033Dr 1  85 49                STA STRPTR +1 			; STORE IN POINTER HIGH BYTE
00033Fr 1  4C rr rr             JMP OUTSTR				; OUTPUT THE STRING
000342r 1
000342r 1
000342r 1               ;__GETNUMBER______________________________________________________
000342r 1               ;
000342r 1               ; GET ASCII NUMBER FROM BUFFER AND PARSE INTO TEMPWORD
000342r 1               ;
000342r 1               ;_______________________________________________________________
000342r 1               GETNUMBER:
000342r 1  A9 00        		LDA #$00				;
000344r 1  85 36        		STA TEMPWORD			; CLEAR OUT TEMPWORD (OUTPUT OF GETNUMBER)
000346r 1  85 37        		STA TEMPWORD+1			;
000348r 1  A2 00        		LDX #$00				;
00034Ar 1               GETNUMBER_LOOP:
00034Ar 1  A1 32        		LDA (WORKPTR,X)			; GET NEXT BYTE FROM BUFFER
00034Cr 1  C9 20        		CMP #$20				; IS SPACE?
00034Er 1  F0 31        		BEQ GETNUMBER_DONE		; YES, WE'RE DONE
000350r 1  C9 00        		CMP #$00				; IS NULL?
000352r 1  F0 2D        		BEQ GETNUMBER_DONE		; YES, WE'RE DONE
000354r 1  C9 2C        		CMP #$2C				; IS ","?
000356r 1  F0 29        		BEQ GETNUMBER_DONE		; YES, WE'RE DONE
000358r 1  C9 29        		CMP #$29				; IS ")"?
00035Ar 1  F0 25        		BEQ GETNUMBER_DONE		; YES, WE'RE DONE
00035Cr 1  20 rr rr     		JSR HEXIN				; GET HEX DIGIT
00035Fr 1  B0 1E        		BCS GETNUMBER_ERROR		; IS INVALID DIGIT?, YES PRINT ERROR AND ABORT
000361r 1  18           		CLC						; CLEAR CARRY
000362r 1  26 36        		ROL TEMPWORD			; MOVE WORD OVER 4 BITS TO LEFT
000364r 1  26 37        		ROL TEMPWORD+1			;
000366r 1  18           		CLC						;
000367r 1  26 36        		ROL TEMPWORD			;
000369r 1  26 37        		ROL TEMPWORD+1			;
00036Br 1  18           		CLC						;
00036Cr 1  26 36        		ROL TEMPWORD			;
00036Er 1  26 37        		ROL TEMPWORD+1			;
000370r 1  18           		CLC						;
000371r 1  26 36        		ROL TEMPWORD			;
000373r 1  26 37        		ROL TEMPWORD+1			;
000375r 1  05 36        		ORA TEMPWORD			; ADD IN NEW DIGIT
000377r 1  85 36        		STA TEMPWORD			; STORE BACK TO TEMPWORD
000379r 1  20 rr rr     		JSR INCWORKPTR			; INCREMENT BUFFER POINTER
00037Cr 1  4C rr rr     		JMP GETNUMBER_LOOP		; LOOP
00037Fr 1               GETNUMBER_ERROR:
00037Fr 1  38           		SEC						; SET ERROR FLAG (CARRY)
000380r 1  60           		RTS						; RETURN
000381r 1               GETNUMBER_DONE:
000381r 1  18           		CLC						; CLEAR ERROR FLAG (CARRY)
000382r 1  60           		RTS						; RETURN
000383r 1
000383r 1               ;__HEXIN________________________________________________________
000383r 1               ;
000383r 1               ; GET NEXT CHAR FROM INPUT BUFFER AND CHANGE TO HEX DIGIT
000383r 1               ;
000383r 1               ; IF INVALID, SET CARRY FLAG
000383r 1               ;_______________________________________________________________
000383r 1               HEXIN:
000383r 1  A2 00        		LDX #$00				;
000385r 1  A1 32        		LDA (WORKPTR,X)			; GET NEXT CHAR FROM BUFFER
000387r 1  C9 3A              	CMP #$3A  				; LESS THAN 9?
000389r 1  B0 02              	BCS HEXIN_BIG  			; NO, SKIP NEXT
00038Br 1  E9 2F              	SBC #$2F  				; CONVERT 0-9
00038Dr 1               HEXIN_BIG:
00038Dr 1  C9 41        		CMP #$41  				; A OR MORE?
00038Fr 1  90 02              	BCC HEXIN_SMALL 		; NO, SKIP NEXT
000391r 1  E9 37              	SBC #$37  				; CONVERT A-F
000393r 1               HEXIN_SMALL:
000393r 1  C9 10        		CMP #$10  				; RESULT TOO BIG?
000395r 1  60                 	RTS
000396r 1
000396r 1
000396r 1               ;__EATWHITESPACE___________________________________________________
000396r 1               ;
000396r 1               ; FORWARD THE BUFFER POINTER PAST ANY WHITE SPACE IN THE INPUT BUFFER
000396r 1               ;
000396r 1               ;_______________________________________________________________
000396r 1               EATWHITESPACE:
000396r 1  A2 00        		LDX #$00				;
000398r 1  A1 32        		LDA (WORKPTR,X)			; GET NEXT CHAR FROM BUFFER
00039Ar 1  C9 20        		CMP #$20				; IS SPACE
00039Cr 1  D0 06        		BNE EATWHITESPACE_OUT	; NO, DONE
00039Er 1  20 rr rr     		JSR INCWORKPTR			; YES, INCREMENT BUFFER POINTER
0003A1r 1  4C rr rr     		JMP EATWHITESPACE		; LOOP
0003A4r 1               EATWHITESPACE_OUT:
0003A4r 1  60           		RTS						; RETURN
0003A5r 1
0003A5r 1
0003A5r 1               ;__PRINT_BYTE__________________________________________________
0003A5r 1               ;
0003A5r 1               ; PRINT OUT ACCUMULATOR AS HEX NUMBER
0003A5r 1               ;
0003A5r 1               ;______________________________________________________________
0003A5r 1               PRINT_BYTE:
0003A5r 1  AA           		TAX						; SAVE A REGISTER
0003A6r 1  4A           		LSR 					; SHIFT HIGH NIBBLE TO LOW NIBBLE
0003A7r 1  4A           		LSR 					;
0003A8r 1  4A           		LSR 					;
0003A9r 1  4A           		LSR 					;
0003AAr 1  18           		CLC              		; CLEAR CARRY
0003ABr 1  20 rr rr     		JSR PRINT_DIGIT			; PRINT LOW NIBBLE
0003AEr 1  8A           		TXA						; RESTORE ACCUMULATOR
0003AFr 1  4C rr rr     		JMP PRINT_DIGIT			; PRINT LOW NIBBLE
0003B2r 1
0003B2r 1               ;__PRINT_DIGIT_________________________________________________
0003B2r 1               ;
0003B2r 1               ; PRINT OUT LOW NIBBLE OF ACCUMULATOR IN HEX
0003B2r 1               ;
0003B2r 1               ;______________________________________________________________
0003B2r 1               PRINT_DIGIT:
0003B2r 1  29 0F        		AND #$0F				; STRIP OFF HIGH NIBBLE
0003B4r 1  09 30        		ORA #$30				; ADD $30 TO PRODUCE ASCII
0003B6r 1  C9 3A        		CMP #$3A             	; IS GREATER THAN 9
0003B8r 1  30 03        		BMI PRINT_DIGIT_OUT		; NO, SKIP ADD
0003BAr 1  18           		CLC						; CLEAR CARRY
0003BBr 1  69 07        		ADC #$07				; ADD ON FOR LETTER VALUES
0003BDr 1               PRINT_DIGIT_OUT:				;
0003BDr 1  4C rr rr     		JMP OUTCH           	; PRINT OUT CHAR
0003C0r 1
0003C0r 1
0003C0r 1               ;__PRINT_BIN_BYTE______________________________________________
0003C0r 1               ;
0003C0r 1               ; PRINT OUT BYTE IN BINARY
0003C0r 1               ;
0003C0r 1               ;______________________________________________________________
0003C0r 1               PRINT_BIN_BYTE:
0003C0r 1  0A           		ASL						; ROTATE BIT 7 INTO CARRY FLAG
0003C1r 1  90 06        		BCC PRINT_BIN8_0		;  IS ZERO?
0003C3r 1  20 rr rr     		JSR PRINT_1				;  NO, PRINT OUT A '1'
0003C6r 1  4C rr rr     		JMP PRINT_BIN_BIT_7		;  JUMP TO NEXT BIT
0003C9r 1               PRINT_BIN8_0:
0003C9r 1  20 rr rr     		JSR PRINT_0				;  YES, PRINT A '0'
0003CCr 1               PRINT_BIN_BIT_7:				;
0003CCr 1  0A           		ASL						; ROTATE BIT 6 INTO CARRY FLAG
0003CDr 1  90 06        		BCC PRINT_BIN7_0		;  IS ZERO?
0003CFr 1  20 rr rr     		JSR PRINT_1				;  NO, PRINT OUT A '1'
0003D2r 1  4C rr rr     		JMP PRINT_BIN_BIT_6		;  JUMP TO NEXT BIT
0003D5r 1               PRINT_BIN7_0:
0003D5r 1  20 rr rr     		JSR PRINT_0				;  YES, PRINT A '0'
0003D8r 1               PRINT_BIN_BIT_6:				;
0003D8r 1  0A           		ASL						; ROTATE BIT 5 INTO CARRY FLAG
0003D9r 1  90 06        		BCC PRINT_BIN6_0		;  IS ZERO?
0003DBr 1  20 rr rr     		JSR PRINT_1				;  NO, PRINT OUT A '1'
0003DEr 1  4C rr rr     		JMP PRINT_BIN_BIT_5		;  JUMP TO NEXT BIT
0003E1r 1               PRINT_BIN6_0:					;
0003E1r 1  20 rr rr     		JSR PRINT_0				;  YES, PRINT A '0'
0003E4r 1               PRINT_BIN_BIT_5:				;
0003E4r 1  0A           		ASL						; ROTATE BIT 4 INTO CARRY FLAG
0003E5r 1  90 06        		BCC PRINT_BIN5_0		;  IS ZERO?
0003E7r 1  20 rr rr     		JSR PRINT_1				;  NO, PRINT OUT A '1'
0003EAr 1  4C rr rr     		JMP PRINT_BIN_BIT_4		;  JUMP TO NEXT BIT
0003EDr 1               PRINT_BIN5_0:					;
0003EDr 1  20 rr rr     		JSR PRINT_0				;  YES, PRINT A '0'
0003F0r 1               PRINT_BIN_BIT_4:				;
0003F0r 1  0A           		ASL						; ROTATE BIT 3 INTO CARRY FLAG
0003F1r 1  90 06        		BCC PRINT_BIN3_0		;  IS ZERO?
0003F3r 1  20 rr rr     		JSR PRINT_1				;  NO, PRINT OUT A '1'
0003F6r 1  4C rr rr     		JMP PRINT_BIN_BIT_2		;  JUMP TO NEXT BIT
0003F9r 1               PRINT_BIN3_0:					;
0003F9r 1  20 rr rr     		JSR PRINT_0				;  YES, PRINT A '0'
0003FCr 1               PRINT_BIN_BIT_2:				;
0003FCr 1  0A           		ASL						; ROTATE BIT 2 INTO CARRY FLAG
0003FDr 1  90 06        		BCC PRINT_BIN2_0		;  IS ZERO?
0003FFr 1  20 rr rr     		JSR PRINT_1				;  NO, PRINT OUT A '1'
000402r 1  4C rr rr     		JMP PRINT_BIN_BIT_1		;  JUMP TO NEXT BIT
000405r 1               PRINT_BIN2_0:					;
000405r 1  20 rr rr     		JSR PRINT_0				;  YES, PRINT A '0'
000408r 1               PRINT_BIN_BIT_1:				;
000408r 1  0A           		ASL						; ROTATE BIT 1 INTO CARRY FLAG
000409r 1  90 06        		BCC PRINT_BIN1_0		;  IS ZERO?
00040Br 1  20 rr rr     		JSR PRINT_1				;  NO, PRINT OUT A '1'
00040Er 1  4C rr rr     		JMP PRINT_BIN_BIT_0		;  JUMP TO NEXT BIT
000411r 1               PRINT_BIN1_0:					;
000411r 1  20 rr rr     		JSR PRINT_0				;  YES, PRINT A '0'
000414r 1               PRINT_BIN_BIT_0:				;
000414r 1  0A           		ASL						; ROTATE BIT 0 INTO CARRY FLAG
000415r 1  90 03        		BCC PRINT_BIN0_0		;  IS ZERO?
000417r 1  4C rr rr     		JMP PRINT_1				;  NO, PRINT OUT A '1'
00041Ar 1               PRINT_BIN0_0:					;
00041Ar 1  4C rr rr     		JMP PRINT_0				;   YES, PRINT A '0'
00041Dr 1
00041Dr 1
00041Dr 1
00041Dr 1               ;__PRINT_1_____________________________________________________
00041Dr 1               ;
00041Dr 1               ; PRINT OUT A '1'
00041Dr 1               ;
00041Dr 1               ;______________________________________________________________
00041Dr 1               PRINT_1:
00041Dr 1  48           		PHA						; PUSH ACC TO STACK
00041Er 1  A9 31        		LDA #$31				; LOAD '1'
000420r 1  20 rr rr     		JSR OUTCH				; OUTPUT CHAR TO SCREEN
000423r 1  68           		PLA						; PULL ACC FROM STACK
000424r 1  60           		RTS						; RETURN
000425r 1
000425r 1
000425r 1               ;__PRINT_0_____________________________________________________
000425r 1               ;
000425r 1               ; PRINT OUT A '0'
000425r 1               ;
000425r 1               ;______________________________________________________________
000425r 1               PRINT_0:
000425r 1  48           		PHA						; PUSH ACC TO STACK
000426r 1  A9 30        		LDA #$30				; LOAD '0'
000428r 1  20 rr rr     		JSR OUTCH				; OUTPUT CHAR TO SCREEN
00042Br 1  68           		PLA						; PULL ACC FROM STACK
00042Cr 1  60           		RTS						; RETURN
00042Dr 1
00042Dr 1
00042Dr 1               ;__OUTSTR______________________________________________________
00042Dr 1               ;
00042Dr 1               ; OUTPUT THE STRING POINTED TO BU OUTSTR TO THE SCREEN
00042Dr 1               ;
00042Dr 1               ;______________________________________________________________
00042Dr 1               OUTSTR:
00042Dr 1  A0 00        		LDY   #$00				; LOAD $00 INTO Y
00042Fr 1               OUTSTRLP:
00042Fr 1  B1 48        		LDA (STRPTR),Y    	 	; LOAD NEXT CHAR FROM STRING INTO ACC
000431r 1  C9 00        		CMP #$00				; IS NULL?
000433r 1  F0 07        		BEQ ENDOUTSTR			; YES, END PRINT OUT
000435r 1  20 rr rr     		JSR OUTCH  				; PRINT CHAR IN ACC
000438r 1  C8           		INY      				; Y=Y+1 (BUMP INDEX)
000439r 1  4C rr rr     		JMP OUTSTRLP			; DO NEXT CHAR
00043Cr 1               ENDOUTSTR:
00043Cr 1  60           		RTS						; RETURN
00043Dr 1
00043Dr 1               ;__INSTR_______________________________________________________
00043Dr 1               ;
00043Dr 1               ; INPUT STRING FROM KEYBOARD INTO KEYBOARD BUFFER
00043Dr 1               ;
00043Dr 1               ;______________________________________________________________
00043Dr 1               INSTR:
00043Dr 1  A0 00        		LDY   #$00				; LOAD $00 INTO Y
00043Fr 1               INSTRLP:
00043Fr 1  20 rr rr     		JSR IOF_CONINW
000442r 1  C9 0D        		CMP #$0D				; IS CR?
000444r 1  F0 1E        		BEQ ENDINSTR			; YES, DONE WITH INPUT
000446r 1  C9 08        		CMP #$08				; IS BACKSPACE?
000448r 1  D0 10        		BNE INSTR_NOTBS			; NO, SKIP BACKSPACE RTN
00044Ar 1  C0 00        		CPY #$00				; IS INDEX =0 ?
00044Cr 1  F0 1B        		BEQ INSTR_EMPTY_BS		; YES, SKIP BACKSPACE
00044Er 1  20 rr rr     		JSR OUTCH     			; OUTPUT CHAR TO SCREEN
000451r 1  88           		DEY						; Y=Y-1
000452r 1  A9 00        		LDA #$00				;
000454r 1  91 48        		STA (STRPTR),Y			; NULL TERMINATE INPUT BUFFER
000456r 1  88           		DEY						; Y=Y-1
000457r 1  4C rr rr     		JMP INSTR_SKIP_STORE    ; SKIP STORE OF CHAR TO INPUT BUFFER
00045Ar 1               INSTR_NOTBS:
00045Ar 1  91 48        		STA (STRPTR),Y			; STORE CHAR IN KEYBAORD BUFFER
00045Cr 1  20 rr rr     		JSR OUTCH     			; OUTPUT CHAR TO SCREEN
00045Fr 1               INSTR_SKIP_STORE:
00045Fr 1  C8           		INY						; Y=Y+1
000460r 1  C0 FF        		CPY #$FF				; DOES Y=$FF
000462r 1  D0 DB        		BNE INSTRLP         	; NO, LOOP FOR NEXT CHAR
000464r 1               ENDINSTR:
000464r 1  A9 00        		LDA #$00				; A=0
000466r 1  91 48        		STA (STRPTR),Y			; NULL TERMINATE INPUT BUFFER
000468r 1  60           		RTS
000469r 1               INSTR_EMPTY_BS:
000469r 1  A9 00        		LDA #$00				; BLANK OUT KEYBOARD CHAR, TO SIGNAL READY FOR NEXT CHAR
00046Br 1  4C rr rr     		JMP INSTRLP				; JUMP TO INPUT LOOP
00046Er 1
00046Er 1
00046Er 1               ;__________________________________________________________________________________________________________
00046Er 1
00046Er 1               IOF_CONINW:						;
00046Er 1               SERIAL_INCHW1:
00046Er 1  AD 6D 03     		LDA	UART5				; READ LINE STATUS REGISTER
000471r 1  29 01        		AND	#$01				; TEST IF DATA IN RECEIVE BUFFER
000473r 1  C9 00        		CMP 	#$00
000475r 1  F0 F7        		BEQ	SERIAL_INCHW1		; LOOP UNTIL DATA IS READY
000477r 1  AD 68 03     		LDA	UART0				; THEN READ THE CHAR FROM THE UART
00047Ar 1
00047Ar 1  60           		RTS
00047Br 1
00047Br 1               IOF_CONIN:						;
00047Br 1  AD 6D 03     		LDA	UART5				; READ LINE STATUS REGISTER
00047Er 1  29 01        		AND	#$01				; TEST IF DATA IN RECEIVE BUFFER
000480r 1  F0 04        		BEQ	SERIAL_INCH1		; NO CHAR FOUND
000482r 1  AD 68 03     		LDA	UART0				; THEN READ THE CHAR FROM THE UART
000485r 1  60           		RTS
000486r 1               SERIAL_INCH1:					;
000486r 1  A9 00        		LDA	#$00
000488r 1  60           		RTS						;
000489r 1
000489r 1               OUTCH:							;
000489r 1  48           		PHA						; STORE A
00048Ar 1               TX_BUSYLP:
00048Ar 1  AD 6D 03     		LDA	UART5				; READ LINE STATUS REGISTER
00048Dr 1  29 20        		AND	#$20				; TEST IF UART IS READY TO SEND (BIT 5)
00048Fr 1  C9 00        		CMP 	#$00
000491r 1  F0 F7        		BEQ	TX_BUSYLP			; IF NOT REPEAT
000493r 1  68           		PLA						; RESTORE ACC
000494r 1  8D 68 03     		STA	UART0				; THEN WRITE THE CHAR TO UART
000497r 1  60           		RTS
000498r 1
000498r 1               Z80:
000498r 1  AD FF 03     		LDA 	$03FF
00049Br 1  00           		BRK
00049Cr 1  00 00 00     	.BYTE 00,00,00
00049Fr 1
00049Fr 1               	.include"assmb.asm"
00049Fr 2               ;*
00049Fr 2               ;* ASSEMBLER/DISSASSEMBLER
00049Fr 2               ;*
00049Fr 2               ;* Based on original source code by Jim Butterfield
00049Fr 2               ;*
00049Fr 2               ;* Mr. Butterfield inspired many of us with his work on the commodore series of computers.
00049Fr 2               ;* May he rest in peace. (1936-2007)
00049Fr 2               ;*
00049Fr 2
00049Fr 2
00049Fr 2               savx	=	$1c
00049Fr 2               tmpc	=	$1d
00049Fr 2               length	=	$1f
00049Fr 2               wrap	=	$26
00049Fr 2               aflg	=	$28
00049Fr 2               acmd	=	$2a
00049Fr 2               nemo	=	$44
00049Fr 2               tmp0	=	$c1
00049Fr 2               tmp2	=	$c3
00049Fr 2               stage	=	$0210
00049Fr 2
00049Fr 2
00049Fr 2               ;__DISASSEMBLE_________________________________________________
00049Fr 2               ;
00049Fr 2               ; Disassemble assembly lines to screen
00049Fr 2               ; USAGE:
00049Fr 2               ;
00049Fr 2               ; DISSASSEMBLE XXXX
00049Fr 2               ;______________________________________________________________
00049Fr 2               DISASSEMBLE:
00049Fr 2
00049Fr 2  A9 00        	LDA #<INBUFFER             	; SETUP WORK BUFFER
0004A1r 2  85 32        	STA WORKPTR			;
0004A3r 2  A9 02        	LDA #>INBUFFER              	;
0004A5r 2  85 33        	STA WORKPTR +1 			;
0004A7r 2
0004A7r 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "D"
0004AAr 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "I"
0004ADr 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "S"
0004B0r 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "S"
0004B3r 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "A"
0004B6r 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "S"
0004B9r 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "S"
0004BCr 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "E"
0004BFr 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "M"
0004C2r 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "B"
0004C5r 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "L"
0004C8r 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "E"
0004CBr 2
0004CBr 2  20 rr rr     	JSR EATWHITESPACE		; SKIP OVER THE WHITESPACE
0004CEr 2  20 rr rr     	JSR GETNUMBER			; GET THE STARTING ADDRESS
0004D1r 2  B0 45        	BCS DISASSEMBLE_ERROR		; IF NOT A NUMBER, REPORT ERROR
0004D3r 2  A5 36                LDA TEMPWORD
0004D5r 2  85 C1                STA tmp0
0004D7r 2  A5 37                LDA TEMPWORD+1
0004D9r 2  85 C2                STA tmp0+1
0004DBr 2  A9 0F        diss:	lda #$0f
0004DDr 2  85 3B                sta TEMPBYTE
0004DFr 2  20 rr rr     dislp:  jsr diss1
0004E2r 2  20 rr rr             jsr pcadj
0004E5r 2  85 C1                sta tmp0
0004E7r 2  84 C2                sty tmp0+1
0004E9r 2  C6 3B                dec TEMPBYTE
0004EBr 2  D0 F2                bne dislp
0004EDr 2
0004EDr 2
0004EDr 2  A9 rr        	LDA #<DISSASSEMBLE_TEXT         ; LOAD LOW BYTE OF PROMPT STRING
0004EFr 2  85 48        	STA STRPTR			; STORE IN POINTER LOW BYTE
0004F1r 2  A9 rr        	LDA #>DISSASSEMBLE_TEXT         ; LOAD HOGH BYTE OF PROMPR STRING
0004F3r 2  85 49        	STA STRPTR +1 			; STORE IN POINTER HIGH BYTE
0004F5r 2  20 rr rr     	JSR OUTSTR			; OUTPUT THE STRING
0004F8r 2
0004F8r 2  20 rr rr           	JSR IOF_CONINW
0004FBr 2  C9 59        	cmp #'Y'
0004FDr 2  D0 03        	bne dissexit
0004FFr 2  4C rr rr     	jmp diss
000502r 2               dissexit:
000502r 2  60                   rts
000503r 2               DISSASSEMBLE_TEXT:
000503r 2  0D 0A        	.BYTE $0d,$0a
000505r 2  43 4F 4E 54  	.BYTE "CONTINUE? (Y/N) "
000509r 2  49 4E 55 45
00050Dr 2  3F 20 28 59
000515r 2  0D 0A 00     	.BYTE $0d,$0a,$00
000518r 2
000518r 2               DISASSEMBLE_ERROR:
000518r 2  4C rr rr     	JMP INVALID_NUMBER_ERROR
00051Br 2               ENTER_BYTE:
00051Br 2  AA           	TAX				; SAVE A REGISTER
00051Cr 2  4A           	LSR A				; SHIFT HIGH NIBBLE TO LOW NIBBLE
00051Dr 2  4A           	LSR A				;
00051Er 2  4A           	LSR A				;
00051Fr 2  4A           	LSR A				;
000520r 2  18           	CLC               		; CLEAR CARRY
000521r 2  20 rr rr     	JSR ENTER_DIGIT			; PRINT LOW NIBBLE
000524r 2  8A           	TXA				; RESTORE ACCUMULATOR
000525r 2  4C rr rr     	JMP ENTER_DIGIT			; PRINT LOW NIBBLE
000528r 2               ENTER_DIGIT:
000528r 2  29 0F        	AND #$0F			; STRIP OFF HIGH NIBBLE
00052Ar 2  09 30        	ORA #$30			; ADD $30 TO PRODUCE ASCII
00052Cr 2  C9 3A        	CMP #$3A               		; IS GREATER THAN 9
00052Er 2  30 03        	BMI ENTER_DIGIT_OUT		; NO, SKIP ADD
000530r 2  18           	CLC				; CLEAR CARRY
000531r 2  69 07        	ADC #$07			; ADD ON FOR LETTER VALUES
000533r 2               ENTER_DIGIT_OUT:			;
000533r 2  48           	PHA
000534r 2  20 rr rr     	JSR OUTCH                   	; PRINT OUT CHAR
000537r 2  68           	PLA
000538r 2  85 32        	STA WORKPTR
00053Ar 2  4C rr rr     	JMP INCWORKPTR
00053Dr 2
00053Dr 2
00053Dr 2
00053Dr 2
00053Dr 2               ;__diss1_______________________________________________________
00053Dr 2               ;
00053Dr 2               ; Disassemble 1 assembly line to screen
00053Dr 2               ; Parms:
00053Dr 2               ; tmp0 (WORD) Word Pointer to begin disassembly
00053Dr 2               ;______________________________________________________________
00053Dr 2               diss1:
00053Dr 2  20 rr rr              JSR crlf
000540r 2  A9 2E        	 lda #'.'
000542r 2  20 rr rr              jsr OUTCH
000545r 2  20 rr rr              jsr space
000548r 2  20 rr rr     diss1a:  jsr PRINT_WORD
00054Br 2  20 rr rr              jsr space
00054Er 2  A2 00                 ldx #0
000550r 2  A1 C1                 lda (tmp0,x)
000552r 2  20 rr rr              jsr instxx
000555r 2  48                    pha
000556r 2  20 rr rr              jsr disvv
000559r 2  68                    pla
00055Ar 2  20 rr rr              jsr propxx
00055Dr 2  A2 06                 ldx #$06
00055Fr 2  E0 03        pradr1:  cpx #$03
000561r 2  D0 12                 bne pradr3
000563r 2  A4 1F                 ldy length
000565r 2  F0 0E                 beq pradr3
000567r 2  A5 2A        pradr2:  lda acmd
000569r 2  C9 E8                 cmp #$e8
00056Br 2  B1 C1                 lda (tmp0),y
00056Dr 2  B0 1C                 bcs reladr
00056Fr 2  20 rr rr              jsr prbyte
000572r 2  88                    dey
000573r 2  D0 F2                 bne pradr2
000575r 2  06 2A        pradr3:  asl acmd
000577r 2  90 0E                 bcc pradr4
000579r 2  BD rr rr              lda char1-1,x
00057Cr 2  20 rr rr              jsr chrout
00057Fr 2  BD rr rr              lda char2-1,x
000582r 2  F0 03                 beq pradr4
000584r 2  20 rr rr              jsr chrout
000587r 2  CA           pradr4:  dex
000588r 2  D0 D5                 bne pradr1
00058Ar 2  60                    rts
00058Br 2               ; ** print rel address **
00058Br 2  20 rr rr     reladr:  jsr pcadj3
00058Er 2  AA                    tax
00058Fr 2  E8                    inx
000590r 2  D0 01                 bne prntyx
000592r 2  C8                    iny
000593r 2               ; ** print word address **
000593r 2  98           prntyx:  tya
000594r 2  20 rr rr              jsr prbyte
000597r 2  8A                    txa
000598r 2               ; ** print Byte **
000598r 2  86 1C        prbyte:  stx savx
00059Ar 2  20 rr rr              jsr PRINT_BYTE
00059Dr 2  A6 1C                 ldx savx
00059Fr 2  60                    rts
0005A0r 2               ; ** advance the program counter **
0005A0r 2  A5 1F        pcadj:   lda length
0005A2r 2  38                    sec
0005A3r 2  A4 C2        pcadj3:  ldy tmp0+1
0005A5r 2  AA                    tax
0005A6r 2  10 01                 bpl pcadj4
0005A8r 2  88                    dey
0005A9r 2  65 C1        pcadj4:  adc tmp0
0005ABr 2  90 01                 bcc rts1
0005ADr 2  C8                    iny
0005AEr 2  60           rts1:    rts
0005AFr 2               ; ** check inst valid, len **
0005AFr 2  A8           instxx:  tay
0005B0r 2  4A                    lsr a
0005B1r 2  90 0B                 bcc ieven
0005B3r 2  4A                    lsr a
0005B4r 2  B0 17                 bcs err
0005B6r 2  C9 22                 cmp #$22
0005B8r 2  F0 13                 beq err
0005BAr 2  29 07                 and #$07
0005BCr 2  09 80                 ora #$80
0005BEr 2  4A           ieven:   lsr a
0005BFr 2  AA                    tax
0005C0r 2  BD rr rr              lda mode,x
0005C3r 2  B0 04                 bcs rtmode
0005C5r 2  4A                    lsr a
0005C6r 2  4A                    lsr a
0005C7r 2  4A                    lsr a
0005C8r 2  4A                    lsr a
0005C9r 2  29 0F        rtmode:  and #$0f
0005CBr 2  D0 04                 bne getfmt
0005CDr 2  A0 80        err:     ldy #$80
0005CFr 2  A9 00                 lda #0
0005D1r 2               ; ** get addr mode, length **
0005D1r 2  AA           getfmt:  tax
0005D2r 2  BD rr rr              lda mode2,x
0005D5r 2  85 2A                 sta acmd
0005D7r 2  29 03                 and #$03
0005D9r 2  85 1F                 sta length
0005DBr 2               ; ** extract intructn **
0005DBr 2  98                    tya
0005DCr 2  29 8F                 and #$8f
0005DEr 2  AA                    tax
0005DFr 2  98                    tya
0005E0r 2  A0 03                 ldy #$03
0005E2r 2  E0 8A                 cpx #$8a
0005E4r 2  F0 0B                 beq mnndx3
0005E6r 2  4A           mnndx1:  lsr a
0005E7r 2  90 08                 bcc mnndx3
0005E9r 2  4A                    lsr a
0005EAr 2  4A           mnndx2:  lsr a
0005EBr 2  09 20                 ora #$20
0005EDr 2  88                    dey
0005EEr 2  D0 FA                 bne mnndx2
0005F0r 2  C8                    iny
0005F1r 2  88           mnndx3:  dey
0005F2r 2  D0 F2                 bne mnndx1
0005F4r 2  60                    rts
0005F5r 2               ; print bytes
0005F5r 2  B1 C1        disvv:   lda (tmp0),y
0005F7r 2  20 rr rr              jsr prbyte
0005FAr 2  A2 01                 ldx #1
0005FCr 2  20 rr rr     disvl:   jsr spacd
0005FFr 2  C4 1F                 cpy length
000601r 2  C8                    iny
000602r 2  90 F1                 bcc disvv
000604r 2  A2 03                 ldx #$03
000606r 2  C0 04                 cpy #4
000608r 2  90 F2                 bcc disvl
00060Ar 2  60                    rts
00060Br 2               ; ** print mnemonic **
00060Br 2  A8           propxx:  tay
00060Cr 2  B9 rr rr              lda mneml,y
00060Fr 2  85 28                 sta aflg
000611r 2  B9 rr rr              lda mnemr,y
000614r 2  85 29                 sta aflg+1
000616r 2  A9 00        prmn1:   lda #0
000618r 2  A0 05                 ldy #$05
00061Ar 2  06 29        prmn2:   asl aflg+1
00061Cr 2  26 28                 rol aflg
00061Er 2  2A                    rol a
00061Fr 2  88                    dey
000620r 2  D0 F8                 bne prmn2
000622r 2  69 3F                 adc #$3f
000624r 2  20 rr rr              jsr OUTCH
000627r 2  CA                    dex
000628r 2  D0 EC                 bne prmn1
00062Ar 2               ; ** print space **
00062Ar 2  A9 20        space:   lda #$20
00062Cr 2  D0 07                 bne flip
00062Er 2               ; ** print cr, maybe lf **
00062Er 2  A9 0D        crlf:    lda #$0d
000630r 2  20 rr rr              jsr OUTCH
000633r 2  A9 0A                 lda #$0a
000635r 2  4C rr rr     flip:    jmp OUTCH
000638r 2
000638r 2
000638r 2               ;__ASSEMBLE____________________________________________________
000638r 2               ;
000638r 2               ; Assemble line from keyboard to memory
000638r 2               ;______________________________________________________________
000638r 2               ASSEMBLE:
000638r 2  A9 00                LDA #<INBUFFER                  ; SETUP WORK BUFFER
00063Ar 2  85 32        	STA WORKPTR			;
00063Cr 2  A9 02        	LDA #>INBUFFER                  ;
00063Er 2  85 33        	STA WORKPTR +1 			;
000640r 2
000640r 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "A"
000643r 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "S"
000646r 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "S"
000649r 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "E"
00064Cr 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "M"
00064Fr 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "B"
000652r 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "L"
000655r 2  20 rr rr     	JSR INCWORKPTR			; JUMP OVER "E"
000658r 2
000658r 2  20 rr rr     	JSR EATWHITESPACE		; SKIP OVER ANY WHITESPACE
00065Br 2  20 rr rr     	JSR GETNUMBER			; GET NUMBER
00065Er 2  B0 03        	BCS ASSEMBLE_ERROR		; IF NOT A NUMBER REPORT ERROR
000660r 2  4C rr rr             jmp asvald
000663r 2               ASSEMBLE_ERROR:
000663r 2  4C rr rr     	jmp error
000666r 2               asvald:
000666r 2  A5 36        	LDA TEMPWORD
000668r 2  85 C1        	STA tmp0
00066Ar 2  A5 37        	LDA TEMPWORD+1
00066Cr 2  85 C2        	STA tmp0+1
00066Er 2               asv1:
00066Er 2  20 rr rr     	JSR crlf
000671r 2  A9 2E        	lda #'.'
000673r 2  20 rr rr             jsr OUTCH
000676r 2  20 rr rr             jsr space
000679r 2  20 rr rr             jsr PRINT_WORD
00067Cr 2  20 rr rr             jsr space
00067Fr 2  20 rr rr             JSR t2t2
000682r 2  8E 11 02             STX stage+1
000685r 2  A9 00         	LDA #<INBUFFER                 	; SETUP INPUT COMMAND BUFFER
000687r 2  85 48        	STA STRPTR			;
000689r 2  85 32        	sta WORKPTR			;
00068Br 2  A9 02        	LDA #>INBUFFER              	;
00068Dr 2  85 49        	STA STRPTR +1 			;
00068Fr 2  85 33        	STA WORKPTR+1	             	;
000691r 2  20 rr rr     	JSR INSTR			; GET A STRING FROM THE CONSOLE
000694r 2  20 rr rr     	jsr EATWHITESPACE
000697r 2  A2 03        	LDX #$03			; push opcode to stack
000699r 2  A0 00        	LDY #$00
00069Br 2  B1 32        apush:  LDA (WORKPTR),Y			; GET NEXT CHAR FROM BUFFER
00069Dr 2  48           	pha
00069Er 2  20 rr rr     	JSR INCWORKPTR
0006A1r 2  CA           	dex
0006A2r 2  D0 F7        	bne apush
0006A4r 2
0006A4r 2  A2 03                ldx #$03
0006A6r 2  68           apull:   pla
0006A7r 2  38                    sec
0006A8r 2  E9 3F                 sbc #$3f
0006AAr 2  A0 05                 ldy #$05
0006ACr 2  4A           acrun:   lsr a
0006ADr 2  6E 11 02              ror stage+1
0006B0r 2  6E 10 02              ror stage
0006B3r 2  88                    dey
0006B4r 2  D0 F6                 bne acrun
0006B6r 2  CA                    dex
0006B7r 2  D0 ED                 bne apull
0006B9r 2  A2 02                 ldx #$02
0006BBr 2  A0 00        ainp:    LDY #$00
0006BDr 2  B1 32        	 LDA (WORKPTR),Y		; GET NEXT CHAR FROM BUFFER
0006BFr 2  20 rr rr       	 JSR INCWORKPTR
0006C2r 2  C9 00                 cmp #$00
0006C4r 2  F0 1E                 beq aret
0006C6r 2  C9 20                 cmp #$20
0006C8r 2  F0 F1                 beq ainp
0006CAr 2  20 rr rr              jsr ahex
0006CDr 2  B0 0F                 bcs stone
0006CFr 2
0006CFr 2  20 rr rr              jsr rdob2
0006D2r 2  A4 C1                 ldy tmp0
0006D4r 2  84 C2                 sty tmp0+1
0006D6r 2  85 C1                 sta tmp0
0006D8r 2
0006D8r 2  A9 30                 lda #$30
0006DAr 2  9D 10 02              sta stage,x
0006DDr 2  E8                    inx
0006DEr 2  9D 10 02     stone:   sta stage,x
0006E1r 2  E8                    inx
0006E2r 2  D0 D7                 bne ainp
0006E4r 2  86 28        aret:    stx aflg
0006E6r 2  A2 00                 ldx #0
0006E8r 2  86 26                 stx wrap
0006EAr 2  F0 04                 beq atry
0006ECr 2  E6 26        abump:   inc wrap
0006EEr 2  F0 75                 beq aerr
0006F0r 2  A2 00        atry:    ldx #0
0006F2r 2  86 1D                 stx tmpc
0006F4r 2  A5 26                 lda wrap
0006F6r 2  20 rr rr              jsr instxx
0006F9r 2  A6 2A                 ldx acmd
0006FBr 2  86 29                 stx aflg+1
0006FDr 2  AA                    tax
0006FEr 2  BC rr rr              ldy mneml,x
000701r 2  BD rr rr              lda mnemr,x
000704r 2  20 rr rr              jsr achek2
000707r 2  D0 E3                 bne abump
000709r 2  A2 06                 ldx #$06
00070Br 2  E0 03        aoprnd:  cpx #$03
00070Dr 2  D0 19                 bne ashf
00070Fr 2  A4 1F                 ldy length
000711r 2  F0 15                 beq ashf
000713r 2  A5 2A        arsc:    lda acmd
000715r 2  C9 E8                 cmp #$e8
000717r 2  A9 30                 lda #$30
000719r 2  B0 21                 bcs arel1
00071Br 2  20 rr rr              jsr acheck
00071Er 2  D0 CC                 bne abump
000720r 2  20 rr rr              jsr achick
000723r 2  D0 C7                 bne abump
000725r 2  88                    dey
000726r 2  D0 EB                 bne arsc
000728r 2  06 2A        ashf:    asl acmd
00072Ar 2  90 0B                 bcc adex
00072Cr 2  BC rr rr              ldy char2-1,x
00072Fr 2  BD rr rr              lda char1-1,x
000732r 2  20 rr rr              jsr achek2
000735r 2  D0 B5                 bne abump
000737r 2  CA           adex:    dex
000738r 2  D0 D1                 bne aoprnd
00073Ar 2  F0 0A                 beq ald
00073Cr 2  20 rr rr     arel1:   jsr acdb1
00073Fr 2  D0 AB                 bne abump
000741r 2  20 rr rr              jsr acdb1
000744r 2  D0 A6                 bne abump
000746r 2  A5 28        ald:     lda aflg
000748r 2  C5 1D                 cmp tmpc
00074Ar 2  D0 A0                 bne abump
00074Cr 2  20 rr rr              jsr t2t2
00074Fr 2  A4 1F                 ldy length
000751r 2  F0 28                 beq aopset
000753r 2  A5 29                 lda aflg+1
000755r 2  C9 9D                 cmp #$9d
000757r 2  D0 1A                 bne aopnd
000759r 2  20 rr rr              jsr diffb
00075Cr 2  90 0A                 bcc abdown
00075Er 2  98                    tya
00075Fr 2  D0 04                 bne aerr
000761r 2  A5 44                 lda nemo
000763r 2  10 0A                 bpl abran
000765r 2  4C rr rr     aerr:    jmp error
000768r 2  C8           abdown:  iny
000769r 2  D0 FA                 bne aerr
00076Br 2  A5 44                 lda nemo
00076Dr 2  10 F6                 bpl aerr
00076Fr 2  A4 1F        abran:   ldy length
000771r 2  D0 03                 bne abrel
000773r 2  B9 C2 00     aopnd:   lda tmp2-1,y
000776r 2  91 C1        abrel:   sta (tmp0),y
000778r 2  88                    dey
000779r 2  D0 F8                 bne aopnd
00077Br 2  A5 26        aopset:  lda wrap
00077Dr 2  91 C1                 sta (tmp0),y
00077Fr 2  20 rr rr              jsr pcadj
000782r 2  85 C1                 sta tmp0
000784r 2  84 C2                 sty tmp0+1
000786r 2  4C rr rr              jmp asv1
000789r 2  A8           acdb1:   tay
00078Ar 2  20 rr rr     achek2:  jsr acheck
00078Dr 2  D0 11                 bne acex
00078Fr 2  98                    tya
000790r 2  F0 0E        acheck:  beq acex
000792r 2  86 1C        achick:  stx savx
000794r 2  A6 1D                 ldx tmpc
000796r 2  DD 10 02              cmp stage,x
000799r 2  08                    php
00079Ar 2  E8                    inx
00079Br 2  86 1D                 stx tmpc
00079Dr 2  A6 1C                 ldx savx
00079Fr 2  28                    plp
0007A0r 2  60           acex:    rts
0007A1r 2  C9 30        ahex:    cmp #$30
0007A3r 2  90 03                 bcc asx
0007A5r 2  C9 47                 cmp #$47
0007A7r 2  60                    rts
0007A8r 2  38           asx:     sec
0007A9r 2  60                    rts
0007AAr 2
0007AAr 2
0007AAr 2
0007AAr 2                                        ; ** swap tmp0, tmp2 **
0007AAr 2  A2 02        t2t2:    ldx #$02
0007ACr 2  B5 C0        t2t21:   lda tmp0-1,x
0007AEr 2  48                    pha
0007AFr 2  B5 C2                 lda tmp2-1,x
0007B1r 2  95 C0                 sta tmp0-1,x
0007B3r 2  68                    pla
0007B4r 2  95 C2                 sta tmp2-1,x
0007B6r 2  CA                    dex
0007B7r 2  D0 F3                 bne t2t21
0007B9r 2  60                    rts
0007BAr 2
0007BAr 2               PRINT_WORD:
0007BAr 2  48           	pha
0007BBr 2  A5 C2        	lda tmp0+1
0007BDr 2  20 rr rr     	jsr prbyte
0007C0r 2  A5 C1        	lda tmp0
0007C2r 2  20 rr rr     	jsr prbyte
0007C5r 2  68           	pla
0007C6r 2  60           	rts
0007C7r 2                                         ; ** calc tmp2-tmp0-2 **
0007C7r 2  A5 C3        diffb:   lda tmp2
0007C9r 2  A4 C4                 ldy tmp2+1
0007CBr 2  38                    sec
0007CCr 2  E9 02                 sbc #2
0007CEr 2  B0 0E                 bcs deck
0007D0r 2  88                    dey
0007D1r 2  90 0B                 bcc deck
0007D3r 2                                         ; ** calc aflg-tmp0 **
0007D3r 2  A5 28        diffa:   lda aflg
0007D5r 2  A4 29                 ldy aflg+1
0007D7r 2  4C rr rr              jmp deck
0007DAr 2                                         ; ** calc tmp2-tmp0 **
0007DAr 2  A5 C3        diffp:   lda tmp2
0007DCr 2  A4 C4                 ldy tmp2+1
0007DEr 2  38           deck:    sec
0007DFr 2  E5 C1                 sbc tmp0
0007E1r 2  85 44                 sta nemo
0007E3r 2  98                    tya
0007E4r 2  E5 C2                 sbc tmp0+1
0007E6r 2  A8                    tay
0007E7r 2  05 44                 ora nemo
0007E9r 2  60                    rts
0007EAr 2
0007EAr 2  A9 3F        error:   lda #$3f
0007ECr 2  20 rr rr              jsr OUTCH
0007EFr 2  60                    rts
0007F0r 2                                      ; ** print spaces **
0007F0r 2  20 rr rr     spacd:   jsr space
0007F3r 2  CA                    dex
0007F4r 2  D0 FA                 bne spacd
0007F6r 2  60                    rts
0007F7r 2  C5 28        chrout:  cmp aflg
0007F9r 2  F0 03                 beq caltrit
0007FBr 2  20 rr rr              jsr OUTCH
0007FEr 2  60           caltrit: rts
0007FFr 2
0007FFr 2  98           altrit:  tya
000800r 2  48                    pha
000801r 2  20 rr rr              jsr crlf
000804r 2  68                    pla
000805r 2  20 rr rr              jsr OUTCH
000808r 2  A9 2E                 lda #$2e
00080Ar 2  4C rr rr              jmp OUTCH
00080Dr 2
00080Dr 2                                         ; ** print hex byte **
00080Dr 2  A5 C2        wroa:    lda tmp0+1
00080Fr 2  20 rr rr              jsr PRINT_BYTE
000812r 2  A5 C1                 lda tmp0
000814r 2  4C rr rr              jmp PRINT_BYTE
000817r 2
000817r 2                                        ; ** read hex byte **
000817r 2  20 rr rr     rdob2:   jsr hexit
00081Ar 2  0A                    asl a
00081Br 2  0A                    asl a
00081Cr 2  0A                    asl a
00081Dr 2  0A                    asl a
00081Er 2  85 2A                 sta acmd
000820r 2  B1 32                 LDA (WORKPTR),Y			; GET NEXT CHAR FROM BUFFER
000822r 2  20 rr rr       	 JSR INCWORKPTR
000825r 2  20 rr rr     rdob3:   jsr hexit
000828r 2  05 2A                 ora acmd
00082Ar 2  38                    sec
00082Br 2  60                    rts
00082Cr 2                                         ; ** convert from hex **
00082Cr 2  C9 3A        hexit:   cmp #$3a
00082Er 2  90 02                 bcc hex08
000830r 2  69 08                 adc #$08
000832r 2  29 0F        hex08:   and #$0f
000834r 2  60                    rts
000835r 2
000835r 2
000835r 2                                         ; mode table... nybble organized
000835r 2                                         ; 0= err  4= implied  8= zer,x   c= zer,y
000835r 2                                         ; 1= imm  5= acc      9= abs,x   d= rel
000835r 2                                         ; 2= zer  6= (ind,x)  a= abs,y
000835r 2                                         ; 3= abs  7= (ind),y  b= (ind)
000835r 2  40 02 45 03  mode:    .byte $40,$02,$45,$03
000839r 2  D0 08 40 09           .byte $d0,$08,$40,$09
00083Dr 2  30 22 45 33           .byte $30,$22,$45,$33
000841r 2  D0 08 40 09           .byte $d0,$08,$40,$09
000845r 2  40 02 45 33           .byte $40,$02,$45,$33
000849r 2  D0 08 40 09           .byte $d0,$08,$40,$09
00084Dr 2  40 02 45 B3           .byte $40,$02,$45,$b3
000851r 2  D0 08 40 09           .byte $d0,$08,$40,$09
000855r 2  00 22 44 33           .byte $00,$22,$44,$33
000859r 2  D0 8C 44 00           .byte $d0,$8c,$44,$00
00085Dr 2  11 22 44 33           .byte $11,$22,$44,$33
000861r 2  D0 8C 44 9A           .byte $d0,$8c,$44,$9a
000865r 2  10 22 44 33           .byte $10,$22,$44,$33
000869r 2  D0 08 40 09           .byte $d0,$08,$40,$09
00086Dr 2  10 22 44 33           .byte $10,$22,$44,$33
000871r 2  D0 08 40 09           .byte $d0,$08,$40,$09
000875r 2  62 13 78 A9           .byte $62,$13,$78,$a9
000879r 2                                         ;master modes
000879r 2                                         ;six hi-order bits  mode options
000879r 2                                         ;two lo-order bits  operand length ready.
000879r 2  00 21 81 82  mode2:   .byte $00,$21,$81,$82
00087Dr 2  00 00 59 4D           .byte $00,$00,$59,$4d
000881r 2  91 92 86 4A           .byte $91,$92,$86,$4a,$85,$9d
000885r 2  85 9D
000887r 2  2C 29 2C 23  char1:   .byte $2c,$29,$2c,$23,$28,$24
00088Br 2  28 24
00088Dr 2  59 00 58 24  char2:   .byte $59,$00,$58,$24,$24,$00
000891r 2  24 00
000893r 2                                         ; packed mnemonics
000893r 2  1C 8A 1C 23  mneml:   .byte $1c,$8a,$1c,$23
000897r 2  5D 8B 1B A1           .byte $5d,$8b,$1b,$a1
00089Br 2  9D 8A 1D 23           .byte $9d,$8a,$1d,$23
00089Fr 2  9D 8B 1D A1           .byte $9d,$8b,$1d,$a1
0008A3r 2  00 29 19 AE           .byte $00,$29,$19,$ae
0008A7r 2  69 A8 19 23           .byte $69,$a8,$19,$23
0008ABr 2  24 53 1B 23           .byte $24,$53,$1b,$23
0008AFr 2  24 53 19 A1           .byte $24,$53,$19,$a1
0008B3r 2  00 1A 5B 5B           .byte $00,$1a,$5b,$5b
0008B7r 2  A5 69 24 24           .byte $a5,$69,$24,$24
0008BBr 2  AE AE A8 AD           .byte $ae,$ae,$a8,$ad
0008BFr 2  29 00 7C 00           .byte $29,$00,$7c,$00
0008C3r 2  15 9C 6D 9C           .byte $15,$9c,$6d,$9c
0008C7r 2  A5 69 29 53           .byte $a5,$69,$29,$53
0008CBr 2  84 13 34 11           .byte $84,$13,$34,$11
0008CFr 2  A5 69 23 A0           .byte $a5,$69,$23,$a0
0008D3r 2
0008D3r 2  D8 62 5A 48  mnemr:   .byte $d8,$62,$5a,$48
0008D7r 2  26 62 94 88           .byte $26,$62,$94,$88
0008DBr 2  54 44 C8 54           .byte $54,$44,$c8,$54
0008DFr 2  68 44 E8 94           .byte $68,$44,$e8,$94
0008E3r 2  00 B4 08 84           .byte $00,$b4,$08,$84
0008E7r 2  74 B4 28 6E           .byte $74,$b4,$28,$6e
0008EBr 2  74 F4 CC 4A           .byte $74,$f4,$cc,$4a
0008EFr 2  72 F2 A4 8A           .byte $72,$f2,$a4,$8a
0008F3r 2  00 AA A2 A2           .byte $00,$aa,$a2,$a2
0008F7r 2  74 74 74 72           .byte $74,$74,$74,$72
0008FBr 2  44 68 B2 32           .byte $44,$68,$b2,$32
0008FFr 2  B2 00 22 00           .byte $b2,$00,$22,$00
000903r 2  1A 1A 26 26           .byte $1a,$1a,$26,$26
000907r 2  72 72 88 C8           .byte $72,$72,$88,$c8
00090Br 2  C4 CA 26 48           .byte $c4,$ca,$26,$48
00090Fr 2  44 44 A2 C8           .byte $44,$44,$a2,$c8
000913r 2
000913r 1
000913r 1               ; COMMAND PROCESSOR JUMP TABLE
000913r 1               COMMAND_LOOKUP_TABLE:
000913r 1  52 45 47 49   		.BYTE "REGISTER",0,<DO_PRINT_REG,>DO_PRINT_REG
000917r 1  53 54 45 52
00091Br 1  00 rr rr
00091Er 1  44 55 4D 50   		.BYTE "DUMP",0,<DUMP,>DUMP
000922r 1  00 rr rr
000925r 1  45 4E 54 45   		.BYTE "ENTER",0,<ENTERMEM,>ENTERMEM
000929r 1  52 00 rr rr
00092Dr 1  47 4F 00 rr   		.BYTE "GO",0,<GO,>GO
000931r 1  rr
000932r 1  4C 4F 41 44   		.BYTE "LOAD",0,<LOAD,>LOAD
000936r 1  00 rr rr
000939r 1  5A 38 30 00   		.BYTE "Z80",0,<Z80,>Z80
00093Dr 1  rr rr
00093Fr 1  44 49 53 41  		.BYTE "DISASSEMBLE",0,<DISASSEMBLE,>DISASSEMBLE
000943r 1  53 53 45 4D
000947r 1  42 4C 45 00
00094Dr 1  41 53 53 45  		.BYTE "ASSEMBLE",0,<ASSEMBLE,>ASSEMBLE
000951r 1  4D 42 4C 45
000955r 1  00 rr rr
000958r 1  01 00        		.BYTE 01,0
00095Ar 1               ; COMMAND PROMPT STRING
00095Ar 1  0D 0A 2E 00  PROMPT:  	.BYTE   $0D,$0A,".",0
00095Er 1               ; ERROR STRING
00095Er 1  0D 0A 3F 20  ERROR:	 	.BYTE   $0D,$0A,"? COMMAND NOT FOUND",$0D,0
000962r 1  43 4F 4D 4D
000966r 1  41 4E 44 20
000975r 1  0D 0A 3F 20  INERROR:	.BYTE   $0D,$0A,"? INVALID HEX NUMBER",$0D,0
000979r 1  49 4E 56 41
00097Dr 1  4C 49 44 20
00098Dr 1               ; STRINGS FOR REGISTER DISPLY
00098Dr 1  0D 0A        REGDATA: 	.BYTE   $0D,$0A
00098Fr 1  20 20 20 50  		.BYTE   "   PC  AC  XR  YR  SP  SR(NVRBDIZC)"
000993r 1  43 20 20 41
000997r 1  43 20 20 58
0009B2r 1  0D 0A 21 20  		.BYTE   $0D,$0A,"! ",0
0009B6r 1  00
0009B7r 1               ; START BANNER
0009B7r 1  0D 0A        STARTUP: 	.BYTE   $0D,$0A
0009B9r 1
0009B9r 1  20 20 5F 5F  		.BYTE   "  __ |_  _ ",$0D,$0A
0009BDr 1  20 7C 5F 20
0009C1r 1  20 5F 20 0D
0009C6r 1  20 20 7C 7C  		.BYTE   "  ||||_)(_ ",$0D,$0A
0009CAr 1  7C 7C 5F 29
0009CEr 1  28 5F 20 0D
0009D3r 1  20 20 20 5F  		.BYTE   "   __ _____  _____ ___ ___ ",$0D,$0A
0009D7r 1  5F 20 5F 5F
0009DBr 1  5F 5F 5F 20
0009F0r 1  20 20 2F 20     		.BYTE   "  / /| ____|/ ____/ _ \__ \ ",$0D,$0A
0009F4r 1  2F 7C 20 5F
0009F8r 1  5F 5F 5F 7C
000A0Er 1  20 2F 20 2F    		.BYTE   " / /_| |__ | |   | | | | ) | ",$0D,$0A
000A12r 1  5F 7C 20 7C
000A16r 1  5F 5F 20 7C
000A2Dr 1  7C 20 27 5F   		.BYTE   "| '_ \___ \| |   | | | |/ / ",$0D,$0A
000A31r 1  20 5C 5F 5F
000A35r 1  5F 20 5C 7C
000A4Br 1  7C 20 28 5F   		.BYTE   "| (_) |__) | |___| |_| / /_ ",$0D,$0A
000A4Fr 1  29 20 7C 5F
000A53r 1  5F 29 20 7C
000A69r 1  20 5C 5F 5F    		.BYTE   " \___/____/ \_____\___/____| ",$0D,$0A
000A6Dr 1  5F 2F 5F 5F
000A71r 1  5F 5F 2F 20
000A88r 1  2A 20 36 35  		.BYTE   "* 6502 MONITOR ",$0D,$0A,$00
000A8Cr 1  30 32 20 4D
000A90r 1  4F 4E 49 54
000A9Ar 1
000A9Ar 1                                .segment "VECTORS"
000000r 1  rr rr        NMIVECTOR:  .WORD   INTERRUPT		;
000002r 1  rr rr        RSTVECTOR:  .WORD   COLD_START		;
000004r 1  rr rr        INTVECTOR: 	.WORD   INTERRUPT		; ROM VECTOR FOR IRQ
000006r 1
000006r 1               	.END
